use crate::context::Context;
use crate::dispatch::gl_types::*;
use crate::enums::{
    AtomicCounterBufferPName, AttributeType, BlendEquationModeEXT, BlendingFactor,
    BlitFramebufferFilter, Buffer, BufferAccess, BufferPName, BufferStorageMask,
    BufferStorageTarget, BufferTarget, BufferUsage, ClampColorMode, ClearBufferMask,
    ClipControlDepth, ClipControlOrigin, ColorBuffer, ConditionalRenderMode,
    CopyBufferSubDataTarget, CopyImageSubDataTarget, DebugSeverity, DebugSource, DebugType,
    DepthFunction, DrawBufferMode, DrawElementsType, EnableCap, FramebufferAttachment,
    FramebufferAttachmentParameterName, FramebufferParameterName, FramebufferTarget,
    FrontFaceDirection, GetFramebufferParameter, GetPointervPName, GetTextureParameter, HintMode,
    HintTarget, InternalFormat, InternalFormatPName, InvalidateFramebufferAttachment, LogicOp,
    MapBufferAccessMask, MemoryBarrierMask, ObjectIdentifier, PatchParameterName,
    PipelineParameterName, PixelFormat, PixelStoreParameter, PixelType, PolygonMode, PrecisionType,
    PrimitiveType, ProgramInterface, ProgramInterfacePName, ProgramParameterPName, ProgramProperty,
    ProgramResourceProperty, ProgramStagePName, QueryObjectParameterName, QueryParameterName,
    QueryTarget, ReadBufferMode, RenderbufferParameterName, SamplerParameterF, SamplerParameterI,
    ShaderParameterName, ShaderType, SizedInternalFormat, StencilFunction, StencilOp,
    SubroutineParameterName, SyncParameterName, TextureParameterName, TextureTarget, TextureUnit,
    TransformFeedbackBufferMode, TransformFeedbackPName, TriangleFace, UniformBlockPName,
    UniformPName, UniformType, UseProgramStageMask, VertexArrayPName, VertexAttribEnum, VertexAttribPointerType, VertexAttribProperty, VertexBufferObjectUsage,
    VertexProvokingMode,
};

/// ### Parameters
/// `id`
///
/// > Specifies the name of an occlusion query object whose results are used
/// > to determine if the rendering commands are discarded.
///
/// `mode`
///
/// > Specifies how [**glBeginConditionalRender**](crate::context::Context::oxidegl_begin_conditional_render)
/// > interprets the results of the occlusion query.
///
/// ### Description
/// Conditional rendering is started using [**glBeginConditionalRender**](crate::context::Context::oxidegl_begin_conditional_render)
/// and ended using [**glEndConditionalRender**](crate::context::Context::oxidegl_end_conditional_render).
/// During conditional rendering, all vertex array commands, as well as [**glClear**](crate::context::Context::oxidegl_clear)
/// and [**glClearBuffer**](crate::context::Context::oxidegl_clear_buffer)
/// have no effect if the( [`GL_SAMPLES_PASSED`](crate::enums::GL_SAMPLES_PASSED))
/// result of the query object `id` is zero, or if the( [`GL_ANY_SAMPLES_PASSED`](crate::enums::GL_ANY_SAMPLES_PASSED))
/// result is [`GL_FALSE`](crate::enums::GL_FALSE). The results of commands
/// setting the current vertex state, such as [**glVertexAttrib**](crate::context::Context::oxidegl_vertex_attrib)
/// are undefined. If the( [`GL_SAMPLES_PASSED`](crate::enums::GL_SAMPLES_PASSED))
/// result is non-zero or if the( [`GL_ANY_SAMPLES_PASSED`](crate::enums::GL_ANY_SAMPLES_PASSED))
/// result is [`GL_TRUE`](crate::enums::GL_TRUE), such commands are not discarded.
/// The `id` parameter to [**glBeginConditionalRender**](crate::context::Context::oxidegl_begin_conditional_render)
/// must be the name of a query object previously returned from a call to [**glGenQueries**](crate::context::Context::oxidegl_gen_queries).
/// `mode` specifies how the results of the query object are to be interpreted.
/// If `mode` is [`GL_QUERY_WAIT`](crate::enums::GL_QUERY_WAIT), the GL waits
/// for the results of the query to be available and then uses the results
/// to determine if subsequent rendering commands are discarded. If `mode`
/// is [`GL_QUERY_NO_WAIT`](crate::enums::GL_QUERY_NO_WAIT), the GL may choose
/// to unconditionally execute the subsequent rendering commands without waiting
/// for the query to complete.
///
/// If `mode` is [`GL_QUERY_BY_REGION_WAIT`](crate::enums::GL_QUERY_BY_REGION_WAIT),
/// the GL will also wait for occlusion query results and discard rendering
/// commands if the result of the occlusion query is zero. If the query result
/// is non-zero, subsequent rendering commands are executed, but the GL may
/// discard the results of the commands for any region of the framebuffer that
/// did not contribute to the sample count in the specified occlusion query.
/// Any such discarding is done in an implementation-dependent manner, but
/// the rendering command results may not be discarded for any samples that
/// contributed to the occlusion query sample count. If `mode` is [`GL_QUERY_BY_REGION_NO_WAIT`](crate::enums::GL_QUERY_BY_REGION_NO_WAIT),
/// the GL operates as in [`GL_QUERY_BY_REGION_WAIT`](crate::enums::GL_QUERY_BY_REGION_WAIT),
/// but may choose to unconditionally execute the subsequent rendering commands
/// without waiting for the query to complete.
///
/// ### Notes
/// [**glBeginConditionalRender**](crate::context::Context::oxidegl_begin_conditional_render)
/// and [**glEndConditionalRender**](crate::context::Context::oxidegl_end_conditional_render)
/// are available only if the GL version is 3.0 or greater.
///
/// The [`GL_ANY_SAMPLES_PASSED`](crate::enums::GL_ANY_SAMPLES_PASSED) query
/// result is available only if the GL version is 3.3 or greater.
impl Context {
    pub fn oxidegl_begin_conditional_render(&mut self, id: GLuint, mode: ConditionalRenderMode) {
        panic!("command oxidegl_begin_conditional_render not yet implemented");
    }
    pub fn oxidegl_end_conditional_render(&mut self) {
        panic!("command oxidegl_end_conditional_render not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target type of query object established between [**glBeginQuery**](crate::context::Context::oxidegl_begin_query)
/// > and the subsequent [**glEndQuery**](crate::context::Context::oxidegl_end_query).
/// > The symbolic constant must be one of [`GL_SAMPLES_PASSED`](crate::enums::GL_SAMPLES_PASSED),
/// > [`GL_ANY_SAMPLES_PASSED`](crate::enums::GL_ANY_SAMPLES_PASSED), [`GL_ANY_SAMPLES_PASSED_CONSERVATIVE`](crate::enums::GL_ANY_SAMPLES_PASSED_CONSERVATIVE),
/// > [`GL_PRIMITIVES_GENERATED`](crate::enums::GL_PRIMITIVES_GENERATED), [`GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`](crate::enums::GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN),
/// > or [`GL_TIME_ELAPSED`](crate::enums::GL_TIME_ELAPSED).
///
/// `id`
///
/// > Specifies the name of a query object.
///
/// ### Description
/// [**glBeginQuery**](crate::context::Context::oxidegl_begin_query) and [**glEndQuery**](crate::context::Context::oxidegl_end_query)
/// delimit the boundaries of a query object. `query` must be a name previously
/// returned from a call to [**glGenQueries**](crate::context::Context::oxidegl_gen_queries).
/// If a query object with name `id` does not yet exist it is created with
/// the type determined by `target`. `target` must be one of [`GL_SAMPLES_PASSED`](crate::enums::GL_SAMPLES_PASSED),
/// [`GL_ANY_SAMPLES_PASSED`](crate::enums::GL_ANY_SAMPLES_PASSED), [`GL_PRIMITIVES_GENERATED`](crate::enums::GL_PRIMITIVES_GENERATED),
/// [`GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`](crate::enums::GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN),
/// or [`GL_TIME_ELAPSED`](crate::enums::GL_TIME_ELAPSED). The behavior of
/// the query object depends on its type and is as follows.
///
/// If `target` is [`GL_SAMPLES_PASSED`](crate::enums::GL_SAMPLES_PASSED), `id`
/// must be an unused name, or the name of an existing occlusion query object.
/// When [**glBeginQuery**](crate::context::Context::oxidegl_begin_query) is
/// executed, the query object's samples-passed counter is reset to 0. Subsequent
/// rendering will increment the counter for every sample that passes the depth
/// test. If the value of [`GL_SAMPLE_BUFFERS`](crate::enums::GL_SAMPLE_BUFFERS)
/// is 0, then the samples-passed count is incremented by 1 for each fragment.
/// If the value of [`GL_SAMPLE_BUFFERS`](crate::enums::GL_SAMPLE_BUFFERS)
/// is 1, then the samples-passed count is incremented by the number of samples
/// whose coverage bit is set. However, implementations, at their discression
/// may instead increase the samples-passed count by the value of [`GL_SAMPLES`](crate::enums::GL_SAMPLES)
/// if any sample in the fragment is covered. When [**glEndQuery**](crate::context::Context::oxidegl_end_query)
/// is executed, the samples-passed counter is assigned to the query object's
/// result value. This value can be queried by calling [**glGetQueryObject**](crate::context::Context::oxidegl_get_query_object)
/// with `pname` [`GL_QUERY_RESULT`](crate::enums::GL_QUERY_RESULT).
///
/// If `target` is [`GL_ANY_SAMPLES_PASSED`](crate::enums::GL_ANY_SAMPLES_PASSED)
/// or [`GL_ANY_SAMPLES_PASSED_CONSERVATIVE`](crate::enums::GL_ANY_SAMPLES_PASSED_CONSERVATIVE),
/// `id` must be an unused name, or the name of an existing boolean occlusion
/// query object. When [**glBeginQuery**](crate::context::Context::oxidegl_begin_query)
/// is executed, the query object's samples-passed flag is reset to [`GL_FALSE`](crate::enums::GL_FALSE).
/// Subsequent rendering causes the flag to be set to [`GL_TRUE`](crate::enums::GL_TRUE)
/// if any sample passes the depth test in the case of [`GL_ANY_SAMPLES_PASSED`](crate::enums::GL_ANY_SAMPLES_PASSED),
/// or if the implementation determines that any sample might pass the depth
/// test in the case of [`GL_ANY_SAMPLES_PASSED_CONSERVATIVE`](crate::enums::GL_ANY_SAMPLES_PASSED_CONSERVATIVE).
/// The implementation may be able to provide a more efficient test in the
/// case of [`GL_ANY_SAMPLES_PASSED_CONSERVATIVE`](crate::enums::GL_ANY_SAMPLES_PASSED_CONSERVATIVE)
/// if some false positives are acceptable to the application. When [**glEndQuery**](crate::context::Context::oxidegl_end_query)
/// is executed, the samples-passed flag is assigned to the query object's
/// result value. This value can be queried by calling [**glGetQueryObject**](crate::context::Context::oxidegl_get_query_object)
/// with `pname` [`GL_QUERY_RESULT`](crate::enums::GL_QUERY_RESULT).
///
/// If `target` is [`GL_PRIMITIVES_GENERATED`](crate::enums::GL_PRIMITIVES_GENERATED),
/// `id` must be an unused name, or the name of an existing primitive query
/// object previously bound to the [`GL_PRIMITIVES_GENERATED`](crate::enums::GL_PRIMITIVES_GENERATED)
/// query binding. When [**glBeginQuery**](crate::context::Context::oxidegl_begin_query)
/// is executed, the query object's primitives-generated counter is reset to
/// 0. Subsequent rendering will increment the counter once for every vertex
/// that is emitted from the geometry shader, or from the vertex shader if
/// no geometry shader is present. When [**glEndQuery**](crate::context::Context::oxidegl_end_query)
/// is executed, the primitives-generated counter is assigned to the query
/// object's result value. This value can be queried by calling [**glGetQueryObject**](crate::context::Context::oxidegl_get_query_object)
/// with `pname` [`GL_QUERY_RESULT`](crate::enums::GL_QUERY_RESULT).
///
/// If `target` is [`GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`](crate::enums::GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN),
/// `id` must be an unused name, or the name of an existing primitive query
/// object previously bound to the [`GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`](crate::enums::GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN)
/// query binding. When [**glBeginQuery**](crate::context::Context::oxidegl_begin_query)
/// is executed, the query object's primitives-written counter is reset to
/// 0. Subsequent rendering will increment the counter once for every vertex
/// that is written into the bound transform feedback buffer(s). If transform
/// feedback mode is not activated between the call to [**glBeginQuery**](crate::context::Context::oxidegl_begin_query)
/// and [**glEndQuery**](crate::context::Context::oxidegl_end_query), the counter
/// will not be incremented. When [**glEndQuery**](crate::context::Context::oxidegl_end_query)
/// is executed, the primitives-written counter is assigned to the query object's
/// result value. This value can be queried by calling [**glGetQueryObject**](crate::context::Context::oxidegl_get_query_object)
/// with `pname` [`GL_QUERY_RESULT`](crate::enums::GL_QUERY_RESULT).
///
/// If `target` is [`GL_TIME_ELAPSED`](crate::enums::GL_TIME_ELAPSED), `id`
/// must be an unused name, or the name of an existing timer query object previously
/// bound to the [`GL_TIME_ELAPSED`](crate::enums::GL_TIME_ELAPSED) query binding.
/// When [**glBeginQuery**](crate::context::Context::oxidegl_begin_query) is
/// executed, the query object's time counter is reset to 0. When [**glEndQuery**](crate::context::Context::oxidegl_end_query)
/// is executed, the elapsed server time that has passed since the call to
/// [**glBeginQuery**](crate::context::Context::oxidegl_begin_query) is written
/// into the query object's time counter. This value can be queried by calling
/// [**glGetQueryObject**](crate::context::Context::oxidegl_get_query_object)
/// with `pname` [`GL_QUERY_RESULT`](crate::enums::GL_QUERY_RESULT).
///
/// Querying the [`GL_QUERY_RESULT`](crate::enums::GL_QUERY_RESULT) implicitly
/// flushes the GL pipeline until the rendering delimited by the query object
/// has completed and the result is available. [`GL_QUERY_RESULT_AVAILABLE`](crate::enums::GL_QUERY_RESULT_AVAILABLE)
/// can be queried to determine if the result is immediately available or if
/// the rendering is not yet complete.
///
/// ### Notes
/// If the query target's count exceeds the maximum value representable in
/// the number of available bits, as reported by [**glGetQueryiv**](crate::context::Context::oxidegl_get_queryiv)
/// with `target` set to the appropriate query target and `pname` [`GL_QUERY_COUNTER_BITS`](crate::enums::GL_QUERY_COUNTER_BITS),
/// the count becomes undefined.
///
/// An implementation may support 0 bits in its counter, in which case query
/// results are always undefined and essentially useless.
///
/// When [`GL_SAMPLE_BUFFERS`](crate::enums::GL_SAMPLE_BUFFERS) is 0, the samples-passed
/// counter of an occlusion query will increment once for each fragment that
/// passes the depth test. When [`GL_SAMPLE_BUFFERS`](crate::enums::GL_SAMPLE_BUFFERS)
/// is 1, an implementation may either increment the samples-passed counter
/// individually for each sample of a fragment that passes the depth test,
/// or it may choose to increment the counter for all samples of a fragment
/// if any one of them passes the depth test.
///
/// The query targets [`GL_ANY_SAMPLES_PASSED`](crate::enums::GL_ANY_SAMPLES_PASSED),
/// and [`GL_TIME_ELAPSED`](crate::enums::GL_TIME_ELAPSED) are availale only
/// if the GL version is 3.3 or higher.
///
/// The query target [`GL_ANY_SAMPLES_PASSED_CONSERVATIVE`](crate::enums::GL_ANY_SAMPLES_PASSED_CONSERVATIVE)
/// is available only of the GL version is 4.3 or higher.
impl Context {
    pub fn oxidegl_begin_query(&mut self, target: QueryTarget, id: GLuint) {
        panic!("command oxidegl_begin_query not yet implemented");
    }
    pub fn oxidegl_end_query(&mut self, target: QueryTarget) {
        panic!("command oxidegl_end_query not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target type of query object established between [**glBeginQueryIndexed**](crate::context::Context::oxidegl_begin_query_indexed)
/// > and the subsequent [**glEndQueryIndexed**](crate::context::Context::oxidegl_end_query_indexed).
/// > The symbolic constant must be one of [`GL_SAMPLES_PASSED`](crate::enums::GL_SAMPLES_PASSED),
/// > [`GL_ANY_SAMPLES_PASSED`](crate::enums::GL_ANY_SAMPLES_PASSED), [`GL_PRIMITIVES_GENERATED`](crate::enums::GL_PRIMITIVES_GENERATED),
/// > [`GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`](crate::enums::GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN),
/// > or [`GL_TIME_ELAPSED`](crate::enums::GL_TIME_ELAPSED).
///
/// `index`
///
/// > Specifies the index of the query target upon which to begin the query.
///
/// `id`
///
/// > Specifies the name of a query object.
///
/// ### Description
/// [**glBeginQueryIndexed**](crate::context::Context::oxidegl_begin_query_indexed)
/// and [**glEndQueryIndexed**](crate::context::Context::oxidegl_end_query_indexed)
/// delimit the boundaries of a query object. `query` must be a name previously
/// returned from a call to [**glGenQueries**](crate::context::Context::oxidegl_gen_queries).
/// If a query object with name `id` does not yet exist it is created with
/// the type determined by `target`. `target` must be one of [`GL_SAMPLES_PASSED`](crate::enums::GL_SAMPLES_PASSED),
/// [`GL_ANY_SAMPLES_PASSED`](crate::enums::GL_ANY_SAMPLES_PASSED), [`GL_PRIMITIVES_GENERATED`](crate::enums::GL_PRIMITIVES_GENERATED),
/// [`GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`](crate::enums::GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN),
/// or [`GL_TIME_ELAPSED`](crate::enums::GL_TIME_ELAPSED). The behavior of
/// the query object depends on its type and is as follows.
///
/// `index` specifies the index of the query target and must be between a `target`
/// -specific maximum.
///
/// If `target` is [`GL_SAMPLES_PASSED`](crate::enums::GL_SAMPLES_PASSED), `id`
/// must be an unused name, or the name of an existing occlusion query object.
/// When [**glBeginQueryIndexed**](crate::context::Context::oxidegl_begin_query_indexed)
/// is executed, the query object's samples-passed counter is reset to 0. Subsequent
/// rendering will increment the counter for every sample that passes the depth
/// test. If the value of [`GL_SAMPLE_BUFFERS`](crate::enums::GL_SAMPLE_BUFFERS)
/// is 0, then the samples-passed count is incremented by 1 for each fragment.
/// If the value of [`GL_SAMPLE_BUFFERS`](crate::enums::GL_SAMPLE_BUFFERS)
/// is 1, then the samples-passed count is incremented by the number of samples
/// whose coverage bit is set. However, implementations, at their discression
/// may instead increase the samples-passed count by the value of [`GL_SAMPLES`](crate::enums::GL_SAMPLES)
/// if any sample in the fragment is covered. When [**glEndQueryIndexed**](crate::context::Context::oxidegl_end_query_indexed)
/// is executed, the samples-passed counter is assigned to the query object's
/// result value. This value can be queried by calling [**glGetQueryObject**](crate::context::Context::oxidegl_get_query_object)
/// with `pname` [`GL_QUERY_RESULT`](crate::enums::GL_QUERY_RESULT). When `target`
/// is [`GL_SAMPLES_PASSED`](crate::enums::GL_SAMPLES_PASSED), `index` must
/// be zero.
///
/// If `target` is [`GL_ANY_SAMPLES_PASSED`](crate::enums::GL_ANY_SAMPLES_PASSED),
/// `id` must be an unused name, or the name of an existing boolean occlusion
/// query object. When [**glBeginQueryIndexed**](crate::context::Context::oxidegl_begin_query_indexed)
/// is executed, the query object's samples-passed flag is reset to [`GL_FALSE`](crate::enums::GL_FALSE).
/// Subsequent rendering causes the flag to be set to [`GL_TRUE`](crate::enums::GL_TRUE)
/// if any sample passes the depth test. When [**glEndQueryIndexed**](crate::context::Context::oxidegl_end_query_indexed)
/// is executed, the samples-passed flag is assigned to the query object's
/// result value. This value can be queried by calling [**glGetQueryObject**](crate::context::Context::oxidegl_get_query_object)
/// with `pname` [`GL_QUERY_RESULT`](crate::enums::GL_QUERY_RESULT). When `target`
/// is [`GL_ANY_SAMPLES_PASSED`](crate::enums::GL_ANY_SAMPLES_PASSED), `index`
/// must be zero.
///
/// If `target` is [`GL_PRIMITIVES_GENERATED`](crate::enums::GL_PRIMITIVES_GENERATED),
/// `id` must be an unused name, or the name of an existing primitive query
/// object previously bound to the [`GL_PRIMITIVES_GENERATED`](crate::enums::GL_PRIMITIVES_GENERATED)
/// query binding. When [**glBeginQueryIndexed**](crate::context::Context::oxidegl_begin_query_indexed)
/// is executed, the query object's primitives-generated counter is reset to
/// 0. Subsequent rendering will increment the counter once for every vertex
/// that is emitted from the geometry shader to the stream given by `index`,
/// or from the vertex shader if `index` is zero and no geometry shader is
/// present. When [**glEndQueryIndexed**](crate::context::Context::oxidegl_end_query_indexed)
/// is executed, the primitives-generated counter for stream `index` is assigned
/// to the query object's result value. This value can be queried by calling
/// [**glGetQueryObject**](crate::context::Context::oxidegl_get_query_object)
/// with `pname` [`GL_QUERY_RESULT`](crate::enums::GL_QUERY_RESULT). When `target`
/// is [`GL_PRIMITIVES_GENERATED`](crate::enums::GL_PRIMITIVES_GENERATED), `index`
/// must be less than the value of [`GL_MAX_VERTEX_STREAMS`](crate::enums::GL_MAX_VERTEX_STREAMS).
///
/// If `target` is [`GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`](crate::enums::GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN),
/// `id` must be an unused name, or the name of an existing primitive query
/// object previously bound to the [`GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`](crate::enums::GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN)
/// query binding. When [**glBeginQueryIndexed**](crate::context::Context::oxidegl_begin_query_indexed)
/// is executed, the query object's primitives-written counter for the stream
/// specified by `index` is reset to 0. Subsequent rendering will increment
/// the counter once for every vertex that is written into the bound transform
/// feedback buffer(s) for stream `index`. If transform feedback mode is not
/// activated between the call to [**glBeginQueryIndexed**](crate::context::Context::oxidegl_begin_query_indexed)
/// and [**glEndQueryIndexed**](crate::context::Context::oxidegl_end_query_indexed),
/// the counter will not be incremented. When [**glEndQueryIndexed**](crate::context::Context::oxidegl_end_query_indexed)
/// is executed, the primitives-written counter for stream `index` is assigned
/// to the query object's result value. This value can be queried by calling
/// [**glGetQueryObject**](crate::context::Context::oxidegl_get_query_object)
/// with `pname` [`GL_QUERY_RESULT`](crate::enums::GL_QUERY_RESULT). When `target`
/// is [`GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`](crate::enums::GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN),
/// `index` must be less than the value of [`GL_MAX_VERTEX_STREAMS`](crate::enums::GL_MAX_VERTEX_STREAMS).
///
/// If `target` is [`GL_TIME_ELAPSED`](crate::enums::GL_TIME_ELAPSED), `id`
/// must be an unused name, or the name of an existing timer query object previously
/// bound to the [`GL_TIME_ELAPSED`](crate::enums::GL_TIME_ELAPSED) query binding.
/// When [**glBeginQueryIndexed**](crate::context::Context::oxidegl_begin_query_indexed)
/// is executed, the query object's time counter is reset to 0. When [**glEndQueryIndexed**](crate::context::Context::oxidegl_end_query_indexed)
/// is executed, the elapsed server time that has passed since the call to
/// [**glBeginQueryIndexed**](crate::context::Context::oxidegl_begin_query_indexed)
/// is written into the query object's time counter. This value can be queried
/// by calling [**glGetQueryObject**](crate::context::Context::oxidegl_get_query_object)
/// with `pname` [`GL_QUERY_RESULT`](crate::enums::GL_QUERY_RESULT). When `target`
/// is [`GL_TIME_ELAPSED`](crate::enums::GL_TIME_ELAPSED), `index` must be
/// zero.
///
/// Querying the [`GL_QUERY_RESULT`](crate::enums::GL_QUERY_RESULT) implicitly
/// flushes the GL pipeline until the rendering delimited by the query object
/// has completed and the result is available. [`GL_QUERY_RESULT_AVAILABLE`](crate::enums::GL_QUERY_RESULT_AVAILABLE)
/// can be queried to determine if the result is immediately available or if
/// the rendering is not yet complete.
///
/// ### Notes
/// If the query target's count exceeds the maximum value representable in
/// the number of available bits, as reported by [**glGetQueryiv**](crate::context::Context::oxidegl_get_queryiv)
/// with `target` set to the appropriate query target and `pname` [`GL_QUERY_COUNTER_BITS`](crate::enums::GL_QUERY_COUNTER_BITS),
/// the count becomes undefined.
///
/// An implementation may support 0 bits in its counter, in which case query
/// results are always undefined and essentially useless.
///
/// When [`GL_SAMPLE_BUFFERS`](crate::enums::GL_SAMPLE_BUFFERS) is 0, the samples-passed
/// counter of an occlusion query will increment once for each fragment that
/// passes the depth test. When [`GL_SAMPLE_BUFFERS`](crate::enums::GL_SAMPLE_BUFFERS)
/// is 1, an implementation may either increment the samples-passed counter
/// individually for each sample of a fragment that passes the depth test,
/// or it may choose to increment the counter for all samples of a fragment
/// if any one of them passes the depth test.
///
/// Calling [**glBeginQuery**](crate::context::Context::oxidegl_begin_query)
/// or [**glEndQuery**](crate::context::Context::oxidegl_end_query) is equivalent
/// to calling [**glBeginQueryIndexed**](crate::context::Context::oxidegl_begin_query_indexed)
/// or [**glEndQueryIndexed**](crate::context::Context::oxidegl_end_query_indexed)
/// with `index` set to zero, respectively.
impl Context {
    pub fn oxidegl_begin_query_indexed(&mut self, target: QueryTarget, index: GLuint, id: GLuint) {
        panic!("command oxidegl_begin_query_indexed not yet implemented");
    }
    pub fn oxidegl_end_query_indexed(&mut self, target: QueryTarget, index: GLuint) {
        panic!("command oxidegl_end_query_indexed not yet implemented");
    }
}
/// ### Parameters
/// `primitiveMode`
///
/// > Specify the output type of the primitives that will be recorded into the
/// > buffer objects that are bound for transform feedback.
///
/// ### Description
/// Transform feedback mode captures the values of varying variables written
/// by the vertex shader (or, if active, the geometry shader). Transform feedback
/// is said to be active after a call to [**glBeginTransformFeedback**](crate::context::Context::oxidegl_begin_transform_feedback)
/// until a subsequent call to [**glEndTransformFeedback**](crate::context::Context::oxidegl_end_transform_feedback).
/// Transform feedback commands must be paired.
///
/// If no geometry shader is present, while transform feedback is active the
/// `mode` parameter to [**glDrawArrays**](crate::context::Context::oxidegl_draw_arrays)
/// must match those specified in the following table:
///
/// |* Transform Feedback*                              |* Allowed Render Primitive*                                 |
/// |---------------------------------------------------|------------------------------------------------------------|
/// | [`GL_POINTS`](crate::enums::GL_POINTS)            | [`GL_POINTS`](crate::enums::GL_POINTS)                     |
/// | [`GL_LINES`](crate::enums::GL_LINES)              | [`GL_LINES`](crate::enums::GL_LINES), [`GL_LINE_LOOP`](crate::enums::GL_LINE_LOOP), [`GL_LINE_STRIP`](crate::enums::GL_LINE_STRIP), [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY), [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY) |
/// | [`GL_TRIANGLES`](crate::enums::GL_TRIANGLES)      | [`GL_TRIANGLES`](crate::enums::GL_TRIANGLES), [`GL_TRIANGLE_STRIP`](crate::enums::GL_TRIANGLE_STRIP), [`GL_TRIANGLE_FAN`](crate::enums::GL_TRIANGLE_FAN), [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY), [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY) |
///
/// If a geometry shader is present, the output primitive type from the geometry
/// shader must match those provided in the following table:
///
/// |* Transform Feedback*                              |* Allowed Geometry Shader Output Primitive Type*                                           |
/// |---------------------------------------------------|-------------------------------------------------------------------------------------------|
/// | [`GL_POINTS`](crate::enums::GL_POINTS)            | [`points`](crate::enums::points)                                                          |
/// | [`GL_LINES`](crate::enums::GL_LINES)              | [`line_strip`](crate::enums::line_strip)                                                  |
/// | [`GL_TRIANGLES`](crate::enums::GL_TRIANGLES)      | [`triangle_strip`](crate::enums::triangle_strip)                                          |
///
/// ### Notes
/// Geometry shaders, and the [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY),
/// [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY),
/// [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY) and [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY)
/// primtive modes are available only if the GL version is 3.2 or greater.
impl Context {
    pub fn oxidegl_begin_transform_feedback(&mut self, primitive_mode: PrimitiveType) {
        panic!("command oxidegl_begin_transform_feedback not yet implemented");
    }
    pub fn oxidegl_end_transform_feedback(&mut self) {
        panic!("command oxidegl_end_transform_feedback not yet implemented");
    }
}
/// ### Parameters
/// `buf`
///
/// > for [**glBlendEquationi**](crate::context::Context::oxidegl_blend_equationi),
/// > specifies the index of the draw buffer for which to set the blend equation.
///
/// `mode`
///
/// > specifies how source and destination colors are combined. It must be [`GL_FUNC_ADD`](crate::enums::GL_FUNC_ADD),
/// > [`GL_FUNC_SUBTRACT`](crate::enums::GL_FUNC_SUBTRACT), [`GL_FUNC_REVERSE_SUBTRACT`](crate::enums::GL_FUNC_REVERSE_SUBTRACT),
/// > [`GL_MIN`](crate::enums::GL_MIN), [`GL_MAX`](crate::enums::GL_MAX).
///
/// ### Description
/// The blend equations determine how a new pixel (the ''source'' color) is
/// combined with a pixel already in the framebuffer (the ''destination'' color).
/// This function sets both the RGB blend equation and the alpha blend equation
/// to a single equation. [**glBlendEquationi**](crate::context::Context::oxidegl_blend_equationi)
/// specifies the blend equation for a single draw buffer whereas [**glBlendEquation**](crate::context::Context::oxidegl_blend_equation)
/// sets the blend equation for all draw buffers.
///
/// These equations use the source and destination blend factors specified
/// by either [**glBlendFunc**](crate::context::Context::oxidegl_blend_func)
/// or [**glBlendFuncSeparate**](crate::context::Context::oxidegl_blend_func_separate).
/// See [**glBlendFunc**](crate::context::Context::oxidegl_blend_func) or
/// [**glBlendFuncSeparate**](crate::context::Context::oxidegl_blend_func_separate)
/// for a description of the various blend factors.
///
/// In the equations that follow, source and destination color components are
/// referred to as `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]`
/// `[inlineq]`
/// |* Mode*     |* RGB Components*                            |* Alpha Component*                            |
/// |------------|---------------------------------------------|----------------------------------------------|
/// | [`GL_FUNC_ADD`](crate::enums::GL_FUNC_ADD) | `[inlineq]` `[inlineq]` `[inlineq]` | `[inlineq]`          |
/// | [`GL_FUNC_SUBTRACT`](crate::enums::GL_FUNC_SUBTRACT) | `[inlineq]` `[inlineq]` `[inlineq]` | `[inlineq]` |
/// | [`GL_FUNC_REVERSE_SUBTRACT`](crate::enums::GL_FUNC_REVERSE_SUBTRACT) | `[inlineq]` `[inlineq]` `[inlineq]` | `[inlineq]` |
/// | [`GL_MIN`](crate::enums::GL_MIN) | `[inlineq]` `[inlineq]` `[inlineq]` | `[inlineq]`                    |
/// | [`GL_MAX`](crate::enums::GL_MAX) | `[inlineq]` `[inlineq]` `[inlineq]` | `[inlineq]`                    |
///
///
/// The results of these equations are clamped to the range `[inlineq]`
///
/// The [`GL_MIN`](crate::enums::GL_MIN) and [`GL_MAX`](crate::enums::GL_MAX)
/// equations are useful for applications that analyze image data (image thresholding
/// against a constant color, for example). The [`GL_FUNC_ADD`](crate::enums::GL_FUNC_ADD)
/// equation is useful for antialiasing and transparency, among other things.
///
/// Initially, both the RGB blend equation and the alpha blend equation are
/// set to [`GL_FUNC_ADD`](crate::enums::GL_FUNC_ADD).
///
///
/// ### Notes
/// The [`GL_MIN`](crate::enums::GL_MIN), and [`GL_MAX`](crate::enums::GL_MAX)
/// equations do not use the source or destination factors, only the source
/// and destination colors.
///
/// ### Associated Gets
/// [**glGet**](crate::context::Context::oxidegl_get) with an argument of [`GL_BLEND_EQUATION_RGB`](crate::enums::GL_BLEND_EQUATION_RGB)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with an argument of [`GL_BLEND_EQUATION_ALPHA`](crate::enums::GL_BLEND_EQUATION_ALPHA)
impl Context {
    pub fn oxidegl_blend_equation(&mut self, mode: BlendEquationModeEXT) {
        panic!("command oxidegl_blend_equation not yet implemented");
    }
    pub fn oxidegl_blend_equationi(&mut self, buf: GLuint, mode: BlendEquationModeEXT) {
        panic!("command oxidegl_blend_equationi not yet implemented");
    }
}
/// ### Parameters
/// `buf`
///
/// > for [**glBlendEquationSeparatei**](crate::context::Context::oxidegl_blend_equation_separatei),
/// > specifies the index of the draw buffer for which to set the blend equations.
///
/// `modeRGB`
///
/// > specifies the RGB blend equation, how the red, green, and blue components
/// > of the source and destination colors are combined. It must be [`GL_FUNC_ADD`](crate::enums::GL_FUNC_ADD),
/// > [`GL_FUNC_SUBTRACT`](crate::enums::GL_FUNC_SUBTRACT), [`GL_FUNC_REVERSE_SUBTRACT`](crate::enums::GL_FUNC_REVERSE_SUBTRACT),
/// > [`GL_MIN`](crate::enums::GL_MIN), [`GL_MAX`](crate::enums::GL_MAX).
///
/// `modeAlpha`
///
/// > specifies the alpha blend equation, how the alpha component of the source
/// > and destination colors are combined. It must be [`GL_FUNC_ADD`](crate::enums::GL_FUNC_ADD),
/// > [`GL_FUNC_SUBTRACT`](crate::enums::GL_FUNC_SUBTRACT), [`GL_FUNC_REVERSE_SUBTRACT`](crate::enums::GL_FUNC_REVERSE_SUBTRACT),
/// > [`GL_MIN`](crate::enums::GL_MIN), [`GL_MAX`](crate::enums::GL_MAX).
///
/// ### Description
/// The blend equations determines how a new pixel (the ''source'' color) is
/// combined with a pixel already in the framebuffer (the ''destination'' color).
/// These functions specify one blend equation for the RGB-color components
/// and one blend equation for the alpha component. [**glBlendEquationSeparatei**](crate::context::Context::oxidegl_blend_equation_separatei)
/// specifies the blend equations for a single draw buffer whereas [**glBlendEquationSeparate**](crate::context::Context::oxidegl_blend_equation_separate)
/// sets the blend equations for all draw buffers.
///
/// The blend equations use the source and destination blend factors specified
/// by either [**glBlendFunc**](crate::context::Context::oxidegl_blend_func)
/// or [**glBlendFuncSeparate**](crate::context::Context::oxidegl_blend_func_separate).
/// See [**glBlendFunc**](crate::context::Context::oxidegl_blend_func) or
/// [**glBlendFuncSeparate**](crate::context::Context::oxidegl_blend_func_separate)
/// for a description of the various blend factors.
///
/// In the equations that follow, source and destination color components are
/// referred to as `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]`
/// `[inlineq]`
/// |* Mode*     |* RGB Components*                            |* Alpha Component*                            |
/// |------------|---------------------------------------------|----------------------------------------------|
/// | [`GL_FUNC_ADD`](crate::enums::GL_FUNC_ADD) | `[inlineq]` `[inlineq]` `[inlineq]` | `[inlineq]`          |
/// | [`GL_FUNC_SUBTRACT`](crate::enums::GL_FUNC_SUBTRACT) | `[inlineq]` `[inlineq]` `[inlineq]` | `[inlineq]` |
/// | [`GL_FUNC_REVERSE_SUBTRACT`](crate::enums::GL_FUNC_REVERSE_SUBTRACT) | `[inlineq]` `[inlineq]` `[inlineq]` | `[inlineq]` |
/// | [`GL_MIN`](crate::enums::GL_MIN) | `[inlineq]` `[inlineq]` `[inlineq]` | `[inlineq]`                    |
/// | [`GL_MAX`](crate::enums::GL_MAX) | `[inlineq]` `[inlineq]` `[inlineq]` | `[inlineq]`                    |
///
///
/// The results of these equations are clamped to the range `[inlineq]`
///
/// The [`GL_MIN`](crate::enums::GL_MIN) and [`GL_MAX`](crate::enums::GL_MAX)
/// equations are useful for applications that analyze image data (image thresholding
/// against a constant color, for example). The [`GL_FUNC_ADD`](crate::enums::GL_FUNC_ADD)
/// equation is useful for antialiasing and transparency, among other things.
///
/// Initially, both the RGB blend equation and the alpha blend equation are
/// set to [`GL_FUNC_ADD`](crate::enums::GL_FUNC_ADD).
///
///
/// ### Notes
/// The [`GL_MIN`](crate::enums::GL_MIN), and [`GL_MAX`](crate::enums::GL_MAX)
/// equations do not use the source or destination factors, only the source
/// and destination colors.
///
/// ### Associated Gets
/// [**glGet**](crate::context::Context::oxidegl_get) with an argument of [`GL_BLEND_EQUATION_RGB`](crate::enums::GL_BLEND_EQUATION_RGB)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with an argument of [`GL_BLEND_EQUATION_ALPHA`](crate::enums::GL_BLEND_EQUATION_ALPHA)
impl Context {
    pub fn oxidegl_blend_equation_separate(
        &mut self,
        mode_r_g_b: BlendEquationModeEXT,
        mode_alpha: BlendEquationModeEXT,
    ) {
        panic!("command oxidegl_blend_equation_separate not yet implemented");
    }
    pub fn oxidegl_blend_equation_separatei(
        &mut self,
        buf: GLuint,
        mode_r_g_b: BlendEquationModeEXT,
        mode_alpha: BlendEquationModeEXT,
    ) {
        panic!("command oxidegl_blend_equation_separatei not yet implemented");
    }
}
/// ### Parameters
/// `buf`
///
/// > For [**glBlendFunci**](crate::context::Context::oxidegl_blend_funci), specifies
/// > the index of the draw buffer for which to set the blend function.
///
/// `sfactor`
///
/// > Specifies how the red, green, blue, and alpha source blending factors are
/// > computed. The initial value is [`GL_ONE`](crate::enums::GL_ONE).
///
/// `dfactor`
///
/// > Specifies how the red, green, blue, and alpha destination blending factors
/// > are computed. The following symbolic constants are accepted: [`GL_ZERO`](crate::enums::GL_ZERO),
/// > [`GL_ONE`](crate::enums::GL_ONE), [`GL_SRC_COLOR`](crate::enums::GL_SRC_COLOR),
/// > [`GL_ONE_MINUS_SRC_COLOR`](crate::enums::GL_ONE_MINUS_SRC_COLOR), [`GL_DST_COLOR`](crate::enums::GL_DST_COLOR),
/// > [`GL_ONE_MINUS_DST_COLOR`](crate::enums::GL_ONE_MINUS_DST_COLOR), [`GL_SRC_ALPHA`](crate::enums::GL_SRC_ALPHA),
/// > [`GL_ONE_MINUS_SRC_ALPHA`](crate::enums::GL_ONE_MINUS_SRC_ALPHA), [`GL_DST_ALPHA`](crate::enums::GL_DST_ALPHA),
/// > [`GL_ONE_MINUS_DST_ALPHA`](crate::enums::GL_ONE_MINUS_DST_ALPHA). [`GL_CONSTANT_COLOR`](crate::enums::GL_CONSTANT_COLOR),
/// > [`GL_ONE_MINUS_CONSTANT_COLOR`](crate::enums::GL_ONE_MINUS_CONSTANT_COLOR),
/// > [`GL_CONSTANT_ALPHA`](crate::enums::GL_CONSTANT_ALPHA), and [`GL_ONE_MINUS_CONSTANT_ALPHA`](crate::enums::GL_ONE_MINUS_CONSTANT_ALPHA).
/// > The initial value is [`GL_ZERO`](crate::enums::GL_ZERO).
///
/// ### Description
/// Pixels can be drawn using a function that blends the incoming (source)
/// RGBA values with the RGBA values that are already in the frame buffer (the
/// destination values). Blending is initially disabled. Use [**glEnable**](crate::context::Context::oxidegl_enable)
/// and [**glDisable**](crate::context::Context::oxidegl_disable) with argument
/// [`GL_BLEND`](crate::enums::GL_BLEND) to enable and disable blending.
///
/// [**glBlendFunc**](crate::context::Context::oxidegl_blend_func) defines
/// the operation of blending for all draw buffers when it is enabled. [**glBlendFunci**](crate::context::Context::oxidegl_blend_funci)
/// defines the operation of blending for a single draw buffer specified by
/// `buf` when enabled for that draw buffer. `sfactor` specifies which method
/// is used to scale the source color components. `dfactor` specifies which
/// method is used to scale the destination color components. Both parameters
/// must be one of the following symbolic constants: [`GL_ZERO`](crate::enums::GL_ZERO),
/// [`GL_ONE`](crate::enums::GL_ONE), [`GL_SRC_COLOR`](crate::enums::GL_SRC_COLOR),
/// [`GL_ONE_MINUS_SRC_COLOR`](crate::enums::GL_ONE_MINUS_SRC_COLOR), [`GL_DST_COLOR`](crate::enums::GL_DST_COLOR),
/// [`GL_ONE_MINUS_DST_COLOR`](crate::enums::GL_ONE_MINUS_DST_COLOR), [`GL_SRC_ALPHA`](crate::enums::GL_SRC_ALPHA),
/// [`GL_ONE_MINUS_SRC_ALPHA`](crate::enums::GL_ONE_MINUS_SRC_ALPHA), [`GL_DST_ALPHA`](crate::enums::GL_DST_ALPHA),
/// [`GL_ONE_MINUS_DST_ALPHA`](crate::enums::GL_ONE_MINUS_DST_ALPHA), [`GL_CONSTANT_COLOR`](crate::enums::GL_CONSTANT_COLOR),
/// [`GL_ONE_MINUS_CONSTANT_COLOR`](crate::enums::GL_ONE_MINUS_CONSTANT_COLOR),
/// [`GL_CONSTANT_ALPHA`](crate::enums::GL_CONSTANT_ALPHA), [`GL_ONE_MINUS_CONSTANT_ALPHA`](crate::enums::GL_ONE_MINUS_CONSTANT_ALPHA),
/// [`GL_SRC_ALPHA_SATURATE`](crate::enums::GL_SRC_ALPHA_SATURATE), [`GL_SRC1_COLOR`](crate::enums::GL_SRC1_COLOR),
/// [`GL_ONE_MINUS_SRC1_COLOR`](crate::enums::GL_ONE_MINUS_SRC1_COLOR), [`GL_SRC1_ALPHA`](crate::enums::GL_SRC1_ALPHA),
/// and [`GL_ONE_MINUS_SRC1_ALPHA`](crate::enums::GL_ONE_MINUS_SRC1_ALPHA).
/// The possible methods are described in the following table. Each method
/// defines four scale factors, one each for red, green, blue, and alpha. In
/// the table and in subsequent equations, first source, second source and
/// destination color components are referred to as `[inlineq]` `[inlineq]`
/// `[inlineq]` [**glBlendColor**](crate::context::Context::oxidegl_blend_color)
/// is referred to as `[inlineq]` `[inlineq]`
///
/// `[inlineq]`
///
/// and `[inlineq]`
///
/// Source and destination scale factors are referred to as `[inlineq]` `[inlineq]`
/// `[inlineq]` `[inlineq]`
///
///
/// |* Parameter*       | `[inlineq]`       |
/// |-------------------|-------------------|
/// | [`GL_ZERO`](crate::enums::GL_ZERO) | `[inlineq]` |
/// | [`GL_ONE`](crate::enums::GL_ONE) | `[inlineq]` |
/// | [`GL_SRC_COLOR`](crate::enums::GL_SRC_COLOR) | `[inlineq]` |
/// | [`GL_ONE_MINUS_SRC_COLOR`](crate::enums::GL_ONE_MINUS_SRC_COLOR) | `[inlineq]` |
/// | [`GL_DST_COLOR`](crate::enums::GL_DST_COLOR) | `[inlineq]` |
/// | [`GL_ONE_MINUS_DST_COLOR`](crate::enums::GL_ONE_MINUS_DST_COLOR) | `[inlineq]` |
/// | [`GL_SRC_ALPHA`](crate::enums::GL_SRC_ALPHA) | `[inlineq]` |
/// | [`GL_ONE_MINUS_SRC_ALPHA`](crate::enums::GL_ONE_MINUS_SRC_ALPHA) | `[inlineq]` |
/// | [`GL_DST_ALPHA`](crate::enums::GL_DST_ALPHA) | `[inlineq]` |
/// | [`GL_ONE_MINUS_DST_ALPHA`](crate::enums::GL_ONE_MINUS_DST_ALPHA) | `[inlineq]` |
/// | [`GL_CONSTANT_COLOR`](crate::enums::GL_CONSTANT_COLOR) | `[inlineq]` |
/// | [`GL_ONE_MINUS_CONSTANT_COLOR`](crate::enums::GL_ONE_MINUS_CONSTANT_COLOR) | `[inlineq]` |
/// | [`GL_CONSTANT_ALPHA`](crate::enums::GL_CONSTANT_ALPHA) | `[inlineq]` |
/// | [`GL_ONE_MINUS_CONSTANT_ALPHA`](crate::enums::GL_ONE_MINUS_CONSTANT_ALPHA) | `[inlineq]` |
/// | [`GL_SRC_ALPHA_SATURATE`](crate::enums::GL_SRC_ALPHA_SATURATE) | `[inlineq]` |
/// | [`GL_SRC1_COLOR`](crate::enums::GL_SRC1_COLOR) | `[inlineq]` |
/// | [`GL_ONE_MINUS_SRC1_COLOR`](crate::enums::GL_ONE_MINUS_SRC1_COLOR) | `[inlineq]` |
/// | [`GL_SRC1_ALPHA`](crate::enums::GL_SRC1_ALPHA) | `[inlineq]` |
/// | [`GL_ONE_MINUS_SRC1_ALPHA`](crate::enums::GL_ONE_MINUS_SRC1_ALPHA) | `[inlineq]` |
///
/// In the table,
///
/// `[inlineq]`
///
/// To determine the blended RGBA values of a pixel, the system uses the following
/// equations:
///
/// `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]`
///
/// Despite the apparent precision of the above equations, blending arithmetic
/// is not exactly specified, because blending operates with imprecise integer
/// color values. However, a blend factor that should be equal to 1 is guaranteed
/// not to modify its multiplicand, and a blend factor equal to 0 reduces its
/// multiplicand to 0. For example, when `sfactor` is [`GL_SRC_ALPHA`](crate::enums::GL_SRC_ALPHA),
/// `dfactor` is [`GL_ONE_MINUS_SRC_ALPHA`](crate::enums::GL_ONE_MINUS_SRC_ALPHA),
/// and `[inlineq]` `[inlineq]`
///
/// `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]`
///
///
/// ### Notes
/// Incoming (source) alpha would typically be used as a material opacity,
/// ranging from 1.0( `[inlineq]`
///
/// When more than one color buffer is enabled for drawing, the GL performs
/// blending separately for each enabled buffer, using the contents of that
/// buffer for destination color. (See [**glDrawBuffer**](crate::context::Context::oxidegl_draw_buffer)
/// .)
///
/// When dual source blending is enabled (i.e., one of the blend factors requiring
/// the second color input is used), the maximum number of enabled draw buffers
/// is given by [`GL_MAX_DUAL_SOURCE_DRAW_BUFFERS`](crate::enums::GL_MAX_DUAL_SOURCE_DRAW_BUFFERS),
/// which may be lower than [`GL_MAX_DRAW_BUFFERS`](crate::enums::GL_MAX_DRAW_BUFFERS).
///
/// ### Associated Gets
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_BLEND_SRC_RGB`](crate::enums::GL_BLEND_SRC_RGB)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_BLEND_SRC_ALPHA`](crate::enums::GL_BLEND_SRC_ALPHA)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_BLEND_DST_RGB`](crate::enums::GL_BLEND_DST_RGB)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_BLEND_DST_ALPHA`](crate::enums::GL_BLEND_DST_ALPHA)
///
/// [**glIsEnabled**](crate::context::Context::oxidegl_is_enabled) with argument
/// [`GL_BLEND`](crate::enums::GL_BLEND)
///
impl Context {
    pub fn oxidegl_blend_func(&mut self, sfactor: BlendingFactor, dfactor: BlendingFactor) {
        panic!("command oxidegl_blend_func not yet implemented");
    }
    pub fn oxidegl_blend_funci(&mut self, buf: GLuint, src: BlendingFactor, dst: BlendingFactor) {
        panic!("command oxidegl_blend_funci not yet implemented");
    }
}
/// ### Parameters
/// `buf`
///
/// > For [**glBlendFuncSeparatei**](crate::context::Context::oxidegl_blend_func_separatei),
/// > specifies the index of the draw buffer for which to set the blend functions.
///
/// `srcRGB`
///
/// > Specifies how the red, green, and blue blending factors are computed. The
/// > initial value is [`GL_ONE`](crate::enums::GL_ONE).
///
/// `dstRGB`
///
/// > Specifies how the red, green, and blue destination blending factors are
/// > computed. The initial value is [`GL_ZERO`](crate::enums::GL_ZERO).
///
/// `srcAlpha`
///
/// > Specified how the alpha source blending factor is computed. The initial
/// > value is [`GL_ONE`](crate::enums::GL_ONE).
///
/// `dstAlpha`
///
/// > Specified how the alpha destination blending factor is computed. The initial
/// > value is [`GL_ZERO`](crate::enums::GL_ZERO).
///
/// ### Description
/// Pixels can be drawn using a function that blends the incoming (source)
/// RGBA values with the RGBA values that are already in the frame buffer (the
/// destination values). Blending is initially disabled. Use [**glEnable**](crate::context::Context::oxidegl_enable)
/// and [**glDisable**](crate::context::Context::oxidegl_disable) with argument
/// [`GL_BLEND`](crate::enums::GL_BLEND) to enable and disable blending.
///
/// [**glBlendFuncSeparate**](crate::context::Context::oxidegl_blend_func_separate)
/// defines the operation of blending for all draw buffers when it is enabled.
/// [**glBlendFuncSeparatei**](crate::context::Context::oxidegl_blend_func_separatei)
/// defines the operation of blending for a single draw buffer specified by
/// `buf` when enabled for that draw buffer. `srcRGB` specifies which method
/// is used to scale the source RGB-color components. `dstRGB` specifies which
/// method is used to scale the destination RGB-color components. Likewise,
/// `srcAlpha` specifies which method is used to scale the source alpha color
/// component, and `dstAlpha` specifies which method is used to scale the destination
/// alpha component. The possible methods are described in the following table.
/// Each method defines four scale factors, one each for red, green, blue,
/// and alpha.
///
/// In the table and in subsequent equations, first source, second source and
/// destination color components are referred to as `[inlineq]` `[inlineq]`
/// `[inlineq]` [**glBlendColor**](crate::context::Context::oxidegl_blend_color)
/// is referred to as `[inlineq]` `[inlineq]`
///
/// `[inlineq]`
///
/// and `[inlineq]`
///
/// Source and destination scale factors are referred to as `[inlineq]` `[inlineq]`
/// `[inlineq]`
///
///
/// |* Parameter*       |* RGB Factor*        |* Alpha Factor*                           |
/// |-------------------|---------------------|------------------------------------------|
/// | [`GL_ZERO`](crate::enums::GL_ZERO) | `[inlineq]` | `[inlineq]`                     |
/// | [`GL_ONE`](crate::enums::GL_ONE) | `[inlineq]` | `[inlineq]`                       |
/// | [`GL_SRC_COLOR`](crate::enums::GL_SRC_COLOR) | `[inlineq]` | `[inlineq]`           |
/// | [`GL_ONE_MINUS_SRC_COLOR`](crate::enums::GL_ONE_MINUS_SRC_COLOR) | `[inlineq]` | `[inlineq]` |
/// | [`GL_DST_COLOR`](crate::enums::GL_DST_COLOR) | `[inlineq]` | `[inlineq]`           |
/// | [`GL_ONE_MINUS_DST_COLOR`](crate::enums::GL_ONE_MINUS_DST_COLOR) | `[inlineq]` | `[inlineq]` |
/// | [`GL_SRC_ALPHA`](crate::enums::GL_SRC_ALPHA) | `[inlineq]` | `[inlineq]`           |
/// | [`GL_ONE_MINUS_SRC_ALPHA`](crate::enums::GL_ONE_MINUS_SRC_ALPHA) | `[inlineq]` | `[inlineq]` |
/// | [`GL_DST_ALPHA`](crate::enums::GL_DST_ALPHA) | `[inlineq]` | `[inlineq]`           |
/// | [`GL_ONE_MINUS_DST_ALPHA`](crate::enums::GL_ONE_MINUS_DST_ALPHA) | `[inlineq]` | `[inlineq]` |
/// | [`GL_CONSTANT_COLOR`](crate::enums::GL_CONSTANT_COLOR) | `[inlineq]` | `[inlineq]` |
/// | [`GL_ONE_MINUS_CONSTANT_COLOR`](crate::enums::GL_ONE_MINUS_CONSTANT_COLOR) | `[inlineq]` | `[inlineq]` |
/// | [`GL_CONSTANT_ALPHA`](crate::enums::GL_CONSTANT_ALPHA) | `[inlineq]` | `[inlineq]` |
/// | [`GL_ONE_MINUS_CONSTANT_ALPHA`](crate::enums::GL_ONE_MINUS_CONSTANT_ALPHA) | `[inlineq]` | `[inlineq]` |
/// | [`GL_SRC_ALPHA_SATURATE`](crate::enums::GL_SRC_ALPHA_SATURATE) | `[inlineq]` | `[inlineq]` |
/// | [`GL_SRC1_COLOR`](crate::enums::GL_SRC1_COLOR) | `[inlineq]` | `[inlineq]`         |
/// | [`GL_ONE_MINUS_SRC1_COLOR`](crate::enums::GL_ONE_MINUS_SRC1_COLOR) | `[inlineq]` | `[inlineq]` |
/// | [`GL_SRC1_ALPHA`](crate::enums::GL_SRC1_ALPHA) | `[inlineq]` | `[inlineq]`         |
/// | [`GL_ONE_MINUS_SRC1_ALPHA`](crate::enums::GL_ONE_MINUS_SRC1_ALPHA) | `[inlineq]` | `[inlineq]` |
///
/// In the table,
///
/// `[inlineq]`
///
/// To determine the blended RGBA values of a pixel, the system uses the following
/// equations:
///
/// `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]`
///
/// Despite the apparent precision of the above equations, blending arithmetic
/// is not exactly specified, because blending operates with imprecise integer
/// color values. However, a blend factor that should be equal to 1 is guaranteed
/// not to modify its multiplicand, and a blend factor equal to 0 reduces its
/// multiplicand to 0. For example, when `srcRGB` is [`GL_SRC_ALPHA`](crate::enums::GL_SRC_ALPHA),
/// `dstRGB` is [`GL_ONE_MINUS_SRC_ALPHA`](crate::enums::GL_ONE_MINUS_SRC_ALPHA),
/// and `[inlineq]` `[inlineq]`
///
/// `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]`
///
///
/// ### Notes
/// Incoming (source) alpha is correctly thought of as a material opacity,
/// ranging from 1.0( `[inlineq]`
///
/// When more than one color buffer is enabled for drawing, the GL performs
/// blending separately for each enabled buffer, using the contents of that
/// buffer for destination color. (See [**glDrawBuffer**](crate::context::Context::oxidegl_draw_buffer)
/// .)
///
/// When dual source blending is enabled (i.e., one of the blend factors requiring
/// the second color input is used), the maximum number of enabled draw buffers
/// is given by [`GL_MAX_DUAL_SOURCE_DRAW_BUFFERS`](crate::enums::GL_MAX_DUAL_SOURCE_DRAW_BUFFERS),
/// which may be lower than [`GL_MAX_DRAW_BUFFERS`](crate::enums::GL_MAX_DRAW_BUFFERS).
///
/// ### Associated Gets
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_BLEND_SRC_RGB`](crate::enums::GL_BLEND_SRC_RGB)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_BLEND_SRC_ALPHA`](crate::enums::GL_BLEND_SRC_ALPHA)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_BLEND_DST_RGB`](crate::enums::GL_BLEND_DST_RGB)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_BLEND_DST_ALPHA`](crate::enums::GL_BLEND_DST_ALPHA)
///
/// [**glIsEnabled**](crate::context::Context::oxidegl_is_enabled) with argument
/// [`GL_BLEND`](crate::enums::GL_BLEND)
///
impl Context {
    pub fn oxidegl_blend_func_separate(
        &mut self,
        sfactor_r_g_b: BlendingFactor,
        dfactor_r_g_b: BlendingFactor,
        sfactor_alpha: BlendingFactor,
        dfactor_alpha: BlendingFactor,
    ) {
        panic!("command oxidegl_blend_func_separate not yet implemented");
    }
    pub fn oxidegl_blend_func_separatei(
        &mut self,
        buf: GLuint,
        src_r_g_b: BlendingFactor,
        dst_r_g_b: BlendingFactor,
        src_alpha: BlendingFactor,
        dst_alpha: BlendingFactor,
    ) {
        panic!("command oxidegl_blend_func_separatei not yet implemented");
    }
}
/// ### Parameters
/// `readFramebuffer`
///
/// > Specifies the name of the source framebuffer object for [**glBlitNamedFramebuffer**](crate::context::Context::oxidegl_blit_named_framebuffer).
///
/// `drawFramebuffer`
///
/// > Specifies the name of the destination framebuffer object for [**glBlitNamedFramebuffer**](crate::context::Context::oxidegl_blit_named_framebuffer).
///
/// `srcX0`
///
/// `srcY0`
///
/// `srcX1`
///
/// `srcY1`
///
/// > Specify the bounds of the source rectangle within the read buffer of the
/// > read framebuffer.
///
/// `dstX0`
///
/// `dstY0`
///
/// `dstX1`
///
/// `dstY1`
///
/// > Specify the bounds of the destination rectangle within the write buffer
/// > of the write framebuffer.
///
/// `mask`
///
/// > The bitwise OR of the flags indicating which buffers are to be copied.
/// > The allowed flags are [`GL_COLOR_BUFFER_BIT`](crate::enums::GL_COLOR_BUFFER_BIT),
/// > [`GL_DEPTH_BUFFER_BIT`](crate::enums::GL_DEPTH_BUFFER_BIT) and [`GL_STENCIL_BUFFER_BIT`](crate::enums::GL_STENCIL_BUFFER_BIT).
///
/// `filter`
///
/// > Specifies the interpolation to be applied if the image is stretched. Must
/// > be [`GL_NEAREST`](crate::enums::GL_NEAREST) or [`GL_LINEAR`](crate::enums::GL_LINEAR).
///
/// ### Description
/// [**glBlitFramebuffer**](crate::context::Context::oxidegl_blit_framebuffer)
/// and [**glBlitNamedFramebuffer**](crate::context::Context::oxidegl_blit_named_framebuffer)
/// transfer a rectangle of pixel values from one region of a read framebuffer
/// to another region of a draw framebuffer.
///
/// For [**glBlitFramebuffer**](crate::context::Context::oxidegl_blit_framebuffer),
/// the read and draw framebuffers are those bound to the [`GL_READ_FRAMEBUFFER`](crate::enums::GL_READ_FRAMEBUFFER)
/// and [`GL_DRAW_FRAMEBUFFER`](crate::enums::GL_DRAW_FRAMEBUFFER) targets
/// respectively.
///
/// For [**glBlitNamedFramebuffer**](crate::context::Context::oxidegl_blit_named_framebuffer),
/// `readFramebuffer` and `drawFramebuffer` are the names of the read and draw
/// framebuffer objects respectively. If `readFramebuffer` or `drawFramebuffer`
/// is zero, then the default read or draw framebuffer respectively is used.
///
/// `mask` is the bitwise OR of a number of values indicating which buffers
/// are to be copied. The values are [`GL_COLOR_BUFFER_BIT`](crate::enums::GL_COLOR_BUFFER_BIT),
/// [`GL_DEPTH_BUFFER_BIT`](crate::enums::GL_DEPTH_BUFFER_BIT), and [`GL_STENCIL_BUFFER_BIT`](crate::enums::GL_STENCIL_BUFFER_BIT).
/// The pixels corresponding to these buffers are copied from the source rectangle
/// bounded by the locations( `srcX0`, `srcY0`) and( `srcX1`, `srcY1`) to the
/// destination rectangle bounded by the locations( `dstX0`, `dstY0`) and( `dstX1`,
/// `dstY1` ). The lower bounds of the rectangle are inclusive, while the upper
/// bounds are exclusive.
///
/// The actual region taken from the read framebuffer is limited to the intersection
/// of the source buffers being transferred, which may include the color buffer
/// selected by the read buffer, the depth buffer, and/or the stencil buffer
/// depending on mask. The actual region written to the draw framebuffer is
/// limited to the intersection of the destination buffers being written, which
/// may include multiple draw buffers, the depth buffer, and/or the stencil
/// buffer depending on mask. Whether or not the source or destination regions
/// are altered due to these limits, the scaling and offset applied to pixels
/// being transferred is performed as though no such limits were present.
///
/// If the sizes of the source and destination rectangles are not equal, `filter`
/// specifies the interpolation method that will be applied to resize the source
/// image, and must be [`GL_NEAREST`](crate::enums::GL_NEAREST) or [`GL_LINEAR`](crate::enums::GL_LINEAR).
/// [`GL_LINEAR`](crate::enums::GL_LINEAR) is only a valid interpolation method
/// for the color buffer. If `filter` is not [`GL_NEAREST`](crate::enums::GL_NEAREST)
/// and `mask` includes [`GL_DEPTH_BUFFER_BIT`](crate::enums::GL_DEPTH_BUFFER_BIT)
/// or [`GL_STENCIL_BUFFER_BIT`](crate::enums::GL_STENCIL_BUFFER_BIT), no data
/// is transferred and a [`GL_INVALID_OPERATION`](crate::enums::GL_INVALID_OPERATION)
/// error is generated.
///
/// If `filter` is [`GL_LINEAR`](crate::enums::GL_LINEAR) and the source rectangle
/// would require sampling outside the bounds of the source framebuffer, values
/// are read as if the [`GL_CLAMP_TO_EDGE`](crate::enums::GL_CLAMP_TO_EDGE)
/// texture wrapping mode were applied.
///
/// When the color buffer is transferred, values are taken from the read buffer
/// of the specified read framebuffer and written to each of the draw buffers
/// of the specified draw framebuffer.
///
/// If the source and destination rectangles overlap or are the same, and the
/// read and draw buffers are the same, the result of the operation is undefined.
impl Context {
    pub fn oxidegl_blit_framebuffer(
        &mut self,
        src_x0: GLint,
        src_y0: GLint,
        src_x1: GLint,
        src_y1: GLint,
        dst_x0: GLint,
        dst_y0: GLint,
        dst_x1: GLint,
        dst_y1: GLint,
        mask: ClearBufferMask,
        filter: BlitFramebufferFilter,
    ) {
        panic!("command oxidegl_blit_framebuffer not yet implemented");
    }
    pub fn oxidegl_blit_named_framebuffer(
        &mut self,
        read_framebuffer: GLuint,
        draw_framebuffer: GLuint,
        src_x0: GLint,
        src_y0: GLint,
        src_x1: GLint,
        src_y1: GLint,
        dst_x0: GLint,
        dst_y0: GLint,
        dst_x1: GLint,
        dst_y1: GLint,
        mask: ClearBufferMask,
        filter: BlitFramebufferFilter,
    ) {
        panic!("command oxidegl_blit_named_framebuffer not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the buffer object is bound for [**glBufferData**](crate::context::Context::oxidegl_buffer_data),
/// > which must be one of the buffer binding targets in the following table:
///
/// > | *Buffer Binding Target*                               | *Purpose*      |
/// > |-------------------------------------------------------|----------------|
/// > | [`GL_ARRAY_BUFFER`](crate::enums::GL_ARRAY_BUFFER)    | Vertex attributes |
/// > | [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER) | Atomic counter storage |
/// > | [`GL_COPY_READ_BUFFER`](crate::enums::GL_COPY_READ_BUFFER) | Buffer copy source |
/// > | [`GL_COPY_WRITE_BUFFER`](crate::enums::GL_COPY_WRITE_BUFFER) | Buffer copy destination |
/// > | [`GL_DISPATCH_INDIRECT_BUFFER`](crate::enums::GL_DISPATCH_INDIRECT_BUFFER) | Indirect compute dispatch commands |
/// > | [`GL_DRAW_INDIRECT_BUFFER`](crate::enums::GL_DRAW_INDIRECT_BUFFER) | Indirect command arguments |
/// > | [`GL_ELEMENT_ARRAY_BUFFER`](crate::enums::GL_ELEMENT_ARRAY_BUFFER) | Vertex array indices |
/// > | [`GL_PIXEL_PACK_BUFFER`](crate::enums::GL_PIXEL_PACK_BUFFER) | Pixel read target |
/// > | [`GL_PIXEL_UNPACK_BUFFER`](crate::enums::GL_PIXEL_UNPACK_BUFFER) | Texture data source |
/// > | [`GL_QUERY_BUFFER`](crate::enums::GL_QUERY_BUFFER)    | Query result buffer |
/// > | [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER) | Read-write storage for shaders |
/// > | [`GL_TEXTURE_BUFFER`](crate::enums::GL_TEXTURE_BUFFER) | Texture data buffer |
/// > | [`GL_TRANSFORM_FEEDBACK_BUFFER`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER) | Transform feedback buffer |
/// > | [`GL_UNIFORM_BUFFER`](crate::enums::GL_UNIFORM_BUFFER) | Uniform block storage |
///
/// `buffer`
///
/// > Specifies the name of the buffer object for [**glNamedBufferData**](crate::context::Context::oxidegl_named_buffer_data)
/// > function.
///
/// `size`
///
/// > Specifies the size in bytes of the buffer object's new data store.
///
/// `data`
///
/// > Specifies a pointer to data that will be copied into the data store for
/// > initialization, or [`NULL`](crate::enums::NULL) if no data is to be copied.
///
/// `usage`
///
/// > Specifies the expected usage pattern of the data store. The symbolic constant
/// > must be [`GL_STREAM_DRAW`](crate::enums::GL_STREAM_DRAW), [`GL_STREAM_READ`](crate::enums::GL_STREAM_READ),
/// > [`GL_STREAM_COPY`](crate::enums::GL_STREAM_COPY), [`GL_STATIC_DRAW`](crate::enums::GL_STATIC_DRAW),
/// > [`GL_STATIC_READ`](crate::enums::GL_STATIC_READ), [`GL_STATIC_COPY`](crate::enums::GL_STATIC_COPY),
/// > [`GL_DYNAMIC_DRAW`](crate::enums::GL_DYNAMIC_DRAW), [`GL_DYNAMIC_READ`](crate::enums::GL_DYNAMIC_READ),
/// > or [`GL_DYNAMIC_COPY`](crate::enums::GL_DYNAMIC_COPY).
///
/// ### Description
/// [**glBufferData**](crate::context::Context::oxidegl_buffer_data) and [**glNamedBufferData**](crate::context::Context::oxidegl_named_buffer_data)
/// create a new data store for a buffer object. In case of [**glBufferData**](crate::context::Context::oxidegl_buffer_data),
/// the buffer object currently bound to `target` is used. For [**glNamedBufferData**](crate::context::Context::oxidegl_named_buffer_data),
/// a buffer object associated with ID specified by the caller in `buffer`
/// will be used instead.
///
/// While creating the new storage, any pre-existing data store is deleted.
/// The new data store is created with the specified `size` in bytes and `usage`.
/// If `data` is not [`NULL`](crate::enums::NULL), the data store is initialized
/// with data from this pointer. In its initial state, the new data store is
/// not mapped, it has a [`NULL`](crate::enums::NULL) mapped pointer, and its
/// mapped access is [`GL_READ_WRITE`](crate::enums::GL_READ_WRITE).
///
/// `usage` is a hint to the GL implementation as to how a buffer object's
/// data store will be accessed. This enables the GL implementation to make
/// more intelligent decisions that may significantly impact buffer object
/// performance. It does not, however, constrain the actual usage of the data
/// store. `usage` can be broken down into two parts: first, the frequency
/// of access (modification and usage), and second, the nature of that access.
/// The frequency of access may be one of these:
///
/// STREAM
///
/// > The data store contents will be modified once and used at most a few times.
///
/// STATIC
///
/// > The data store contents will be modified once and used many times.
///
/// DYNAMIC
///
/// > The data store contents will be modified repeatedly and used many times.
///
/// The nature of access may be one of these:
///
/// DRAW
///
/// > The data store contents are modified by the application, and used as the
/// > source for GL drawing and image specification commands.
///
/// READ
///
/// > The data store contents are modified by reading data from the GL, and used
/// > to return that data when queried by the application.
///
/// COPY
///
/// > The data store contents are modified by reading data from the GL, and used
/// > as the source for GL drawing and image specification commands.
///
/// ### Notes
/// If `data` is [`NULL`](crate::enums::NULL), a data store of the specified
/// size is still created, but its contents remain uninitialized and thus undefined.
///
/// Clients must align data elements consistently with the requirements of
/// the client platform, with an additional base-level requirement that an
/// offset within a buffer to a datum comprising `[inlineq]` `[inlineq]`
///
/// The [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER)
/// target is available only if the GL version is 4.2 or greater.
///
/// The [`GL_DISPATCH_INDIRECT_BUFFER`](crate::enums::GL_DISPATCH_INDIRECT_BUFFER)
/// and [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER)
/// targets are available only if the GL version is 4.3 or greater.
///
/// The [`GL_QUERY_BUFFER`](crate::enums::GL_QUERY_BUFFER) target is available
/// only if the GL version is 4.4 or greater.
///
/// ### Associated Gets
/// [**glGetBufferSubData**](crate::context::Context::oxidegl_get_buffer_sub_data)
///
/// [**glGetBufferParameter**](crate::context::Context::oxidegl_get_buffer_parameter)
/// with argument [`GL_BUFFER_SIZE`](crate::enums::GL_BUFFER_SIZE) or [`GL_BUFFER_USAGE`](crate::enums::GL_BUFFER_USAGE)
impl Context {
    pub unsafe fn oxidegl_buffer_data(
        &mut self,
        target: BufferTarget,
        size: GLsizeiptr,
        data: *const GLvoid,
        usage: BufferUsage,
    ) {
        panic!("command oxidegl_buffer_data not yet implemented");
    }
    pub unsafe fn oxidegl_named_buffer_data(
        &mut self,
        buffer: GLuint,
        size: GLsizeiptr,
        data: *const GLvoid,
        usage: VertexBufferObjectUsage,
    ) {
        panic!("command oxidegl_named_buffer_data not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the buffer object is bound for [**glBufferStorage**](crate::context::Context::oxidegl_buffer_storage),
/// > which must be one of the buffer binding targets in the following table:
///
/// > | *Buffer Binding Target*                               | *Purpose*      |
/// > |-------------------------------------------------------|----------------|
/// > | [`GL_ARRAY_BUFFER`](crate::enums::GL_ARRAY_BUFFER)    | Vertex attributes |
/// > | [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER) | Atomic counter storage |
/// > | [`GL_COPY_READ_BUFFER`](crate::enums::GL_COPY_READ_BUFFER) | Buffer copy source |
/// > | [`GL_COPY_WRITE_BUFFER`](crate::enums::GL_COPY_WRITE_BUFFER) | Buffer copy destination |
/// > | [`GL_DISPATCH_INDIRECT_BUFFER`](crate::enums::GL_DISPATCH_INDIRECT_BUFFER) | Indirect compute dispatch commands |
/// > | [`GL_DRAW_INDIRECT_BUFFER`](crate::enums::GL_DRAW_INDIRECT_BUFFER) | Indirect command arguments |
/// > | [`GL_ELEMENT_ARRAY_BUFFER`](crate::enums::GL_ELEMENT_ARRAY_BUFFER) | Vertex array indices |
/// > | [`GL_PIXEL_PACK_BUFFER`](crate::enums::GL_PIXEL_PACK_BUFFER) | Pixel read target |
/// > | [`GL_PIXEL_UNPACK_BUFFER`](crate::enums::GL_PIXEL_UNPACK_BUFFER) | Texture data source |
/// > | [`GL_QUERY_BUFFER`](crate::enums::GL_QUERY_BUFFER)    | Query result buffer |
/// > | [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER) | Read-write storage for shaders |
/// > | [`GL_TEXTURE_BUFFER`](crate::enums::GL_TEXTURE_BUFFER) | Texture data buffer |
/// > | [`GL_TRANSFORM_FEEDBACK_BUFFER`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER) | Transform feedback buffer |
/// > | [`GL_UNIFORM_BUFFER`](crate::enums::GL_UNIFORM_BUFFER) | Uniform block storage |
///
/// `buffer`
///
/// > Specifies the name of the buffer object for [**glNamedBufferStorage**](crate::context::Context::oxidegl_named_buffer_storage)
/// > function.
///
/// `size`
///
/// > Specifies the size in bytes of the buffer object's new data store.
///
/// `data`
///
/// > Specifies a pointer to data that will be copied into the data store for
/// > initialization, or [`NULL`](crate::enums::NULL) if no data is to be copied.
///
/// `flags`
///
/// > Specifies the intended usage of the buffer's data store. Must be a bitwise
/// > combination of the following flags. [`GL_DYNAMIC_STORAGE_BIT`](crate::enums::GL_DYNAMIC_STORAGE_BIT),
/// > [`GL_MAP_READ_BIT`](crate::enums::GL_MAP_READ_BIT) [`GL_MAP_WRITE_BIT`](crate::enums::GL_MAP_WRITE_BIT),
/// > [`GL_MAP_PERSISTENT_BIT`](crate::enums::GL_MAP_PERSISTENT_BIT), [`GL_MAP_COHERENT_BIT`](crate::enums::GL_MAP_COHERENT_BIT),
/// > and [`GL_CLIENT_STORAGE_BIT`](crate::enums::GL_CLIENT_STORAGE_BIT).
///
/// ### Description
/// [**glBufferStorage**](crate::context::Context::oxidegl_buffer_storage)
/// and [**glNamedBufferStorage**](crate::context::Context::oxidegl_named_buffer_storage)
/// create a new immutable data store. For [**glBufferStorage**](crate::context::Context::oxidegl_buffer_storage),
/// the buffer object currently bound to `target` will be initialized. For
/// [**glNamedBufferStorage**](crate::context::Context::oxidegl_named_buffer_storage),
/// `buffer` is the name of the buffer object that will be configured. The
/// size of the data store is specified by `size`. If an initial data is available,
/// its address may be supplied in `data`. Otherwise, to create an uninitialized
/// data store, `data` should be [`NULL`](crate::enums::NULL).
///
/// The `flags` parameters specifies the intended usage of the buffer's data
/// store. It must be a bitwise combination of a subset of the following flags:
/// [`GL_DYNAMIC_STORAGE_BIT`](crate::enums::GL_DYNAMIC_STORAGE_BIT)
///
/// > The contents of the data store may be updated after creation through calls
/// > to [**glBufferSubData**](crate::context::Context::oxidegl_buffer_sub_data).
/// > If this bit is not set, the buffer content may not be directly updated
/// > by the client. The data argument may be used to specify the initial content
/// > of the buffer's data store regardless of the presence of the [`GL_DYNAMIC_STORAGE_BIT`](crate::enums::GL_DYNAMIC_STORAGE_BIT).
/// > Regardless of the presence of this bit, buffers may always be updated
/// > with server-side calls such as [**glCopyBufferSubData**](crate::context::Context::oxidegl_copy_buffer_sub_data)
/// > and [**glClearBufferSubData**](crate::context::Context::oxidegl_clear_buffer_sub_data).
///
/// [`GL_MAP_READ_BIT`](crate::enums::GL_MAP_READ_BIT)
///
/// > The data store may be mapped by the client for read access and a pointer
/// > in the client's address space obtained that may be read from.
///
/// [`GL_MAP_WRITE_BIT`](crate::enums::GL_MAP_WRITE_BIT)
///
/// > The data store may be mapped by the client for write access and a pointer
/// > in the client's address space obtained that may be written through.
///
/// [`GL_MAP_PERSISTENT_BIT`](crate::enums::GL_MAP_PERSISTENT_BIT)
///
/// > The client may request that the server read from or write to the buffer
/// > while it is mapped. The client's pointer to the data store remains valid
/// > so long as the data store is mapped, even during execution of drawing or
/// > dispatch commands.
///
/// [`GL_MAP_COHERENT_BIT`](crate::enums::GL_MAP_COHERENT_BIT)
///
/// > Shared access to buffers that are simultaneously mapped for client access
/// > and are used by the server will be coherent, so long as that mapping is
/// > performed using [**glMapBufferRange**](crate::context::Context::oxidegl_map_buffer_range).
/// > That is, data written to the store by either the client or server will
/// > be immediately visible to the other with no further action taken by the
/// > application. In particular,
///
/// >> If [`GL_MAP_COHERENT_BIT`](crate::enums::GL_MAP_COHERENT_BIT) is not set
/// >> and the client performs a write followed by a call to the [**glMemoryBarrier**](crate::context::Context::oxidegl_memory_barrier)
/// >> command with the [`GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT`](crate::enums::GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT)
/// >> set, then in subsequent commands the server will see the writes.
///
/// >> If [`GL_MAP_COHERENT_BIT`](crate::enums::GL_MAP_COHERENT_BIT) is set and
/// >> the client performs a write, then in subsequent commands the server will
/// >> see the writes.
///
/// >> If [`GL_MAP_COHERENT_BIT`](crate::enums::GL_MAP_COHERENT_BIT) is not set
/// >> and the server performs a write, the application must call [**glMemoryBarrier**](crate::context::Context::oxidegl_memory_barrier)
/// >> with the [`GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT`](crate::enums::GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT)
/// >> set and then call [**glFenceSync**](crate::context::Context::oxidegl_fence_sync)
/// >> with [`GL_SYNC_GPU_COMMANDS_COMPLETE`](crate::enums::GL_SYNC_GPU_COMMANDS_COMPLETE)
/// >> (or [**glFinish**](crate::context::Context::oxidegl_finish) ). Then the
/// >> CPU will see the writes after the sync is complete.
///
/// >> If [`GL_MAP_COHERENT_BIT`](crate::enums::GL_MAP_COHERENT_BIT) is set and
/// >> the server does a write, the app must call [**glFenceSync**](crate::context::Context::oxidegl_fence_sync)
/// >> with [`GL_SYNC_GPU_COMMANDS_COMPLETE`](crate::enums::GL_SYNC_GPU_COMMANDS_COMPLETE)
/// >> (or [**glFinish**](crate::context::Context::oxidegl_finish) ). Then the
/// >> CPU will see the writes after the sync is complete.
///
/// [`GL_CLIENT_STORAGE_BIT`](crate::enums::GL_CLIENT_STORAGE_BIT)
///
/// > When all other criteria for the buffer storage allocation are met, this
/// > bit may be used by an implementation to determine whether to use storage
/// > that is local to the server or to the client to serve as the backing store
/// > for the buffer.
///
///
/// The allowed combinations of flags are subject to certain restrictions.
/// They are as follows: If `flags` contains [`GL_MAP_PERSISTENT_BIT`](crate::enums::GL_MAP_PERSISTENT_BIT),
/// > it must also contain at least one of [`GL_MAP_READ_BIT`](crate::enums::GL_MAP_READ_BIT)
/// > or [`GL_MAP_WRITE_BIT`](crate::enums::GL_MAP_WRITE_BIT).
///
/// > If `flags` contains [`GL_MAP_COHERENT_BIT`](crate::enums::GL_MAP_COHERENT_BIT),
/// > it must also contain [`GL_MAP_PERSISTENT_BIT`](crate::enums::GL_MAP_PERSISTENT_BIT).
///
///
/// ### Notes
/// [**glBufferStorage**](crate::context::Context::oxidegl_buffer_storage)
/// is available only if the GL version is 4.4 or greater.
///
/// [**glNamedBufferStorage**](crate::context::Context::oxidegl_named_buffer_storage)
/// is available only if the GL version is 4.5 or greater.
///
/// If `data` is [`NULL`](crate::enums::NULL), a data store of the specified
/// size is still created, but its contents remain uninitialized and thus undefined.
///
/// ### Associated Gets
/// [**glGetBufferSubData**](crate::context::Context::oxidegl_get_buffer_sub_data)
///
/// [**glGetBufferParameter**](crate::context::Context::oxidegl_get_buffer_parameter)
/// with argument [`GL_BUFFER_SIZE`](crate::enums::GL_BUFFER_SIZE) or [`GL_BUFFER_USAGE`](crate::enums::GL_BUFFER_USAGE)
impl Context {
    pub unsafe fn oxidegl_buffer_storage(
        &mut self,
        target: BufferStorageTarget,
        size: GLsizeiptr,
        data: *const GLvoid,
        flags: BufferStorageMask,
    ) {
        panic!("command oxidegl_buffer_storage not yet implemented");
    }
    pub unsafe fn oxidegl_named_buffer_storage(
        &mut self,
        buffer: GLuint,
        size: GLsizeiptr,
        data: *const GLvoid,
        flags: BufferStorageMask,
    ) {
        panic!("command oxidegl_named_buffer_storage not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the buffer object is bound for [**glBufferSubData**](crate::context::Context::oxidegl_buffer_sub_data),
/// > which must be one of the buffer binding targets in the following table:
///
/// > | *Buffer Binding Target*                               | *Purpose*      |
/// > |-------------------------------------------------------|----------------|
/// > | [`GL_ARRAY_BUFFER`](crate::enums::GL_ARRAY_BUFFER)    | Vertex attributes |
/// > | [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER) | Atomic counter storage |
/// > | [`GL_COPY_READ_BUFFER`](crate::enums::GL_COPY_READ_BUFFER) | Buffer copy source |
/// > | [`GL_COPY_WRITE_BUFFER`](crate::enums::GL_COPY_WRITE_BUFFER) | Buffer copy destination |
/// > | [`GL_DISPATCH_INDIRECT_BUFFER`](crate::enums::GL_DISPATCH_INDIRECT_BUFFER) | Indirect compute dispatch commands |
/// > | [`GL_DRAW_INDIRECT_BUFFER`](crate::enums::GL_DRAW_INDIRECT_BUFFER) | Indirect command arguments |
/// > | [`GL_ELEMENT_ARRAY_BUFFER`](crate::enums::GL_ELEMENT_ARRAY_BUFFER) | Vertex array indices |
/// > | [`GL_PIXEL_PACK_BUFFER`](crate::enums::GL_PIXEL_PACK_BUFFER) | Pixel read target |
/// > | [`GL_PIXEL_UNPACK_BUFFER`](crate::enums::GL_PIXEL_UNPACK_BUFFER) | Texture data source |
/// > | [`GL_QUERY_BUFFER`](crate::enums::GL_QUERY_BUFFER)    | Query result buffer |
/// > | [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER) | Read-write storage for shaders |
/// > | [`GL_TEXTURE_BUFFER`](crate::enums::GL_TEXTURE_BUFFER) | Texture data buffer |
/// > | [`GL_TRANSFORM_FEEDBACK_BUFFER`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER) | Transform feedback buffer |
/// > | [`GL_UNIFORM_BUFFER`](crate::enums::GL_UNIFORM_BUFFER) | Uniform block storage |
///
/// `buffer`
///
/// > Specifies the name of the buffer object for [**glNamedBufferSubData**](crate::context::Context::oxidegl_named_buffer_sub_data).
///
/// `offset`
///
/// > Specifies the offset into the buffer object's data store where data replacement
/// > will begin, measured in bytes.
///
/// `size`
///
/// > Specifies the size in bytes of the data store region being replaced.
///
/// `data`
///
/// > Specifies a pointer to the new data that will be copied into the data store.
///
/// ### Description
/// [**glBufferSubData**](crate::context::Context::oxidegl_buffer_sub_data)
/// and [**glNamedBufferSubData**](crate::context::Context::oxidegl_named_buffer_sub_data)
/// redefine some or all of the data store for the specified buffer object.
/// Data starting at byte offset `offset` and extending for `size` bytes is
/// copied to the data store from the memory pointed to by `data`. `offset`
/// and `size` must define a range lying entirely within the buffer object's
/// data store.
///
/// ### Notes
/// When replacing the entire data store, consider using [**glBufferSubData**](crate::context::Context::oxidegl_buffer_sub_data)
/// rather than completely recreating the data store with [**glBufferData**](crate::context::Context::oxidegl_buffer_data).
/// This avoids the cost of reallocating the data store.
///
/// Consider using multiple buffer objects to avoid stalling the rendering
/// pipeline during data store updates. If any rendering in the pipeline makes
/// reference to data in the buffer object being updated by [**glBufferSubData**](crate::context::Context::oxidegl_buffer_sub_data),
/// especially from the specific region being updated, that rendering must
/// drain from the pipeline before the data store can be updated.
///
/// Clients must align data elements consistent with the requirements of the
/// client platform, with an additional base-level requirement that an offset
/// within a buffer to a datum comprising $N$ bytes be a multiple of $N$.
///
/// The [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER)
/// target is available only if the GL version is 4.2 or greater.
///
/// The [`GL_DISPATCH_INDIRECT_BUFFER`](crate::enums::GL_DISPATCH_INDIRECT_BUFFER)
/// and [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER)
/// targets are available only if the GL version is 4.3 or greater.
///
/// The [`GL_QUERY_BUFFER`](crate::enums::GL_QUERY_BUFFER) target is available
/// only if the GL version is 4.4 or greater.
///
/// ### Associated Gets
/// [**glGetBufferSubData**](crate::context::Context::oxidegl_get_buffer_sub_data)
impl Context {
    pub unsafe fn oxidegl_buffer_sub_data(
        &mut self,
        target: BufferTarget,
        offset: GLintptr,
        size: GLsizeiptr,
        data: *const GLvoid,
    ) {
        panic!("command oxidegl_buffer_sub_data not yet implemented");
    }
    pub unsafe fn oxidegl_named_buffer_sub_data(
        &mut self,
        buffer: GLuint,
        offset: GLintptr,
        size: GLsizeiptr,
        data: *const GLvoid,
    ) {
        panic!("command oxidegl_named_buffer_sub_data not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specify the target to which the framebuffer is bound for [**glCheckFramebufferStatus**](crate::context::Context::oxidegl_check_framebuffer_status),
/// > and the target against which framebuffer completeness of `framebuffer`
/// > is checked for [**glCheckNamedFramebufferStatus**](crate::context::Context::oxidegl_check_named_framebuffer_status).
///
/// `framebuffer`
///
/// > Specifies the name of the framebuffer object for [**glCheckNamedFramebufferStatus**](crate::context::Context::oxidegl_check_named_framebuffer_status)
///
/// ### Description
/// [**glCheckFramebufferStatus**](crate::context::Context::oxidegl_check_framebuffer_status)
/// and [**glCheckNamedFramebufferStatus**](crate::context::Context::oxidegl_check_named_framebuffer_status)
/// return the completeness status of a framebuffer object when treated as
/// a read or draw framebuffer, depending on the value of `target`.
///
/// For [**glCheckFramebufferStatus**](crate::context::Context::oxidegl_check_framebuffer_status),
/// the framebuffer checked is that bound to `target`, which must be [`GL_DRAW_FRAMEBUFFER`](crate::enums::GL_DRAW_FRAMEBUFFER),
/// [`GL_READ_FRAMEBUFFER`](crate::enums::GL_READ_FRAMEBUFFER) or [`GL_FRAMEBUFFER`](crate::enums::GL_FRAMEBUFFER).
/// [`GL_FRAMEBUFFER`](crate::enums::GL_FRAMEBUFFER) is equivalent to [`GL_DRAW_FRAMEBUFFER`](crate::enums::GL_DRAW_FRAMEBUFFER).
///
/// For [**glCheckNamedFramebufferStatus**](crate::context::Context::oxidegl_check_named_framebuffer_status),
/// `framebuffer` is zero or the name of the framebuffer object to check. If
/// `framebuffer` is zero, then the status of the default read or draw framebuffer,
/// as determined by `target`, is returned.
///
/// The return value is [`GL_FRAMEBUFFER_COMPLETE`](crate::enums::GL_FRAMEBUFFER_COMPLETE)
/// if the specified framebuffer is complete. Otherwise, the return value is
/// determined as follows: [`GL_FRAMEBUFFER_UNDEFINED`](crate::enums::GL_FRAMEBUFFER_UNDEFINED)
/// > is returned if the specified framebuffer is the default read or draw framebuffer,
/// > but the default framebuffer does not exist.
///
/// > [`GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT`](crate::enums::GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT)
/// > is returned if any of the framebuffer attachment points are framebuffer
/// > incomplete.
///
/// > [`GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT`](crate::enums::GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT)
/// > is returned if the framebuffer does not have at least one image attached
/// > to it.
///
/// > [`GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER`](crate::enums::GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER)
/// > is returned if the value of [`GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE)
/// > is [`GL_NONE`](crate::enums::GL_NONE) for any color attachment point(s)
/// > named by [`GL_DRAW_BUFFERi`](crate::enums::GL_DRAW_BUFFERi).
///
/// > [`GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER`](crate::enums::GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER)
/// > is returned if [`GL_READ_BUFFER`](crate::enums::GL_READ_BUFFER) is not
/// > [`GL_NONE`](crate::enums::GL_NONE) and the value of [`GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE)
/// > is [`GL_NONE`](crate::enums::GL_NONE) for the color attachment point named
/// > by [`GL_READ_BUFFER`](crate::enums::GL_READ_BUFFER).
///
/// > [`GL_FRAMEBUFFER_UNSUPPORTED`](crate::enums::GL_FRAMEBUFFER_UNSUPPORTED)
/// > is returned if the combination of internal formats of the attached images
/// > violates an implementation-dependent set of restrictions.
///
/// > [`GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE`](crate::enums::GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE)
/// > is returned if the value of [`GL_RENDERBUFFER_SAMPLES`](crate::enums::GL_RENDERBUFFER_SAMPLES)
/// > is not the same for all attached renderbuffers; if the value of [`GL_TEXTURE_SAMPLES`](crate::enums::GL_TEXTURE_SAMPLES)
/// > is the not same for all attached textures; or, if the attached images are
/// > a mix of renderbuffers and textures, the value of [`GL_RENDERBUFFER_SAMPLES`](crate::enums::GL_RENDERBUFFER_SAMPLES)
/// > does not match the value of [`GL_TEXTURE_SAMPLES`](crate::enums::GL_TEXTURE_SAMPLES).
///
/// > [`GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE`](crate::enums::GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE)
/// > is also returned if the value of [`GL_TEXTURE_FIXED_SAMPLE_LOCATIONS`](crate::enums::GL_TEXTURE_FIXED_SAMPLE_LOCATIONS)
/// > is not the same for all attached textures; or, if the attached images are
/// > a mix of renderbuffers and textures, the value of [`GL_TEXTURE_FIXED_SAMPLE_LOCATIONS`](crate::enums::GL_TEXTURE_FIXED_SAMPLE_LOCATIONS)
/// > is not [`GL_TRUE`](crate::enums::GL_TRUE) for all attached textures.
///
/// > [`GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS`](crate::enums::GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS)
/// > is returned if any framebuffer attachment is layered, and any populated
/// > attachment is not layered, or if all populated color attachments are not
/// > from textures of the same target.
///
///
/// Additionally, if an error occurs, zero is returned.
impl Context {
    pub fn oxidegl_check_framebuffer_status(&mut self, target: FramebufferTarget) -> GLenum {
        panic!("command oxidegl_check_framebuffer_status not yet implemented");
    }
    pub fn oxidegl_check_named_framebuffer_status(
        &mut self,
        framebuffer: GLuint,
        target: FramebufferTarget,
    ) -> GLenum {
        panic!("command oxidegl_check_named_framebuffer_status not yet implemented");
    }
}
/// ### Parameters
/// `framebuffer`
///
/// > Specifies the name of the framebuffer object for [**glClearNamedFramebuffer***](crate::context::Context::oxidegl_clear_named_framebuffer*).
///
/// `buffer`
///
/// > Specify the buffer to clear.
///
/// `drawbuffer`
///
/// > Specify a particular draw buffer to clear.
///
/// `value`
///
/// > A pointer to the value or values to clear the buffer to.
///
/// `depth`
///
/// > The value to clear the depth buffer to.
///
/// `stencil`
///
/// > The value to clear the stencil buffer to.
///
/// ### Description
/// These commands clear a specified buffer of a framebuffer to specified value(s).
/// For [**glClearBuffer***](crate::context::Context::oxidegl_clear_buffer*),
/// the framebuffer is the currently bound draw framebuffer object. For [**glClearNamedFramebuffer***](crate::context::Context::oxidegl_clear_named_framebuffer*),
/// `framebuffer` is zero, indicating the default draw framebuffer, or the
/// name of a framebuffer object.
///
/// `buffer` and `drawbuffer` identify the buffer to clear.
///
/// If `buffer` is [`GL_COLOR`](crate::enums::GL_COLOR), a particular draw
/// buffer [`GL_DRAW_BUFFER`](crate::enums::GL_DRAW_BUFFER) `i` is specified
/// by passing `i` as `drawbuffer`, and `value` points to a four-element vector
/// specifying the R, G, B and A color to clear that draw buffer to. If the
/// value of [`GL_DRAW_BUFFER`](crate::enums::GL_DRAW_BUFFER) `i` is [`GL_NONE`](crate::enums::GL_NONE),
/// the command has no effect. Otherwise, the value of [`GL_DRAW_BUFFER`](crate::enums::GL_DRAW_BUFFER)
/// `i` identifies one or more color buffers, each of which is cleared to the
/// same value. Clamping and type conversion for fixed-point color buffers
/// are performed in the same fashion as for [**glClearColor**](crate::context::Context::oxidegl_clear_color).
/// The [***fv**](crate::context::Context::oxide*fv), [***iv**](crate::context::Context::oxide*iv)
/// and [***uiv**](crate::context::Context::oxide*uiv) forms of these commands
/// should be used to clear fixed- and floating-point, signed integer, and
/// unsigned integer color buffers respectively.
///
/// If `buffer` is [`GL_DEPTH`](crate::enums::GL_DEPTH), `drawbuffer` must
/// be zero, and `value` points to a single value to clear the depth buffer
/// to. Clamping and type conversion for fixed-point depth buffers are performed
/// in the same fashion as for [**glClearDepth**](crate::context::Context::oxidegl_clear_depth).
/// Only the [***fv**](crate::context::Context::oxide*fv) forms of these commands
/// should be used to clear depth buffers; other forms do not accept a `buffer`
/// of [`GL_DEPTH`](crate::enums::GL_DEPTH).
///
/// If `buffer` is [`GL_STENCIL`](crate::enums::GL_STENCIL), `drawbuffer` must
/// be zero, and `value` points to a single value to clear the stencil buffer
/// to. Masking is performed in the same fashion as for [**glClearStencil**](crate::context::Context::oxidegl_clear_stencil).
/// Only the [***iv**](crate::context::Context::oxide*iv) forms of these commands
/// should be used to clear stencil buffers; be used to clear stencil buffers;
/// other forms do not accept a `buffer` of [`GL_STENCIL`](crate::enums::GL_STENCIL).
///
/// [**glClearBufferfi**](crate::context::Context::oxidegl_clear_bufferfi)
/// and [**glClearNamedFramebufferfi**](crate::context::Context::oxidegl_clear_named_framebufferfi)
/// are used to clear the depth and stencil buffers simultaneously. `buffer`
/// must be [`GL_DEPTH_STENCIL`](crate::enums::GL_DEPTH_STENCIL) and `drawbuffer`
/// must be zero. `depth` and `stencil` are the values to clear the depth and
/// stencil buffers to, respectively. Clamping and type conversion of `depth`
/// for fixed-point depth buffers are performed in the same fashion as for
/// [**glClearDepth**](crate::context::Context::oxidegl_clear_depth). Masking
/// of `stencil` for stencil buffers is performed in the same fashion as for
/// [**glClearStencil**](crate::context::Context::oxidegl_clear_stencil). These
/// commands are equivalent to clearing the depth and stencil buffers separately,
/// but may be faster when a buffer of internal format [`GL_DEPTH_STENCIL`](crate::enums::GL_DEPTH_STENCIL)
/// is being cleared. The same per-fragment and masking operations defined
/// for [**glClear**](crate::context::Context::oxidegl_clear) are applied.
///
/// The result of these commands is undefined if no conversion between the
/// type of the specified `value` and the type of the buffer being cleared
/// is defined (for example, if [**glClearBufferiv**](crate::context::Context::oxidegl_clear_bufferiv)
/// is called for a fixed- or floating-point buffer, or if [**glClearBufferfv**](crate::context::Context::oxidegl_clear_bufferfv)
/// is called for a signed or unsigned integer buffer). This is not an error.
impl Context {
    pub unsafe fn oxidegl_clear_bufferiv(
        &mut self,
        buffer: Buffer,
        drawbuffer: GLint,
        value: *const GLint,
    ) {
        panic!("command oxidegl_clear_bufferiv not yet implemented");
    }
    pub unsafe fn oxidegl_clear_bufferuiv(
        &mut self,
        buffer: Buffer,
        drawbuffer: GLint,
        value: *const GLuint,
    ) {
        panic!("command oxidegl_clear_bufferuiv not yet implemented");
    }
    pub unsafe fn oxidegl_clear_bufferfv(
        &mut self,
        buffer: Buffer,
        drawbuffer: GLint,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_clear_bufferfv not yet implemented");
    }
    pub fn oxidegl_clear_bufferfi(
        &mut self,
        buffer: Buffer,
        drawbuffer: GLint,
        depth: GLfloat,
        stencil: GLint,
    ) {
        panic!("command oxidegl_clear_bufferfi not yet implemented");
    }
    pub unsafe fn oxidegl_clear_named_framebufferiv(
        &mut self,
        framebuffer: GLuint,
        buffer: Buffer,
        drawbuffer: GLint,
        value: *const GLint,
    ) {
        panic!("command oxidegl_clear_named_framebufferiv not yet implemented");
    }
    pub unsafe fn oxidegl_clear_named_framebufferuiv(
        &mut self,
        framebuffer: GLuint,
        buffer: Buffer,
        drawbuffer: GLint,
        value: *const GLuint,
    ) {
        panic!("command oxidegl_clear_named_framebufferuiv not yet implemented");
    }
    pub unsafe fn oxidegl_clear_named_framebufferfv(
        &mut self,
        framebuffer: GLuint,
        buffer: Buffer,
        drawbuffer: GLint,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_clear_named_framebufferfv not yet implemented");
    }
    pub fn oxidegl_clear_named_framebufferfi(
        &mut self,
        framebuffer: GLuint,
        buffer: Buffer,
        drawbuffer: GLint,
        depth: GLfloat,
        stencil: GLint,
    ) {
        panic!("command oxidegl_clear_named_framebufferfi not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the buffer object is bound for [**glClearBufferData**](crate::context::Context::oxidegl_clear_buffer_data),
/// > which must be one of the buffer binding targets in the following table:
///
/// > | *Buffer Binding Target*                               | *Purpose*      |
/// > |-------------------------------------------------------|----------------|
/// > | [`GL_ARRAY_BUFFER`](crate::enums::GL_ARRAY_BUFFER)    | Vertex attributes |
/// > | [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER) | Atomic counter storage |
/// > | [`GL_COPY_READ_BUFFER`](crate::enums::GL_COPY_READ_BUFFER) | Buffer copy source |
/// > | [`GL_COPY_WRITE_BUFFER`](crate::enums::GL_COPY_WRITE_BUFFER) | Buffer copy destination |
/// > | [`GL_DISPATCH_INDIRECT_BUFFER`](crate::enums::GL_DISPATCH_INDIRECT_BUFFER) | Indirect compute dispatch commands |
/// > | [`GL_DRAW_INDIRECT_BUFFER`](crate::enums::GL_DRAW_INDIRECT_BUFFER) | Indirect command arguments |
/// > | [`GL_ELEMENT_ARRAY_BUFFER`](crate::enums::GL_ELEMENT_ARRAY_BUFFER) | Vertex array indices |
/// > | [`GL_PIXEL_PACK_BUFFER`](crate::enums::GL_PIXEL_PACK_BUFFER) | Pixel read target |
/// > | [`GL_PIXEL_UNPACK_BUFFER`](crate::enums::GL_PIXEL_UNPACK_BUFFER) | Texture data source |
/// > | [`GL_QUERY_BUFFER`](crate::enums::GL_QUERY_BUFFER)    | Query result buffer |
/// > | [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER) | Read-write storage for shaders |
/// > | [`GL_TEXTURE_BUFFER`](crate::enums::GL_TEXTURE_BUFFER) | Texture data buffer |
/// > | [`GL_TRANSFORM_FEEDBACK_BUFFER`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER) | Transform feedback buffer |
/// > | [`GL_UNIFORM_BUFFER`](crate::enums::GL_UNIFORM_BUFFER) | Uniform block storage |
///
/// `buffer`
///
/// > Specifies the name of the buffer object for [**glClearNamedBufferData**](crate::context::Context::oxidegl_clear_named_buffer_data).
///
/// `internalformat`
///
/// > The internal format with which the data will be stored in the buffer object.
///
/// `format`
///
/// > The format of the data in memory addressed by `data`.
///
/// `type`
///
/// > The type of the data in memory addressed by `data`.
///
/// `data`
///
/// > The address of a memory location storing the data to be replicated into
/// > the buffer's data store.
///
/// ### Description
/// [**glClearBufferData**](crate::context::Context::oxidegl_clear_buffer_data)
/// and [**glClearNamedBufferData**](crate::context::Context::oxidegl_clear_named_buffer_data)
/// fill the entirety of a buffer object's data store with data from client
/// memory.
///
/// Data, initially supplied in a format specified by `format` in data type
/// `type` is read from the memory address given by `data` and converted into
/// the internal representation given by `internalformat`, which must be one
/// of the following sized internal formats:
///
/// | *Sized Internal Format*                               | *Base Type*       | *Components*        | *Norm*     | 0  | 1  | 2  | 3  |
/// |-------------------------------------------------------|-------------------|---------------------|------------|----|----|----|----|
/// | [`GL_R8`](crate::enums::GL_R8)                        | ubyte             | 1                   | YES        | R  | 0  | 0  | 1  |
/// | [`GL_R16`](crate::enums::GL_R16)                      | ushort            | 1                   | YES        | R  | 0  | 0  | 1  |
/// | [`GL_R16F`](crate::enums::GL_R16F)                    | half              | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R32F`](crate::enums::GL_R32F)                    | float             | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R8I`](crate::enums::GL_R8I)                      | byte              | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R16I`](crate::enums::GL_R16I)                    | short             | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R32I`](crate::enums::GL_R32I)                    | int               | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R8UI`](crate::enums::GL_R8UI)                    | ubyte             | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R16UI`](crate::enums::GL_R16UI)                  | ushort            | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R32UI`](crate::enums::GL_R32UI)                  | uint              | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_RG8`](crate::enums::GL_RG8)                      | ubyte             | 2                   | YES        | R  | G  | 0  | 1  |
/// | [`GL_RG16`](crate::enums::GL_RG16)                    | ushort            | 2                   | YES        | R  | G  | 0  | 1  |
/// | [`GL_RG16F`](crate::enums::GL_RG16F)                  | half              | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG32F`](crate::enums::GL_RG32F)                  | float             | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG8I`](crate::enums::GL_RG8I)                    | byte              | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG16I`](crate::enums::GL_RG16I)                  | short             | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG32I`](crate::enums::GL_RG32I)                  | int               | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG8UI`](crate::enums::GL_RG8UI)                  | ubyte             | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG16UI`](crate::enums::GL_RG16UI)                | ushort            | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG32UI`](crate::enums::GL_RG32UI)                | uint              | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RGB32F`](crate::enums::GL_RGB32F)                | float             | 3                   | NO         | R  | G  | B  | 1  |
/// | [`GL_RGB32I`](crate::enums::GL_RGB32I)                | int               | 3                   | NO         | R  | G  | B  | 1  |
/// | [`GL_RGB32UI`](crate::enums::GL_RGB32UI)              | uint              | 3                   | NO         | R  | G  | B  | 1  |
/// | [`GL_RGBA8`](crate::enums::GL_RGBA8)                  | uint              | 4                   | YES        | R  | G  | B  | A  |
/// | [`GL_RGBA16`](crate::enums::GL_RGBA16)                | short             | 4                   | YES        | R  | G  | B  | A  |
/// | [`GL_RGBA16F`](crate::enums::GL_RGBA16F)              | half              | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA32F`](crate::enums::GL_RGBA32F)              | float             | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA8I`](crate::enums::GL_RGBA8I)                | byte              | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA16I`](crate::enums::GL_RGBA16I)              | short             | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA32I`](crate::enums::GL_RGBA32I)              | int               | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA8UI`](crate::enums::GL_RGBA8UI)              | ubyte             | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA16UI`](crate::enums::GL_RGBA16UI)            | ushort            | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA32UI`](crate::enums::GL_RGBA32UI)            | uint              | 4                   | NO         | R  | G  | B  | A  |
///
/// This converted data is then replicated throughout the buffer object's data
/// store. If `data` is NULL, then the buffer's data store is filled with zeros.
impl Context {
    pub unsafe fn oxidegl_clear_buffer_data(
        &mut self,
        target: BufferStorageTarget,
        internalformat: SizedInternalFormat,
        format: PixelFormat,
        r#type: PixelType,
        data: *const GLvoid,
    ) {
        panic!("command oxidegl_clear_buffer_data not yet implemented");
    }
    pub unsafe fn oxidegl_clear_named_buffer_data(
        &mut self,
        buffer: GLuint,
        internalformat: SizedInternalFormat,
        format: PixelFormat,
        r#type: PixelType,
        data: *const GLvoid,
    ) {
        panic!("command oxidegl_clear_named_buffer_data not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the buffer object is bound for [**glClearBufferSubData**](crate::context::Context::oxidegl_clear_buffer_sub_data),
/// > which must be one of the buffer binding targets in the following table:
///
/// > | *Buffer Binding Target*                               | *Purpose*      |
/// > |-------------------------------------------------------|----------------|
/// > | [`GL_ARRAY_BUFFER`](crate::enums::GL_ARRAY_BUFFER)    | Vertex attributes |
/// > | [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER) | Atomic counter storage |
/// > | [`GL_COPY_READ_BUFFER`](crate::enums::GL_COPY_READ_BUFFER) | Buffer copy source |
/// > | [`GL_COPY_WRITE_BUFFER`](crate::enums::GL_COPY_WRITE_BUFFER) | Buffer copy destination |
/// > | [`GL_DISPATCH_INDIRECT_BUFFER`](crate::enums::GL_DISPATCH_INDIRECT_BUFFER) | Indirect compute dispatch commands |
/// > | [`GL_DRAW_INDIRECT_BUFFER`](crate::enums::GL_DRAW_INDIRECT_BUFFER) | Indirect command arguments |
/// > | [`GL_ELEMENT_ARRAY_BUFFER`](crate::enums::GL_ELEMENT_ARRAY_BUFFER) | Vertex array indices |
/// > | [`GL_PIXEL_PACK_BUFFER`](crate::enums::GL_PIXEL_PACK_BUFFER) | Pixel read target |
/// > | [`GL_PIXEL_UNPACK_BUFFER`](crate::enums::GL_PIXEL_UNPACK_BUFFER) | Texture data source |
/// > | [`GL_QUERY_BUFFER`](crate::enums::GL_QUERY_BUFFER)    | Query result buffer |
/// > | [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER) | Read-write storage for shaders |
/// > | [`GL_TEXTURE_BUFFER`](crate::enums::GL_TEXTURE_BUFFER) | Texture data buffer |
/// > | [`GL_TRANSFORM_FEEDBACK_BUFFER`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER) | Transform feedback buffer |
/// > | [`GL_UNIFORM_BUFFER`](crate::enums::GL_UNIFORM_BUFFER) | Uniform block storage |
///
/// `buffer`
///
/// > Specifies the name of the buffer object for [**glClearNamedBufferSubData**](crate::context::Context::oxidegl_clear_named_buffer_sub_data).
///
/// `internalformat`
///
/// > The internal format with which the data will be stored in the buffer object.
///
/// `offset`
///
/// > The offset in basic machine units into the buffer object's data store at
/// > which to start filling.
///
/// `size`
///
/// > The size in basic machine units of the range of the data store to fill.
///
/// `format`
///
/// > The format of the data in memory addressed by `data`.
///
/// `type`
///
/// > The type of the data in memory addressed by `data`.
///
/// `data`
///
/// > The address of a memory location storing the data to be replicated into
/// > the buffer's data store.
///
/// ### Description
/// [**glClearBufferSubData**](crate::context::Context::oxidegl_clear_buffer_sub_data)
/// and [**glClearNamedBufferSubData**](crate::context::Context::oxidegl_clear_named_buffer_sub_data)
/// fill a specified region of a buffer object's data store with data from
/// client memory.
///
/// `offset` and `size` specify the extent of the region within the data store
/// of the buffer object to fill with data. Data, initially supplied in a format
/// specified by `format` in data type `type` is read from the memory address
/// given by `data` and converted into the internal representation given by
/// `internalformat`, which must be one of the following sized internal formats:
///
/// | *Sized Internal Format*                               | *Base Type*       | *Components*        | *Norm*     | 0  | 1  | 2  | 3  |
/// |-------------------------------------------------------|-------------------|---------------------|------------|----|----|----|----|
/// | [`GL_R8`](crate::enums::GL_R8)                        | ubyte             | 1                   | YES        | R  | 0  | 0  | 1  |
/// | [`GL_R16`](crate::enums::GL_R16)                      | ushort            | 1                   | YES        | R  | 0  | 0  | 1  |
/// | [`GL_R16F`](crate::enums::GL_R16F)                    | half              | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R32F`](crate::enums::GL_R32F)                    | float             | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R8I`](crate::enums::GL_R8I)                      | byte              | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R16I`](crate::enums::GL_R16I)                    | short             | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R32I`](crate::enums::GL_R32I)                    | int               | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R8UI`](crate::enums::GL_R8UI)                    | ubyte             | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R16UI`](crate::enums::GL_R16UI)                  | ushort            | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R32UI`](crate::enums::GL_R32UI)                  | uint              | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_RG8`](crate::enums::GL_RG8)                      | ubyte             | 2                   | YES        | R  | G  | 0  | 1  |
/// | [`GL_RG16`](crate::enums::GL_RG16)                    | ushort            | 2                   | YES        | R  | G  | 0  | 1  |
/// | [`GL_RG16F`](crate::enums::GL_RG16F)                  | half              | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG32F`](crate::enums::GL_RG32F)                  | float             | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG8I`](crate::enums::GL_RG8I)                    | byte              | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG16I`](crate::enums::GL_RG16I)                  | short             | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG32I`](crate::enums::GL_RG32I)                  | int               | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG8UI`](crate::enums::GL_RG8UI)                  | ubyte             | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG16UI`](crate::enums::GL_RG16UI)                | ushort            | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG32UI`](crate::enums::GL_RG32UI)                | uint              | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RGB32F`](crate::enums::GL_RGB32F)                | float             | 3                   | NO         | R  | G  | B  | 1  |
/// | [`GL_RGB32I`](crate::enums::GL_RGB32I)                | int               | 3                   | NO         | R  | G  | B  | 1  |
/// | [`GL_RGB32UI`](crate::enums::GL_RGB32UI)              | uint              | 3                   | NO         | R  | G  | B  | 1  |
/// | [`GL_RGBA8`](crate::enums::GL_RGBA8)                  | uint              | 4                   | YES        | R  | G  | B  | A  |
/// | [`GL_RGBA16`](crate::enums::GL_RGBA16)                | short             | 4                   | YES        | R  | G  | B  | A  |
/// | [`GL_RGBA16F`](crate::enums::GL_RGBA16F)              | half              | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA32F`](crate::enums::GL_RGBA32F)              | float             | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA8I`](crate::enums::GL_RGBA8I)                | byte              | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA16I`](crate::enums::GL_RGBA16I)              | short             | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA32I`](crate::enums::GL_RGBA32I)              | int               | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA8UI`](crate::enums::GL_RGBA8UI)              | ubyte             | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA16UI`](crate::enums::GL_RGBA16UI)            | ushort            | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA32UI`](crate::enums::GL_RGBA32UI)            | uint              | 4                   | NO         | R  | G  | B  | A  |
///
/// This converted data is then replicated throughout the specified region
/// of the buffer object's data store. If `data` is NULL, then the subrange
/// of the buffer's data store is filled with zeros.
impl Context {
    pub unsafe fn oxidegl_clear_buffer_sub_data(
        &mut self,
        target: BufferTarget,
        internalformat: SizedInternalFormat,
        offset: GLintptr,
        size: GLsizeiptr,
        format: PixelFormat,
        r#type: PixelType,
        data: *const GLvoid,
    ) {
        panic!("command oxidegl_clear_buffer_sub_data not yet implemented");
    }
    pub unsafe fn oxidegl_clear_named_buffer_sub_data(
        &mut self,
        buffer: GLuint,
        internalformat: SizedInternalFormat,
        offset: GLintptr,
        size: GLsizeiptr,
        format: PixelFormat,
        r#type: PixelType,
        data: *const GLvoid,
    ) {
        panic!("command oxidegl_clear_named_buffer_sub_data not yet implemented");
    }
}
/// ### Parameters
/// `buf`
///
/// > For [**glColorMaski**](crate::context::Context::oxidegl_color_maski), specifies
/// > the index of the draw buffer whose color mask to set.
///
/// `red`
///
/// `green`
///
/// `blue`
///
/// `alpha`
///
/// > Specify whether red, green, blue, and alpha are to be written into the
/// > frame buffer. The initial values are all [`GL_TRUE`](crate::enums::GL_TRUE),
/// > indicating that the color components are written.
///
/// ### Description
/// [**glColorMask**](crate::context::Context::oxidegl_color_mask) and [**glColorMaski**](crate::context::Context::oxidegl_color_maski)
/// specify whether the individual color components in the frame buffer can
/// or cannot be written. [**glColorMaski**](crate::context::Context::oxidegl_color_maski)
/// sets the mask for a specific draw buffer, whereas [**glColorMask**](crate::context::Context::oxidegl_color_mask)
/// sets the mask for all draw buffers. If `red` is [`GL_FALSE`](crate::enums::GL_FALSE),
/// for example, no change is made to the red component of any pixel in any
/// of the color buffers, regardless of the drawing operation attempted.
///
/// Changes to individual bits of components cannot be controlled. Rather,
/// changes are either enabled or disabled for entire color components.
///
/// ### Associated Gets
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_COLOR_WRITEMASK`](crate::enums::GL_COLOR_WRITEMASK)
impl Context {
    pub fn oxidegl_color_mask(
        &mut self,
        red: GLboolean,
        green: GLboolean,
        blue: GLboolean,
        alpha: GLboolean,
    ) {
        panic!("command oxidegl_color_mask not yet implemented");
    }
    pub fn oxidegl_color_maski(
        &mut self,
        index: GLuint,
        r: GLboolean,
        g: GLboolean,
        b: GLboolean,
        a: GLboolean,
    ) {
        panic!("command oxidegl_color_maski not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target, to which the texture is bound, for [**glCompressedTexSubImage1D**](crate::context::Context::oxidegl_compressed_tex_sub_image1_d)
/// > function. Must be [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D).
///
/// `texture`
///
/// > Specifies the texture object name for [**glCompressedTextureSubImage1D**](crate::context::Context::oxidegl_compressed_texture_sub_image1_d)
/// > function.
///
/// `level`
///
/// > Specifies the level-of-detail number. Level 0 is the base image level.
/// > Level *n* is the *n* th mipmap reduction image.
///
/// `xoffset`
///
/// > Specifies a texel offset in the x direction within the texture array.
///
/// `width`
///
/// > Specifies the width of the texture subimage.
///
/// `format`
///
/// > Specifies the format of the compressed image data stored at address `data`.
///
/// `imageSize`
///
/// > Specifies the number of unsigned bytes of image data starting at the address
/// > specified by `data`.
///
/// `data`
///
/// > Specifies a pointer to the compressed image data in memory.
///
/// ### Description
/// Texturing allows elements of an image array to be read by shaders.
///
/// [**glCompressedTexSubImage1D**](crate::context::Context::oxidegl_compressed_tex_sub_image1_d)
/// and [**glCompressedTextureSubImage1D**](crate::context::Context::oxidegl_compressed_texture_sub_image1_d)
/// redefine a contiguous subregion of an existing one-dimensional texture
/// image. The texels referenced by `data` replace the portion of the existing
/// texture array with x indices `xoffset` and `[inlineq]`
///
/// `internalformat` must be a known compressed image format (such as [`GL_RGTC`](crate::enums::GL_RGTC))
/// or an extension-specified compressed-texture format. The `format` of the
/// compressed texture image is selected by the GL implementation that compressed
/// it (see [**glTexImage1D**](crate::context::Context::oxidegl_tex_image1_d)
/// ), and should be queried at the time the texture was compressed with [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter).
///
/// If a non-zero named buffer object is bound to the [`GL_PIXEL_UNPACK_BUFFER`](crate::enums::GL_PIXEL_UNPACK_BUFFER)
/// target (see [**glBindBuffer**](crate::context::Context::oxidegl_bind_buffer))
/// while a texture image is specified, `data` is treated as a byte offset
/// into the buffer object's data store.
///
/// ### Associated Gets
/// [**glGetCompressedTexImage**](crate::context::Context::oxidegl_get_compressed_tex_image)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_TEXTURE_COMPRESSED`](crate::enums::GL_TEXTURE_COMPRESSED)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_PIXEL_UNPACK_BUFFER_BINDING`](crate::enums::GL_PIXEL_UNPACK_BUFFER_BINDING)
///
/// [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter)
/// with arguments [`GL_TEXTURE_INTERNAL_FORMAT`](crate::enums::GL_TEXTURE_INTERNAL_FORMAT)
/// and [`GL_TEXTURE_COMPRESSED_IMAGE_SIZE`](crate::enums::GL_TEXTURE_COMPRESSED_IMAGE_SIZE)
impl Context {
    pub unsafe fn oxidegl_compressed_tex_sub_image1_d(
        &mut self,
        target: TextureTarget,
        level: GLint,
        xoffset: GLint,
        width: GLsizei,
        format: InternalFormat,
        image_size: GLsizei,
        data: *const GLvoid,
    ) {
        panic!("command oxidegl_compressed_tex_sub_image1_d not yet implemented");
    }
    pub unsafe fn oxidegl_compressed_texture_sub_image1_d(
        &mut self,
        texture: GLuint,
        level: GLint,
        xoffset: GLint,
        width: GLsizei,
        format: InternalFormat,
        image_size: GLsizei,
        data: *const GLvoid,
    ) {
        panic!("command oxidegl_compressed_texture_sub_image1_d not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the texture is bound for [**glCompressedTexSubImage2D**](crate::context::Context::oxidegl_compressed_tex_sub_image2_d)
/// > function. Must be [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY),
/// > [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D), [`GL_TEXTURE_CUBE_MAP_POSITIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_X),
/// > [`GL_TEXTURE_CUBE_MAP_NEGATIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_X),
/// > [`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Y),
/// > [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Y),
/// > [`GL_TEXTURE_CUBE_MAP_POSITIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Z),
/// > or [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Z).
///
/// `texture`
///
/// > Specifies the texture object name for [**glCompressedTextureSubImage2D**](crate::context::Context::oxidegl_compressed_texture_sub_image2_d)
/// > function.
///
/// `level`
///
/// > Specifies the level-of-detail number. Level 0 is the base image level.
/// > Level *n* is the *n* th mipmap reduction image.
///
/// `xoffset`
///
/// > Specifies a texel offset in the x direction within the texture array.
///
/// `yoffset`
///
/// > Specifies a texel offset in the y direction within the texture array.
///
/// `width`
///
/// > Specifies the width of the texture subimage.
///
/// `height`
///
/// > Specifies the height of the texture subimage.
///
/// `format`
///
/// > Specifies the format of the compressed image data stored at address `data`.
///
/// `imageSize`
///
/// > Specifies the number of unsigned bytes of image data starting at the address
/// > specified by `data`.
///
/// `data`
///
/// > Specifies a pointer to the compressed image data in memory.
///
/// ### Description
/// Texturing allows elements of an image array to be read by shaders.
///
/// [**glCompressedTexSubImage2D**](crate::context::Context::oxidegl_compressed_tex_sub_image2_d)
/// and [**glCompressedTextureSubImage2D**](crate::context::Context::oxidegl_compressed_texture_sub_image2_d)
/// redefine a contiguous subregion of an existing two-dimensional texture
/// image. The texels referenced by `data` replace the portion of the existing
/// texture array with x indices `xoffset` and `[inlineq]` `yoffset` and `[inlineq]`
///
/// `internalformat` must be a known compressed image format (such as [`GL_RGTC`](crate::enums::GL_RGTC))
/// or an extension-specified compressed-texture format. The `format` of the
/// compressed texture image is selected by the GL implementation that compressed
/// it (see [**glTexImage2D**](crate::context::Context::oxidegl_tex_image2_d))
/// and should be queried at the time the texture was compressed with [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter).
///
/// If a non-zero named buffer object is bound to the [`GL_PIXEL_UNPACK_BUFFER`](crate::enums::GL_PIXEL_UNPACK_BUFFER)
/// target (see [**glBindBuffer**](crate::context::Context::oxidegl_bind_buffer))
/// while a texture image is specified, `data` is treated as a byte offset
/// into the buffer object's data store.
///
/// ### Associated Gets
/// [**glGetCompressedTexImage**](crate::context::Context::oxidegl_get_compressed_tex_image)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_TEXTURE_COMPRESSED`](crate::enums::GL_TEXTURE_COMPRESSED)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_PIXEL_UNPACK_BUFFER_BINDING`](crate::enums::GL_PIXEL_UNPACK_BUFFER_BINDING)
///
/// [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter)
/// with arguments [`GL_TEXTURE_INTERNAL_FORMAT`](crate::enums::GL_TEXTURE_INTERNAL_FORMAT)
/// and [`GL_TEXTURE_COMPRESSED_IMAGE_SIZE`](crate::enums::GL_TEXTURE_COMPRESSED_IMAGE_SIZE)
impl Context {
    pub unsafe fn oxidegl_compressed_tex_sub_image2_d(
        &mut self,
        target: TextureTarget,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        width: GLsizei,
        height: GLsizei,
        format: InternalFormat,
        image_size: GLsizei,
        data: *const GLvoid,
    ) {
        panic!("command oxidegl_compressed_tex_sub_image2_d not yet implemented");
    }
    pub unsafe fn oxidegl_compressed_texture_sub_image2_d(
        &mut self,
        texture: GLuint,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        width: GLsizei,
        height: GLsizei,
        format: InternalFormat,
        image_size: GLsizei,
        data: *const GLvoid,
    ) {
        panic!("command oxidegl_compressed_texture_sub_image2_d not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the texture is bound for [**glCompressedTexSubImage3D**](crate::context::Context::oxidegl_compressed_tex_sub_image3_d)
/// > function. Must be [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY),
/// > [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D), or [`GL_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_CUBE_MAP_ARRAY).
///
/// `texture`
///
/// > Specifies the texture object name for [**glCompressedTextureSubImage3D**](crate::context::Context::oxidegl_compressed_texture_sub_image3_d)
/// > function.
///
/// `level`
///
/// > Specifies the level-of-detail number. Level 0 is the base image level.
/// > Level *n* is the *n* th mipmap reduction image.
///
/// `xoffset`
///
/// > Specifies a texel offset in the x direction within the texture array.
///
/// `yoffset`
///
/// > Specifies a texel offset in the y direction within the texture array.
///
/// `zoffset`
///
/// > Specifies a texel offset in the z direction within the texture array.
///
/// `width`
///
/// > Specifies the width of the texture subimage.
///
/// `height`
///
/// > Specifies the height of the texture subimage.
///
/// `depth`
///
/// > Specifies the depth of the texture subimage.
///
/// `format`
///
/// > Specifies the format of the compressed image data stored at address `data`.
///
/// `imageSize`
///
/// > Specifies the number of unsigned bytes of image data starting at the address
/// > specified by `data`.
///
/// `data`
///
/// > Specifies a pointer to the compressed image data in memory.
///
/// ### Description
/// Texturing allows elements of an image array to be read by shaders.
///
/// [**glCompressedTexSubImage3D**](crate::context::Context::oxidegl_compressed_tex_sub_image3_d)
/// and [**glCompressedTextureSubImage3D**](crate::context::Context::oxidegl_compressed_texture_sub_image3_d)
/// redefine a contiguous subregion of an existing three-dimensional texture
/// image. The texels referenced by `data` replace the portion of the existing
/// texture array with x indices `xoffset` and `[inlineq]` `yoffset` and `[inlineq]`
/// `zoffset` and `[inlineq]`
///
/// `internalformat` must be a known compressed image format (such as [`GL_RGTC`](crate::enums::GL_RGTC))
/// or an extension-specified compressed-texture format. The `format` of the
/// compressed texture image is selected by the GL implementation that compressed
/// it (see [**glTexImage3D**](crate::context::Context::oxidegl_tex_image3_d))
/// and should be queried at the time the texture was compressed with [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter).
///
/// If a non-zero named buffer object is bound to the [`GL_PIXEL_UNPACK_BUFFER`](crate::enums::GL_PIXEL_UNPACK_BUFFER)
/// target (see [**glBindBuffer**](crate::context::Context::oxidegl_bind_buffer))
/// while a texture image is specified, `data` is treated as a byte offset
/// into the buffer object's data store.
///
/// ### Associated Gets
/// [**glGetCompressedTexImage**](crate::context::Context::oxidegl_get_compressed_tex_image)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_TEXTURE_COMPRESSED`](crate::enums::GL_TEXTURE_COMPRESSED)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_PIXEL_UNPACK_BUFFER_BINDING`](crate::enums::GL_PIXEL_UNPACK_BUFFER_BINDING)
///
/// [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter)
/// with arguments [`GL_TEXTURE_INTERNAL_FORMAT`](crate::enums::GL_TEXTURE_INTERNAL_FORMAT)
/// and [`GL_TEXTURE_COMPRESSED_IMAGE_SIZE`](crate::enums::GL_TEXTURE_COMPRESSED_IMAGE_SIZE)
impl Context {
    pub unsafe fn oxidegl_compressed_tex_sub_image3_d(
        &mut self,
        target: TextureTarget,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        zoffset: GLint,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        format: InternalFormat,
        image_size: GLsizei,
        data: *const GLvoid,
    ) {
        panic!("command oxidegl_compressed_tex_sub_image3_d not yet implemented");
    }
    pub unsafe fn oxidegl_compressed_texture_sub_image3_d(
        &mut self,
        texture: GLuint,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        zoffset: GLint,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        format: InternalFormat,
        image_size: GLsizei,
        data: *const GLvoid,
    ) {
        panic!("command oxidegl_compressed_texture_sub_image3_d not yet implemented");
    }
}
/// ### Parameters
/// `readTarget`
///
/// > Specifies the target to which the source buffer object is bound for [**glCopyBufferSubData**](crate::context::Context::oxidegl_copy_buffer_sub_data)
///
/// `writeTarget`
///
/// > Specifies the target to which the destination buffer object is bound for
/// > [**glCopyBufferSubData**](crate::context::Context::oxidegl_copy_buffer_sub_data).
///
/// `readBuffer`
///
/// > Specifies the name of the source buffer object for [**glCopyNamedBufferSubData**](crate::context::Context::oxidegl_copy_named_buffer_sub_data).
///
/// `writeBuffer`
///
/// > Specifies the name of the destination buffer object for [**glCopyNamedBufferSubData**](crate::context::Context::oxidegl_copy_named_buffer_sub_data).
///
/// `readOffset`
///
/// > Specifies the offset, in basic machine units, within the data store of
/// > the source buffer object at which data will be read.
///
/// `writeOffset`
///
/// > Specifies the offset, in basic machine units, within the data store of
/// > the destination buffer object at which data will be written.
///
/// `size`
///
/// > Specifies the size, in basic machine units, of the data to be copied from
/// > the source buffer object to the destination buffer object.
///
/// ### Description
/// [**glCopyBufferSubData**](crate::context::Context::oxidegl_copy_buffer_sub_data)
/// and [**glCopyNamedBufferSubData**](crate::context::Context::oxidegl_copy_named_buffer_sub_data)
/// copy part of the data store attached to a source buffer object to the data
/// store attached to a destination buffer object. The number of basic machine
/// units indicated by `size` is copied from the source at offset `readOffset`
/// to the destination at `writeOffset`. `readOffset`, `writeOffset` and `size`
/// are in terms of basic machine units.
///
/// For [**glCopyBufferSubData**](crate::context::Context::oxidegl_copy_buffer_sub_data),
/// `readTarget` and `writeTarget` specify the targets to which the source
/// and destination buffer objects are bound, and must each be one of the buffer
/// binding targets in the following table:
///
/// | *Buffer Binding Target*                               | *Purpose*      |
/// |-------------------------------------------------------|----------------|
/// | [`GL_ARRAY_BUFFER`](crate::enums::GL_ARRAY_BUFFER)    | Vertex attributes |
/// | [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER) | Atomic counter storage |
/// | [`GL_COPY_READ_BUFFER`](crate::enums::GL_COPY_READ_BUFFER) | Buffer copy source |
/// | [`GL_COPY_WRITE_BUFFER`](crate::enums::GL_COPY_WRITE_BUFFER) | Buffer copy destination |
/// | [`GL_DISPATCH_INDIRECT_BUFFER`](crate::enums::GL_DISPATCH_INDIRECT_BUFFER) | Indirect compute dispatch commands |
/// | [`GL_DRAW_INDIRECT_BUFFER`](crate::enums::GL_DRAW_INDIRECT_BUFFER) | Indirect command arguments |
/// | [`GL_ELEMENT_ARRAY_BUFFER`](crate::enums::GL_ELEMENT_ARRAY_BUFFER) | Vertex array indices |
/// | [`GL_PIXEL_PACK_BUFFER`](crate::enums::GL_PIXEL_PACK_BUFFER) | Pixel read target |
/// | [`GL_PIXEL_UNPACK_BUFFER`](crate::enums::GL_PIXEL_UNPACK_BUFFER) | Texture data source |
/// | [`GL_QUERY_BUFFER`](crate::enums::GL_QUERY_BUFFER)    | Query result buffer |
/// | [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER) | Read-write storage for shaders |
/// | [`GL_TEXTURE_BUFFER`](crate::enums::GL_TEXTURE_BUFFER) | Texture data buffer |
/// | [`GL_TRANSFORM_FEEDBACK_BUFFER`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER) | Transform feedback buffer |
/// | [`GL_UNIFORM_BUFFER`](crate::enums::GL_UNIFORM_BUFFER) | Uniform block storage |
///
/// Any of these targets may be used, but the targets [`GL_COPY_READ_BUFFER`](crate::enums::GL_COPY_READ_BUFFER)
/// and [`GL_COPY_WRITE_BUFFER`](crate::enums::GL_COPY_WRITE_BUFFER) are provided
/// specifically to allow copies between buffers without disturbing other GL
/// state.
///
/// `readOffset`, `writeOffset` and `size` must all be greater than or equal
/// to zero. Furthermore, $readOffset+size$ must not exceeed the size of the
/// source buffer object, and $writeOffset+size$ must not exceeed the size
/// of the buffer bound to `writeTarget`. If the source and destination are
/// the same buffer object, then the source and destination ranges must not
/// overlap.
///
/// ### Notes
/// The [`GL_DISPATCH_INDIRECT_BUFFER`](crate::enums::GL_DISPATCH_INDIRECT_BUFFER)
/// and [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER)
/// targets are available only if the GL version is 4.3 or greater.
///
/// The [`GL_QUERY_BUFFER`](crate::enums::GL_QUERY_BUFFER) target is available
/// only if the GL version is 4.4 or greater.
impl Context {
    pub fn oxidegl_copy_buffer_sub_data(
        &mut self,
        read_target: CopyBufferSubDataTarget,
        write_target: CopyBufferSubDataTarget,
        read_offset: GLintptr,
        write_offset: GLintptr,
        size: GLsizeiptr,
    ) {
        panic!("command oxidegl_copy_buffer_sub_data not yet implemented");
    }
    pub fn oxidegl_copy_named_buffer_sub_data(
        &mut self,
        read_buffer: GLuint,
        write_buffer: GLuint,
        read_offset: GLintptr,
        write_offset: GLintptr,
        size: GLsizeiptr,
    ) {
        panic!("command oxidegl_copy_named_buffer_sub_data not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the texture object is bound for [**glCopyTexSubImage1D**](crate::context::Context::oxidegl_copy_tex_sub_image1_d)
/// > function. Must be [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D).
///
/// `texture`
///
/// > Specifies the texture object name for [**glCopyTextureSubImage1D**](crate::context::Context::oxidegl_copy_texture_sub_image1_d)
/// > function.
///
/// `level`
///
/// > Specifies the level-of-detail number. Level 0 is the base image level.
/// > Level *n* is the *n* th mipmap reduction image.
///
/// `xoffset`
///
/// > Specifies the texel offset within the texture array.
///
/// `x`
///
/// `y`
///
/// > Specify the window coordinates of the left corner of the row of pixels
/// > to be copied.
///
/// `width`
///
/// > Specifies the width of the texture subimage.
///
/// ### Description
/// [**glCopyTexSubImage1D**](crate::context::Context::oxidegl_copy_tex_sub_image1_d)
/// and [**glCopyTextureSubImage1D**](crate::context::Context::oxidegl_copy_texture_sub_image1_d)
/// replace a portion of a one-dimensional texture image with pixels from the
/// current [`GL_READ_BUFFER`](crate::enums::GL_READ_BUFFER) (rather than from
/// main memory, as is the case for [**glTexSubImage1D**](crate::context::Context::oxidegl_tex_sub_image1_d)
/// ). For [**glCopyTexSubImage1D**](crate::context::Context::oxidegl_copy_tex_sub_image1_d),
/// the texture object that is bound to `target` will be used for the process.
/// For [**glCopyTextureSubImage1D**](crate::context::Context::oxidegl_copy_texture_sub_image1_d),
/// `texture` tells which texture object should be used for the purpose of
/// the call.
///
/// The screen-aligned pixel row with left corner at( `x` ,\ `y` ), and with
/// length `width` replaces the portion of the texture array with x indices
/// `xoffset` through `[inlineq]`
///
/// The pixels in the row are processed exactly as if [**glReadPixels**](crate::context::Context::oxidegl_read_pixels)
/// had been called, but the process stops just before final conversion. At
/// this point, all pixel component values are clamped to the range `[inlineq]`
///
/// It is not an error to specify a subtexture with zero width, but such a
/// specification has no effect. If any of the pixels within the specified
/// row of the current [`GL_READ_BUFFER`](crate::enums::GL_READ_BUFFER) are
/// outside the read window associated with the current rendering context,
/// then the values obtained for those pixels are undefined.
///
/// No change is made to the *internalformat* or *width* parameters of the
/// specified texture array or to texel values outside the specified subregion.
///
/// ### Notes
/// The [**glPixelStore**](crate::context::Context::oxidegl_pixel_store) mode
/// affects texture images.
///
/// ### Associated Gets
/// [**glGetTexImage**](crate::context::Context::oxidegl_get_tex_image)
impl Context {
    pub fn oxidegl_copy_tex_sub_image1_d(
        &mut self,
        target: TextureTarget,
        level: GLint,
        xoffset: GLint,
        x: GLint,
        y: GLint,
        width: GLsizei,
    ) {
        panic!("command oxidegl_copy_tex_sub_image1_d not yet implemented");
    }
    pub fn oxidegl_copy_texture_sub_image1_d(
        &mut self,
        texture: GLuint,
        level: GLint,
        xoffset: GLint,
        x: GLint,
        y: GLint,
        width: GLsizei,
    ) {
        panic!("command oxidegl_copy_texture_sub_image1_d not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the texture object is bound for [**glCopyTexSubImage2D**](crate::context::Context::oxidegl_copy_tex_sub_image2_d)
/// > function. Must be [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY),
/// > [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D), [`GL_TEXTURE_CUBE_MAP_POSITIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_X),
/// > [`GL_TEXTURE_CUBE_MAP_NEGATIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_X),
/// > [`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Y),
/// > [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Y),
/// > [`GL_TEXTURE_CUBE_MAP_POSITIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Z),
/// > [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Z),
/// > or [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE).
///
/// `texture`
///
/// > Specifies the texture object name for [**glCopyTextureSubImage2D**](crate::context::Context::oxidegl_copy_texture_sub_image2_d)
/// > function.
///
/// `level`
///
/// > Specifies the level-of-detail number. Level 0 is the base image level.
/// > Level *n* is the *n* th mipmap reduction image.
///
/// `xoffset`
///
/// > Specifies a texel offset in the x direction within the texture array.
///
/// `yoffset`
///
/// > Specifies a texel offset in the y direction within the texture array.
///
/// `x`
///
/// `y`
///
/// > Specify the window coordinates of the lower left corner of the rectangular
/// > region of pixels to be copied.
///
/// `width`
///
/// > Specifies the width of the texture subimage.
///
/// `height`
///
/// > Specifies the height of the texture subimage.
///
/// ### Description
/// [**glCopyTexSubImage2D**](crate::context::Context::oxidegl_copy_tex_sub_image2_d)
/// and [**glCopyTextureSubImage2D**](crate::context::Context::oxidegl_copy_texture_sub_image2_d)
/// replace a rectangular portion of a two-dimensional texture image, cube-map
/// texture image, rectangular image, or a linear portion of a number of slices
/// of a one-dimensional array texture with pixels from the current [`GL_READ_BUFFER`](crate::enums::GL_READ_BUFFER)
/// (rather than from main memory, as is the case for [**glTexSubImage2D**](crate::context::Context::oxidegl_tex_sub_image2_d)
/// ).
///
/// The screen-aligned pixel rectangle with lower left corner at `[inlineq]`
/// `width` and height `height` replaces the portion of the texture array with
/// x indices `xoffset` through `[inlineq]` `yoffset` through `[inlineq]` `level`.
///
/// The pixels in the rectangle are processed exactly as if [**glReadPixels**](crate::context::Context::oxidegl_read_pixels)
/// had been called, but the process stops just before final conversion. At
/// this point, all pixel component values are clamped to the range $\[0,1\]$
/// and then converted to the texture's internal format for storage in the
/// texel array.
///
/// The destination rectangle in the texture array may not include any texels
/// outside the texture array as it was originally specified. It is not an
/// error to specify a subtexture with zero width or height, but such a specification
/// has no effect.
///
/// When `target` is [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY)
/// then the y coordinate and height are treated as the start slice and number
/// of slices to modify, respectively.
///
/// If any of the pixels within the specified rectangle of the current [`GL_READ_BUFFER`](crate::enums::GL_READ_BUFFER)
/// are outside the read window associated with the current rendering context,
/// then the values obtained for those pixels are undefined.
///
/// No change is made to the *internalformat*, *width* or *height* parameters
/// of the specified texture array, or to texel values outside the specified
/// subregion.
///
/// ### Notes
/// [**glPixelStore**](crate::context::Context::oxidegl_pixel_store) modes
/// affect texture images.
///
/// ### Associated Gets
/// [**glGetTexImage**](crate::context::Context::oxidegl_get_tex_image)
impl Context {
    pub fn oxidegl_copy_tex_sub_image2_d(
        &mut self,
        target: TextureTarget,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        x: GLint,
        y: GLint,
        width: GLsizei,
        height: GLsizei,
    ) {
        panic!("command oxidegl_copy_tex_sub_image2_d not yet implemented");
    }
    pub fn oxidegl_copy_texture_sub_image2_d(
        &mut self,
        texture: GLuint,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        x: GLint,
        y: GLint,
        width: GLsizei,
        height: GLsizei,
    ) {
        panic!("command oxidegl_copy_texture_sub_image2_d not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the texture object is bound for [**glCopyTexSubImage3D**](crate::context::Context::oxidegl_copy_tex_sub_image3_d)
/// > function. Must be [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D), [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY)
/// > or [`GL_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_CUBE_MAP_ARRAY).
///
/// `texture`
///
/// > Specifies the texture object name for [**glCopyTextureSubImage3D**](crate::context::Context::oxidegl_copy_texture_sub_image3_d)
/// > function.
///
/// `level`
///
/// > Specifies the level-of-detail number. Level 0 is the base image level.
/// > Level *n* is the *n* th mipmap reduction image.
///
/// `xoffset`
///
/// > Specifies a texel offset in the x direction within the texture array.
///
/// `yoffset`
///
/// > Specifies a texel offset in the y direction within the texture array.
///
/// `zoffset`
///
/// > Specifies a texel offset in the z direction within the texture array.
///
/// `x`
///
/// `y`
///
/// > Specify the window coordinates of the lower left corner of the rectangular
/// > region of pixels to be copied.
///
/// `width`
///
/// > Specifies the width of the texture subimage.
///
/// `height`
///
/// > Specifies the height of the texture subimage.
///
/// ### Description
/// [**glCopyTexSubImage3D**](crate::context::Context::oxidegl_copy_tex_sub_image3_d)
/// and [**glCopyTextureSubImage3D**](crate::context::Context::oxidegl_copy_texture_sub_image3_d)
/// functions replace a rectangular portion of a three-dimensional or two-dimensional
/// array texture image with pixels from the current [`GL_READ_BUFFER`](crate::enums::GL_READ_BUFFER)
/// (rather than from main memory, as is the case for [**glTexSubImage3D**](crate::context::Context::oxidegl_tex_sub_image3_d)
/// ).
///
/// The screen-aligned pixel rectangle with lower left corner at( `x`, `y`)
/// and with width `width` and height `height` replaces the portion of the
/// texture array with x indices `xoffset` through `[inlineq]` `yoffset` through
/// `[inlineq]` `zoffset` and at the mipmap level specified by `level`.
///
/// The pixels in the rectangle are processed exactly as if [**glReadPixels**](crate::context::Context::oxidegl_read_pixels)
/// had been called, but the process stops just before final conversion. At
/// this point, all pixel component values are clamped to the range `[inlineq]`
///
/// The destination rectangle in the texture array may not include any texels
/// outside the texture array as it was originally specified. It is not an
/// error to specify a subtexture with zero width or height, but such a specification
/// has no effect.
///
/// If any of the pixels within the specified rectangle of the current [`GL_READ_BUFFER`](crate::enums::GL_READ_BUFFER)
/// are outside the read window associated with the current rendering context,
/// then the values obtained for those pixels are undefined.
///
/// No change is made to the *internalformat*, *width*, *height*, *depth*, or
/// *border* parameters of the specified texture array or to texel values outside
/// the specified subregion.
///
/// ### Notes
/// [**glPixelStore**](crate::context::Context::oxidegl_pixel_store) modes
/// affect texture images.
///
/// ### Associated Gets
/// [**glGetTexImage**](crate::context::Context::oxidegl_get_tex_image)
impl Context {
    pub fn oxidegl_copy_tex_sub_image3_d(
        &mut self,
        target: TextureTarget,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        zoffset: GLint,
        x: GLint,
        y: GLint,
        width: GLsizei,
        height: GLsizei,
    ) {
        panic!("command oxidegl_copy_tex_sub_image3_d not yet implemented");
    }
    pub fn oxidegl_copy_texture_sub_image3_d(
        &mut self,
        texture: GLuint,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        zoffset: GLint,
        x: GLint,
        y: GLint,
        width: GLsizei,
        height: GLsizei,
    ) {
        panic!("command oxidegl_copy_texture_sub_image3_d not yet implemented");
    }
}
/// ### Parameters
/// `nearVal`
///
/// > Specifies the mapping of the near clipping plane to window coordinates.
/// > The initial value is 0.
///
/// `farVal`
///
/// > Specifies the mapping of the far clipping plane to window coordinates.
/// > The initial value is 1.
///
/// ### Description
/// After clipping and division by *w*, depth coordinates range from `[inlineq]`
/// [**glDepthRange**](crate::context::Context::oxidegl_depth_range) specifies
/// a linear mapping of the normalized depth coordinates in this range to window
/// depth coordinates. Regardless of the actual depth buffer implementation,
/// window coordinate depth values are treated as though they range from 0
/// through 1 (like color components). Thus, the values accepted by [**glDepthRange**](crate::context::Context::oxidegl_depth_range)
/// are both clamped to this range before they are accepted.
///
/// The setting of (0,1) maps the near plane to 0 and the far plane to 1. With
/// this mapping, the depth buffer range is fully utilized.
///
/// ### Notes
/// It is not necessary that `nearVal` be less than `farVal`. Reverse mappings
/// such as `[inlineq]` `[inlineq]`
///
/// The type of the `nearVal` and `farVal` parameters was changed from `GLclampf`
/// to `GLfloat` for [**glDepthRangef**](crate::context::Context::oxidegl_depth_rangef)
/// and from `GLclampd` to `GLdouble` for [**glDepthRange**](crate::context::Context::oxidegl_depth_range).
/// This change is transparent to user code and is described in detail on
/// the [**removedTypes**](crate::context::Context::oxideremoved_types) page.
///
/// ### Associated Gets
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_DEPTH_RANGE`](crate::enums::GL_DEPTH_RANGE)
impl Context {
    pub fn oxidegl_depth_range(&mut self, n: GLdouble, f: GLdouble) {
        panic!("command oxidegl_depth_range not yet implemented");
    }
    pub fn oxidegl_depth_rangef(&mut self, n: GLfloat, f: GLfloat) {
        panic!("command oxidegl_depth_rangef not yet implemented");
    }
}
/// ### Parameters
/// `framebuffer`
///
/// > Specifies the name of the framebuffer object for [**glNamedFramebufferDrawBuffer**](crate::context::Context::oxidegl_named_framebuffer_draw_buffer)
/// > function. Must be zero or the name of a framebuffer object.
///
/// `buf`
///
/// > For default framebuffer, the argument specifies up to four color buffers
/// > to be drawn into. Symbolic constants [`GL_NONE`](crate::enums::GL_NONE),
/// > [`GL_FRONT_LEFT`](crate::enums::GL_FRONT_LEFT), [`GL_FRONT_RIGHT`](crate::enums::GL_FRONT_RIGHT),
/// > [`GL_BACK_LEFT`](crate::enums::GL_BACK_LEFT), [`GL_BACK_RIGHT`](crate::enums::GL_BACK_RIGHT),
/// > [`GL_FRONT`](crate::enums::GL_FRONT), [`GL_BACK`](crate::enums::GL_BACK),
/// > [`GL_LEFT`](crate::enums::GL_LEFT), [`GL_RIGHT`](crate::enums::GL_RIGHT),
/// > and [`GL_FRONT_AND_BACK`](crate::enums::GL_FRONT_AND_BACK) are accepted.
/// > The initial value is [`GL_FRONT`](crate::enums::GL_FRONT) for single-buffered
/// > contexts, and [`GL_BACK`](crate::enums::GL_BACK) for double-buffered contexts.
/// > For framebuffer objects, [`GL_COLOR_ATTACHMENT$m$`](crate::enums::GL_COLOR_ATTACHMENT$m$)
/// > and [`GL_NONE`](crate::enums::GL_NONE) enums are accepted, where [`$m$`](crate::enums::$m$)
/// > is a value between 0 and [`GL_MAX_COLOR_ATTACHMENTS`](crate::enums::GL_MAX_COLOR_ATTACHMENTS).
///
/// ### Description
/// When colors are written to the frame buffer, they are written into the
/// color buffers specified by [**glDrawBuffer**](crate::context::Context::oxidegl_draw_buffer).
/// One of the following values can be used for default framebuffer:
///
/// [`GL_NONE`](crate::enums::GL_NONE)
///
/// > No color buffers are written.
///
/// [`GL_FRONT_LEFT`](crate::enums::GL_FRONT_LEFT)
///
/// > Only the front left color buffer is written.
///
/// [`GL_FRONT_RIGHT`](crate::enums::GL_FRONT_RIGHT)
///
/// > Only the front right color buffer is written.
///
/// [`GL_BACK_LEFT`](crate::enums::GL_BACK_LEFT)
///
/// > Only the back left color buffer is written.
///
/// [`GL_BACK_RIGHT`](crate::enums::GL_BACK_RIGHT)
///
/// > Only the back right color buffer is written.
///
/// [`GL_FRONT`](crate::enums::GL_FRONT)
///
/// > Only the front left and front right color buffers are written. If there
/// > is no front right color buffer, only the front left color buffer is written.
///
/// [`GL_BACK`](crate::enums::GL_BACK)
///
/// > Only the back left and back right color buffers are written. If there is
/// > no back right color buffer, only the back left color buffer is written.
///
/// [`GL_LEFT`](crate::enums::GL_LEFT)
///
/// > Only the front left and back left color buffers are written. If there is
/// > no back left color buffer, only the front left color buffer is written.
///
/// [`GL_RIGHT`](crate::enums::GL_RIGHT)
///
/// > Only the front right and back right color buffers are written. If there
/// > is no back right color buffer, only the front right color buffer is written.
///
/// [`GL_FRONT_AND_BACK`](crate::enums::GL_FRONT_AND_BACK)
///
/// > All the front and back color buffers (front left, front right, back left,
/// > back right) are written. If there are no back color buffers, only the front
/// > left and front right color buffers are written. If there are no right color
/// > buffers, only the front left and back left color buffers are written. If
/// > there are no right or back color buffers, only the front left color buffer
/// > is written.
///
/// If more than one color buffer is selected for drawing, then blending or
/// logical operations are computed and applied independently for each color
/// buffer and can produce different results in each buffer.
///
/// Monoscopic contexts include only *left* buffers, and stereoscopic contexts
/// include both *left* and *right* buffers. Likewise, single-buffered contexts
/// include only *front* buffers, and double-buffered contexts include both
/// *front* and *back* buffers. The context is selected at GL initialization.
///
/// For framebuffer objects, [`GL_COLOR_ATTACHMENT$m$`](crate::enums::GL_COLOR_ATTACHMENT$m$)
/// and [`GL_NONE`](crate::enums::GL_NONE) enums are accepted, where [`$m$`](crate::enums::$m$)
/// is a value between 0 and [`GL_MAX_COLOR_ATTACHMENTS`](crate::enums::GL_MAX_COLOR_ATTACHMENTS).
/// glDrawBuffer will set the draw buffer for fragment colors other than zero
/// to [`GL_NONE`](crate::enums::GL_NONE).
///
/// ### Associated Gets
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_DRAW_BUFFER`](crate::enums::GL_DRAW_BUFFER)
impl Context {
    pub fn oxidegl_draw_buffer(&mut self, buf: DrawBufferMode) {
        panic!("command oxidegl_draw_buffer not yet implemented");
    }
    pub fn oxidegl_named_framebuffer_draw_buffer(&mut self, framebuffer: GLuint, buf: ColorBuffer) {
        panic!("command oxidegl_named_framebuffer_draw_buffer not yet implemented");
    }
}
/// ### Parameters
/// `framebuffer`
///
/// > Specifies the name of the framebuffer object for [**glNamedFramebufferDrawBuffers**](crate::context::Context::oxidegl_named_framebuffer_draw_buffers).
///
/// `n`
///
/// > Specifies the number of buffers in `bufs`.
///
/// `bufs`
///
/// > Points to an array of symbolic constants specifying the buffers into which
/// > fragment colors or data values will be written.
///
/// ### Description
/// [**glDrawBuffers**](crate::context::Context::oxidegl_draw_buffers) and
/// [**glNamedFramebufferDrawBuffers**](crate::context::Context::oxidegl_named_framebuffer_draw_buffers)
/// define an array of buffers into which outputs from the fragment shader
/// data will be written. If a fragment shader writes a value to one or more
/// user defined output variables, then the value of each variable will be
/// written into the buffer specified at a location within `bufs` corresponding
/// to the location assigned to that user defined output. The draw buffer used
/// for user defined outputs assigned to locations greater than or equal to
/// `n` is implicitly set to [`GL_NONE`](crate::enums::GL_NONE) and any data
/// written to such an output is discarded.
///
/// For [**glDrawBuffers**](crate::context::Context::oxidegl_draw_buffers),
/// the framebuffer object that is bound to the [`GL_DRAW_FRAMEBUFFER`](crate::enums::GL_DRAW_FRAMEBUFFER)
/// binding will be used. For [**glNamedFramebufferDrawBuffers**](crate::context::Context::oxidegl_named_framebuffer_draw_buffers),
/// `framebuffer` is the name of the framebuffer object. If `framebuffer` is
/// zero, then the default framebuffer is affected.
///
/// The symbolic constants contained in `bufs` may be any of the following:
///
/// [`GL_NONE`](crate::enums::GL_NONE)
///
/// > The fragment shader output value is not written into any color buffer.
///
/// [`GL_FRONT_LEFT`](crate::enums::GL_FRONT_LEFT)
///
/// > The fragment shader output value is written into the front left color buffer.
///
/// [`GL_FRONT_RIGHT`](crate::enums::GL_FRONT_RIGHT)
///
/// > The fragment shader output value is written into the front right color
/// > buffer.
///
/// [`GL_BACK_LEFT`](crate::enums::GL_BACK_LEFT)
///
/// > The fragment shader output value is written into the back left color buffer.
///
/// [`GL_BACK_RIGHT`](crate::enums::GL_BACK_RIGHT)
///
/// > The fragment shader output value is written into the back right color buffer.
///
/// [`GL_COLOR_ATTACHMENT`](crate::enums::GL_COLOR_ATTACHMENT) *n*
///
/// > The fragment shader output value is written into the *n* th color attachment
/// > of the current framebuffer. *n* may range from zero to the value of [`GL_MAX_COLOR_ATTACHMENTS`](crate::enums::GL_MAX_COLOR_ATTACHMENTS).
///
/// Except for [`GL_NONE`](crate::enums::GL_NONE), the preceding symbolic constants
/// may not appear more than once in `bufs`. The maximum number of draw buffers
/// supported is implementation dependent and can be queried by calling [**glGet**](crate::context::Context::oxidegl_get)
/// with the argument [`GL_MAX_DRAW_BUFFERS`](crate::enums::GL_MAX_DRAW_BUFFERS).
///
/// ### Notes
/// The symbolic constants [`GL_FRONT`](crate::enums::GL_FRONT), [`GL_BACK`](crate::enums::GL_BACK),
/// [`GL_LEFT`](crate::enums::GL_LEFT), [`GL_RIGHT`](crate::enums::GL_RIGHT),
/// and [`GL_FRONT_AND_BACK`](crate::enums::GL_FRONT_AND_BACK) are not allowed
/// in the `bufs` array since they may refer to multiple buffers.
///
/// If a fragment shader does not write to a user defined output variable,
/// the values of the fragment colors following shader execution are undefined.
/// For each fragment generated in this situation, a different value may be
/// written into each of the buffers specified by `bufs`.
///
/// ### Associated Gets
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_DRAW_BUFFERS`](crate::enums::GL_MAX_DRAW_BUFFERS)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_DRAW_BUFFER`](crate::enums::GL_DRAW_BUFFER)
/// *i* where ** indicates the number of the draw buffer whose value is to
/// be queried.
impl Context {
    pub fn oxidegl_draw_buffers(&mut self, n: GLsizei, bufs: DrawBufferMode) {
        panic!("command oxidegl_draw_buffers not yet implemented");
    }
    pub fn oxidegl_named_framebuffer_draw_buffers(
        &mut self,
        framebuffer: GLuint,
        n: GLsizei,
        bufs: ColorBuffer,
    ) {
        panic!("command oxidegl_named_framebuffer_draw_buffers not yet implemented");
    }
}
/// ### Parameters
/// `cap`
///
/// > Specifies a symbolic constant indicating a GL capability.
///
/// `index`
///
/// > Specifies the index of the switch to disable (for [**glEnablei**](crate::context::Context::oxidegl_enablei)
/// > and [**glDisablei**](crate::context::Context::oxidegl_disablei) only).
///
/// ### Description
/// [**glEnable**](crate::context::Context::oxidegl_enable) and [**glDisable**](crate::context::Context::oxidegl_disable)
/// enable and disable various capabilities. Use [**glIsEnabled**](crate::context::Context::oxidegl_is_enabled)
/// or [**glGet**](crate::context::Context::oxidegl_get) to determine the current
/// setting of any capability. The initial value for each capability with the
/// exception of [`GL_DITHER`](crate::enums::GL_DITHER) and [`GL_MULTISAMPLE`](crate::enums::GL_MULTISAMPLE)
/// is [`GL_FALSE`](crate::enums::GL_FALSE). The initial value for [`GL_DITHER`](crate::enums::GL_DITHER)
/// and [`GL_MULTISAMPLE`](crate::enums::GL_MULTISAMPLE) is [`GL_TRUE`](crate::enums::GL_TRUE).
///
/// Both [**glEnable**](crate::context::Context::oxidegl_enable) and [**glDisable**](crate::context::Context::oxidegl_disable)
/// take a single argument, `cap`, which can assume one of the following values:
///
/// Some of the GL's capabilities are indexed. [**glEnablei**](crate::context::Context::oxidegl_enablei)
/// and [**glDisablei**](crate::context::Context::oxidegl_disablei) enable
/// and disable indexed capabilities.
///
/// [`GL_BLEND`](crate::enums::GL_BLEND)
///
///
/// > If enabled, blend the computed fragment color values with the values in
/// > the color buffers. See [**glBlendFunc**](crate::context::Context::oxidegl_blend_func).
///
/// [`GL_CLIP_DISTANCE`](crate::enums::GL_CLIP_DISTANCE) *i*
///
///
/// > If enabled, clip geometry against user-defined half space *i*.
///
/// [`GL_COLOR_LOGIC_OP`](crate::enums::GL_COLOR_LOGIC_OP)
///
///
/// > If enabled, apply the currently selected logical operation to the computed
/// > fragment color and color buffer values. See [**glLogicOp**](crate::context::Context::oxidegl_logic_op).
///
/// [`GL_CULL_FACE`](crate::enums::GL_CULL_FACE)
///
///
/// > If enabled, cull polygons based on their winding in window coordinates.
/// > See [**glCullFace**](crate::context::Context::oxidegl_cull_face).
///
/// [`GL_DEBUG_OUTPUT`](crate::enums::GL_DEBUG_OUTPUT)
///
///
/// > If enabled, debug messages are produced by a debug context. When disabled,
/// > the debug message log is silenced. Note that in a non-debug context, very
/// > few, if any messages might be produced, even when [`GL_DEBUG_OUTPUT`](crate::enums::GL_DEBUG_OUTPUT)
/// > is enabled.
///
/// [`GL_DEBUG_OUTPUT_SYNCHRONOUS`](crate::enums::GL_DEBUG_OUTPUT_SYNCHRONOUS)
///
///
/// > If enabled, debug messages are produced synchronously by a debug context.
/// > If disabled, debug messages may be produced asynchronously. In particular,
/// > they may be delayed relative to the execution of GL commands, and the debug
/// > callback function may be called from a thread other than that in which
/// > the commands are executed. See [**glDebugMessageCallback**](crate::context::Context::oxidegl_debug_message_callback).
///
/// [`GL_DEPTH_CLAMP`](crate::enums::GL_DEPTH_CLAMP)
///
///
/// > If enabled, the `[inlineq]` [**glDepthRange**](crate::context::Context::oxidegl_depth_range).
///
/// [`GL_DEPTH_TEST`](crate::enums::GL_DEPTH_TEST)
///
///
/// > If enabled, do depth comparisons and update the depth buffer. Note that
/// > even if the depth buffer exists and the depth mask is non-zero, the depth
/// > buffer is not updated if the depth test is disabled. See [**glDepthFunc**](crate::context::Context::oxidegl_depth_func)
/// > and [**glDepthRange**](crate::context::Context::oxidegl_depth_range).
///
/// [`GL_DITHER`](crate::enums::GL_DITHER)
///
///
/// > If enabled, dither color components or indices before they are written
/// > to the color buffer.
///
/// [`GL_FRAMEBUFFER_SRGB`](crate::enums::GL_FRAMEBUFFER_SRGB)
///
///
/// > If enabled and the value of [`GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING)
/// > for the framebuffer attachment corresponding to the destination buffer
/// > is [`GL_SRGB`](crate::enums::GL_SRGB), the R, G, and B destination color
/// > values (after conversion from fixed-point to floating-point) are considered
/// > to be encoded for the sRGB color space and hence are linearized prior to
/// > their use in blending.
///
/// [`GL_LINE_SMOOTH`](crate::enums::GL_LINE_SMOOTH)
///
///
/// > If enabled, draw lines with correct filtering. Otherwise, draw aliased
/// > lines. See [**glLineWidth**](crate::context::Context::oxidegl_line_width).
///
/// [`GL_MULTISAMPLE`](crate::enums::GL_MULTISAMPLE)
///
///
/// > If enabled, use multiple fragment samples in computing the final color
/// > of a pixel. See [**glSampleCoverage**](crate::context::Context::oxidegl_sample_coverage).
///
/// [`GL_POLYGON_OFFSET_FILL`](crate::enums::GL_POLYGON_OFFSET_FILL)
///
///
/// > If enabled, and if the polygon is rendered in [`GL_FILL`](crate::enums::GL_FILL)
/// > mode, an offset is added to depth values of a polygon's fragments before
/// > the depth comparison is performed. See [**glPolygonOffset**](crate::context::Context::oxidegl_polygon_offset).
///
/// [`GL_POLYGON_OFFSET_LINE`](crate::enums::GL_POLYGON_OFFSET_LINE)
///
///
/// > If enabled, and if the polygon is rendered in [`GL_LINE`](crate::enums::GL_LINE)
/// > mode, an offset is added to depth values of a polygon's fragments before
/// > the depth comparison is performed. See [**glPolygonOffset**](crate::context::Context::oxidegl_polygon_offset).
///
/// [`GL_POLYGON_OFFSET_POINT`](crate::enums::GL_POLYGON_OFFSET_POINT)
///
///
/// > If enabled, an offset is added to depth values of a polygon's fragments
/// > before the depth comparison is performed, if the polygon is rendered in
/// > [`GL_POINT`](crate::enums::GL_POINT) mode. See [**glPolygonOffset**](crate::context::Context::oxidegl_polygon_offset).
///
/// [`GL_POLYGON_SMOOTH`](crate::enums::GL_POLYGON_SMOOTH)
///
///
/// > If enabled, draw polygons with proper filtering. Otherwise, draw aliased
/// > polygons. For correct antialiased polygons, an alpha buffer is needed and
/// > the polygons must be sorted front to back.
///
/// [`GL_PRIMITIVE_RESTART`](crate::enums::GL_PRIMITIVE_RESTART)
///
///
/// > Enables primitive restarting. If enabled, any one of the draw commands
/// > which transfers a set of generic attribute array elements to the GL will
/// > restart the primitive when the index of the vertex is equal to the primitive
/// > restart index. See [**glPrimitiveRestartIndex**](crate::context::Context::oxidegl_primitive_restart_index).
///
/// [`GL_PRIMITIVE_RESTART_FIXED_INDEX`](crate::enums::GL_PRIMITIVE_RESTART_FIXED_INDEX)
///
///
/// > Enables primitive restarting with a fixed index. If enabled, any one of
/// > the draw commands which transfers a set of generic attribute array elements
/// > to the GL will restart the primitive when the index of the vertex is equal
/// > to the fixed primitive index for the specified index type. The fixed index
/// > is equal to `[inlineq]` *n* is equal to 8 for [`GL_UNSIGNED_BYTE`](crate::enums::GL_UNSIGNED_BYTE),
/// > 16 for [`GL_UNSIGNED_SHORT`](crate::enums::GL_UNSIGNED_SHORT) and 32 for
/// > [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT).
///
/// [`GL_RASTERIZER_DISCARD`](crate::enums::GL_RASTERIZER_DISCARD)
///
///
/// > If enabled, primitives are discarded after the optional transform feedback
/// > stage, but before rasterization. Furthermore, when enabled, [**glClear**](crate::context::Context::oxidegl_clear),
/// > [**glClearBufferData**](crate::context::Context::oxidegl_clear_buffer_data),
/// > [**glClearBufferSubData**](crate::context::Context::oxidegl_clear_buffer_sub_data),
/// > [**glClearTexImage**](crate::context::Context::oxidegl_clear_tex_image),
/// > and [**glClearTexSubImage**](crate::context::Context::oxidegl_clear_tex_sub_image)
/// > are ignored.
///
/// [`GL_SAMPLE_ALPHA_TO_COVERAGE`](crate::enums::GL_SAMPLE_ALPHA_TO_COVERAGE)
///
///
/// > If enabled, compute a temporary coverage value where each bit is determined
/// > by the alpha value at the corresponding sample location. The temporary
/// > coverage value is then ANDed with the fragment coverage value.
///
/// [`GL_SAMPLE_ALPHA_TO_ONE`](crate::enums::GL_SAMPLE_ALPHA_TO_ONE)
///
///
/// > If enabled, each sample alpha value is replaced by the maximum representable
/// > alpha value.
///
/// [`GL_SAMPLE_COVERAGE`](crate::enums::GL_SAMPLE_COVERAGE)
///
///
/// > If enabled, the fragment's coverage is ANDed with the temporary coverage
/// > value. If [`GL_SAMPLE_COVERAGE_INVERT`](crate::enums::GL_SAMPLE_COVERAGE_INVERT)
/// > is set to [`GL_TRUE`](crate::enums::GL_TRUE), invert the coverage value.
/// > See [**glSampleCoverage**](crate::context::Context::oxidegl_sample_coverage).
///
/// [`GL_SAMPLE_SHADING`](crate::enums::GL_SAMPLE_SHADING)
///
///
/// > If enabled, the active fragment shader is run once for each covered sample,
/// > or at fraction of this rate as determined by the current value of [`GL_MIN_SAMPLE_SHADING_VALUE`](crate::enums::GL_MIN_SAMPLE_SHADING_VALUE).
/// > See [**glMinSampleShading**](crate::context::Context::oxidegl_min_sample_shading).
///
/// [`GL_SAMPLE_MASK`](crate::enums::GL_SAMPLE_MASK)
///
///
/// > If enabled, the sample coverage mask generated for a fragment during rasterization
/// > will be ANDed with the value of [`GL_SAMPLE_MASK_VALUE`](crate::enums::GL_SAMPLE_MASK_VALUE)
/// > before shading occurs. See [**glSampleMaski**](crate::context::Context::oxidegl_sample_maski).
///
/// [`GL_SCISSOR_TEST`](crate::enums::GL_SCISSOR_TEST)
///
///
/// > If enabled, discard fragments that are outside the scissor rectangle. See
/// > [**glScissor**](crate::context::Context::oxidegl_scissor).
///
/// [`GL_STENCIL_TEST`](crate::enums::GL_STENCIL_TEST)
///
///
/// > If enabled, do stencil testing and update the stencil buffer. See [**glStencilFunc**](crate::context::Context::oxidegl_stencil_func)
/// > and [**glStencilOp**](crate::context::Context::oxidegl_stencil_op).
///
/// [`GL_TEXTURE_CUBE_MAP_SEAMLESS`](crate::enums::GL_TEXTURE_CUBE_MAP_SEAMLESS)
///
///
/// > If enabled, cubemap textures are sampled such that when linearly sampling
/// > from the border between two adjacent faces, texels from both faces are
/// > used to generate the final sample value. When disabled, texels from only
/// > a single face are used to construct the final sample value.
///
/// [`GL_PROGRAM_POINT_SIZE`](crate::enums::GL_PROGRAM_POINT_SIZE)
///
///
/// > If enabled and a vertex or geometry shader is active, then the derived
/// > point size is taken from the (potentially clipped) shader builtin [`gl_PointSize`](crate::enums::gl_PointSize)
/// > and clamped to the implementation-dependent point size range.
///
/// ### Notes
/// [`GL_PRIMITIVE_RESTART`](crate::enums::GL_PRIMITIVE_RESTART) is available
/// only if the GL version is 3.1 or greater.
///
/// [`GL_TEXTURE_CUBE_MAP_SEAMLESS`](crate::enums::GL_TEXTURE_CUBE_MAP_SEAMLESS)
/// is available only if the GL version is 3.2 or greater.
///
/// [`GL_PRIMITIVE_RESTART_FIXED_INDEX`](crate::enums::GL_PRIMITIVE_RESTART_FIXED_INDEX)
/// is available only if the GL version is 4.3 or greater.
///
/// [`GL_DEBUG_OUTPUT`](crate::enums::GL_DEBUG_OUTPUT) and [`GL_DEBUG_OUTPUT_SYNCHRONOUS`](crate::enums::GL_DEBUG_OUTPUT_SYNCHRONOUS)
/// are available only if the GL version is 4.3 or greater.
///
/// Any token accepted by [**glEnable**](crate::context::Context::oxidegl_enable)
/// or [**glDisable**](crate::context::Context::oxidegl_disable) is also accepted
/// by [**glEnablei**](crate::context::Context::oxidegl_enablei) and [**glDisablei**](crate::context::Context::oxidegl_disablei),
/// but if the capability is not indexed, the maximum value that `index` may
/// take is zero.
///
/// In general, passing an indexed capability to [**glEnable**](crate::context::Context::oxidegl_enable)
/// or [**glDisable**](crate::context::Context::oxidegl_disable) will enable
/// or disable that capability for all indices, resepectively.
///
/// ### Associated Gets
/// [**glIsEnabled**](crate::context::Context::oxidegl_is_enabled)
///
/// [**glGet**](crate::context::Context::oxidegl_get)
impl Context {
    pub fn oxidegl_disable(&mut self, cap: EnableCap) {
        panic!("command oxidegl_disable not yet implemented");
    }
    pub fn oxidegl_enable(&mut self, cap: EnableCap) {
        panic!("command oxidegl_enable not yet implemented");
    }
    pub fn oxidegl_enablei(&mut self, target: EnableCap, index: GLuint) {
        panic!("command oxidegl_enablei not yet implemented");
    }
    pub fn oxidegl_disablei(&mut self, target: EnableCap, index: GLuint) {
        panic!("command oxidegl_disablei not yet implemented");
    }
}

/// ### Parameters
/// `target`
///
/// > Specifies the target to which the buffer object is bound for [**glFlushMappedBufferRange**](crate::context::Context::oxidegl_flush_mapped_buffer_range),
/// > which must be one of the buffer binding targets in the following table:
///
/// > | *Buffer Binding Target*                               | *Purpose*      |
/// > |-------------------------------------------------------|----------------|
/// > | [`GL_ARRAY_BUFFER`](crate::enums::GL_ARRAY_BUFFER)    | Vertex attributes |
/// > | [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER) | Atomic counter storage |
/// > | [`GL_COPY_READ_BUFFER`](crate::enums::GL_COPY_READ_BUFFER) | Buffer copy source |
/// > | [`GL_COPY_WRITE_BUFFER`](crate::enums::GL_COPY_WRITE_BUFFER) | Buffer copy destination |
/// > | [`GL_DISPATCH_INDIRECT_BUFFER`](crate::enums::GL_DISPATCH_INDIRECT_BUFFER) | Indirect compute dispatch commands |
/// > | [`GL_DRAW_INDIRECT_BUFFER`](crate::enums::GL_DRAW_INDIRECT_BUFFER) | Indirect command arguments |
/// > | [`GL_ELEMENT_ARRAY_BUFFER`](crate::enums::GL_ELEMENT_ARRAY_BUFFER) | Vertex array indices |
/// > | [`GL_PIXEL_PACK_BUFFER`](crate::enums::GL_PIXEL_PACK_BUFFER) | Pixel read target |
/// > | [`GL_PIXEL_UNPACK_BUFFER`](crate::enums::GL_PIXEL_UNPACK_BUFFER) | Texture data source |
/// > | [`GL_QUERY_BUFFER`](crate::enums::GL_QUERY_BUFFER)    | Query result buffer |
/// > | [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER) | Read-write storage for shaders |
/// > | [`GL_TEXTURE_BUFFER`](crate::enums::GL_TEXTURE_BUFFER) | Texture data buffer |
/// > | [`GL_TRANSFORM_FEEDBACK_BUFFER`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER) | Transform feedback buffer |
/// > | [`GL_UNIFORM_BUFFER`](crate::enums::GL_UNIFORM_BUFFER) | Uniform block storage |
///
/// `buffer`
///
/// > Specifies the name of the buffer object for [**glFlushMappedNamedBufferRange**](crate::context::Context::oxidegl_flush_mapped_named_buffer_range).
///
/// `offset`
///
/// > Specifies the start of the buffer subrange, in basic machine units.
///
/// `length`
///
/// > Specifies the length of the buffer subrange, in basic machine units.
///
/// ### Description
/// [**glFlushMappedBufferRange**](crate::context::Context::oxidegl_flush_mapped_buffer_range)
/// indicates that modifications have been made to a range of a mapped buffer
/// object. The buffer object must previously have been mapped with the [`GL_MAP_FLUSH_EXPLICIT_BIT`](crate::enums::GL_MAP_FLUSH_EXPLICIT_BIT)
/// flag.
///
/// `offset` and `length` indicate the modified subrange of the mapping, in
/// basic machine units. The specified subrange to flush is relative to the
/// start of the currently mapped range of the buffer. These commands may be
/// called multiple times to indicate distinct subranges of the mapping which
/// require flushing.
///
/// If a buffer range is mapped with both [`GL_MAP_PERSISTENT_BIT`](crate::enums::GL_MAP_PERSISTENT_BIT)
/// and [`GL_MAP_FLUSH_EXPLICIT_BIT`](crate::enums::GL_MAP_FLUSH_EXPLICIT_BIT)
/// set, then these commands may be called to ensure that data written by the
/// client into the flushed region becomes visible to the server. Data written
/// to a coherent store will always become visible to the server after an unspecified
/// period of time.
///
/// ### Notes
/// The [`GL_DISPATCH_INDIRECT_BUFFER`](crate::enums::GL_DISPATCH_INDIRECT_BUFFER)
/// and [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER)
/// targets are available only if the GL version is 4.3 or greater.
///
/// The [`GL_QUERY_BUFFER`](crate::enums::GL_QUERY_BUFFER) target is available
/// only if the GL version is 4.4 or greater.
impl Context {
    pub fn oxidegl_flush_mapped_buffer_range(
        &mut self,
        target: BufferTarget,
        offset: GLintptr,
        length: GLsizeiptr,
    ) {
        panic!("command oxidegl_flush_mapped_buffer_range not yet implemented");
    }
    pub fn oxidegl_flush_mapped_named_buffer_range(
        &mut self,
        buffer: GLuint,
        offset: GLintptr,
        length: GLsizeiptr,
    ) {
        panic!("command oxidegl_flush_mapped_named_buffer_range not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the framebuffer is bound for [**glFramebufferParameteri**](crate::context::Context::oxidegl_framebuffer_parameteri).
///
/// `framebuffer`
///
/// > Specifies the name of the framebuffer object for [**glNamedFramebufferParameteri**](crate::context::Context::oxidegl_named_framebuffer_parameteri).
///
/// `pname`
///
/// > Specifies the framebuffer parameter to be modified.
///
/// `param`
///
/// > The new value for the parameter named `pname`.
///
/// ### Description
/// [**glFramebufferParameteri**](crate::context::Context::oxidegl_framebuffer_parameteri)
/// and [**glNamedFramebufferParameteri**](crate::context::Context::oxidegl_named_framebuffer_parameteri)
/// modify the value of the parameter named `pname` in the specified framebuffer
/// object. There are no modifiable parameters of the default draw and read
/// framebuffer, so they are not valid targets of these commands.
///
/// For [**glFramebufferParameteri**](crate::context::Context::oxidegl_framebuffer_parameteri),
/// the framebuffer object is that bound to `target`, which must be [`GL_DRAW_FRAMEBUFFER`](crate::enums::GL_DRAW_FRAMEBUFFER),
/// [`GL_READ_FRAMEBUFFER`](crate::enums::GL_READ_FRAMEBUFFER) or [`GL_FRAMEBUFFER`](crate::enums::GL_FRAMEBUFFER).
/// [`GL_FRAMEBUFFER`](crate::enums::GL_FRAMEBUFFER) is equivalent to [`GL_DRAW_FRAMEBUFFER`](crate::enums::GL_DRAW_FRAMEBUFFER).
///
/// For [**glNamedFramebufferParameteri**](crate::context::Context::oxidegl_named_framebuffer_parameteri),
/// `framebuffer` is the name of the framebuffer object.
///
/// `pname` specifies the parameter to be modified. The following values are
/// accepted:
///
/// [`GL_FRAMEBUFFER_DEFAULT_WIDTH`](crate::enums::GL_FRAMEBUFFER_DEFAULT_WIDTH)
///
/// > `param` specifies the assumed with for a framebuffer object with no attachments.
/// > If a framebuffer has attachments then the width of those attachments is
/// > used, otherwise the value of [`GL_FRAMEBUFFER_DEFAULT_WIDTH`](crate::enums::GL_FRAMEBUFFER_DEFAULT_WIDTH)
/// > is used for the framebuffer. `param` must be greater than or equal to zero
/// > and less than or equal to the value of [`GL_MAX_FRAMEBUFFER_WIDTH`](crate::enums::GL_MAX_FRAMEBUFFER_WIDTH).
///
/// [`GL_FRAMEBUFFER_DEFAULT_HEIGHT`](crate::enums::GL_FRAMEBUFFER_DEFAULT_HEIGHT)
///
/// > `param` specifies the assumed height for a framebuffer object with no attachments.
/// > If a framebuffer has attachments then the height of those attachments is
/// > used, otherwise the value of [`GL_FRAMEBUFFER_DEFAULT_HEIGHT`](crate::enums::GL_FRAMEBUFFER_DEFAULT_HEIGHT)
/// > is used for the framebuffer. `param` must be greater than or equal to zero
/// > and less than or equal to the value of [`GL_MAX_FRAMEBUFFER_HEIGHT`](crate::enums::GL_MAX_FRAMEBUFFER_HEIGHT).
///
/// [`GL_FRAMEBUFFER_DEFAULT_LAYERS`](crate::enums::GL_FRAMEBUFFER_DEFAULT_LAYERS)
///
/// > `param` specifies the assumed number of layers for a framebuffer object
/// > with no attachments. If a framebuffer has attachments then the layer count
/// > of those attachments is used, otherwise the value of [`GL_FRAMEBUFFER_DEFAULT_LAYERS`](crate::enums::GL_FRAMEBUFFER_DEFAULT_LAYERS)
/// > is used for the framebuffer. `param` must be greater than or equal to zero
/// > and less than or equal to the value of [`GL_MAX_FRAMEBUFFER_LAYERS`](crate::enums::GL_MAX_FRAMEBUFFER_LAYERS).
///
/// [`GL_FRAMEBUFFER_DEFAULT_SAMPLES`](crate::enums::GL_FRAMEBUFFER_DEFAULT_SAMPLES)
///
/// > `param` specifies the assumed number of samples in a framebuffer object
/// > with no attachments. If a framebuffer has attachments then the sample count
/// > of those attachments is used, otherwise the value of [`GL_FRAMEBUFFER_DEFAULT_SAMPLES`](crate::enums::GL_FRAMEBUFFER_DEFAULT_SAMPLES)
/// > is used for the framebuffer. `param` must be greater than or equal to zero
/// > and less than or equal to the value of [`GL_MAX_FRAMEBUFFER_SAMPLE`](crate::enums::GL_MAX_FRAMEBUFFER_SAMPLE).
///
/// [`GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS`](crate::enums::GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS)
///
/// > `param` specifies whether the framebuffer should assume identical sample
/// > locations and the same number of samples for all texels in the virtual
/// > image. If `param` is zero, then the implementation may vary the position
/// > or the count of samples within the virtual image from pixel to pixel, otherwise
/// > it will use the same sample position and count for all pixels in the virtual
/// > image.
///
/// ### Associated Gets
/// [**glGetFramebufferParameteriv**](crate::context::Context::oxidegl_get_framebuffer_parameteriv).
impl Context {
    pub fn oxidegl_framebuffer_parameteri(
        &mut self,
        target: FramebufferTarget,
        pname: FramebufferParameterName,
        param: GLint,
    ) {
        panic!("command oxidegl_framebuffer_parameteri not yet implemented");
    }
    pub fn oxidegl_named_framebuffer_parameteri(
        &mut self,
        framebuffer: GLuint,
        pname: FramebufferParameterName,
        param: GLint,
    ) {
        panic!("command oxidegl_named_framebuffer_parameteri not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the framebuffer is bound for [**glFramebufferRenderbuffer**](crate::context::Context::oxidegl_framebuffer_renderbuffer).
///
/// `framebuffer`
///
/// > Specifies the name of the framebuffer object for [**glNamedFramebufferRenderbuffer**](crate::context::Context::oxidegl_named_framebuffer_renderbuffer).
///
/// `attachment`
///
/// > Specifies the attachment point of the framebuffer.
///
/// `renderbuffertarget`
///
/// > Specifies the renderbuffer target. Must be [`GL_RENDERBUFFER`](crate::enums::GL_RENDERBUFFER).
///
/// `renderbuffer`
///
/// > Specifies the name of an existing renderbuffer object of type `renderbuffertarget`
/// > to attach.
///
/// ### Description
/// [**glFramebufferRenderbuffer**](crate::context::Context::oxidegl_framebuffer_renderbuffer)
/// and [**glNamedFramebufferRenderbuffer**](crate::context::Context::oxidegl_named_framebuffer_renderbuffer)
/// attaches a renderbuffer as one of the logical buffers of the specified
/// framebuffer object. Renderbuffers cannot be attached to the default draw
/// and read framebuffer, so they are not valid targets of these commands.
///
/// For [**glFramebufferRenderbuffer**](crate::context::Context::oxidegl_framebuffer_renderbuffer),
/// the framebuffer object is that bound to `target`, which must be [`GL_DRAW_FRAMEBUFFER`](crate::enums::GL_DRAW_FRAMEBUFFER),
/// [`GL_READ_FRAMEBUFFER`](crate::enums::GL_READ_FRAMEBUFFER) or [`GL_FRAMEBUFFER`](crate::enums::GL_FRAMEBUFFER).
/// [`GL_FRAMEBUFFER`](crate::enums::GL_FRAMEBUFFER) is equivalent to [`GL_DRAW_FRAMEBUFFER`](crate::enums::GL_DRAW_FRAMEBUFFER).
///
/// For [**glNamedFramebufferRenderbuffer**](crate::context::Context::oxidegl_named_framebuffer_renderbuffer),
/// `framebuffer` is the name of the framebuffer object.
///
/// `renderbuffertarget` must be [`GL_RENDERBUFFER`](crate::enums::GL_RENDERBUFFER).
///
/// `renderbuffer` must be zero or the name of an existing renderbuffer object
/// of type `renderbuffertarget`. If `renderbuffer` is not zero, then the specified
/// renderbuffer will be used as the logical buffer identified by `attachment`
/// of the specified framebuffer object. If `renderbuffer` is zero, then the
/// value of `renderbuffertarget` is ignored.
///
/// `attachment` specifies the logical attachment of the framebuffer and must
/// be [`GL_COLOR_ATTACHMENT`](crate::enums::GL_COLOR_ATTACHMENT) *i*, [`GL_DEPTH_ATTACHMENT`](crate::enums::GL_DEPTH_ATTACHMENT),
/// [`GL_STENCIL_ATTACHMENT`](crate::enums::GL_STENCIL_ATTACHMENT) or [`GL_DEPTH_STENCIL_ATTACHMENT`](crate::enums::GL_DEPTH_STENCIL_ATTACHMENT).
/// *i* in may range from zero to the value of [`GL_MAX_COLOR_ATTACHMENTS`](crate::enums::GL_MAX_COLOR_ATTACHMENTS)
/// minus one. Setting `attachment` to the value [`GL_DEPTH_STENCIL_ATTACHMENT`](crate::enums::GL_DEPTH_STENCIL_ATTACHMENT)
/// is a special case causing both the depth and stencil attachments of the
/// specified framebuffer object to be set to `renderbuffer`, which should
/// have the base internal format [`GL_DEPTH_STENCIL`](crate::enums::GL_DEPTH_STENCIL).
///
/// The value of [`GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE)
/// for the specified attachment point is set to [`GL_RENDERBUFFER`](crate::enums::GL_RENDERBUFFER)
/// and the value of [`GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME)
/// is set to `renderbuffer`. All other state values of specified attachment
/// point are set to their default values. No change is made to the state of
/// the renderbuuffer object and any previous attachment to the `attachment`
/// logical buffer of the specified framebuffer object is broken.
///
/// If `renderbuffer` is zero, these commands will detach the image, if any,
/// identified by the specified attachment point of the specified framebuffer
/// object. All state values of the attachment point are set to their default
/// values.
impl Context {
    pub fn oxidegl_framebuffer_renderbuffer(
        &mut self,
        target: FramebufferTarget,
        attachment: FramebufferAttachment,
        renderbuffertarget: GLenum,
        renderbuffer: GLuint,
    ) {
        panic!("command oxidegl_framebuffer_renderbuffer not yet implemented");
    }
    pub fn oxidegl_named_framebuffer_renderbuffer(
        &mut self,
        framebuffer: GLuint,
        attachment: FramebufferAttachment,
        renderbuffertarget: GLenum,
        renderbuffer: GLuint,
    ) {
        panic!("command oxidegl_named_framebuffer_renderbuffer not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the framebuffer is bound for all commands
/// > *except* [**glNamedFramebufferTexture**](crate::context::Context::oxidegl_named_framebuffer_texture).
///
/// `framebuffer`
///
/// > Specifies the name of the framebuffer object for [**glNamedFramebufferTexture**](crate::context::Context::oxidegl_named_framebuffer_texture).
///
/// `attachment`
///
/// > Specifies the attachment point of the framebuffer.
///
/// `textarget`
///
/// > For [**glFramebufferTexture1D**](crate::context::Context::oxidegl_framebuffer_texture1_d),
/// > [**glFramebufferTexture2D**](crate::context::Context::oxidegl_framebuffer_texture2_d)
/// > and [**glFramebufferTexture3D**](crate::context::Context::oxidegl_framebuffer_texture3_d),
/// > specifies what type of texture is expected in the `texture` parameter,
/// > or for cube map textures, which face is to be attached.
///
/// `texture`
///
/// > Specifies the name of an existing texture object to attach.
///
/// `level`
///
/// > Specifies the mipmap level of the texture object to attach.
///
/// ### Description
/// These commands attach a selected mipmap level or image of a texture object
/// as one of the logical buffers of the specified framebuffer object. Textures
/// cannot be attached to the default draw and read framebuffer, so they are
/// not valid targets of these commands.
///
/// For all commands *except* [**glNamedFramebufferTexture**](crate::context::Context::oxidegl_named_framebuffer_texture),
/// the framebuffer object is that bound to `target`, which must be [`GL_DRAW_FRAMEBUFFER`](crate::enums::GL_DRAW_FRAMEBUFFER),
/// [`GL_READ_FRAMEBUFFER`](crate::enums::GL_READ_FRAMEBUFFER), or [`GL_FRAMEBUFFER`](crate::enums::GL_FRAMEBUFFER).
/// [`GL_FRAMEBUFFER`](crate::enums::GL_FRAMEBUFFER) is equivalent to [`GL_DRAW_FRAMEBUFFER`](crate::enums::GL_DRAW_FRAMEBUFFER).
///
/// For [**glNamedFramebufferTexture**](crate::context::Context::oxidegl_named_framebuffer_texture),
/// `framebuffer` is the name of the framebuffer object.
///
/// `attachment` specifies the logical attachment of the framebuffer and must
/// be [`GL_COLOR_ATTACHMENT`](crate::enums::GL_COLOR_ATTACHMENT) *i*, [`GL_DEPTH_ATTACHMENT`](crate::enums::GL_DEPTH_ATTACHMENT),
/// [`GL_STENCIL_ATTACHMENT`](crate::enums::GL_STENCIL_ATTACHMENT) or [`GL_DEPTH_STENCIL_ATTACHMENT`](crate::enums::GL_DEPTH_STENCIL_ATTACHMENT).
/// *i* in [`GL_COLOR_ATTACHMENT`](crate::enums::GL_COLOR_ATTACHMENT) *i* may
/// range from zero to the value of [`GL_MAX_COLOR_ATTACHMENTS`](crate::enums::GL_MAX_COLOR_ATTACHMENTS)
/// minus one. Attaching a level of a texture to [`GL_DEPTH_STENCIL_ATTACHMENT`](crate::enums::GL_DEPTH_STENCIL_ATTACHMENT)
/// is equivalent to attaching that level to both the [`GL_DEPTH_ATTACHMENT`](crate::enums::GL_DEPTH_ATTACHMENT)
/// *and* the [`GL_STENCIL_ATTACHMENT`](crate::enums::GL_STENCIL_ATTACHMENT)
/// attachment points simultaneously.
///
/// For [**glFramebufferTexture1D**](crate::context::Context::oxidegl_framebuffer_texture1_d),
/// [**glFramebufferTexture2D**](crate::context::Context::oxidegl_framebuffer_texture2_d)
/// and [**glFramebufferTexture3D**](crate::context::Context::oxidegl_framebuffer_texture3_d),
/// `textarget` specifies what type of texture is named by `texture`, and for
/// cube map textures, specifies the face that is to be attached. If `texture`
/// is not zero, it must be the name of an existing texture object with effective
/// target `textarget` unless it is a cube map texture, in which case `textarget`
/// must be [`GL_TEXTURE_CUBE_MAP_POSITIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_X)
/// [`GL_TEXTURE_CUBE_MAP_NEGATIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_X),
/// [`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Y),
/// [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Y),
/// [`GL_TEXTURE_CUBE_MAP_POSITIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Z),
/// or [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Z).
///
/// If `texture` is non-zero, the specified `level` of the texture object named
/// `texture` is attached to the framebuffer attachment point named by `attachment`.
/// For [**glFramebufferTexture1D**](crate::context::Context::oxidegl_framebuffer_texture1_d),
/// [**glFramebufferTexture2D**](crate::context::Context::oxidegl_framebuffer_texture2_d),
/// and [**glFramebufferTexture3D**](crate::context::Context::oxidegl_framebuffer_texture3_d),
/// `texture` must be zero or the name of an existing texture with an effective
/// target of `textarget`, or `texture` must be the name of an existing cube-map
/// texture and `textarget` must be one of [`GL_TEXTURE_CUBE_MAP_POSITIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_X),
/// [`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Y),
/// [`GL_TEXTURE_CUBE_MAP_POSITIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Z),
/// [`GL_TEXTURE_CUBE_MAP_NEGATIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_X),
/// [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Y),
/// or [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Z).
///
/// If `textarget` is [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE),
/// [`GL_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE),
/// or [`GL_TEXTURE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE_ARRAY),
/// then `level` must be zero.
///
/// If `textarget` is [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D), then
/// `level` must be greater than or equal to zero and less than or equal to
/// $`log_2`$ of the value of [`GL_MAX_3D_TEXTURE_SIZE`](crate::enums::GL_MAX_3D_TEXTURE_SIZE).
///
/// If `textarget` is one of [`GL_TEXTURE_CUBE_MAP_POSITIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_X),
/// [`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Y),
/// [`GL_TEXTURE_CUBE_MAP_POSITIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Z),
/// [`GL_TEXTURE_CUBE_MAP_NEGATIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_X),
/// [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Y),
/// or [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Z),
/// then `level` must be greater than or equal to zero and less than or equal
/// to $`log_2`$ of the value of [`GL_MAX_CUBE_MAP_TEXTURE_SIZE`](crate::enums::GL_MAX_CUBE_MAP_TEXTURE_SIZE).
///
/// For all other values of `textarget`, `level` must be greater than or equal
/// to zero and less than or equal to $`log_2`$ of the value of [`GL_MAX_TEXTURE_SIZE`](crate::enums::GL_MAX_TEXTURE_SIZE).
///
/// `layer` specifies the layer of a 2-dimensional image within a 3-dimensional
/// texture.
///
/// For [**glFramebufferTexture1D**](crate::context::Context::oxidegl_framebuffer_texture1_d),
/// if `texture` is not zero, then `textarget` must be [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D).
/// For [**glFramebufferTexture2D**](crate::context::Context::oxidegl_framebuffer_texture2_d),
/// if `texture` is not zero, `textarget` must be one of [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D),
/// [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE), [`GL_TEXTURE_CUBE_MAP_POSITIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_X),
/// [`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Y),
/// [`GL_TEXTURE_CUBE_MAP_POSITIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Z),
/// [`GL_TEXTURE_CUBE_MAP_NEGATIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_X),
/// [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Y),
/// [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Z),
/// or [`GL_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE).
/// For [**glFramebufferTexture3D**](crate::context::Context::oxidegl_framebuffer_texture3_d),
/// if `texture` is not zero, then `textarget` must be [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D).
///
/// For [**glFramebufferTexture**](crate::context::Context::oxidegl_framebuffer_texture)
/// and [**glNamedFramebufferTexture**](crate::context::Context::oxidegl_named_framebuffer_texture),
/// if `texture` is the name of a three-dimensional, cube map array, cube
/// map, one- or two-dimensional array, or two-dimensional multisample array
/// texture, the specified texture level is an array of images, and the framebuffer
/// attachment is considered to be *layered*.
impl Context {
    pub fn oxidegl_framebuffer_texture1_d(
        &mut self,
        target: FramebufferTarget,
        attachment: FramebufferAttachment,
        textarget: TextureTarget,
        texture: GLuint,
        level: GLint,
    ) {
        panic!("command oxidegl_framebuffer_texture1_d not yet implemented");
    }
    pub fn oxidegl_framebuffer_texture2_d(
        &mut self,
        target: FramebufferTarget,
        attachment: FramebufferAttachment,
        textarget: TextureTarget,
        texture: GLuint,
        level: GLint,
    ) {
        panic!("command oxidegl_framebuffer_texture2_d not yet implemented");
    }
    pub fn oxidegl_framebuffer_texture3_d(
        &mut self,
        target: FramebufferTarget,
        attachment: FramebufferAttachment,
        textarget: TextureTarget,
        texture: GLuint,
        level: GLint,
        zoffset: GLint,
    ) {
        panic!("command oxidegl_framebuffer_texture3_d not yet implemented");
    }
    pub fn oxidegl_framebuffer_texture(
        &mut self,
        target: FramebufferTarget,
        attachment: FramebufferAttachment,
        texture: GLuint,
        level: GLint,
    ) {
        panic!("command oxidegl_framebuffer_texture not yet implemented");
    }
    pub fn oxidegl_named_framebuffer_texture(
        &mut self,
        framebuffer: GLuint,
        attachment: FramebufferAttachment,
        texture: GLuint,
        level: GLint,
    ) {
        panic!("command oxidegl_named_framebuffer_texture not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the framebuffer is bound for [**glFramebufferTextureLayer**](crate::context::Context::oxidegl_framebuffer_texture_layer).
///
/// `framebuffer`
///
/// > Specifies the name of the framebuffer object for [**glNamedFramebufferTextureLayer**](crate::context::Context::oxidegl_named_framebuffer_texture_layer).
///
/// `attachment`
///
/// > Specifies the attachment point of the framebuffer.
///
/// `texture`
///
/// > Specifies the name of an existing texture object to attach.
///
/// `level`
///
/// > Specifies the mipmap level of the texture object to attach.
///
/// `layer`
///
/// > Specifies the layer of the texture object to attach.
///
/// ### Description
/// [**glFramebufferTextureLayer**](crate::context::Context::oxidegl_framebuffer_texture_layer)
/// and [**glNamedFramebufferTextureLayer**](crate::context::Context::oxidegl_named_framebuffer_texture_layer)
/// attach a single layer of a three-dimensional or array texture object as
/// one of the logical buffers of the specified framebuffer object. Textures
/// cannot be attached to the default draw and read framebuffer, so they are
/// not valid targets of these commands.
///
/// For [**glFramebufferTextureLayer**](crate::context::Context::oxidegl_framebuffer_texture_layer),
/// the framebuffer object is that bound to `target`, which must be [`GL_DRAW_FRAMEBUFFER`](crate::enums::GL_DRAW_FRAMEBUFFER),
/// [`GL_READ_FRAMEBUFFER`](crate::enums::GL_READ_FRAMEBUFFER), or [`GL_FRAMEBUFFER`](crate::enums::GL_FRAMEBUFFER).
/// [`GL_FRAMEBUFFER`](crate::enums::GL_FRAMEBUFFER) is equivalent to [`GL_DRAW_FRAMEBUFFER`](crate::enums::GL_DRAW_FRAMEBUFFER).
///
/// For [**glNamedFramebufferTextureLayer**](crate::context::Context::oxidegl_named_framebuffer_texture_layer),
/// `framebuffer` is the name of the framebuffer object.
///
/// `attachment` specifies the logical attachment of the framebuffer and must
/// be [`GL_COLOR_ATTACHMENT`](crate::enums::GL_COLOR_ATTACHMENT) *i*, [`GL_DEPTH_ATTACHMENT`](crate::enums::GL_DEPTH_ATTACHMENT),
/// [`GL_STENCIL_ATTACHMENT`](crate::enums::GL_STENCIL_ATTACHMENT) or [`GL_DEPTH_STENCIL_ATTACHMENT`](crate::enums::GL_DEPTH_STENCIL_ATTACHMENT).
/// *i* in [`GL_COLOR_ATTACHMENT`](crate::enums::GL_COLOR_ATTACHMENT) *i* may
/// range from zero to the value of [`GL_MAX_COLOR_ATTACHMENTS`](crate::enums::GL_MAX_COLOR_ATTACHMENTS)
/// minus one. Attaching a level of a texture to [`GL_DEPTH_STENCIL_ATTACHMENT`](crate::enums::GL_DEPTH_STENCIL_ATTACHMENT)
/// is equivalent to attaching that level to both the [`GL_DEPTH_ATTACHMENT`](crate::enums::GL_DEPTH_ATTACHMENT)
/// *and* the [`GL_STENCIL_ATTACHMENT`](crate::enums::GL_STENCIL_ATTACHMENT)
/// attachment points simultaneously.
///
/// If `texture` is not zero, it must be the name of a three-dimensional, two-dimensional
/// multisample array, one- or two-dimensional array, or cube map array texture.
///
/// If `texture` is a three-dimensional texture, then `level` must be greater
/// than or equal to zero and less than or equal to $`log_2`$ of the value of
/// [`GL_MAX_3D_TEXTURE_SIZE`](crate::enums::GL_MAX_3D_TEXTURE_SIZE).
///
/// If `texture` is a two-dimensional array texture, then `level` must be greater
/// than or equal to zero and less than or equal to $`log_2`$ of the value of
/// [`GL_MAX_TEXTURE_SIZE`](crate::enums::GL_MAX_TEXTURE_SIZE).
///
/// For cube map textures, `layer` is translated into a cube map face according
/// to $$ face= k \bmod 6. $$ For cube map array textures, `layer` is translated
/// into an array layer and face according to $$ layer= \left\lfloor{ layer
/// \over 6} \right\rfloor$$ and $$ face= k \bmod 6. $$
impl Context {
    pub fn oxidegl_framebuffer_texture_layer(
        &mut self,
        target: FramebufferTarget,
        attachment: FramebufferAttachment,
        texture: GLuint,
        level: GLint,
        layer: GLint,
    ) {
        panic!("command oxidegl_framebuffer_texture_layer not yet implemented");
    }
    pub fn oxidegl_named_framebuffer_texture_layer(
        &mut self,
        framebuffer: GLuint,
        attachment: FramebufferAttachment,
        texture: GLuint,
        level: GLint,
        layer: GLint,
    ) {
        panic!("command oxidegl_named_framebuffer_texture_layer not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the texture object is bound for [**glGenerateMipmap**](crate::context::Context::oxidegl_generate_mipmap).
/// > Must be one of [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D), [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D),
/// > [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D), [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY),
/// > [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY), [`GL_TEXTURE_CUBE_MAP`](crate::enums::GL_TEXTURE_CUBE_MAP),
/// > or [`GL_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_CUBE_MAP_ARRAY).
///
/// `texture`
///
/// > Specifies the texture object name for [**glGenerateTextureMipmap**](crate::context::Context::oxidegl_generate_texture_mipmap).
///
/// ### Description
/// [**glGenerateMipmap**](crate::context::Context::oxidegl_generate_mipmap)
/// and [**glGenerateTextureMipmap**](crate::context::Context::oxidegl_generate_texture_mipmap)
/// generates mipmaps for the specified texture object. For [**glGenerateMipmap**](crate::context::Context::oxidegl_generate_mipmap),
/// the texture object that is bound to `target`. For [**glGenerateTextureMipmap**](crate::context::Context::oxidegl_generate_texture_mipmap),
/// `texture` is the name of the texture object.
///
/// For cube map and cube map array textures, the texture object must be cube
/// complete or cube array complete respectively.
///
/// Mipmap generation replaces texel image levels $level_{base}+ 1$ through
/// $q$ with images derived from the $level_{base}$ image, regardless of their
/// previous contents. All other mimap images, including the $level_{base}$
/// image, are left unchanged by this computation.
///
/// The internal formats of the derived mipmap images all match those of the
/// $level_{base}$ image. The contents of the derived images are computed by
/// repeated, filtered reduction of the $level_{base}$ image. For one- and
/// two-dimensional array and cube map array textures, each layer is filtered
/// independently.
///
/// ### Notes
/// Cube map array textures are accepted only if the GL version is 4.0 or higher.
impl Context {
    pub fn oxidegl_generate_mipmap(&mut self, target: TextureTarget) {
        panic!("command oxidegl_generate_mipmap not yet implemented");
    }
    pub fn oxidegl_generate_texture_mipmap(&mut self, texture: GLuint) {
        panic!("command oxidegl_generate_texture_mipmap not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the buffer object is bound for [**glGetBufferParameteriv**](crate::context::Context::oxidegl_get_buffer_parameteriv)
/// > and [**glGetBufferParameteri64v**](crate::context::Context::oxidegl_get_buffer_parameteri64v).
/// > Must be one of the buffer binding targets in the following table:
///
/// > | *Buffer Binding Target*                               | *Purpose*      |
/// > |-------------------------------------------------------|----------------|
/// > | [`GL_ARRAY_BUFFER`](crate::enums::GL_ARRAY_BUFFER)    | Vertex attributes |
/// > | [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER) | Atomic counter storage |
/// > | [`GL_COPY_READ_BUFFER`](crate::enums::GL_COPY_READ_BUFFER) | Buffer copy source |
/// > | [`GL_COPY_WRITE_BUFFER`](crate::enums::GL_COPY_WRITE_BUFFER) | Buffer copy destination |
/// > | [`GL_DISPATCH_INDIRECT_BUFFER`](crate::enums::GL_DISPATCH_INDIRECT_BUFFER) | Indirect compute dispatch commands |
/// > | [`GL_DRAW_INDIRECT_BUFFER`](crate::enums::GL_DRAW_INDIRECT_BUFFER) | Indirect command arguments |
/// > | [`GL_ELEMENT_ARRAY_BUFFER`](crate::enums::GL_ELEMENT_ARRAY_BUFFER) | Vertex array indices |
/// > | [`GL_PIXEL_PACK_BUFFER`](crate::enums::GL_PIXEL_PACK_BUFFER) | Pixel read target |
/// > | [`GL_PIXEL_UNPACK_BUFFER`](crate::enums::GL_PIXEL_UNPACK_BUFFER) | Texture data source |
/// > | [`GL_QUERY_BUFFER`](crate::enums::GL_QUERY_BUFFER)    | Query result buffer |
/// > | [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER) | Read-write storage for shaders |
/// > | [`GL_TEXTURE_BUFFER`](crate::enums::GL_TEXTURE_BUFFER) | Texture data buffer |
/// > | [`GL_TRANSFORM_FEEDBACK_BUFFER`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER) | Transform feedback buffer |
/// > | [`GL_UNIFORM_BUFFER`](crate::enums::GL_UNIFORM_BUFFER) | Uniform block storage |
///
/// `buffer`
///
/// > Specifies the name of the buffer object for [**glGetNamedBufferParameteriv**](crate::context::Context::oxidegl_get_named_buffer_parameteriv)
/// > and [**glGetNamedBufferParameteri64v**](crate::context::Context::oxidegl_get_named_buffer_parameteri64v).
///
/// `value`
///
/// > Specifies the name of the buffer object parameter to query.
///
/// `data`
///
/// > Returns the requested parameter.
///
/// ### Description
/// These functions return in `data` a selected parameter of the specified
/// buffer object.
///
/// `pname` names a specific buffer object parameter, as follows:
///
/// [`GL_BUFFER_ACCESS`](crate::enums::GL_BUFFER_ACCESS)
///
/// > `params` returns the access policy set while mapping the buffer object
/// > (the value of the `access` parameter enum passed to [**glMapBuffer**](crate::context::Context::oxidegl_map_buffer)
/// > ). If the buffer was mapped with [**glMapBufferRange**](crate::context::Context::oxidegl_map_buffer_range),
/// > the access policy is determined by translating the bits in that `access`
/// > parameter to one of the supported enums for [**glMapBuffer**](crate::context::Context::oxidegl_map_buffer)
/// > as described in the OpenGL Specification.
///
/// [`GL_BUFFER_ACCESS_FLAGS`](crate::enums::GL_BUFFER_ACCESS_FLAGS)
///
/// > `params` returns the access policy set while mapping the buffer object
/// > (the value of the `access` parameter bitfield passed to [**glMapBufferRange**](crate::context::Context::oxidegl_map_buffer_range)
/// > ). If the buffer was mapped with [**glMapBuffer**](crate::context::Context::oxidegl_map_buffer),
/// > the access policy is determined by translating the enums in that `access`
/// > parameter to the corresponding bits for [**glMapBufferRange**](crate::context::Context::oxidegl_map_buffer_range)
/// > as described in the OpenGL Specification. The initial value is zero.
///
/// [`GL_BUFFER_IMMUTABLE_STORAGE`](crate::enums::GL_BUFFER_IMMUTABLE_STORAGE)
///
/// > `params` returns a boolean flag indicating whether the buffer object is
/// > immutable. The initial value is [`GL_FALSE`](crate::enums::GL_FALSE).
///
/// [`GL_BUFFER_MAPPED`](crate::enums::GL_BUFFER_MAPPED)
///
/// > `params` returns a flag indicating whether the buffer object is currently
/// > mapped. The initial value is [`GL_FALSE`](crate::enums::GL_FALSE).
///
/// [`GL_BUFFER_MAP_LENGTH`](crate::enums::GL_BUFFER_MAP_LENGTH)
///
/// > `params` returns the length of the mapping into the buffer object established
/// > with [**glMapBuffer***](crate::context::Context::oxidegl_map_buffer*). The
/// > [**i64v**](crate::context::Context::oxidei64v) versions of these queries
/// > should be used for this parameter. The initial value is zero.
///
/// [`GL_BUFFER_MAP_OFFSET`](crate::enums::GL_BUFFER_MAP_OFFSET)
///
/// > `params` returns the offset of the mapping into the buffer object established
/// > with [**glMapBuffer***](crate::context::Context::oxidegl_map_buffer*). The
/// > [**i64v**](crate::context::Context::oxidei64v) versions of these queries
/// > should be used for this parameter. The initial value is zero.
///
/// [`GL_BUFFER_SIZE`](crate::enums::GL_BUFFER_SIZE)
///
/// > `params` returns the size of the buffer object, measured in bytes. The
/// > initial value is 0.
///
/// [`GL_BUFFER_STORAGE_FLAGS`](crate::enums::GL_BUFFER_STORAGE_FLAGS)
///
/// > `params` returns a bitfield indicating the storage flags for the buffer
/// > object. If the buffer object is immutable, the value returned will be that
/// > specified when the data store was established with [**glBufferStorage**](crate::context::Context::oxidegl_buffer_storage).
/// > If the data store was established with [**glBufferData**](crate::context::Context::oxidegl_buffer_data),
/// > the value will be [`GL_MAP_READ_BIT`](crate::enums::GL_MAP_READ_BIT) \|
/// > [`GL_MAP_WRITE_BIT`](crate::enums::GL_MAP_WRITE_BIT) \| [`GL_DYNAMIC_STORAGE_BIT`](crate::enums::GL_DYNAMIC_STORAGE_BIT)
/// > \| [`GL_MAP_WRITE_BIT`](crate::enums::GL_MAP_WRITE_BIT). The initial value
/// > is zero.
///
/// [`GL_BUFFER_USAGE`](crate::enums::GL_BUFFER_USAGE)
///
/// > `params` returns the buffer object's usage pattern. The initial value is
/// > [`GL_STATIC_DRAW`](crate::enums::GL_STATIC_DRAW).
///
/// ### Notes
/// If an error is generated, no change is made to the contents of `data`.
///
/// The [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER)
/// target is available only if the GL version is 4.2 or greater.
///
/// The [`GL_DISPATCH_INDIRECT_BUFFER`](crate::enums::GL_DISPATCH_INDIRECT_BUFFER)
/// and [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER)
/// targets are available only if the GL version is 4.3 or greater.
///
/// The [`GL_QUERY_BUFFER`](crate::enums::GL_QUERY_BUFFER) target is available
/// only if the GL version is 4.4 or greater.
impl Context {
    pub unsafe fn oxidegl_get_buffer_parameteriv(
        &mut self,
        target: BufferTarget,
        pname: BufferPName,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_buffer_parameteriv not yet implemented");
    }
    pub unsafe fn oxidegl_get_buffer_parameteri64v(
        &mut self,
        target: BufferTarget,
        pname: BufferPName,
        params: *mut GLint64,
    ) {
        panic!("command oxidegl_get_buffer_parameteri64v not yet implemented");
    }
    pub unsafe fn oxidegl_get_named_buffer_parameteriv(
        &mut self,
        buffer: GLuint,
        pname: BufferPName,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_named_buffer_parameteriv not yet implemented");
    }
    pub unsafe fn oxidegl_get_named_buffer_parameteri64v(
        &mut self,
        buffer: GLuint,
        pname: BufferPName,
        params: *mut GLint64,
    ) {
        panic!("command oxidegl_get_named_buffer_parameteri64v not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the buffer object is bound for [**glGetBufferPointerv**](crate::context::Context::oxidegl_get_buffer_pointerv),
/// > which must be one of the buffer binding targets in the following table:
///
/// > | *Buffer Binding Target*                               | *Purpose*      |
/// > |-------------------------------------------------------|----------------|
/// > | [`GL_ARRAY_BUFFER`](crate::enums::GL_ARRAY_BUFFER)    | Vertex attributes |
/// > | [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER) | Atomic counter storage |
/// > | [`GL_COPY_READ_BUFFER`](crate::enums::GL_COPY_READ_BUFFER) | Buffer copy source |
/// > | [`GL_COPY_WRITE_BUFFER`](crate::enums::GL_COPY_WRITE_BUFFER) | Buffer copy destination |
/// > | [`GL_DISPATCH_INDIRECT_BUFFER`](crate::enums::GL_DISPATCH_INDIRECT_BUFFER) | Indirect compute dispatch commands |
/// > | [`GL_DRAW_INDIRECT_BUFFER`](crate::enums::GL_DRAW_INDIRECT_BUFFER) | Indirect command arguments |
/// > | [`GL_ELEMENT_ARRAY_BUFFER`](crate::enums::GL_ELEMENT_ARRAY_BUFFER) | Vertex array indices |
/// > | [`GL_PIXEL_PACK_BUFFER`](crate::enums::GL_PIXEL_PACK_BUFFER) | Pixel read target |
/// > | [`GL_PIXEL_UNPACK_BUFFER`](crate::enums::GL_PIXEL_UNPACK_BUFFER) | Texture data source |
/// > | [`GL_QUERY_BUFFER`](crate::enums::GL_QUERY_BUFFER)    | Query result buffer |
/// > | [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER) | Read-write storage for shaders |
/// > | [`GL_TEXTURE_BUFFER`](crate::enums::GL_TEXTURE_BUFFER) | Texture data buffer |
/// > | [`GL_TRANSFORM_FEEDBACK_BUFFER`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER) | Transform feedback buffer |
/// > | [`GL_UNIFORM_BUFFER`](crate::enums::GL_UNIFORM_BUFFER) | Uniform block storage |
///
/// `buffer`
///
/// > Specifies the name of the buffer object for [**glGetNamedBufferPointerv**](crate::context::Context::oxidegl_get_named_buffer_pointerv).
///
/// `pname`
///
/// > Specifies the name of the pointer to be returned. Must be [`GL_BUFFER_MAP_POINTER`](crate::enums::GL_BUFFER_MAP_POINTER).
///
/// `params`
///
/// > Returns the pointer value specified by `pname`.
///
/// ### Description
/// [**glGetBufferPointerv**](crate::context::Context::oxidegl_get_buffer_pointerv)
/// and [**glGetNamedBufferPointerv**](crate::context::Context::oxidegl_get_named_buffer_pointerv)
/// return the buffer pointer `pname`, which must be [`GL_BUFFER_MAP_POINTER`](crate::enums::GL_BUFFER_MAP_POINTER).
/// The single buffer map pointer is returned in `params`. A [`NULL`](crate::enums::NULL)
/// pointer is returned if the buffer object's data store is not currently
/// mapped; or if the requesting context did not map the buffer object's data
/// store, and the implementation is unable to support mappings on multiple
/// clients.
///
/// ### Notes
/// If an error is generated, no change is made to the contents of `params`.
///
/// The initial value for the pointer is [`NULL`](crate::enums::NULL).
///
/// The [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER)
/// target is available only if the GL version is 4.2 or greater.
///
/// The [`GL_DISPATCH_INDIRECT_BUFFER`](crate::enums::GL_DISPATCH_INDIRECT_BUFFER)
/// and [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER)
/// targets are available only if the GL version is 4.3 or greater.
///
/// The [`GL_QUERY_BUFFER`](crate::enums::GL_QUERY_BUFFER) target is available
/// only if the GL version is 4.4 or greater.
impl Context {
    pub unsafe fn oxidegl_get_buffer_pointerv(
        &mut self,
        target: BufferTarget,
        pname: GLenum,
        params: *mut *mut GLvoid,
    ) {
        panic!("command oxidegl_get_buffer_pointerv not yet implemented");
    }
    pub unsafe fn oxidegl_get_named_buffer_pointerv(
        &mut self,
        buffer: GLuint,
        pname: GLenum,
        params: *mut *mut GLvoid,
    ) {
        panic!("command oxidegl_get_named_buffer_pointerv not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the buffer object is bound for [**glGetBufferSubData**](crate::context::Context::oxidegl_get_buffer_sub_data),
/// > which must be one of the buffer binding targets in the following table:
///
/// > | *Buffer Binding Target*                               | *Purpose*      |
/// > |-------------------------------------------------------|----------------|
/// > | [`GL_ARRAY_BUFFER`](crate::enums::GL_ARRAY_BUFFER)    | Vertex attributes |
/// > | [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER) | Atomic counter storage |
/// > | [`GL_COPY_READ_BUFFER`](crate::enums::GL_COPY_READ_BUFFER) | Buffer copy source |
/// > | [`GL_COPY_WRITE_BUFFER`](crate::enums::GL_COPY_WRITE_BUFFER) | Buffer copy destination |
/// > | [`GL_DISPATCH_INDIRECT_BUFFER`](crate::enums::GL_DISPATCH_INDIRECT_BUFFER) | Indirect compute dispatch commands |
/// > | [`GL_DRAW_INDIRECT_BUFFER`](crate::enums::GL_DRAW_INDIRECT_BUFFER) | Indirect command arguments |
/// > | [`GL_ELEMENT_ARRAY_BUFFER`](crate::enums::GL_ELEMENT_ARRAY_BUFFER) | Vertex array indices |
/// > | [`GL_PIXEL_PACK_BUFFER`](crate::enums::GL_PIXEL_PACK_BUFFER) | Pixel read target |
/// > | [`GL_PIXEL_UNPACK_BUFFER`](crate::enums::GL_PIXEL_UNPACK_BUFFER) | Texture data source |
/// > | [`GL_QUERY_BUFFER`](crate::enums::GL_QUERY_BUFFER)    | Query result buffer |
/// > | [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER) | Read-write storage for shaders |
/// > | [`GL_TEXTURE_BUFFER`](crate::enums::GL_TEXTURE_BUFFER) | Texture data buffer |
/// > | [`GL_TRANSFORM_FEEDBACK_BUFFER`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER) | Transform feedback buffer |
/// > | [`GL_UNIFORM_BUFFER`](crate::enums::GL_UNIFORM_BUFFER) | Uniform block storage |
///
/// `buffer`
///
/// > Specifies the name of the buffer object for [**glGetNamedBufferSubData**](crate::context::Context::oxidegl_get_named_buffer_sub_data).
///
/// `offset`
///
/// > Specifies the offset into the buffer object's data store from which data
/// > will be returned, measured in bytes.
///
/// `size`
///
/// > Specifies the size in bytes of the data store region being returned.
///
/// `data`
///
/// > Specifies a pointer to the location where buffer object data is returned.
///
/// ### Description
/// [**glGetBufferSubData**](crate::context::Context::oxidegl_get_buffer_sub_data)
/// and [**glGetNamedBufferSubData**](crate::context::Context::oxidegl_get_named_buffer_sub_data)
/// return some or all of the data contents of the data store of the specified
/// buffer object. Data starting at byte offset `offset` and extending for
/// `size` bytes is copied from the buffer object's data store to the memory
/// pointed to by `data`. An error is thrown if the buffer object is currently
/// mapped, or if `offset` and `size` together define a range beyond the bounds
/// of the buffer object's data store.
///
/// ### Notes
/// If an error is generated, no change is made to the contents of `data`.
///
/// The [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER)
/// target is available only if the GL version is 4.2 or greater.
///
/// The [`GL_DISPATCH_INDIRECT_BUFFER`](crate::enums::GL_DISPATCH_INDIRECT_BUFFER)
/// and [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER)
/// targets are available only if the GL version is 4.3 or greater.
///
/// The [`GL_QUERY_BUFFER`](crate::enums::GL_QUERY_BUFFER) target is available
/// only if the GL version is 4.4 or greater.
impl Context {
    pub unsafe fn oxidegl_get_buffer_sub_data(
        &mut self,
        target: BufferTarget,
        offset: GLintptr,
        size: GLsizeiptr,
        data: *mut GLvoid,
    ) {
        panic!("command oxidegl_get_buffer_sub_data not yet implemented");
    }
    pub unsafe fn oxidegl_get_named_buffer_sub_data(
        &mut self,
        buffer: GLuint,
        offset: GLintptr,
        size: GLsizeiptr,
        data: *mut GLvoid,
    ) {
        panic!("command oxidegl_get_named_buffer_sub_data not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the texture is bound for [**glGetCompressedTexImage**](crate::context::Context::oxidegl_get_compressed_tex_image)
/// > and [**glGetnCompressedTexImage**](crate::context::Context::oxidegl_getn_compressed_tex_image)
/// > functions. [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D), [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY),
/// > [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D), [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY),
/// > [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D), [`GL_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_CUBE_MAP_ARRAY),
/// > [`GL_TEXTURE_CUBE_MAP_POSITIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_X),
/// > [`GL_TEXTURE_CUBE_MAP_NEGATIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_X),
/// > [`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Y),
/// > [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Y),
/// > [`GL_TEXTURE_CUBE_MAP_POSITIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Z),
/// > and [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Z),
/// > [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE) are accepted.
///
/// `texture`
///
/// > Specifies the texture object name for [**glGetCompressedTextureImage**](crate::context::Context::oxidegl_get_compressed_texture_image)
/// > function.
///
/// `level`
///
/// > Specifies the level-of-detail number of the desired image. Level 0 is the
/// > base image level. Level $n$ is the $n$-th mipmap reduction image.
///
/// `bufSize`
///
/// > Specifies the size of the buffer `pixels` for [**glGetCompressedTextureImage**](crate::context::Context::oxidegl_get_compressed_texture_image)
/// > and [**glGetnCompressedTexImage**](crate::context::Context::oxidegl_getn_compressed_tex_image)
/// > functions.
///
/// `pixels`
///
/// > Returns the compressed texture image.
///
/// ### Description
/// [**glGetCompressedTexImage**](crate::context::Context::oxidegl_get_compressed_tex_image)
/// and [**glGetnCompressedTexImage**](crate::context::Context::oxidegl_getn_compressed_tex_image)
/// return the compressed texture image associated with `target` and `lod`
/// into `pixels`. [**glGetCompressedTextureImage**](crate::context::Context::oxidegl_get_compressed_texture_image)
/// serves the same purpose, but instead of taking a texture target, it takes
/// the ID of the texture object. `pixels` should be an array of `bufSize`
/// bytes for [**glGetnCompresedTexImage**](crate::context::Context::oxidegl_getn_compresed_tex_image)
/// and [**glGetCompressedTextureImage**](crate::context::Context::oxidegl_get_compressed_texture_image)
/// functions, and of [`GL_TEXTURE_COMPRESSED_IMAGE_SIZE`](crate::enums::GL_TEXTURE_COMPRESSED_IMAGE_SIZE)
/// bytes in case of [**glGetCompressedTexImage**](crate::context::Context::oxidegl_get_compressed_tex_image).
/// If the actual data takes less space than `bufSize`, the remaining bytes
/// will not be touched. `target` specifies the texture target, to which the
/// texture the data the function should extract the data from is bound to.
/// `lod` specifies the level-of-detail number of the desired image.
///
/// If a non-zero named buffer object is bound to the [`GL_PIXEL_PACK_BUFFER`](crate::enums::GL_PIXEL_PACK_BUFFER)
/// target (see [**glBindBuffer**](crate::context::Context::oxidegl_bind_buffer))
/// while a texture image is requested, `pixels` is treated as a byte offset
/// into the buffer object's data store.
///
/// To minimize errors, first verify that the texture is compressed by calling
/// [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter)
/// with argument [`GL_TEXTURE_COMPRESSED`](crate::enums::GL_TEXTURE_COMPRESSED).
/// If the texture is compressed, you can determine the amount of memory required
/// to store the compressed texture by calling [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter)
/// with argument [`GL_TEXTURE_COMPRESSED_IMAGE_SIZE`](crate::enums::GL_TEXTURE_COMPRESSED_IMAGE_SIZE).
/// Finally, retrieve the internal format of the texture by calling [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter)
/// with argument [`GL_TEXTURE_INTERNAL_FORMAT`](crate::enums::GL_TEXTURE_INTERNAL_FORMAT).
/// To store the texture for later use, associate the internal format and
/// size with the retrieved texture image. These data can be used by the respective
/// texture or subtexture loading routine used for loading `target` textures.
///
/// ### Associated Gets
/// [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter)
/// with argument [`GL_TEXTURE_COMPRESSED`](crate::enums::GL_TEXTURE_COMPRESSED)
///
/// [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter)
/// with argument [`GL_TEXTURE_COMPRESSED_IMAGE_SIZE`](crate::enums::GL_TEXTURE_COMPRESSED_IMAGE_SIZE)
///
/// [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter)
/// with argument [`GL_TEXTURE_INTERNAL_FORMAT`](crate::enums::GL_TEXTURE_INTERNAL_FORMAT)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_PIXEL_PACK_BUFFER_BINDING`](crate::enums::GL_PIXEL_PACK_BUFFER_BINDING)
impl Context {
    pub unsafe fn oxidegl_get_compressed_tex_image(
        &mut self,
        target: TextureTarget,
        level: GLint,
        img: *mut GLvoid,
    ) {
        panic!("command oxidegl_get_compressed_tex_image not yet implemented");
    }
    pub unsafe fn oxidegl_get_compressed_texture_image(
        &mut self,
        texture: GLuint,
        level: GLint,
        buf_size: GLsizei,
        pixels: *mut GLvoid,
    ) {
        panic!("command oxidegl_get_compressed_texture_image not yet implemented");
    }
    pub unsafe fn oxidegl_getn_compressed_tex_image(
        &mut self,
        target: TextureTarget,
        lod: GLint,
        buf_size: GLsizei,
        pixels: *mut GLvoid,
    ) {
        panic!("command oxidegl_getn_compressed_tex_image not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the framebuffer object is bound for [**glGetFramebufferAttachmentParameteriv**](crate::context::Context::oxidegl_get_framebuffer_attachment_parameteriv).
///
/// `framebuffer`
///
/// > Specifies the name of the framebuffer object for [**glGetNamedFramebufferAttachmentParameteriv**](crate::context::Context::oxidegl_get_named_framebuffer_attachment_parameteriv).
///
/// `attachment`
///
/// > Specifies the attachment of the framebuffer object to query.
///
/// `pname`
///
/// > Specifies the parameter of `attachment` to query.
///
/// `params`
///
/// > Returns the value of parameter `pname` for `attachment`.
///
/// ### Description
/// [**glGetFramebufferAttachmentParameteriv**](crate::context::Context::oxidegl_get_framebuffer_attachment_parameteriv)
/// and [**glGetNamedFramebufferAttachmentParameteriv**](crate::context::Context::oxidegl_get_named_framebuffer_attachment_parameteriv)
/// return parameters of attachments of a specified framebuffer object.
///
/// For [**glGetFramebufferAttachmentParameteriv**](crate::context::Context::oxidegl_get_framebuffer_attachment_parameteriv),
/// the framebuffer object is that bound to `target`, which must be one of
/// [`GL_DRAW_FRAMEBUFFER`](crate::enums::GL_DRAW_FRAMEBUFFER), [`GL_READ_FRAMEBUFFER`](crate::enums::GL_READ_FRAMEBUFFER)
/// or [`GL_FRAMEBUFFER`](crate::enums::GL_FRAMEBUFFER). [`GL_FRAMEBUFFER`](crate::enums::GL_FRAMEBUFFER)
/// is equivalent to [`GL_DRAW_FRAMEBUFFER`](crate::enums::GL_DRAW_FRAMEBUFFER).
/// Buffers of default framebuffers may also be queried if bound to `target`.
///
/// For [**glGetNamedFramebufferAttachmentParameteriv**](crate::context::Context::oxidegl_get_named_framebuffer_attachment_parameteriv),
/// `framebuffer` is the name of the framebuffer object. If `framebuffer` is
/// zero, the default draw framebuffer is queried.
///
/// If the specified framebuffer is a framebuffer object, `attachment` must
/// be one of [`GL_DEPTH_ATTACHMENT`](crate::enums::GL_DEPTH_ATTACHMENT), [`GL_STENCIL_ATTACHMENT`](crate::enums::GL_STENCIL_ATTACHMENT)
/// [`GL_DEPTH_STENCIL_ATTACHMENT`](crate::enums::GL_DEPTH_STENCIL_ATTACHMENT),
/// or [`GL_COLOR_ATTACHMENT`](crate::enums::GL_COLOR_ATTACHMENT) *i*, where
/// *i* is between zero and the value of [`GL_MAX_COLOR_ATTACHMENTS`](crate::enums::GL_MAX_COLOR_ATTACHMENTS)
/// minus one.
///
/// If the specified framebuffer is a default framebuffer, `target`, `attachment`
/// must be one of [`GL_FRONT_LEFT`](crate::enums::GL_FRONT_LEFT), [`GL_FRONT_RIGHT`](crate::enums::GL_FRONT_RIGHT),
/// [`GL_BACK_LEFT`](crate::enums::GL_BACK_LEFT), [`GL_BACK_RIGHT`](crate::enums::GL_BACK_RIGHT),
/// [`GL_DEPTH`](crate::enums::GL_DEPTH) or [`GL_STENCIL`](crate::enums::GL_STENCIL),
/// identifying the corresponding buffer.
///
/// If `attachment` is [`GL_DEPTH_STENCIL_ATTACHMENT`](crate::enums::GL_DEPTH_STENCIL_ATTACHMENT),
/// the same object must be bound to both the depth and stencil attachment
/// points of the framebuffer object, and information about that object is
/// returned.
///
/// Upon successful return, if `pname` is [`GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE),
/// then `params` will contain one of [`GL_NONE`](crate::enums::GL_NONE), [`GL_FRAMEBUFFER_DEFAULT`](crate::enums::GL_FRAMEBUFFER_DEFAULT),
/// [`GL_TEXTURE`](crate::enums::GL_TEXTURE), or [`GL_RENDERBUFFER`](crate::enums::GL_RENDERBUFFER),
/// identifying the type of object which contains the attached image. Other
/// values accepted for `pname` depend on the type of object, as described
/// below.
///
/// If the value of [`GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE)
/// is [`GL_NONE`](crate::enums::GL_NONE), then either no framebuffer is bound
/// to `target`; or a default framebuffer is queried, `attachment` is [`GL_DEPTH`](crate::enums::GL_DEPTH)
/// or [`GL_STENCIL`](crate::enums::GL_STENCIL), and the number of depth or
/// stencil bits, respectively, is zero. In this case querying `pname` [`GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME)
/// will return zero, and all other queries will generate an error.
///
/// If the value of [`GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE)
/// is not [`GL_NONE`](crate::enums::GL_NONE), these queries apply to all other
/// framebuffer types:
///
/// > If `pname` is [`GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE),
/// > [`GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE),
/// > [`GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE),
/// > [`GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE),
/// > [`GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE)
/// > or [`GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE),
/// > then `params` will contain the number of bits in the corresponding red,
/// > green, blue, alpha, depth, or stencil component of the specified attachment.
/// > If the requested component is not present in the attachment, or if no data
/// > storage or texture image has been specified for the attachment, then `params`
/// > will contain zero.
///
/// > If `pname` is [`GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE),
/// > then `params` will contain the format of components of the specified attachment,
/// > one of [`GL_FLOAT`](crate::enums::GL_FLOAT), [`GL_INT`](crate::enums::GL_INT),
/// > [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT), [`GL_SIGNED_NORMALIZED`](crate::enums::GL_SIGNED_NORMALIZED),
/// > or [`GL_UNSIGNED_NORMALIZED`](crate::enums::GL_UNSIGNED_NORMALIZED) for
/// > floating-point, signed integer, unsigned integer, signed normalized fixed-point,
/// > or unsigned normalized fixed-point components respectively. Only color
/// > buffers may have integer components. If no data storage or texture image
/// > has been specified for the attachment, then `params` will contain [`GL_NONE`](crate::enums::GL_NONE).
/// > This query cannot be performed for a combined depth+stencil attachment,
/// > since it does not have a single format.
///
/// > If `pname` is [`GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING),
/// > then `params` will contain the encoding of components of the specified
/// > attachment, one of [`GL_LINEAR`](crate::enums::GL_LINEAR) or [`GL_SRGB`](crate::enums::GL_SRGB)
/// > for linear or sRGB-encoded components, respectively. Only color buffer
/// > components may be sRGB-encoded; such components are treated as described
/// > in the OpenGL Specification. For a default framebuffer, color encoding
/// > is determined by the implementation. For framebuffer objects, components
/// > are sRGB-encoded if the internal format of a color attachment is one of
/// > the color-renderable SRGB formats. If the attachment is not a color attachment,
/// > or if no data storage or texture image has been specified for the attachment,
/// > then `params` will contain [`GL_LINEAR`](crate::enums::GL_LINEAR).
///
/// If the value of [`GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE)
/// is [`GL_RENDERBUFFER`](crate::enums::GL_RENDERBUFFER), then
///
/// > If `pname` is [`GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME),
/// > `params` will contain the name of the renderbuffer object which contains
/// > the attached image.
///
/// If the value of [`GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE)
/// is [`GL_TEXTURE`](crate::enums::GL_TEXTURE), then
///
/// > If `pname` is [`GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME),
/// > then `params` will contain the name of the texture object which contains
/// > the attached image.
///
/// > If `pname` is [`GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL),
/// > then `params` will contain the mipmap level of the texture object which
/// > contains the attached image.
///
/// > If `pname` is [`GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE)
/// > and the value of [`GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME)
/// > is the name of a cube map texture object, then `params` will contain the
/// > cube map face of the cubemap texture object which contains the attached
/// > image. Otherwise `params` will contain zero.
///
/// > If `pname` is [`GL_FRAMEBUFFER_ATTACHMENT_LAYERED`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_LAYERED),
/// > then `params` will contain [`GL_TRUE`](crate::enums::GL_TRUE) if an entire
/// > level of a three-dimensional texture, cube map texture, or one-or two-dimensional
/// > array texture is attached. Otherwise, `params` will contain [`GL_FALSE`](crate::enums::GL_FALSE).
///
/// > If `pname` is [`GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER);
/// > the value of [`GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME)
/// > is the name of a three-dimensional, or a one- or two-dimensional array
/// > texture; and the value of [`GL_FRAMEBUFFER_ATTACHMENT_LAYERED`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_LAYERED)
/// > is [`GL_FALSE`](crate::enums::GL_FALSE), then `params` will contain the
/// > texture layer which contains the attached image. Otherwise `params` will
/// > contain zero.
///
/// ### Notes
/// The [`GL_FRAMEBUFFER_ATTACHMENT_LAYERED`](crate::enums::GL_FRAMEBUFFER_ATTACHMENT_LAYERED)
/// query is supported only if the GL version is 3.2 or greater.
impl Context {
    pub unsafe fn oxidegl_get_framebuffer_attachment_parameteriv(
        &mut self,
        target: FramebufferTarget,
        attachment: FramebufferAttachment,
        pname: FramebufferAttachmentParameterName,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_framebuffer_attachment_parameteriv not yet implemented");
    }
    pub unsafe fn oxidegl_get_named_framebuffer_attachment_parameteriv(
        &mut self,
        framebuffer: GLuint,
        attachment: FramebufferAttachment,
        pname: FramebufferAttachmentParameterName,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_named_framebuffer_attachment_parameteriv not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the framebuffer object is bound for [**glGetFramebufferParameteriv**](crate::context::Context::oxidegl_get_framebuffer_parameteriv).
///
/// `framebuffer`
///
/// > Specifies the name of the framebuffer object for [**glGetNamedFramebufferParameteriv**](crate::context::Context::oxidegl_get_named_framebuffer_parameteriv).
///
/// `pname`
///
/// > Specifies the parameter of the framebuffer object to query.
///
/// `params`
///
/// > Returns the value of parameter `pname` for the framebuffer object.
///
/// ### Description
/// [**glGetFramebufferParameteriv**](crate::context::Context::oxidegl_get_framebuffer_parameteriv)
/// and [**glGetNamedFramebufferParameteriv**](crate::context::Context::oxidegl_get_named_framebuffer_parameteriv)
/// query parameters of a specified framebuffer object.
///
/// For [**glGetFramebufferParameteriv**](crate::context::Context::oxidegl_get_framebuffer_parameteriv),
/// the framebuffer object is that bound to `target`, which must be one of
/// [`GL_DRAW_FRAMEBUFFER`](crate::enums::GL_DRAW_FRAMEBUFFER), [`GL_READ_FRAMEBUFFER`](crate::enums::GL_READ_FRAMEBUFFER)
/// or [`GL_FRAMEBUFFER`](crate::enums::GL_FRAMEBUFFER). [`GL_FRAMEBUFFER`](crate::enums::GL_FRAMEBUFFER)
/// is equivalent to [`GL_DRAW_FRAMEBUFFER`](crate::enums::GL_DRAW_FRAMEBUFFER).
/// Default framebuffers may also be queried if bound to `target`.
///
/// For [**glGetNamedFramebufferParameteriv**](crate::context::Context::oxidegl_get_named_framebuffer_parameteriv),
/// `framebuffer` is the name of the framebuffer object. If `framebuffer` is
/// zero, the default draw framebuffer is queried.
///
/// Upon successful return, `param` will contain the value of the framebuffer
/// parameter specified by `pname`, as described below.
///
/// The following parameters can only be queried for framebuffer objects:
///
/// [`GL_FRAMEBUFFER_DEFAULT_WIDTH`](crate::enums::GL_FRAMEBUFFER_DEFAULT_WIDTH)
///
/// > `params` returns the value of [`GL_FRAMEBUFFER_DEFAULT_WIDTH`](crate::enums::GL_FRAMEBUFFER_DEFAULT_WIDTH)
/// > for the framebuffer object.
///
/// [`GL_FRAMEBUFFER_DEFAULT_HEIGHT`](crate::enums::GL_FRAMEBUFFER_DEFAULT_HEIGHT)
///
/// > `params` returns the value of [`GL_FRAMEBUFFER_DEFAULT_HEIGHT`](crate::enums::GL_FRAMEBUFFER_DEFAULT_HEIGHT)
/// > for the framebuffer object.
///
/// [`GL_FRAMEBUFFER_DEFAULT_LAYERS`](crate::enums::GL_FRAMEBUFFER_DEFAULT_LAYERS)
///
/// > `params` returns the value of [`GL_FRAMEBUFFER_DEFAULT_LAYERS`](crate::enums::GL_FRAMEBUFFER_DEFAULT_LAYERS)
/// > for the framebuffer object.
///
/// [`GL_FRAMEBUFFER_DEFAULT_SAMPLES`](crate::enums::GL_FRAMEBUFFER_DEFAULT_SAMPLES)
///
/// > `params` returns the value of [`GL_FRAMEBUFFER_DEFAULT_SAMPLES`](crate::enums::GL_FRAMEBUFFER_DEFAULT_SAMPLES)
/// > for the framebuffer object.
///
/// [`GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS`](crate::enums::GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS)
///
/// > `params` returns the boolean value of [`GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS`](crate::enums::GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS).
///
/// The following parameters can be queried for both default framebuffers and
/// framebuffer objects:
///
/// [`GL_DOUBLEBUFFER`](crate::enums::GL_DOUBLEBUFFER)
///
/// > `param` returns a boolean value indicating whether double buffering is
/// > supported for the framebuffer object.
///
/// [`GL_IMPLEMENTATION_COLOR_READ_FORMAT`](crate::enums::GL_IMPLEMENTATION_COLOR_READ_FORMAT)
///
/// > `param` returns a GLenum value indicating the preferred pixel data format
/// > for the framebuffer object. See [**glReadPixels**](crate::context::Context::oxidegl_read_pixels).
///
/// [`GL_IMPLEMENTATION_COLOR_READ_TYPE`](crate::enums::GL_IMPLEMENTATION_COLOR_READ_TYPE)
///
/// > `param` returns a GLenum value indicating the implementation's preferred
/// > pixel data type for the framebuffer object. See [**glReadPixels**](crate::context::Context::oxidegl_read_pixels).
///
/// [`GL_SAMPLES`](crate::enums::GL_SAMPLES)
///
/// > `param` returns an integer value indicating the coverage mask size for
/// > the framebuffer object. See [**glSampleCoverage**](crate::context::Context::oxidegl_sample_coverage).
///
/// [`GL_SAMPLE_BUFFERS`](crate::enums::GL_SAMPLE_BUFFERS)
///
/// > `param` returns an integer value indicating the number of sample buffers
/// > associated with the framebuffer object. See [**glSampleCoverage**](crate::context::Context::oxidegl_sample_coverage).
///
/// [`GL_STEREO`](crate::enums::GL_STEREO)
///
/// > `param` returns a boolean value indicating whether stereo buffers (left
/// > and right) are supported for the framebuffer object.
///
/// ### Notes
/// Queries of default framebuffers are supported only if the GL version is
/// 4.5 or higher. Otherwise, an [`GL_INVALID_OPERATION`](crate::enums::GL_INVALID_OPERATION)
/// error is generated.
///
/// Queries of the framebuffer-dependent parameters [`GL_DOUBLEBUFFER`](crate::enums::GL_DOUBLEBUFFER),
/// [`GL_IMPLEMENTATION_COLOR_READ_FORMAT`](crate::enums::GL_IMPLEMENTATION_COLOR_READ_FORMAT),
/// [`GL_IMPLEMENTATION_COLOR_READ_TYPE`](crate::enums::GL_IMPLEMENTATION_COLOR_READ_TYPE),
/// [`GL_SAMPLES`](crate::enums::GL_SAMPLES), [`GL_SAMPLE_BUFFERS`](crate::enums::GL_SAMPLE_BUFFERS)
/// and [`GL_STEREO`](crate::enums::GL_STEREO) are supported only if the GL
/// version is 4.5 or higher.
///
/// The framebuffer-dependent state [`GL_SAMPLE_POSITION`](crate::enums::GL_SAMPLE_POSITION)
/// cannot be queried with these commands.
///
/// ### Associated Gets
/// [**glGetFramebufferAttachmentParameter**](crate::context::Context::oxidegl_get_framebuffer_attachment_parameter)
impl Context {
    pub unsafe fn oxidegl_get_framebuffer_parameteriv(
        &mut self,
        target: FramebufferTarget,
        pname: FramebufferAttachmentParameterName,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_framebuffer_parameteriv not yet implemented");
    }
    pub unsafe fn oxidegl_get_named_framebuffer_parameteriv(
        &mut self,
        framebuffer: GLuint,
        pname: GetFramebufferParameter,
        param: *mut GLint,
    ) {
        panic!("command oxidegl_get_named_framebuffer_parameteriv not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Indicates the usage of the internal format. `target` must be [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D),
/// > [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY), [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D),
/// > [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY), [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D),
/// > [`GL_TEXTURE_CUBE_MAP`](crate::enums::GL_TEXTURE_CUBE_MAP), [`GL_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_CUBE_MAP_ARRAY),
/// > [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE), [`GL_TEXTURE_BUFFER`](crate::enums::GL_TEXTURE_BUFFER),
/// > [`GL_RENDERBUFFER`](crate::enums::GL_RENDERBUFFER), [`GL_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE)
/// > or [`GL_TEXTURE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE_ARRAY).
///
/// `internalformat`
///
/// > Specifies the internal format about which to retrieve information.
///
/// `pname`
///
/// > Specifies the type of information to query.
///
/// `bufSize`
///
/// > Specifies the maximum number of integers of the specified width that may
/// > be written to `params` by the function.
///
/// `params`
///
/// > Specifies the address of a variable into which to write the retrieved information.
///
/// ### Description
/// [**glGetInternalformativ**](crate::context::Context::oxidegl_get_internalformativ)
/// and [**glGetInternalformati64v**](crate::context::Context::oxidegl_get_internalformati64v)
/// retrieve information about implementation-dependent support for internal
/// formats. `target` indicates the target with which the internal format will
/// be used and must be one of [`GL_RENDERBUFFER`](crate::enums::GL_RENDERBUFFER),
/// [`GL_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE),
/// or [`GL_TEXTURE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE_ARRAY),
/// corresponding to usage as a renderbuffer, two-dimensional multisample
/// texture or two-dimensional multisample array texture, respectively.
///
/// `internalformat` specifies the internal format about which to retrieve
/// information and must be a color-renderable, depth-renderable or stencil-renderable
/// format.
///
/// The information retrieved will be written to memory addressed by the pointer
/// specified in `params`. No more than `bufSize` integers will be written
/// to this memory.
///
/// If `pname` is [`GL_NUM_SAMPLE_COUNTS`](crate::enums::GL_NUM_SAMPLE_COUNTS),
/// the number of sample counts that would be returned by querying [`GL_SAMPLES`](crate::enums::GL_SAMPLES)
/// will be returned in `params`.
///
/// If `pname` is [`GL_SAMPLES`](crate::enums::GL_SAMPLES), the sample counts
/// supported for `internalformat` and `target` are written into `params` in
/// descending numeric order. Only positive values are returned. Querying [`GL_SAMPLES`](crate::enums::GL_SAMPLES)
/// with `bufSize` of one will return just the maximum supported number of
/// samples for this format. The maximum value in [`GL_SAMPLES`](crate::enums::GL_SAMPLES)
/// is guaranteed to be at least the lowest of the following: The value of
/// > [`GL_MAX_INTEGER_SAMPLES`](crate::enums::GL_MAX_INTEGER_SAMPLES) if `internalformat`
/// > is a signed or unsigned integer format.
///
/// > The value of [`GL_MAX_DEPTH_TEXTURE_SAMPLES`](crate::enums::GL_MAX_DEPTH_TEXTURE_SAMPLES)
/// > if `internalformat` is a depth- or stencil-renderable format and `target`
/// > is [`GL_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE),
/// > [`GL_TEXTURE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE_ARRAY).
///
/// > The value of [`GL_MAX_COLOR_TEXTURE_SAMPLES`](crate::enums::GL_MAX_COLOR_TEXTURE_SAMPLES)
/// > if `internalformat` is a color-renderable format and `target` is [`GL_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE)
/// > or [`GL_TEXTURE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE_ARRAY).
///
/// > The value of [`GL_MAX_SAMPLES`](crate::enums::GL_MAX_SAMPLES).
///
///
/// If `pname` is [`GL_INTERNALFORMAT_SUPPORTED`](crate::enums::GL_INTERNALFORMAT_SUPPORTED),
/// `params` is set to [`GL_TRUE`](crate::enums::GL_TRUE) if `internalformat`
/// is a supported internal format for `target` and to [`GL_FALSE`](crate::enums::GL_FALSE)
/// otherwise.
///
/// If `pname` is [`GL_INTERNALFORMAT_PREFERRED`](crate::enums::GL_INTERNALFORMAT_PREFERRED),
/// `params` is set to [`GL_TRUE`](crate::enums::GL_TRUE) if `internalformat`
/// is an format for `target` that is preferred by the implementation and to
/// [`GL_FALSE`](crate::enums::GL_FALSE) otherwise.
///
/// If `pname` is [`GL_INTERNALFORMAT_RED_SIZE`](crate::enums::GL_INTERNALFORMAT_RED_SIZE),
/// [`GL_INTERNALFORMAT_GREEN_SIZE`](crate::enums::GL_INTERNALFORMAT_GREEN_SIZE),
/// [`GL_INTERNALFORMAT_BLUE_SIZE`](crate::enums::GL_INTERNALFORMAT_BLUE_SIZE),
/// [`GL_INTERNALFORMAT_ALPHA_SIZE`](crate::enums::GL_INTERNALFORMAT_ALPHA_SIZE),
/// [`GL_INTERNALFORMAT_DEPTH_SIZE`](crate::enums::GL_INTERNALFORMAT_DEPTH_SIZE),
/// [`GL_INTERNALFORMAT_STENCIL_SIZE`](crate::enums::GL_INTERNALFORMAT_STENCIL_SIZE),
/// or [`GL_INTERNALFORMAT_SHARED_SIZE`](crate::enums::GL_INTERNALFORMAT_SHARED_SIZE)
/// then `params` is set to the actual resolutions that would be used for storing
/// image array components for the resource for the red, green, blue, alpha,
/// depth, stencil and shared channels respectively. If `internalformat` is
/// a compressed internal format, then `params` is set to the component resolution
/// of an uncompressed internal format that produces an image of roughly the
/// same quality as the compressed algorithm. If the internal format is unsupported,
/// or if a particular component is not present in the format, 0 is written
/// to `params`.
///
/// If `pname` is [`GL_INTERNALFORMAT_RED_TYPE`](crate::enums::GL_INTERNALFORMAT_RED_TYPE),
/// [`GL_INTERNALFORMAT_GREEN_TYPE`](crate::enums::GL_INTERNALFORMAT_GREEN_TYPE),
/// [`GL_INTERNALFORMAT_BLUE_TYPE`](crate::enums::GL_INTERNALFORMAT_BLUE_TYPE),
/// [`GL_INTERNALFORMAT_ALPHA_TYPE`](crate::enums::GL_INTERNALFORMAT_ALPHA_TYPE),
/// [`GL_INTERNALFORMAT_DEPTH_TYPE`](crate::enums::GL_INTERNALFORMAT_DEPTH_TYPE),
/// or [`GL_INTERNALFORMAT_STENCIL_TYPE`](crate::enums::GL_INTERNALFORMAT_STENCIL_TYPE)
/// then `params` is set to a token identifying the data type used to store
/// the respective component. If the `internalformat` represents a compressed
/// internal format then the types returned specify how components are interpreted
/// after decompression.
///
/// If `pname` is [`GL_MAX_WIDTH`](crate::enums::GL_MAX_WIDTH), [`GL_MAX_HEIGHT`](crate::enums::GL_MAX_HEIGHT),
/// [`GL_MAX_DEPTH`](crate::enums::GL_MAX_DEPTH), or [`GL_MAX_LAYERS`](crate::enums::GL_MAX_LAYERS)
/// then `pname` is filled with the maximum width, height, depth or layer count
/// for textures with internal format `internalformat`, respectively. If `pname`
/// is [`GL_MAX_COMBINED_DIMENSIONS`](crate::enums::GL_MAX_COMBINED_DIMENSIONS)
/// then `pname` is filled with the maximum combined dimensions of a texture
/// of the specified internal format.
///
/// If `pname` is [`GL_COLOR_COMPONENTS`](crate::enums::GL_COLOR_COMPONENTS)
/// then `params` is set to the value [`GL_TRUE`](crate::enums::GL_TRUE) if
/// the internal format contains any color component (i.e., red, green, blue
/// or alpha) and to [`GL_FALSE`](crate::enums::GL_FALSE) otherwise. If `pname`
/// is [`GL_DEPTH_COMPONENTS`](crate::enums::GL_DEPTH_COMPONENTS) or [`GL_STENCIL_COMPONENTS`](crate::enums::GL_STENCIL_COMPONENTS)
/// then `params` is set to [`GL_TRUE`](crate::enums::GL_TRUE) if the internal
/// format contains a depth or stencil component, respectively, and to [`GL_FALSE`](crate::enums::GL_FALSE)
/// otherwise.
///
/// If `pname` is [`GL_COLOR_RENDERABLE`](crate::enums::GL_COLOR_RENDERABLE),
/// [`GL_DEPTH_RENDERABLE`](crate::enums::GL_DEPTH_RENDERABLE) or [`GL_STENCIL_RENDERABLE`](crate::enums::GL_STENCIL_RENDERABLE)
/// then `params` is set to [`GL_TRUE`](crate::enums::GL_TRUE) if the specified
/// internal format is color, depth or stencil renderable, respectively, and
/// to [`GL_FALSE`](crate::enums::GL_FALSE) otherwise.
///
/// If `pname` is [`GL_FRAMEBUFFER_RENDERABLE`](crate::enums::GL_FRAMEBUFFER_RENDERABLE)
/// or [`GL_FRAMEBUFFER_RENDERABLE_LAYERED`](crate::enums::GL_FRAMEBUFFER_RENDERABLE_LAYERED)
/// then `params` is set to one of [`GL_FULL_SUPPORT`](crate::enums::GL_FULL_SUPPORT),
/// [`GL_CAVEAT_SUPPORT`](crate::enums::GL_CAVEAT_SUPPORT) or [`GL_NONE`](crate::enums::GL_NONE)
/// to indicate that framebuffer attachments (layered attachments in the case
/// of [`GL_FRAMEBUFFER_RENDERABLE_LAYERED`](crate::enums::GL_FRAMEBUFFER_RENDERABLE_LAYERED))
/// with that internal format are either renderable with no restrictions,
/// renderable with some restrictions or not renderable at all.
///
/// If `pname` is [`GL_FRAMEBUFFER_BLEND`](crate::enums::GL_FRAMEBUFFER_BLEND),
/// `params` is set to [`GL_TRUE`](crate::enums::GL_TRUE) to indicate that
/// the internal format is supported for blending operations when attached
/// to a framebuffer, and to [`GL_FALSE`](crate::enums::GL_FALSE) otherwise.
///
/// If `pname` is [`GL_READ_PIXELS`](crate::enums::GL_READ_PIXELS) then `params`
/// is set to [`GL_FULL_SUPPORT`](crate::enums::GL_FULL_SUPPORT), [`GL_CAVEAT_SUPPORT`](crate::enums::GL_CAVEAT_SUPPORT)
/// or [`GL_NONE`](crate::enums::GL_NONE) to that either full support, limited
/// support or no support at all is supplied for reading pixels from framebuffer
/// attachments in the specified internal format.
///
/// If `pname` is [`GL_READ_PIXELS_FORMAT`](crate::enums::GL_READ_PIXELS_FORMAT)
/// or [`GL_READ_PIXELS_TYPE`](crate::enums::GL_READ_PIXELS_TYPE) then `params`
/// is filled with the format or type, respectively, most recommended to obtain
/// the highest image quality and performance. For [`GL_READ_PIXELS_FORMAT`](crate::enums::GL_READ_PIXELS_FORMAT),
/// the value returned in `params` is a token that is accepted for the `format`
/// argument to [**glReadPixels**](crate::context::Context::oxidegl_read_pixels).
/// For [`GL_READ_PIXELS_TYPE`](crate::enums::GL_READ_PIXELS_TYPE), the value
/// returned in `params` is a token that is accepted for the `type` argument
/// to [**glReadPixels**](crate::context::Context::oxidegl_read_pixels).
///
/// If `pname` is [`GL_TEXTURE_IMAGE_FORMAT`](crate::enums::GL_TEXTURE_IMAGE_FORMAT)
/// or [`GL_TEXTURE_IMAGE_TYPE`](crate::enums::GL_TEXTURE_IMAGE_TYPE) then
/// `params` is filled with the implementation-recommended format or type to
/// be used in calls to [**glTexImage2D**](crate::context::Context::oxidegl_tex_image2_d)
/// and other similar functions. For [`GL_TEXTURE_IMAGE_FORMAT`](crate::enums::GL_TEXTURE_IMAGE_FORMAT),
/// `params` is filled with a token suitable for use as the `format` argument
/// to [**glTexImage2D**](crate::context::Context::oxidegl_tex_image2_d). For
/// [`GL_TEXTURE_IMAGE_TYPE`](crate::enums::GL_TEXTURE_IMAGE_TYPE), `params`
/// is filled with a token suitable for use as the `type` argument to [**glTexImage2D**](crate::context::Context::oxidegl_tex_image2_d).
///
/// If `pname` is [`GL_GET_TEXTURE_IMAGE_FORMAT`](crate::enums::GL_GET_TEXTURE_IMAGE_FORMAT)
/// or [`GL_GET_TEXTURE_IMAGE_TYPE`](crate::enums::GL_GET_TEXTURE_IMAGE_TYPE)
/// then `params` is filled with the implementation-recommended format or type
/// to be used in calls to [**glGetTexImage**](crate::context::Context::oxidegl_get_tex_image)
/// and other similar functions. For [`GL_GET_TEXTURE_IMAGE_FORMAT`](crate::enums::GL_GET_TEXTURE_IMAGE_FORMAT),
/// `params` is filled with a token suitable for use as the `format` argument
/// to [**glGetTexImage**](crate::context::Context::oxidegl_get_tex_image).
/// For [`GL_GET_TEXTURE_IMAGE_TYPE`](crate::enums::GL_GET_TEXTURE_IMAGE_TYPE),
/// `params` is filled with a token suitable for use as the `type` argument
/// to [**glGetTexImage**](crate::context::Context::oxidegl_get_tex_image).
///
/// If `pname` is [`GL_MIPMAP`](crate::enums::GL_MIPMAP) then `pname` is set
/// to [`GL_TRUE`](crate::enums::GL_TRUE) to indicate that the specified internal
/// format supports mipmaps and to [`GL_FALSE`](crate::enums::GL_FALSE) otherwise.
///
/// If `pname` is [`GL_GENERATE_MIPMAP`](crate::enums::GL_GENERATE_MIPMAP)
/// or [`GL_AUTO_GENERATE_MIPMAP`](crate::enums::GL_AUTO_GENERATE_MIPMAP) then
/// `params` is indicates the level of support for manual or automatic mipmap
/// generation for the specified internal format, respectively. Returned values
/// may be one of [`GL_FULL_SUPPORT`](crate::enums::GL_FULL_SUPPORT), [`GL_CAVEAT_SUPPORT`](crate::enums::GL_CAVEAT_SUPPORT)
/// and [`GL_NONE`](crate::enums::GL_NONE) to indicate either full support,
/// limited support or no support at all.
///
/// If `pname` is [`GL_COLOR_ENCODING`](crate::enums::GL_COLOR_ENCODING) then
/// the color encoding for the resource is returned in `params`. Possible values
/// for color buffers are [`GL_LINEAR`](crate::enums::GL_LINEAR) or [`GL_SRGB`](crate::enums::GL_SRGB),
/// for linear or sRGB-encoded color components, respectively. For non-color
/// formats (such as depth or stencil), or for unsupported resources, the value
/// [`GL_NONE`](crate::enums::GL_NONE) is returned.
///
/// If `pname` is [`GL_SRGB_READ`](crate::enums::GL_SRGB_READ), or [`GL_SRGB_WRITE`](crate::enums::GL_SRGB_WRITE)
/// then `params` indicates the level of support for reading and writing to
/// sRGB encoded images, respectively. For [`GL_SRGB_READ`](crate::enums::GL_SRGB_READ),
/// support for converting from sRGB colorspace on read operations is returned
/// in `params` and for [`GL_SRGB_WRITE`](crate::enums::GL_SRGB_WRITE), support
/// for converting to sRGB colorspace on write operations to the resource is
/// returned in `params`. `params` may be set to [`GL_FULL_SUPPORT`](crate::enums::GL_FULL_SUPPORT),
/// [`GL_CAVEAT_SUPPORT`](crate::enums::GL_CAVEAT_SUPPORT), or [`GL_NONE`](crate::enums::GL_NONE)
/// to indicate full support, limited support or no support at all, respecitively.
///
/// If `pname` is [`GL_FILTER`](crate::enums::GL_FILTER) the `params` is set
/// to either [`GL_TRUE`](crate::enums::GL_TRUE) or [`GL_FALSE`](crate::enums::GL_FALSE)
/// to indicate support or lack thereof for filter modes other than [`GL_NEAREST`](crate::enums::GL_NEAREST)
/// or [`GL_NEAREST_MIPMAP`](crate::enums::GL_NEAREST_MIPMAP) for the specified
/// internal format.
///
/// If `pname` is [`GL_VERTEX_TEXTURE`](crate::enums::GL_VERTEX_TEXTURE), [`GL_TESS_CONTROL_TEXTURE`](crate::enums::GL_TESS_CONTROL_TEXTURE),
/// [`GL_TESS_EVALUATION_TEXTURE`](crate::enums::GL_TESS_EVALUATION_TEXTURE),
/// [`GL_GEOMETRY_TEXTURE`](crate::enums::GL_GEOMETRY_TEXTURE), [`GL_FRAGMENT_TEXTURE`](crate::enums::GL_FRAGMENT_TEXTURE),
/// or [`GL_COMPUTE_TEXTURE`](crate::enums::GL_COMPUTE_TEXTURE), then the
/// value written to `params` indicates support for use of the resource as
/// a source of texturing in the vertex, tessellation control, tessellation
/// evaluation, geometry, fragment and compute shader stages, respectively.
/// `params` may be set to [`GL_FULL_SUPPORT`](crate::enums::GL_FULL_SUPPORT),
/// [`GL_CAVEAT_SUPPORT`](crate::enums::GL_CAVEAT_SUPPORT) or [`GL_NONE`](crate::enums::GL_NONE)
/// to indicate full support, limited support or no support at all, respectively.
///
/// If `pname` is [`GL_TEXTURE_SHADOW`](crate::enums::GL_TEXTURE_SHADOW), [`GL_TEXTURE_GATHER`](crate::enums::GL_TEXTURE_GATHER)
/// or [`GL_TEXTURE_GATHER_SHADOW`](crate::enums::GL_TEXTURE_GATHER_SHADOW)
/// then the value written to `params` indicates the level of support for using
/// the resource with a shadow sampler, in gather operations or as a shadow
/// sampler in gather operations, respectively. Returned values may be [`GL_FULL_SUPPORT`](crate::enums::GL_FULL_SUPPORT),
/// [`GL_CAVEAT_SUPPORT`](crate::enums::GL_CAVEAT_SUPPORT) or [`GL_NONE`](crate::enums::GL_NONE)
/// to indicate full support, limited support or no support at all, respectively.
///
/// If `pname` is [`GL_SHADER_IMAGE_LOAD`](crate::enums::GL_SHADER_IMAGE_LOAD),
/// [`GL_SHADER_IMAGE_STORE`](crate::enums::GL_SHADER_IMAGE_STORE) or [`GL_SHADER_IMAGE_ATOMIC`](crate::enums::GL_SHADER_IMAGE_ATOMIC)
/// then the value returned in `params` indicates the level of support for
/// image loads, stores and atomics for resources of the specified internal
/// format. Returned values may be [`GL_FULL_SUPPORT`](crate::enums::GL_FULL_SUPPORT),
/// [`GL_CAVEAT_SUPPORT`](crate::enums::GL_CAVEAT_SUPPORT) or [`GL_NONE`](crate::enums::GL_NONE)
/// to indicate full support, limited support or no support at all, respectively.
///
/// If `pname` is [`GL_IMAGE_TEXEL_SIZE`](crate::enums::GL_IMAGE_TEXEL_SIZE)
/// then the size of a texel when the resource when used as an image texture
/// is returned in `params`. If the resource is not supported for image textures
/// zero is returned.
///
/// If `pname` is [`GL_IMAGE_COMPATIBILITY_CLASS`](crate::enums::GL_IMAGE_COMPATIBILITY_CLASS)
/// then the compatibility class of the resource when used as an image texture
/// is returned in `params`. The possible values returned are [`GL_IMAGE_CLASS_4_X_32`](crate::enums::GL_IMAGE_CLASS_4_X_32),
/// [`GL_IMAGE_CLASS_2_X_32`](crate::enums::GL_IMAGE_CLASS_2_X_32), [`GL_IMAGE_CLASS_1_X_32`](crate::enums::GL_IMAGE_CLASS_1_X_32),
/// [`GL_IMAGE_CLASS_4_X_16`](crate::enums::GL_IMAGE_CLASS_4_X_16), [`GL_IMAGE_CLASS_2_X_16`](crate::enums::GL_IMAGE_CLASS_2_X_16),
/// [`GL_IMAGE_CLASS_1_X_16`](crate::enums::GL_IMAGE_CLASS_1_X_16), [`GL_IMAGE_CLASS_4_X_8`](crate::enums::GL_IMAGE_CLASS_4_X_8),
/// [`GL_IMAGE_CLASS_2_X_8`](crate::enums::GL_IMAGE_CLASS_2_X_8), [`GL_IMAGE_CLASS_1_X_8`](crate::enums::GL_IMAGE_CLASS_1_X_8),
/// [`GL_IMAGE_CLASS_11_11_10`](crate::enums::GL_IMAGE_CLASS_11_11_10), and
/// [`GL_IMAGE_CLASS_10_10_10_2`](crate::enums::GL_IMAGE_CLASS_10_10_10_2),
/// which correspond to the 4x32, 2x32, 1x32, 4x16, 2x16, 1x16, 4x8, 2x8,
/// 1x8, the class (a) 11/11/10 packed floating-point format, and the class
/// (b) 10/10/10/2 packed formats, respectively. If the resource is not supported
/// for image textures, [`GL_NONE`](crate::enums::GL_NONE) is returned.
///
/// If `pname` is [`GL_IMAGE_PIXEL_FORMAT`](crate::enums::GL_IMAGE_PIXEL_FORMAT)
/// or [`GL_IMAGE_PIXEL_TYPE`](crate::enums::GL_IMAGE_PIXEL_TYPE) then the
/// pixel format or type of the resource when used as an image texture is returned
/// in `params`, respectively. In either case, the resource is not supported
/// for image textures [`GL_NONE`](crate::enums::GL_NONE) is returned.
///
/// If `pname` is [`GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`](crate::enums::GL_IMAGE_FORMAT_COMPATIBILITY_TYPE),
/// the matching criteria use for the resource when used as an image textures
/// is returned in `params`. Possible values returned in `params` are [`GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE`](crate::enums::GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE)
/// or [`GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS`](crate::enums::GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS).
/// If the resource is not supported for image textures, [`GL_NONE`](crate::enums::GL_NONE)
/// is returned.
///
/// If `pname` is [`GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST`](crate::enums::GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST)
/// or [`GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST`](crate::enums::GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST),
/// support for using the resource both as a source for texture sampling while
/// it is bound as a buffer for depth or stencil test, respectively, is written
/// to `params`. Possible values returned are [`GL_FULL_SUPPORT`](crate::enums::GL_FULL_SUPPORT),
/// [`GL_CAVEAT_SUPPORT`](crate::enums::GL_CAVEAT_SUPPORT), or [`GL_NONE`](crate::enums::GL_NONE)
/// to indicate full support, limited support or no support at all. If the
/// resource or operation is not supported, [`GL_NONE`](crate::enums::GL_NONE)
/// is returned.
///
/// If `pname` is [`GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE`](crate::enums::GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE)
/// or [`GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE`](crate::enums::GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE),
/// support for using the resource both as a source for texture sampling while
/// performing depth or stencil writes to the resources, respectively, is written
/// to `params`. Possible values returned are [`GL_FULL_SUPPORT`](crate::enums::GL_FULL_SUPPORT),
/// [`GL_CAVEAT_SUPPORT`](crate::enums::GL_CAVEAT_SUPPORT), or [`GL_NONE`](crate::enums::GL_NONE)
/// to indicate full support, limited support or no support at all. If the
/// resource or operation is not supported, [`GL_NONE`](crate::enums::GL_NONE)
/// is returned.
///
/// If `pname` is [`GL_TEXTURE_COMPRESSED`](crate::enums::GL_TEXTURE_COMPRESSED)
/// then [`GL_TRUE`](crate::enums::GL_TRUE) is returned in `params` if `internalformat`
/// is a compressed internal format. [`GL_FALSE`](crate::enums::GL_FALSE) is
/// returned in `params` otherwise.
///
/// If `pname` is [`GL_TEXTURE_COMPRESSED_BLOCK_WIDTH`](crate::enums::GL_TEXTURE_COMPRESSED_BLOCK_WIDTH),
/// [`GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT`](crate::enums::GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT)
/// or [`GL_TEXTURE_COMPRESSED_BLOCK_SIZE`](crate::enums::GL_TEXTURE_COMPRESSED_BLOCK_SIZE)
/// then the width, height or total size, respectively of a block (in basic
/// machine units) is returned in `params`. If the internal format is not compressed,
/// or the resource is not supported, 0 is returned.
///
/// If `pname` is [`GL_CLEAR_BUFFER`](crate::enums::GL_CLEAR_BUFFER), the level
/// of support for using the resource with [**glClearBufferData**](crate::context::Context::oxidegl_clear_buffer_data)
/// and [**glClearBufferSubData**](crate::context::Context::oxidegl_clear_buffer_sub_data)
/// is returned in `params`. Possible values returned are [`GL_FULL_SUPPORT`](crate::enums::GL_FULL_SUPPORT),
/// [`GL_CAVEAT_SUPPORT`](crate::enums::GL_CAVEAT_SUPPORT), or [`GL_NONE`](crate::enums::GL_NONE)
/// to indicate full support, limited support or no support at all, respectively.
/// If the resource or operation is not supported, [`GL_NONE`](crate::enums::GL_NONE)
/// is returned.
///
/// If `pname` is [`GL_TEXTURE_VIEW`](crate::enums::GL_TEXTURE_VIEW), the level
/// of support for using the resource with the [**glTextureView**](crate::context::Context::oxidegl_texture_view)
/// command is returned in `params`. Possible values returned are [`GL_FULL_SUPPORT`](crate::enums::GL_FULL_SUPPORT),
/// [`GL_CAVEAT_SUPPORT`](crate::enums::GL_CAVEAT_SUPPORT), or [`GL_NONE`](crate::enums::GL_NONE)
/// to indicate full support, limited support or no support at all, respectively.
/// If the resource or operation is not supported, [`GL_NONE`](crate::enums::GL_NONE)
/// is returned.
///
/// If `pname` is [`GL_VIEW_COMPATIBILITY_CLASS`](crate::enums::GL_VIEW_COMPATIBILITY_CLASS)
/// then the compatibility class of the resource when used as a texture view
/// is returned in `params`. The possible values returned are [`GL_VIEW_CLASS_128_BITS`](crate::enums::GL_VIEW_CLASS_128_BITS),
/// [`GL_VIEW_CLASS_96_BITS`](crate::enums::GL_VIEW_CLASS_96_BITS), [`GL_VIEW_CLASS_64_BITS`](crate::enums::GL_VIEW_CLASS_64_BITS),
/// [`GL_VIEW_CLASS_48_BITS`](crate::enums::GL_VIEW_CLASS_48_BITS), [`GL_VIEW_CLASS_32_BITS`](crate::enums::GL_VIEW_CLASS_32_BITS),
/// [`GL_VIEW_CLASS_24_BITS`](crate::enums::GL_VIEW_CLASS_24_BITS), [`GL_VIEW_CLASS_16_BITS`](crate::enums::GL_VIEW_CLASS_16_BITS),
/// [`GL_VIEW_CLASS_8_BITS`](crate::enums::GL_VIEW_CLASS_8_BITS), [`GL_VIEW_CLASS_S3TC_DXT1_RGB`](crate::enums::GL_VIEW_CLASS_S3TC_DXT1_RGB),
/// [`GL_VIEW_CLASS_S3TC_DXT1_RGBA`](crate::enums::GL_VIEW_CLASS_S3TC_DXT1_RGBA),
/// [`GL_VIEW_CLASS_S3TC_DXT3_RGBA`](crate::enums::GL_VIEW_CLASS_S3TC_DXT3_RGBA),
/// [`GL_VIEW_CLASS_S3TC_DXT5_RGBA`](crate::enums::GL_VIEW_CLASS_S3TC_DXT5_RGBA),
/// [`GL_VIEW_CLASS_RGTC1_RED`](crate::enums::GL_VIEW_CLASS_RGTC1_RED), [`GL_VIEW_CLASS_RGTC2_RG`](crate::enums::GL_VIEW_CLASS_RGTC2_RG),
/// [`GL_VIEW_CLASS_BPTC_UNORM`](crate::enums::GL_VIEW_CLASS_BPTC_UNORM), and
/// [`GL_VIEW_CLASS_BPTC_FLOAT`](crate::enums::GL_VIEW_CLASS_BPTC_FLOAT).
///
/// If `pname` is [`GL_CLEAR_TEXTURE`](crate::enums::GL_CLEAR_TEXTURE) then
/// the presence of support for using the [**glClearTexImage**](crate::context::Context::oxidegl_clear_tex_image)
/// and [**glClearTexSubImage**](crate::context::Context::oxidegl_clear_tex_sub_image)
/// commands with the resource is written to `params`. Possible values written
/// are [`GL_FULL_SUPPORT`](crate::enums::GL_FULL_SUPPORT), [`GL_CAVEAT_SUPPORT`](crate::enums::GL_CAVEAT_SUPPORT),
/// or [`GL_NONE`](crate::enums::GL_NONE) to indicate full support, limited
/// support or no support at all, respectively. If the resource or operation
/// is not supported, [`GL_NONE`](crate::enums::GL_NONE) is returned.
///
/// ### Notes
/// [**glGetInternalformativ**](crate::context::Context::oxidegl_get_internalformativ)
/// is available only if the GL version is 4.2 or higher.
///
/// The tokens [`GL_INTERNALFORMAT_SUPPORTED`](crate::enums::GL_INTERNALFORMAT_SUPPORTED),
/// [`GL_INTERNALFORMAT_PREFERRED`](crate::enums::GL_INTERNALFORMAT_PREFERRED),
/// [`GL_INTERNALFORMAT_RED_SIZE`](crate::enums::GL_INTERNALFORMAT_RED_SIZE),
/// [`GL_INTERNALFORMAT_GREEN_SIZE`](crate::enums::GL_INTERNALFORMAT_GREEN_SIZE),
/// [`GL_INTERNALFORMAT_BLUE_SIZE`](crate::enums::GL_INTERNALFORMAT_BLUE_SIZE),
/// [`GL_INTERNALFORMAT_ALPHA_SIZE`](crate::enums::GL_INTERNALFORMAT_ALPHA_SIZE),
/// [`GL_INTERNALFORMAT_DEPTH_SIZE`](crate::enums::GL_INTERNALFORMAT_DEPTH_SIZE),
/// [`GL_INTERNALFORMAT_STENCIL_SIZE`](crate::enums::GL_INTERNALFORMAT_STENCIL_SIZE),
/// [`GL_INTERNALFORMAT_SHARED_SIZE`](crate::enums::GL_INTERNALFORMAT_SHARED_SIZE),
/// [`GL_INTERNALFORMAT_RED_TYPE`](crate::enums::GL_INTERNALFORMAT_RED_TYPE),
/// [`GL_INTERNALFORMAT_GREEN_TYPE`](crate::enums::GL_INTERNALFORMAT_GREEN_TYPE),
/// [`GL_INTERNALFORMAT_BLUE_TYPE`](crate::enums::GL_INTERNALFORMAT_BLUE_TYPE),
/// [`GL_INTERNALFORMAT_ALPHA_TYPE`](crate::enums::GL_INTERNALFORMAT_ALPHA_TYPE),
/// [`GL_INTERNALFORMAT_DEPTH_TYPE`](crate::enums::GL_INTERNALFORMAT_DEPTH_TYPE),
/// [`GL_INTERNALFORMAT_STENCIL_TYPE`](crate::enums::GL_INTERNALFORMAT_STENCIL_TYPE),
/// [`GL_MAX_WIDTH`](crate::enums::GL_MAX_WIDTH), [`GL_MAX_HEIGHT`](crate::enums::GL_MAX_HEIGHT),
/// [`GL_MAX_DEPTH`](crate::enums::GL_MAX_DEPTH), [`GL_MAX_LAYERS`](crate::enums::GL_MAX_LAYERS),
/// [`GL_MAX_COMBINED_DIMENSIONS`](crate::enums::GL_MAX_COMBINED_DIMENSIONS),
/// [`GL_COLOR_COMPONENTS`](crate::enums::GL_COLOR_COMPONENTS), [`GL_DEPTH_COMPONENTS`](crate::enums::GL_DEPTH_COMPONENTS),
/// [`GL_STENCIL_COMPONENTS`](crate::enums::GL_STENCIL_COMPONENTS), [`GL_COLOR_RENDERABLE`](crate::enums::GL_COLOR_RENDERABLE),
/// [`GL_DEPTH_RENDERABLE`](crate::enums::GL_DEPTH_RENDERABLE), [`GL_STENCIL_RENDERABLE`](crate::enums::GL_STENCIL_RENDERABLE),
/// [`GL_FRAMEBUFFER_RENDERABLE`](crate::enums::GL_FRAMEBUFFER_RENDERABLE),
/// [`GL_FRAMEBUFFER_RENDERABLE_LAYERED`](crate::enums::GL_FRAMEBUFFER_RENDERABLE_LAYERED),
/// [`GL_FRAMEBUFFER_BLEND`](crate::enums::GL_FRAMEBUFFER_BLEND), [`GL_READ_PIXELS`](crate::enums::GL_READ_PIXELS),
/// [`GL_READ_PIXELS_FORMAT`](crate::enums::GL_READ_PIXELS_FORMAT), [`GL_READ_PIXELS_TYPE`](crate::enums::GL_READ_PIXELS_TYPE),
/// [`GL_TEXTURE_IMAGE_FORMAT`](crate::enums::GL_TEXTURE_IMAGE_FORMAT), [`GL_TEXTURE_IMAGE_TYPE`](crate::enums::GL_TEXTURE_IMAGE_TYPE),
/// [`GL_GET_TEXTURE_IMAGE_FORMAT`](crate::enums::GL_GET_TEXTURE_IMAGE_FORMAT),
/// [`GL_GET_TEXTURE_IMAGE_TYPE`](crate::enums::GL_GET_TEXTURE_IMAGE_TYPE),
/// [`GL_MIPMAP`](crate::enums::GL_MIPMAP), [`GL_GENERATE_MIPMAP`](crate::enums::GL_GENERATE_MIPMAP),
/// [`GL_AUTO_GENERATE_MIPMAP`](crate::enums::GL_AUTO_GENERATE_MIPMAP), [`GL_COLOR_ENCODING`](crate::enums::GL_COLOR_ENCODING),
/// [`GL_SRGB_READ`](crate::enums::GL_SRGB_READ), [`GL_SRGB_WRITE`](crate::enums::GL_SRGB_WRITE),
/// [`GL_SRGB_DECODE_ARB`](crate::enums::GL_SRGB_DECODE_ARB), [`GL_FILTER`](crate::enums::GL_FILTER),
/// [`GL_VERTEX_TEXTURE`](crate::enums::GL_VERTEX_TEXTURE), [`GL_TESS_CONTROL_TEXTURE`](crate::enums::GL_TESS_CONTROL_TEXTURE),
/// [`GL_TESS_EVALUATION_TEXTURE`](crate::enums::GL_TESS_EVALUATION_TEXTURE),
/// [`GL_GEOMETRY_TEXTURE`](crate::enums::GL_GEOMETRY_TEXTURE), [`GL_FRAGMENT_TEXTURE`](crate::enums::GL_FRAGMENT_TEXTURE),
/// [`GL_COMPUTE_TEXTURE`](crate::enums::GL_COMPUTE_TEXTURE), [`GL_TEXTURE_SHADOW`](crate::enums::GL_TEXTURE_SHADOW),
/// [`GL_TEXTURE_GATHER`](crate::enums::GL_TEXTURE_GATHER), [`GL_TEXTURE_GATHER_SHADOW`](crate::enums::GL_TEXTURE_GATHER_SHADOW),
/// [`GL_SHADER_IMAGE_LOAD`](crate::enums::GL_SHADER_IMAGE_LOAD), [`GL_SHADER_IMAGE_STORE`](crate::enums::GL_SHADER_IMAGE_STORE),
/// [`GL_SHADER_IMAGE_ATOMIC`](crate::enums::GL_SHADER_IMAGE_ATOMIC), [`GL_IMAGE_TEXEL_SIZE`](crate::enums::GL_IMAGE_TEXEL_SIZE),
/// [`GL_IMAGE_COMPATIBILITY_CLASS`](crate::enums::GL_IMAGE_COMPATIBILITY_CLASS),
/// [`GL_IMAGE_PIXEL_FORMAT`](crate::enums::GL_IMAGE_PIXEL_FORMAT), [`GL_IMAGE_PIXEL_TYPE`](crate::enums::GL_IMAGE_PIXEL_TYPE),
/// [`GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`](crate::enums::GL_IMAGE_FORMAT_COMPATIBILITY_TYPE),
/// [`GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST`](crate::enums::GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST),
/// [`GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST`](crate::enums::GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST),
/// [`GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE`](crate::enums::GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE),
/// [`GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE`](crate::enums::GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE),
/// [`GL_TEXTURE_COMPRESSED`](crate::enums::GL_TEXTURE_COMPRESSED), [`GL_TEXTURE_COMPRESSED_BLOCK_WIDTH`](crate::enums::GL_TEXTURE_COMPRESSED_BLOCK_WIDTH),
/// [`GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT`](crate::enums::GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT),
/// [`GL_TEXTURE_COMPRESSED_BLOCK_SIZE`](crate::enums::GL_TEXTURE_COMPRESSED_BLOCK_SIZE),
/// [`GL_CLEAR_BUFFER`](crate::enums::GL_CLEAR_BUFFER), [`GL_TEXTURE_VIEW`](crate::enums::GL_TEXTURE_VIEW),
/// and [`GL_VIEW_COMPATIBILITY_CLASS`](crate::enums::GL_VIEW_COMPATIBILITY_CLASS)
/// are supported only if the GL version is 4.3 or higher.
///
/// The [`GL_CLEAR_TEXTURE`](crate::enums::GL_CLEAR_TEXTURE) token is accepted
/// for `pname` only if the GL version is 4.4 or higher.
impl Context {
    pub unsafe fn oxidegl_get_internalformativ(
        &mut self,
        target: TextureTarget,
        internalformat: InternalFormat,
        pname: InternalFormatPName,
        count: GLsizei,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_internalformativ not yet implemented");
    }
    pub unsafe fn oxidegl_get_internalformati64v(
        &mut self,
        target: TextureTarget,
        internalformat: InternalFormat,
        pname: InternalFormatPName,
        count: GLsizei,
        params: *mut GLint64,
    ) {
        panic!("command oxidegl_get_internalformati64v not yet implemented");
    }
}
/// ### Parameters
/// `id`
///
/// > Specifies the name of a query object.
///
/// `buffer`
///
/// > Specifies the name of a buffer object.
///
/// `pname`
///
/// > Specifies the symbolic name of a query object parameter. Accepted values
/// > are [`GL_QUERY_RESULT`](crate::enums::GL_QUERY_RESULT), [`GL_QUERY_RESULT_AVAILABLE`](crate::enums::GL_QUERY_RESULT_AVAILABLE),
/// > [`GL_QUERY_RESULT_NO_WAIT`](crate::enums::GL_QUERY_RESULT_NO_WAIT), or
/// > [`GL_QUERY_TARGET`](crate::enums::GL_QUERY_TARGET).
///
/// `params`
///
/// > If a buffer is bound to the [`GL_QUERY_RESULT_BUFFER`](crate::enums::GL_QUERY_RESULT_BUFFER)
/// > target, then `params` is treated as an offset to a location within that
/// > buffer's data store to receive the result of the query. If no buffer is
/// > bound to [`GL_QUERY_RESULT_BUFFER`](crate::enums::GL_QUERY_RESULT_BUFFER),
/// > then `params` is treated as an address in client memory of a variable
/// > to receive the resulting data.
///
/// `offset`
///
/// > Specifies the byte offset into `buffer` 's data store where the queried
/// > result will be written.
///
/// ### Description
/// These commands return a selected parameter of the query object specified
/// by `id`. [**glGetQueryObject**](crate::context::Context::oxidegl_get_query_object)
/// returns in `params` a selected parameter of the query object specified
/// by `id`. [**glGetQueryBufferObject**](crate::context::Context::oxidegl_get_query_buffer_object)
/// returns in `buffer` a selected parameter of the query object specified
/// by `id`, by writing it to `buffer` 's data store at the byte offset specified
/// by `offset`.
///
/// `pname` names a specific query object parameter. `pname` can be as follows:
///
/// [`GL_QUERY_RESULT`](crate::enums::GL_QUERY_RESULT)
///
/// > `params` or `buffer` returns the value of the query object's passed samples
/// > counter. The initial value is 0.
///
/// [`GL_QUERY_RESULT_NO_WAIT`](crate::enums::GL_QUERY_RESULT_NO_WAIT)
///
/// > If the result of the query is available (that is, a query of [`GL_QUERY_RESULT_AVAILABLE`](crate::enums::GL_QUERY_RESULT_AVAILABLE)
/// > would return non-zero), then `params` or `buffer` returns the value of
/// > the query object's passed samples counter, otherwise, the data referred
/// > to by `params` or `buffer` is not modified. The initial value is 0.
///
/// [`GL_QUERY_RESULT_AVAILABLE`](crate::enums::GL_QUERY_RESULT_AVAILABLE)
///
/// > `params` or `buffer` returns whether the passed samples counter is immediately
/// > available. If a delay would occur waiting for the query result, [`GL_FALSE`](crate::enums::GL_FALSE)
/// > is returned. Otherwise, [`GL_TRUE`](crate::enums::GL_TRUE) is returned,
/// > which also indicates that the results of all previous queries are available
/// > as well.
///
/// [`GL_QUERY_TARGET`](crate::enums::GL_QUERY_TARGET)
///
/// > `params` or `buffer` returns the query object's target.
///
/// ### Notes
/// If an error is generated, no change is made to the contents of `params`
/// or `buffer`.
///
/// [**glGetQueryObject**](crate::context::Context::oxidegl_get_query_object)
/// and [**glGetQueryBufferObject**](crate::context::Context::oxidegl_get_query_buffer_object)
/// implicitly flush the GL pipeline so that any incomplete rendering delimited
/// by the occlusion query completes in finite time.
///
/// If multiple queries are issued using the same query object `id` before
/// calling [**glGetQueryObject**](crate::context::Context::oxidegl_get_query_object)
/// or [**glGetQueryBufferObject**](crate::context::Context::oxidegl_get_query_buffer_object),
/// the results of the most recent query will be returned. In this case, when
/// issuing a new query, the results of the previous query are discarded.
///
/// [**glGetQueryObjecti64v**](crate::context::Context::oxidegl_get_query_objecti64v)
/// and [**glGetQueryObjectui64v**](crate::context::Context::oxidegl_get_query_objectui64v)
/// are available only if the GL version is 3.3 or greater.
///
/// [`GL_QUERY_RESULT_NO_WAIT`](crate::enums::GL_QUERY_RESULT_NO_WAIT) is accepted
/// for `pname` only if the GL version is 4.4 or greater.
///
/// The [`GL_QUERY_RESULT_BUFFER`](crate::enums::GL_QUERY_RESULT_BUFFER) target
/// is available only if the GL version is 4.4 or higher. On earlier versions
/// of the GL, `params` is always an address in client memory.
impl Context {
    pub unsafe fn oxidegl_get_query_objectiv(
        &mut self,
        id: GLuint,
        pname: QueryObjectParameterName,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_query_objectiv not yet implemented");
    }
    pub unsafe fn oxidegl_get_query_objectuiv(
        &mut self,
        id: GLuint,
        pname: QueryObjectParameterName,
        params: *mut GLuint,
    ) {
        panic!("command oxidegl_get_query_objectuiv not yet implemented");
    }
    pub unsafe fn oxidegl_get_query_objecti64v(
        &mut self,
        id: GLuint,
        pname: QueryObjectParameterName,
        params: *mut GLint64,
    ) {
        panic!("command oxidegl_get_query_objecti64v not yet implemented");
    }
    pub unsafe fn oxidegl_get_query_objectui64v(
        &mut self,
        id: GLuint,
        pname: QueryObjectParameterName,
        params: *mut GLuint64,
    ) {
        panic!("command oxidegl_get_query_objectui64v not yet implemented");
    }
    pub fn oxidegl_get_query_buffer_objecti64v(
        &mut self,
        id: GLuint,
        buffer: GLuint,
        pname: QueryObjectParameterName,
        offset: GLintptr,
    ) {
        panic!("command oxidegl_get_query_buffer_objecti64v not yet implemented");
    }
    pub fn oxidegl_get_query_buffer_objectiv(
        &mut self,
        id: GLuint,
        buffer: GLuint,
        pname: QueryObjectParameterName,
        offset: GLintptr,
    ) {
        panic!("command oxidegl_get_query_buffer_objectiv not yet implemented");
    }
    pub fn oxidegl_get_query_buffer_objectui64v(
        &mut self,
        id: GLuint,
        buffer: GLuint,
        pname: QueryObjectParameterName,
        offset: GLintptr,
    ) {
        panic!("command oxidegl_get_query_buffer_objectui64v not yet implemented");
    }
    pub fn oxidegl_get_query_buffer_objectuiv(
        &mut self,
        id: GLuint,
        buffer: GLuint,
        pname: QueryObjectParameterName,
        offset: GLintptr,
    ) {
        panic!("command oxidegl_get_query_buffer_objectuiv not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the renderbuffer object is bound for [**glGetRenderbufferParameteriv**](crate::context::Context::oxidegl_get_renderbuffer_parameteriv).
/// > `target` must be [`GL_RENDERBUFFER`](crate::enums::GL_RENDERBUFFER).
///
/// `renderbuffer`
///
/// > Specifies the name of the renderbuffer object for [**glGetNamedRenderbufferParameteriv**](crate::context::Context::oxidegl_get_named_renderbuffer_parameteriv).
///
/// `pname`
///
/// > Specifies the parameter of the renderbuffer object to query.
///
/// `params`
///
/// > Returns the value of parameter `pname` for the renderbuffer object.
///
/// ### Description
/// [**glGetRenderbufferParameteriv**](crate::context::Context::oxidegl_get_renderbuffer_parameteriv)
/// and [**glGetNamedRenderbufferParameteriv**](crate::context::Context::oxidegl_get_named_renderbuffer_parameteriv)
/// query parameters of a specified renderbuffer object.
///
/// For [**glGetRenderbufferParameteriv**](crate::context::Context::oxidegl_get_renderbuffer_parameteriv),
/// the renderbuffer object is that bound to `target`, which must be [`GL_RENDERBUFFER`](crate::enums::GL_RENDERBUFFER).
///
/// For [**glGetNamedRenderbufferParameteriv**](crate::context::Context::oxidegl_get_named_renderbuffer_parameteriv),
/// `renderbuffer` is the name of the renderbuffer object.
///
/// Upon successful return, `param` will contain the value of the renderbuffer
/// parameter specified by `pname`, as described below.
///
/// [`GL_RENDERBUFFER_WIDTH`](crate::enums::GL_RENDERBUFFER_WIDTH), [`GL_RENDERBUFFER_HEIGHT`](crate::enums::GL_RENDERBUFFER_HEIGHT),
/// [`GL_RENDERBUFFER_INTERNAL_FORMAT`](crate::enums::GL_RENDERBUFFER_INTERNAL_FORMAT)
/// or [`GL_RENDERBUFFER_SAMPLES`](crate::enums::GL_RENDERBUFFER_SAMPLES)
///
/// > `params` returns the width in pixels, the height in pixels, internal format,
/// > or the number of samples, respectively, of the image of the specified renderbuffer
/// > object.
///
/// [`GL_RENDERBUFFER_RED_SIZE`](crate::enums::GL_RENDERBUFFER_RED_SIZE), [`GL_RENDERBUFFER_GREEN_SIZE`](crate::enums::GL_RENDERBUFFER_GREEN_SIZE),
/// [`GL_RENDERBUFFER_BLUE_SIZE`](crate::enums::GL_RENDERBUFFER_BLUE_SIZE),
/// [`GL_RENDERBUFFER_ALPHA_SIZE`](crate::enums::GL_RENDERBUFFER_ALPHA_SIZE),
/// [`GL_RENDERBUFFER_DEPTH_SIZE`](crate::enums::GL_RENDERBUFFER_DEPTH_SIZE)
/// or [`GL_RENDERBUFFER_STENCIL_SIZE`](crate::enums::GL_RENDERBUFFER_STENCIL_SIZE)
///
/// > `params` returns the actual resolution in bits (not the resolution specified
/// > when the image was defined) for the red, green, blue, alpha, depth or stencil
/// > components, respectively, of the image of the renderbuffer object.
impl Context {
    pub unsafe fn oxidegl_get_renderbuffer_parameteriv(
        &mut self,
        target: GLenum,
        pname: RenderbufferParameterName,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_renderbuffer_parameteriv not yet implemented");
    }
    pub unsafe fn oxidegl_get_named_renderbuffer_parameteriv(
        &mut self,
        renderbuffer: GLuint,
        pname: RenderbufferParameterName,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_named_renderbuffer_parameteriv not yet implemented");
    }
}
/// ### Parameters
/// `sampler`
///
/// > Specifies name of the sampler object from which to retrieve parameters.
///
/// `pname`
///
/// > Specifies the symbolic name of a sampler parameter. [`GL_TEXTURE_MAG_FILTER`](crate::enums::GL_TEXTURE_MAG_FILTER),
/// > [`GL_TEXTURE_MIN_FILTER`](crate::enums::GL_TEXTURE_MIN_FILTER), [`GL_TEXTURE_MIN_LOD`](crate::enums::GL_TEXTURE_MIN_LOD),
/// > [`GL_TEXTURE_MAX_LOD`](crate::enums::GL_TEXTURE_MAX_LOD), [`GL_TEXTURE_LOD_BIAS`](crate::enums::GL_TEXTURE_LOD_BIAS),
/// > [`GL_TEXTURE_WRAP_S`](crate::enums::GL_TEXTURE_WRAP_S), [`GL_TEXTURE_WRAP_T`](crate::enums::GL_TEXTURE_WRAP_T),
/// > [`GL_TEXTURE_WRAP_R`](crate::enums::GL_TEXTURE_WRAP_R), [`GL_TEXTURE_BORDER_COLOR`](crate::enums::GL_TEXTURE_BORDER_COLOR),
/// > [`GL_TEXTURE_COMPARE_MODE`](crate::enums::GL_TEXTURE_COMPARE_MODE), and
/// > [`GL_TEXTURE_COMPARE_FUNC`](crate::enums::GL_TEXTURE_COMPARE_FUNC) are
/// > accepted.
///
/// `params`
///
/// > Returns the sampler parameters.
///
/// ### Description
/// [**glGetSamplerParameter**](crate::context::Context::oxidegl_get_sampler_parameter)
/// returns in `params` the value or values of the sampler parameter specified
/// as `pname`. `sampler` defines the target sampler, and must be the name
/// of an existing sampler object, returned from a previous call to [**glGenSamplers**](crate::context::Context::oxidegl_gen_samplers).
/// `pname` accepts the same symbols as [**glSamplerParameter**](crate::context::Context::oxidegl_sampler_parameter),
/// with the same interpretations:
///
/// [`GL_TEXTURE_MAG_FILTER`](crate::enums::GL_TEXTURE_MAG_FILTER)
///
/// > Returns the single-valued texture magnification filter, a symbolic constant.
/// > The initial value is [`GL_LINEAR`](crate::enums::GL_LINEAR).
///
/// [`GL_TEXTURE_MIN_FILTER`](crate::enums::GL_TEXTURE_MIN_FILTER)
///
/// > Returns the single-valued texture minification filter, a symbolic constant.
/// > The initial value is [`GL_NEAREST_MIPMAP_LINEAR`](crate::enums::GL_NEAREST_MIPMAP_LINEAR).
///
/// [`GL_TEXTURE_MIN_LOD`](crate::enums::GL_TEXTURE_MIN_LOD)
///
/// > Returns the single-valued texture minimum level-of-detail value. The initial
/// > value is `[inlineq]`
///
/// [`GL_TEXTURE_MAX_LOD`](crate::enums::GL_TEXTURE_MAX_LOD)
///
/// > Returns the single-valued texture maximum level-of-detail value. The initial
/// > value is 1000.
///
/// [`GL_TEXTURE_WRAP_S`](crate::enums::GL_TEXTURE_WRAP_S)
///
/// > Returns the single-valued wrapping function for texture coordinate `[inlineq]`
/// > [`GL_REPEAT`](crate::enums::GL_REPEAT).
///
/// [`GL_TEXTURE_WRAP_T`](crate::enums::GL_TEXTURE_WRAP_T)
///
/// > Returns the single-valued wrapping function for texture coordinate `[inlineq]`
/// > [`GL_REPEAT`](crate::enums::GL_REPEAT).
///
/// [`GL_TEXTURE_WRAP_R`](crate::enums::GL_TEXTURE_WRAP_R)
///
/// > Returns the single-valued wrapping function for texture coordinate `[inlineq]`
/// > [`GL_REPEAT`](crate::enums::GL_REPEAT).
///
/// [`GL_TEXTURE_BORDER_COLOR`](crate::enums::GL_TEXTURE_BORDER_COLOR)
///
/// > Returns four integer or floating-point numbers that comprise the RGBA color
/// > of the texture border. Floating-point values are returned in the range
/// > `[inlineq]` `[inlineq]`
///
/// [`GL_TEXTURE_COMPARE_MODE`](crate::enums::GL_TEXTURE_COMPARE_MODE)
///
/// > Returns a single-valued texture comparison mode, a symbolic constant. The
/// > initial value is [`GL_NONE`](crate::enums::GL_NONE). See [**glSamplerParameter**](crate::context::Context::oxidegl_sampler_parameter).
///
/// [`GL_TEXTURE_COMPARE_FUNC`](crate::enums::GL_TEXTURE_COMPARE_FUNC)
///
/// > Returns a single-valued texture comparison function, a symbolic constant.
/// > The initial value is [`GL_LEQUAL`](crate::enums::GL_LEQUAL). See [**glSamplerParameter**](crate::context::Context::oxidegl_sampler_parameter).
///
/// ### Notes
/// If an error is generated, no change is made to the contents of `params`.
///
/// [**glGetSamplerParameter**](crate::context::Context::oxidegl_get_sampler_parameter)
/// is available only if the GL version is 3.3 or higher.
impl Context {
    pub unsafe fn oxidegl_get_sampler_parameteriv(
        &mut self,
        sampler: GLuint,
        pname: SamplerParameterI,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_sampler_parameteriv not yet implemented");
    }
    pub unsafe fn oxidegl_get_sampler_parameter_iiv(
        &mut self,
        sampler: GLuint,
        pname: SamplerParameterI,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_sampler_parameter_iiv not yet implemented");
    }
    pub unsafe fn oxidegl_get_sampler_parameterfv(
        &mut self,
        sampler: GLuint,
        pname: SamplerParameterF,
        params: *mut GLfloat,
    ) {
        panic!("command oxidegl_get_sampler_parameterfv not yet implemented");
    }
    pub unsafe fn oxidegl_get_sampler_parameter_iuiv(
        &mut self,
        sampler: GLuint,
        pname: SamplerParameterI,
        params: *mut GLuint,
    ) {
        panic!("command oxidegl_get_sampler_parameter_iuiv not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the texture is bound for [**glGetTexImage**](crate::context::Context::oxidegl_get_tex_image)
/// > and [**glGetnTexImage**](crate::context::Context::oxidegl_getn_tex_image)
/// > functions. [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D), [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D),
/// > [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D), [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY),
/// > [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY), [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE),
/// > [`GL_TEXTURE_CUBE_MAP_POSITIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_X),
/// > [`GL_TEXTURE_CUBE_MAP_NEGATIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_X),
/// > [`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Y),
/// > [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Y),
/// > [`GL_TEXTURE_CUBE_MAP_POSITIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Z),
/// > [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Z),
/// > and [`GL_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_CUBE_MAP_ARRAY)
/// > are acceptable.
///
/// `texture`
///
/// > Specifies the texture object name.
///
/// `level`
///
/// > Specifies the level-of-detail number of the desired image. Level 0 is the
/// > base image level. Level `[inlineq]` `[inlineq]`
///
/// `format`
///
/// > Specifies a pixel format for the returned data. The supported formats are
/// > [`GL_STENCIL_INDEX`](crate::enums::GL_STENCIL_INDEX), [`GL_DEPTH_COMPONENT`](crate::enums::GL_DEPTH_COMPONENT),
/// > [`GL_DEPTH_STENCIL`](crate::enums::GL_DEPTH_STENCIL), [`GL_RED`](crate::enums::GL_RED),
/// > [`GL_GREEN`](crate::enums::GL_GREEN), [`GL_BLUE`](crate::enums::GL_BLUE),
/// > [`GL_RG`](crate::enums::GL_RG), [`GL_RGB`](crate::enums::GL_RGB), [`GL_RGBA`](crate::enums::GL_RGBA),
/// > [`GL_BGR`](crate::enums::GL_BGR), [`GL_BGRA`](crate::enums::GL_BGRA), [`GL_RED_INTEGER`](crate::enums::GL_RED_INTEGER),
/// > [`GL_GREEN_INTEGER`](crate::enums::GL_GREEN_INTEGER), [`GL_BLUE_INTEGER`](crate::enums::GL_BLUE_INTEGER),
/// > [`GL_RG_INTEGER`](crate::enums::GL_RG_INTEGER), [`GL_RGB_INTEGER`](crate::enums::GL_RGB_INTEGER),
/// > [`GL_RGBA_INTEGER`](crate::enums::GL_RGBA_INTEGER), [`GL_BGR_INTEGER`](crate::enums::GL_BGR_INTEGER),
/// > [`GL_BGRA_INTEGER`](crate::enums::GL_BGRA_INTEGER).
///
/// `type`
///
/// > Specifies a pixel type for the returned data. The supported types are [`GL_UNSIGNED_BYTE`](crate::enums::GL_UNSIGNED_BYTE),
/// > [`GL_BYTE`](crate::enums::GL_BYTE), [`GL_UNSIGNED_SHORT`](crate::enums::GL_UNSIGNED_SHORT),
/// > [`GL_SHORT`](crate::enums::GL_SHORT), [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT),
/// > [`GL_INT`](crate::enums::GL_INT), [`GL_HALF_FLOAT`](crate::enums::GL_HALF_FLOAT),
/// > [`GL_FLOAT`](crate::enums::GL_FLOAT), [`GL_UNSIGNED_BYTE_3_3_2`](crate::enums::GL_UNSIGNED_BYTE_3_3_2),
/// > [`GL_UNSIGNED_BYTE_2_3_3_REV`](crate::enums::GL_UNSIGNED_BYTE_2_3_3_REV),
/// > [`GL_UNSIGNED_SHORT_5_6_5`](crate::enums::GL_UNSIGNED_SHORT_5_6_5), [`GL_UNSIGNED_SHORT_5_6_5_REV`](crate::enums::GL_UNSIGNED_SHORT_5_6_5_REV),
/// > [`GL_UNSIGNED_SHORT_4_4_4_4`](crate::enums::GL_UNSIGNED_SHORT_4_4_4_4),
/// > [`GL_UNSIGNED_SHORT_4_4_4_4_REV`](crate::enums::GL_UNSIGNED_SHORT_4_4_4_4_REV),
/// > [`GL_UNSIGNED_SHORT_5_5_5_1`](crate::enums::GL_UNSIGNED_SHORT_5_5_5_1),
/// > [`GL_UNSIGNED_SHORT_1_5_5_5_REV`](crate::enums::GL_UNSIGNED_SHORT_1_5_5_5_REV),
/// > [`GL_UNSIGNED_INT_8_8_8_8`](crate::enums::GL_UNSIGNED_INT_8_8_8_8), [`GL_UNSIGNED_INT_8_8_8_8_REV`](crate::enums::GL_UNSIGNED_INT_8_8_8_8_REV),
/// > [`GL_UNSIGNED_INT_10_10_10_2`](crate::enums::GL_UNSIGNED_INT_10_10_10_2),
/// > [`GL_UNSIGNED_INT_2_10_10_10_REV`](crate::enums::GL_UNSIGNED_INT_2_10_10_10_REV),
/// > [`GL_UNSIGNED_INT_24_8`](crate::enums::GL_UNSIGNED_INT_24_8), [`GL_UNSIGNED_INT_10F_11F_11F_REV`](crate::enums::GL_UNSIGNED_INT_10F_11F_11F_REV),
/// > [`GL_UNSIGNED_INT_5_9_9_9_REV`](crate::enums::GL_UNSIGNED_INT_5_9_9_9_REV),
/// > and [`GL_FLOAT_32_UNSIGNED_INT_24_8_REV`](crate::enums::GL_FLOAT_32_UNSIGNED_INT_24_8_REV).
///
/// `bufSize`
///
/// > Specifies the size of the buffer `pixels` for [**glGetnTexImage**](crate::context::Context::oxidegl_getn_tex_image)
/// > and [**glGetTextureImage**](crate::context::Context::oxidegl_get_texture_image)
/// > functions.
///
/// `pixels`
///
/// > Returns the texture image. Should be a pointer to an array of the type
/// > specified by `type`.
///
/// ### Description
/// [**glGetTexImage**](crate::context::Context::oxidegl_get_tex_image), [**glGetnTexImage**](crate::context::Context::oxidegl_getn_tex_image)
/// and [**glGetTextureImage**](crate::context::Context::oxidegl_get_texture_image)
/// functions return a texture image into `pixels`. For [**glGetTexImage**](crate::context::Context::oxidegl_get_tex_image)
/// and [**glGetnTexImage**](crate::context::Context::oxidegl_getn_tex_image),
/// `target` specifies whether the desired texture image is one specified by
/// [**glTexImage1D**](crate::context::Context::oxidegl_tex_image1_d)( [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D)
/// ), [**glTexImage2D**](crate::context::Context::oxidegl_tex_image2_d)( [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY),
/// [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE), [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D)
/// or any of [`GL_TEXTURE_CUBE_MAP_*`](crate::enums::GL_TEXTURE_CUBE_MAP_*)
/// ), or [**glTexImage3D**](crate::context::Context::oxidegl_tex_image3_d)(
/// [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY), [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D),
/// [`GL_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_CUBE_MAP_ARRAY)
/// ). For [**glGetTextureImage**](crate::context::Context::oxidegl_get_texture_image),
/// `texture` specifies the texture object name. In addition to types of textures
/// accepted by [**glGetTexImage**](crate::context::Context::oxidegl_get_tex_image)
/// and [**glGetnTexImage**](crate::context::Context::oxidegl_getn_tex_image),
/// the function also accepts cube map texture objects (with effective target
/// [`GL_TEXTURE_CUBE_MAP`](crate::enums::GL_TEXTURE_CUBE_MAP) ). `level` specifies
/// the level-of-detail number of the desired image. `format` and `type` specify
/// the format and type of the desired image array. See the reference page
/// for [**glTexImage1D**](crate::context::Context::oxidegl_tex_image1_d) for
/// a description of the acceptable values for the `format` and `type` parameters,
/// respectively. For glGetnTexImage and glGetTextureImage functions, bufSize
/// tells the size of the buffer to receive the retrieved pixel data. [**glGetnTexImage**](crate::context::Context::oxidegl_getn_tex_image)
/// and [**glGetTextureImage**](crate::context::Context::oxidegl_get_texture_image)
/// do not write more than `bufSize` bytes into `pixels`.
///
/// If a non-zero named buffer object is bound to the [`GL_PIXEL_PACK_BUFFER`](crate::enums::GL_PIXEL_PACK_BUFFER)
/// target (see [**glBindBuffer**](crate::context::Context::oxidegl_bind_buffer))
/// while a texture image is requested, `pixels` is treated as a byte offset
/// into the buffer object's data store.
///
/// To understand the operation of [**glGetTexImage**](crate::context::Context::oxidegl_get_tex_image),
/// consider the selected internal four-component texture image to be an RGBA
/// color buffer the size of the image. The semantics of [**glGetTexImage**](crate::context::Context::oxidegl_get_tex_image)
/// are then identical to those of [**glReadPixels**](crate::context::Context::oxidegl_read_pixels),
/// with the exception that no pixel transfer operations are performed, when
/// called with the same `format` and `type`, with *x* and *y* set to 0, *width*
/// set to the width of the texture image and *height* set to 1 for 1D images,
/// or to the height of the texture image for 2D images.
///
/// If the selected texture image does not contain four components, the following
/// mappings are applied. Single-component textures are treated as RGBA buffers
/// with red set to the single-component value, green set to 0, blue set to
/// 0, and alpha set to 1. Two-component textures are treated as RGBA buffers
/// with red set to the value of component zero, alpha set to the value of
/// component one, and green and blue set to 0. Finally, three-component textures
/// are treated as RGBA buffers with red set to component zero, green set to
/// component one, blue set to component two, and alpha set to 1.
///
/// To determine the required size of `pixels`, use [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter)
/// to determine the dimensions of the internal texture image, then scale the
/// required number of pixels by the storage required for each pixel, based
/// on `format` and `type`. Be sure to take the pixel storage parameters into
/// account, especially [`GL_PACK_ALIGNMENT`](crate::enums::GL_PACK_ALIGNMENT).
///
/// If [**glGetTextureImage**](crate::context::Context::oxidegl_get_texture_image)
/// is used against a cube map texture object, the texture is treated as a
/// three-dimensional image of a depth of 6, where the cube map faces are ordered
/// as image layers, in an order presented in the table below:
///
/// | Layer number        | Cube Map Face        |
/// |---------------------|----------------------|
/// | 0                   | `GL_TEXTURE_CUBE_MAP_POSITIVE_X` |
/// | 1                   | `GL_TEXTURE_CUBE_MAP_NEGATIVE_X` |
/// | 2                   | `GL_TEXTURE_CUBE_MAP_POSITIVE_Y` |
/// | 3                   | `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y` |
/// | 4                   | `GL_TEXTURE_CUBE_MAP_POSITIVE_Z` |
/// | 5                   | `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z` |
///
/// ### Notes
/// If an error is generated, no change is made to the contents of `pixels`.
///
/// [**glGetTexImage**](crate::context::Context::oxidegl_get_tex_image) and
/// [**glGetnTexImage**](crate::context::Context::oxidegl_getn_tex_image) return
/// the texture image for the active texture unit.
///
/// [`GL_STENCIL_INDEX`](crate::enums::GL_STENCIL_INDEX) is accepted for `format`
/// only if the GL version is 4.4 or greater.
///
/// ### Associated Gets
/// [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter)
/// with argument [`GL_TEXTURE_WIDTH`](crate::enums::GL_TEXTURE_WIDTH)
///
/// [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter)
/// with argument [`GL_TEXTURE_HEIGHT`](crate::enums::GL_TEXTURE_HEIGHT)
///
/// [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter)
/// with argument [`GL_TEXTURE_INTERNAL_FORMAT`](crate::enums::GL_TEXTURE_INTERNAL_FORMAT)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with arguments [`GL_PACK_ALIGNMENT`](crate::enums::GL_PACK_ALIGNMENT)
/// and others
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_PIXEL_PACK_BUFFER_BINDING`](crate::enums::GL_PIXEL_PACK_BUFFER_BINDING)
impl Context {
    pub unsafe fn oxidegl_get_tex_image(
        &mut self,
        target: TextureTarget,
        level: GLint,
        format: PixelFormat,
        r#type: PixelType,
        pixels: *mut GLvoid,
    ) {
        panic!("command oxidegl_get_tex_image not yet implemented");
    }
    pub unsafe fn oxidegl_get_texture_image(
        &mut self,
        texture: GLuint,
        level: GLint,
        format: PixelFormat,
        r#type: PixelType,
        buf_size: GLsizei,
        pixels: *mut GLvoid,
    ) {
        panic!("command oxidegl_get_texture_image not yet implemented");
    }
    pub unsafe fn oxidegl_getn_tex_image(
        &mut self,
        target: TextureTarget,
        level: GLint,
        format: PixelFormat,
        r#type: PixelType,
        buf_size: GLsizei,
        pixels: *mut GLvoid,
    ) {
        panic!("command oxidegl_getn_tex_image not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the texture is bound for [**glGetTexLevelParameterfv**](crate::context::Context::oxidegl_get_tex_level_parameterfv)
/// > and [**glGetTexLevelParameteriv**](crate::context::Context::oxidegl_get_tex_level_parameteriv)
/// > functions. Must be one of the following values: [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D),
/// > [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D), [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D),
/// > [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY), [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY),
/// > [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE), [`GL_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE),
/// > [`GL_TEXTURE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE_ARRAY),
/// > [`GL_TEXTURE_CUBE_MAP_POSITIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_X),
/// > [`GL_TEXTURE_CUBE_MAP_NEGATIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_X),
/// > [`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Y),
/// > [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Y),
/// > [`GL_TEXTURE_CUBE_MAP_POSITIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Z),
/// > [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Z),
/// > [`GL_PROXY_TEXTURE_1D`](crate::enums::GL_PROXY_TEXTURE_1D), [`GL_PROXY_TEXTURE_2D`](crate::enums::GL_PROXY_TEXTURE_2D),
/// > [`GL_PROXY_TEXTURE_3D`](crate::enums::GL_PROXY_TEXTURE_3D), [`GL_PROXY_TEXTURE_1D_ARRAY`](crate::enums::GL_PROXY_TEXTURE_1D_ARRAY),
/// > [`GL_PROXY_TEXTURE_2D_ARRAY`](crate::enums::GL_PROXY_TEXTURE_2D_ARRAY),
/// > [`GL_PROXY_TEXTURE_RECTANGLE`](crate::enums::GL_PROXY_TEXTURE_RECTANGLE),
/// > [`GL_PROXY_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_PROXY_TEXTURE_2D_MULTISAMPLE),
/// > [`GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY),
/// > [`GL_PROXY_TEXTURE_CUBE_MAP`](crate::enums::GL_PROXY_TEXTURE_CUBE_MAP),
/// > or [`GL_TEXTURE_BUFFER`](crate::enums::GL_TEXTURE_BUFFER).
///
/// `texture`
///
/// > Specifies the texture object name for [**glGetTextureLevelParameterfv**](crate::context::Context::oxidegl_get_texture_level_parameterfv)
/// > and [**glGetTextureLevelParameteriv**](crate::context::Context::oxidegl_get_texture_level_parameteriv)
/// > functions.
///
/// `level`
///
/// > Specifies the level-of-detail number of the desired image. Level 0 is the
/// > base image level. Level `[inlineq]` `[inlineq]`
///
/// `pname`
///
/// > Specifies the symbolic name of a texture parameter. [`GL_TEXTURE_WIDTH`](crate::enums::GL_TEXTURE_WIDTH),
/// > [`GL_TEXTURE_HEIGHT`](crate::enums::GL_TEXTURE_HEIGHT), [`GL_TEXTURE_DEPTH`](crate::enums::GL_TEXTURE_DEPTH),
/// > [`GL_TEXTURE_INTERNAL_FORMAT`](crate::enums::GL_TEXTURE_INTERNAL_FORMAT),
/// > [`GL_TEXTURE_RED_SIZE`](crate::enums::GL_TEXTURE_RED_SIZE), [`GL_TEXTURE_GREEN_SIZE`](crate::enums::GL_TEXTURE_GREEN_SIZE),
/// > [`GL_TEXTURE_BLUE_SIZE`](crate::enums::GL_TEXTURE_BLUE_SIZE), [`GL_TEXTURE_ALPHA_SIZE`](crate::enums::GL_TEXTURE_ALPHA_SIZE),
/// > [`GL_TEXTURE_DEPTH_SIZE`](crate::enums::GL_TEXTURE_DEPTH_SIZE), [`GL_TEXTURE_COMPRESSED`](crate::enums::GL_TEXTURE_COMPRESSED),
/// > [`GL_TEXTURE_COMPRESSED_IMAGE_SIZE`](crate::enums::GL_TEXTURE_COMPRESSED_IMAGE_SIZE),
/// > and [`GL_TEXTURE_BUFFER_OFFSET`](crate::enums::GL_TEXTURE_BUFFER_OFFSET)
/// > are accepted.
///
/// `params`
///
/// > Returns the requested data.
///
/// ### Description
/// [**glGetTexLevelParameterfv**](crate::context::Context::oxidegl_get_tex_level_parameterfv),
/// [**glGetTexLevelParameteriv**](crate::context::Context::oxidegl_get_tex_level_parameteriv),
/// [**glGetTextureLevelParameterfv**](crate::context::Context::oxidegl_get_texture_level_parameterfv)
/// and [**glGetTextureLevelParameteriv**](crate::context::Context::oxidegl_get_texture_level_parameteriv)
/// return in `params` texture parameter values for a specific level-of-detail
/// value, specified as `level`. For the first two functions, `target` defines
/// the target texture, either [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D),
/// [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D), [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D),
/// [`GL_PROXY_TEXTURE_1D`](crate::enums::GL_PROXY_TEXTURE_1D), [`GL_PROXY_TEXTURE_2D`](crate::enums::GL_PROXY_TEXTURE_2D),
/// [`GL_PROXY_TEXTURE_3D`](crate::enums::GL_PROXY_TEXTURE_3D), [`GL_TEXTURE_CUBE_MAP_POSITIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_X),
/// [`GL_TEXTURE_CUBE_MAP_NEGATIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_X),
/// [`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Y),
/// [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Y),
/// [`GL_TEXTURE_CUBE_MAP_POSITIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Z),
/// [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Z),
/// or [`GL_PROXY_TEXTURE_CUBE_MAP`](crate::enums::GL_PROXY_TEXTURE_CUBE_MAP).
/// The remaining two take a `texture` argument which specifies the name of
/// the texture object.
///
/// [`GL_MAX_TEXTURE_SIZE`](crate::enums::GL_MAX_TEXTURE_SIZE), and [`GL_MAX_3D_TEXTURE_SIZE`](crate::enums::GL_MAX_3D_TEXTURE_SIZE)
/// are not really descriptive enough. It has to report the largest square
/// texture image that can be accommodated with mipmaps but a long skinny texture,
/// or a texture without mipmaps may easily fit in texture memory. The proxy
/// targets allow the user to more accurately query whether the GL can accommodate
/// a texture of a given configuration. If the texture cannot be accommodated,
/// the texture state variables, which may be queried with [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter)
/// and [**glGetTextureLevelParameter**](crate::context::Context::oxidegl_get_texture_level_parameter),
/// are set to 0. If the texture can be accommodated, the texture state values
/// will be set as they would be set for a non-proxy target.
///
/// `pname` specifies the texture parameter whose value or values will be returned.
///
/// The accepted parameter names are as follows:
///
/// [`GL_TEXTURE_WIDTH`](crate::enums::GL_TEXTURE_WIDTH)
///
/// > `params` returns a single value, the width of the texture image. The initial
/// > value is 0.
///
/// [`GL_TEXTURE_HEIGHT`](crate::enums::GL_TEXTURE_HEIGHT)
///
/// > `params` returns a single value, the height of the texture image. The initial
/// > value is 0.
///
/// [`GL_TEXTURE_DEPTH`](crate::enums::GL_TEXTURE_DEPTH)
///
/// > `params` returns a single value, the depth of the texture image. The initial
/// > value is 0.
///
/// [`GL_TEXTURE_INTERNAL_FORMAT`](crate::enums::GL_TEXTURE_INTERNAL_FORMAT)
///
/// > `params` returns a single value, the internal format of the texture image.
///
/// [`GL_TEXTURE_RED_TYPE`](crate::enums::GL_TEXTURE_RED_TYPE), [`GL_TEXTURE_GREEN_TYPE`](crate::enums::GL_TEXTURE_GREEN_TYPE),
/// [`GL_TEXTURE_BLUE_TYPE`](crate::enums::GL_TEXTURE_BLUE_TYPE), [`GL_TEXTURE_ALPHA_TYPE`](crate::enums::GL_TEXTURE_ALPHA_TYPE),
/// [`GL_TEXTURE_DEPTH_TYPE`](crate::enums::GL_TEXTURE_DEPTH_TYPE)
///
/// > The data type used to store the component. The types [`GL_NONE`](crate::enums::GL_NONE),
/// > [`GL_SIGNED_NORMALIZED`](crate::enums::GL_SIGNED_NORMALIZED), [`GL_UNSIGNED_NORMALIZED`](crate::enums::GL_UNSIGNED_NORMALIZED),
/// > [`GL_FLOAT`](crate::enums::GL_FLOAT), [`GL_INT`](crate::enums::GL_INT),
/// > and [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT) may be returned
/// > to indicate signed normalized fixed-point, unsigned normalized fixed-point,
/// > floating-point, integer unnormalized, and unsigned integer unnormalized
/// > components, respectively.
///
/// [`GL_TEXTURE_RED_SIZE`](crate::enums::GL_TEXTURE_RED_SIZE), [`GL_TEXTURE_GREEN_SIZE`](crate::enums::GL_TEXTURE_GREEN_SIZE),
/// [`GL_TEXTURE_BLUE_SIZE`](crate::enums::GL_TEXTURE_BLUE_SIZE), [`GL_TEXTURE_ALPHA_SIZE`](crate::enums::GL_TEXTURE_ALPHA_SIZE),
/// [`GL_TEXTURE_DEPTH_SIZE`](crate::enums::GL_TEXTURE_DEPTH_SIZE)
///
///
/// > The internal storage resolution of an individual component. The resolution
/// > chosen by the GL will be a close match for the resolution requested by
/// > the user with the component argument of [**glTexImage1D**](crate::context::Context::oxidegl_tex_image1_d),
/// > [**glTexImage2D**](crate::context::Context::oxidegl_tex_image2_d), [**glTexImage3D**](crate::context::Context::oxidegl_tex_image3_d),
/// > [**glCopyTexImage1D**](crate::context::Context::oxidegl_copy_tex_image1_d),
/// > and [**glCopyTexImage2D**](crate::context::Context::oxidegl_copy_tex_image2_d).
/// > The initial value is 0.
///
/// [`GL_TEXTURE_COMPRESSED`](crate::enums::GL_TEXTURE_COMPRESSED)
///
///
/// > `params` returns a single boolean value indicating if the texture image
/// > is stored in a compressed internal format. The initiali value is [`GL_FALSE`](crate::enums::GL_FALSE).
///
/// [`GL_TEXTURE_COMPRESSED_IMAGE_SIZE`](crate::enums::GL_TEXTURE_COMPRESSED_IMAGE_SIZE)
///
///
/// > `params` returns a single integer value, the number of unsigned bytes of
/// > the compressed texture image that would be returned from [**glGetCompressedTexImage**](crate::context::Context::oxidegl_get_compressed_tex_image).
///
/// [`GL_TEXTURE_BUFFER_OFFSET`](crate::enums::GL_TEXTURE_BUFFER_OFFSET)
///
///
/// > `params` returns a single integer value, the offset into the data store
/// > of the buffer bound to a buffer texture. [**glTexBufferRange**](crate::context::Context::oxidegl_tex_buffer_range).
///
/// [`GL_TEXTURE_BUFFER_SIZE`](crate::enums::GL_TEXTURE_BUFFER_SIZE)
///
///
/// > `params` returns a single integer value, the size of the range of a data
/// > store of the buffer bound to a buffer texture. [**glTexBufferRange**](crate::context::Context::oxidegl_tex_buffer_range).
///
/// ### Notes
/// If an error is generated, no change is made to the contents of `params`.
///
/// [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter)
/// returns the texture level parameters for the active texture unit.
///
/// [`GL_TEXTURE_BUFFER_OFFSET`](crate::enums::GL_TEXTURE_BUFFER_OFFSET) and
/// [`GL_TEXTURE_BUFFER_SIZE`](crate::enums::GL_TEXTURE_BUFFER_SIZE) are available
/// only if the GL version is 4.3 or greater.
impl Context {
    pub unsafe fn oxidegl_get_tex_level_parameterfv(
        &mut self,
        target: TextureTarget,
        level: GLint,
        pname: GetTextureParameter,
        params: *mut GLfloat,
    ) {
        panic!("command oxidegl_get_tex_level_parameterfv not yet implemented");
    }
    pub unsafe fn oxidegl_get_tex_level_parameteriv(
        &mut self,
        target: TextureTarget,
        level: GLint,
        pname: GetTextureParameter,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_tex_level_parameteriv not yet implemented");
    }
    pub unsafe fn oxidegl_get_texture_level_parameterfv(
        &mut self,
        texture: GLuint,
        level: GLint,
        pname: GetTextureParameter,
        params: *mut GLfloat,
    ) {
        panic!("command oxidegl_get_texture_level_parameterfv not yet implemented");
    }
    pub unsafe fn oxidegl_get_texture_level_parameteriv(
        &mut self,
        texture: GLuint,
        level: GLint,
        pname: GetTextureParameter,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_texture_level_parameteriv not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the texture is bound for [**glGetTexParameterfv**](crate::context::Context::oxidegl_get_tex_parameterfv),
/// > [**glGetTexParameteriv**](crate::context::Context::oxidegl_get_tex_parameteriv),
/// > [**glGetTexParameterIiv**](crate::context::Context::oxidegl_get_tex_parameter_iiv),
/// > and [**glGetTexParameterIuiv**](crate::context::Context::oxidegl_get_tex_parameter_iuiv)
/// > functions. [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D), [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY),
/// > [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D), [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY),
/// > [`GL_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE),
/// > [`GL_TEXTURE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE_ARRAY),
/// > [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D), [`GL_TEXTURE_CUBE_MAP`](crate::enums::GL_TEXTURE_CUBE_MAP),
/// > [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE), and [`GL_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_CUBE_MAP_ARRAY)
/// > are accepted.
///
/// `texture`
///
/// > Specifies the texture object name for [**glGetTextureParameterfv**](crate::context::Context::oxidegl_get_texture_parameterfv),
/// > [**glGetTextureParameteriv**](crate::context::Context::oxidegl_get_texture_parameteriv),
/// > [**glGetTextureParameterIiv**](crate::context::Context::oxidegl_get_texture_parameter_iiv),
/// > and [**glGetTextureParameterIuiv**](crate::context::Context::oxidegl_get_texture_parameter_iuiv)
/// > functions.
///
/// `pname`
///
/// > Specifies the symbolic name of a texture parameter. [`GL_DEPTH_STENCIL_TEXTURE_MODE`](crate::enums::GL_DEPTH_STENCIL_TEXTURE_MODE),
/// > [`GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`](crate::enums::GL_IMAGE_FORMAT_COMPATIBILITY_TYPE),
/// > [`GL_TEXTURE_BASE_LEVEL`](crate::enums::GL_TEXTURE_BASE_LEVEL), [`GL_TEXTURE_BORDER_COLOR`](crate::enums::GL_TEXTURE_BORDER_COLOR),
/// > [`GL_TEXTURE_COMPARE_MODE`](crate::enums::GL_TEXTURE_COMPARE_MODE), [`GL_TEXTURE_COMPARE_FUNC`](crate::enums::GL_TEXTURE_COMPARE_FUNC),
/// > [`GL_TEXTURE_IMMUTABLE_FORMAT`](crate::enums::GL_TEXTURE_IMMUTABLE_FORMAT),
/// > [`GL_TEXTURE_IMMUTABLE_LEVELS`](crate::enums::GL_TEXTURE_IMMUTABLE_LEVELS),
/// > [`GL_TEXTURE_LOD_BIAS`](crate::enums::GL_TEXTURE_LOD_BIAS), [`GL_TEXTURE_MAG_FILTER`](crate::enums::GL_TEXTURE_MAG_FILTER),
/// > [`GL_TEXTURE_MAX_LEVEL`](crate::enums::GL_TEXTURE_MAX_LEVEL), [`GL_TEXTURE_MAX_LOD`](crate::enums::GL_TEXTURE_MAX_LOD),
/// > [`GL_TEXTURE_MIN_FILTER`](crate::enums::GL_TEXTURE_MIN_FILTER), [`GL_TEXTURE_MIN_LOD`](crate::enums::GL_TEXTURE_MIN_LOD),
/// > [`GL_TEXTURE_SWIZZLE_R`](crate::enums::GL_TEXTURE_SWIZZLE_R), [`GL_TEXTURE_SWIZZLE_G`](crate::enums::GL_TEXTURE_SWIZZLE_G),
/// > [`GL_TEXTURE_SWIZZLE_B`](crate::enums::GL_TEXTURE_SWIZZLE_B), [`GL_TEXTURE_SWIZZLE_A`](crate::enums::GL_TEXTURE_SWIZZLE_A),
/// > [`GL_TEXTURE_SWIZZLE_RGBA`](crate::enums::GL_TEXTURE_SWIZZLE_RGBA), [`GL_TEXTURE_TARGET`](crate::enums::GL_TEXTURE_TARGET),
/// > [`GL_TEXTURE_VIEW_MIN_LAYER`](crate::enums::GL_TEXTURE_VIEW_MIN_LAYER),
/// > [`GL_TEXTURE_VIEW_MIN_LEVEL`](crate::enums::GL_TEXTURE_VIEW_MIN_LEVEL),
/// > [`GL_TEXTURE_VIEW_NUM_LAYERS`](crate::enums::GL_TEXTURE_VIEW_NUM_LAYERS),
/// > [`GL_TEXTURE_VIEW_NUM_LEVELS`](crate::enums::GL_TEXTURE_VIEW_NUM_LEVELS),
/// > [`GL_TEXTURE_WRAP_S`](crate::enums::GL_TEXTURE_WRAP_S), [`GL_TEXTURE_WRAP_T`](crate::enums::GL_TEXTURE_WRAP_T),
/// > and [`GL_TEXTURE_WRAP_R`](crate::enums::GL_TEXTURE_WRAP_R) are accepted.
///
/// `params`
///
/// > Returns the texture parameters.
///
/// ### Description
/// [**glGetTexParameter**](crate::context::Context::oxidegl_get_tex_parameter)
/// and [**glGetTextureParameter**](crate::context::Context::oxidegl_get_texture_parameter)
/// return in `params` the value or values of the texture parameter specified
/// as `pname`. `target` defines the target texture. [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D),
/// [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D), [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D),
/// [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY), [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY),
/// [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE), [`GL_TEXTURE_CUBE_MAP`](crate::enums::GL_TEXTURE_CUBE_MAP),
/// [`GL_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_CUBE_MAP_ARRAY),
/// [`GL_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE),
/// or [`GL_TEXTURE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE_ARRAY)
/// specify one-, two-, or three-dimensional, one-dimensional array, two-dimensional
/// array, rectangle, cube-mapped or cube-mapped array, two-dimensional multisample,
/// or two-dimensional multisample array texturing, respectively. `pname` accepts
/// the same symbols as [**glTexParameter**](crate::context::Context::oxidegl_tex_parameter),
/// with the same interpretations:
///
/// [`GL_DEPTH_STENCIL_TEXTURE_MODE`](crate::enums::GL_DEPTH_STENCIL_TEXTURE_MODE)
///
/// > Returns the single-value depth stencil texture mode, a symbolic constant.
/// > The initial value is [`GL_DEPTH_COMPONENT`](crate::enums::GL_DEPTH_COMPONENT).
///
/// [`GL_TEXTURE_MAG_FILTER`](crate::enums::GL_TEXTURE_MAG_FILTER)
///
/// > Returns the single-valued texture magnification filter, a symbolic constant.
/// > The initial value is [`GL_LINEAR`](crate::enums::GL_LINEAR).
///
/// [`GL_TEXTURE_MIN_FILTER`](crate::enums::GL_TEXTURE_MIN_FILTER)
///
/// > Returns the single-valued texture minification filter, a symbolic constant.
/// > The initial value is [`GL_NEAREST_MIPMAP_LINEAR`](crate::enums::GL_NEAREST_MIPMAP_LINEAR).
///
/// [`GL_TEXTURE_MIN_LOD`](crate::enums::GL_TEXTURE_MIN_LOD)
///
/// > Returns the single-valued texture minimum level-of-detail value. The initial
/// > value is `[inlineq]`
///
/// [`GL_TEXTURE_MAX_LOD`](crate::enums::GL_TEXTURE_MAX_LOD)
///
/// > Returns the single-valued texture maximum level-of-detail value. The initial
/// > value is 1000.
///
/// [`GL_TEXTURE_BASE_LEVEL`](crate::enums::GL_TEXTURE_BASE_LEVEL)
///
/// > Returns the single-valued base texture mipmap level. The initial value
/// > is 0.
///
/// [`GL_TEXTURE_MAX_LEVEL`](crate::enums::GL_TEXTURE_MAX_LEVEL)
///
/// > Returns the single-valued maximum texture mipmap array level. The initial
/// > value is 1000.
///
/// [`GL_TEXTURE_SWIZZLE_R`](crate::enums::GL_TEXTURE_SWIZZLE_R)
///
/// > Returns the red component swizzle. The initial value is [`GL_RED`](crate::enums::GL_RED).
///
/// [`GL_TEXTURE_SWIZZLE_G`](crate::enums::GL_TEXTURE_SWIZZLE_G)
///
/// > Returns the green component swizzle. The initial value is [`GL_GREEN`](crate::enums::GL_GREEN).
///
/// [`GL_TEXTURE_SWIZZLE_B`](crate::enums::GL_TEXTURE_SWIZZLE_B)
///
/// > Returns the blue component swizzle. The initial value is [`GL_BLUE`](crate::enums::GL_BLUE).
///
/// [`GL_TEXTURE_SWIZZLE_A`](crate::enums::GL_TEXTURE_SWIZZLE_A)
///
/// > Returns the alpha component swizzle. The initial value is [`GL_ALPHA`](crate::enums::GL_ALPHA).
///
/// [`GL_TEXTURE_SWIZZLE_RGBA`](crate::enums::GL_TEXTURE_SWIZZLE_RGBA)
///
/// > Returns the component swizzle for all channels in a single query.
///
/// [`GL_TEXTURE_WRAP_S`](crate::enums::GL_TEXTURE_WRAP_S)
///
/// > Returns the single-valued wrapping function for texture coordinate `[inlineq]`
/// > [`GL_REPEAT`](crate::enums::GL_REPEAT).
///
/// [`GL_TEXTURE_WRAP_T`](crate::enums::GL_TEXTURE_WRAP_T)
///
/// > Returns the single-valued wrapping function for texture coordinate `[inlineq]`
/// > [`GL_REPEAT`](crate::enums::GL_REPEAT).
///
/// [`GL_TEXTURE_WRAP_R`](crate::enums::GL_TEXTURE_WRAP_R)
///
/// > Returns the single-valued wrapping function for texture coordinate `[inlineq]`
/// > [`GL_REPEAT`](crate::enums::GL_REPEAT).
///
/// [`GL_TEXTURE_BORDER_COLOR`](crate::enums::GL_TEXTURE_BORDER_COLOR)
///
/// > Returns four integer or floating-point numbers that comprise the RGBA color
/// > of the texture border. Floating-point values are returned in the range
/// > `[inlineq]` `[inlineq]`
///
/// [`GL_TEXTURE_COMPARE_MODE`](crate::enums::GL_TEXTURE_COMPARE_MODE)
///
/// > Returns a single-valued texture comparison mode, a symbolic constant. The
/// > initial value is [`GL_NONE`](crate::enums::GL_NONE). See [**glTexParameter**](crate::context::Context::oxidegl_tex_parameter).
///
/// [`GL_TEXTURE_COMPARE_FUNC`](crate::enums::GL_TEXTURE_COMPARE_FUNC)
///
/// > Returns a single-valued texture comparison function, a symbolic constant.
/// > The initial value is [`GL_LEQUAL`](crate::enums::GL_LEQUAL). See [**glTexParameter**](crate::context::Context::oxidegl_tex_parameter).
///
/// [`GL_TEXTURE_VIEW_MIN_LEVEL`](crate::enums::GL_TEXTURE_VIEW_MIN_LEVEL)
///
/// > Returns a single-valued base level of a texture view relative to its parent.
/// > The initial value is 0. See [**glTextureView**](crate::context::Context::oxidegl_texture_view).
///
/// [`GL_TEXTURE_VIEW_NUM_LEVELS`](crate::enums::GL_TEXTURE_VIEW_NUM_LEVELS)
///
/// > Returns a single-valued number of levels of detail of a texture view. See
/// > [**glTextureView**](crate::context::Context::oxidegl_texture_view).
///
/// [`GL_TEXTURE_VIEW_MIN_LAYER`](crate::enums::GL_TEXTURE_VIEW_MIN_LAYER)
///
/// > Returns a single-valued first level of a texture array view relative to
/// > its parent. See [**glTextureView**](crate::context::Context::oxidegl_texture_view).
///
/// [`GL_TEXTURE_VIEW_NUM_LAYERS`](crate::enums::GL_TEXTURE_VIEW_NUM_LAYERS)
///
/// > Returns a single-valued number of layers in a texture array view. See [**glTextureView**](crate::context::Context::oxidegl_texture_view).
///
/// [`GL_TEXTURE_IMMUTABLE_LEVELS`](crate::enums::GL_TEXTURE_IMMUTABLE_LEVELS)
///
/// > Returns a single-valued number of immutable texture levels in a texture
/// > view. See [**glTextureView**](crate::context::Context::oxidegl_texture_view).
///
/// In addition to the parameters that may be set with [**glTexParameter**](crate::context::Context::oxidegl_tex_parameter),
/// [**glGetTexParameter**](crate::context::Context::oxidegl_get_tex_parameter)
/// and [**glGetTextureParameter**](crate::context::Context::oxidegl_get_texture_parameter)
/// accept the following read-only parameters:
///
/// [`GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`](crate::enums::GL_IMAGE_FORMAT_COMPATIBILITY_TYPE)
///
/// > Returns the matching criteria use for the texture when used as an image
/// > texture. Can return [`GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE`](crate::enums::GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE),
/// > [`GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS`](crate::enums::GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS)
/// > or [`GL_NONE`](crate::enums::GL_NONE).
///
/// [`GL_TEXTURE_IMMUTABLE_FORMAT`](crate::enums::GL_TEXTURE_IMMUTABLE_FORMAT)
///
/// > Returns non-zero if the texture has an immutable format. Textures become
/// > immutable if their storage is specified with [**glTexStorage1D**](crate::context::Context::oxidegl_tex_storage1_d),
/// > [**glTexStorage2D**](crate::context::Context::oxidegl_tex_storage2_d) or
/// > [**glTexStorage3D**](crate::context::Context::oxidegl_tex_storage3_d). The
/// > initial value is [`GL_FALSE`](crate::enums::GL_FALSE).
///
/// [`GL_TEXTURE_TARGET`](crate::enums::GL_TEXTURE_TARGET)
///
/// > Returns the effective target of the texture object. For [**glGetTex*Parameter**](crate::context::Context::oxidegl_get_tex*_parameter)
/// > functions, this is the target parameter. For [**glGetTextureParameter***](crate::context::Context::oxidegl_get_texture_parameter*),
/// > it is the target to which the texture was initially bound when it was
/// > created, or the value of the target parameter to the call to [**glCreateTextures**](crate::context::Context::oxidegl_create_textures)
/// > which created the texture.
///
/// ### Notes
/// If an error is generated, no change is made to the contents of `params`.
///
/// [`GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`](crate::enums::GL_IMAGE_FORMAT_COMPATIBILITY_TYPE)
/// is available only if the GL version is 4.2 or greater.
///
/// [`GL_DEPTH_STENCIL_TEXTURE_MODE`](crate::enums::GL_DEPTH_STENCIL_TEXTURE_MODE),
/// [`GL_TEXTURE_VIEW_MIN_LEVEL`](crate::enums::GL_TEXTURE_VIEW_MIN_LEVEL),
/// [`GL_TEXTURE_VIEW_NUM_LEVELS`](crate::enums::GL_TEXTURE_VIEW_NUM_LEVELS),
/// [`GL_TEXTURE_VIEW_MIN_LAYER`](crate::enums::GL_TEXTURE_VIEW_MIN_LAYER),
/// [`GL_TEXTURE_VIEW_NUM_LAYERS`](crate::enums::GL_TEXTURE_VIEW_NUM_LAYERS)
/// and [`GL_TEXTURE_IMMUTABLE_LEVELS`](crate::enums::GL_TEXTURE_IMMUTABLE_LEVELS)
/// are available only if the GL version is 4.3 or greater.
///
/// [`GL_TEXTURE_TARGET`](crate::enums::GL_TEXTURE_TARGET) are available only
/// if the GL version is 4.5 or greater.
impl Context {
    pub unsafe fn oxidegl_get_tex_parameterfv(
        &mut self,
        target: TextureTarget,
        pname: GetTextureParameter,
        params: *mut GLfloat,
    ) {
        panic!("command oxidegl_get_tex_parameterfv not yet implemented");
    }
    pub unsafe fn oxidegl_get_tex_parameteriv(
        &mut self,
        target: TextureTarget,
        pname: GetTextureParameter,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_tex_parameteriv not yet implemented");
    }
    pub unsafe fn oxidegl_get_tex_parameter_iiv(
        &mut self,
        target: TextureTarget,
        pname: GetTextureParameter,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_tex_parameter_iiv not yet implemented");
    }
    pub unsafe fn oxidegl_get_tex_parameter_iuiv(
        &mut self,
        target: TextureTarget,
        pname: GetTextureParameter,
        params: *mut GLuint,
    ) {
        panic!("command oxidegl_get_tex_parameter_iuiv not yet implemented");
    }
    pub unsafe fn oxidegl_get_texture_parameterfv(
        &mut self,
        texture: GLuint,
        pname: GetTextureParameter,
        params: *mut GLfloat,
    ) {
        panic!("command oxidegl_get_texture_parameterfv not yet implemented");
    }
    pub unsafe fn oxidegl_get_texture_parameter_iiv(
        &mut self,
        texture: GLuint,
        pname: GetTextureParameter,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_texture_parameter_iiv not yet implemented");
    }
    pub unsafe fn oxidegl_get_texture_parameter_iuiv(
        &mut self,
        texture: GLuint,
        pname: GetTextureParameter,
        params: *mut GLuint,
    ) {
        panic!("command oxidegl_get_texture_parameter_iuiv not yet implemented");
    }
    pub unsafe fn oxidegl_get_texture_parameteriv(
        &mut self,
        texture: GLuint,
        pname: GetTextureParameter,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_texture_parameteriv not yet implemented");
    }
}
/// ### Parameters
/// `xfb`
///
/// > The name of an existing transform feedback object, or zero for the default
/// > transform feedback object.
///
/// `pname`
///
/// > Property to use for the query. Must be one of the values: [`GL_TRANSFORM_FEEDBACK_BUFFER_BINDING`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER_BINDING),
/// > [`GL_TRANSFORM_FEEDBACK_BUFFER_START`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER_START),
/// > [`GL_TRANSFORM_FEEDBACK_BUFFER_SIZE`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER_SIZE),
/// > [`GL_TRANSFORM_FEEDBACK_PAUSED`](crate::enums::GL_TRANSFORM_FEEDBACK_PAUSED),
/// > [`GL_TRANSFORM_FEEDBACK_ACTIVE`](crate::enums::GL_TRANSFORM_FEEDBACK_ACTIVE).
///
/// `index`
///
/// > Index of the transform feedback stream (for indexed state).
///
/// `param`
///
/// > The address of a buffer into which will be written the requested state
/// > information.
///
/// ### Description
/// In order to use the Transform Feedback functionality, you need to configure
/// the Transform Feedback Buffer indexed bindings. This can be achieved by
/// either using [**glBindBufferBase**](crate::context::Context::oxidegl_bind_buffer_base)
/// or [**glBindBuffersBase**](crate::context::Context::oxidegl_bind_buffers_base)
/// to associate whole buffer object storage to one of the Transform Feedback
/// Binding Points, or by calling [**glBindBufferRange**](crate::context::Context::oxidegl_bind_buffer_range)
/// or [**glBindBuffersRange**](crate::context::Context::oxidegl_bind_buffers_range)
/// to use a region of a buffer object storage for the binding. You may want
/// to (but are not required to) bind a Transform Feedback Object first, in
/// order to cache the binding configuration. This usually allows you to restore
/// the Transform Feedback configuration faster, than if you were to execute
/// a list of API calls necessary to set up the Transform Feedback state of
/// your liking.
///
/// This reference page discusses two types of getters that operate on Transform
/// Feedback Objects and their bindings.
///
/// The first class operates on general Transform Feedback binding point and
/// includes [**glGetTransformFeedbackiv**](crate::context::Context::oxidegl_get_transform_feedbackiv)
/// function. [**glGetTransformFeedbackiv**](crate::context::Context::oxidegl_get_transform_feedbackiv)
/// can be used to retrieve information about Transform Feedback object bound
/// to the general Transform Feedback binding point, as configured with a [**glBindTransformFeedback**](crate::context::Context::oxidegl_bind_transform_feedback)
/// call. In this case, you can check:
///
/// > What the ID of the currently bound Transform Feedback Object is;( [`GL_TRANSFORM_FEEDBACK_BUFFER_BINDING`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER_BINDING))
///
/// > Whether the Transform Feedback process is currently paused;( [`GL_TRANSFORM_FEEDBACK_PAUSED`](crate::enums::GL_TRANSFORM_FEEDBACK_PAUSED))
///
/// > Whether the Transform Feedback process has been begun and is currently
/// > undergoing;( [`GL_TRANSFORM_FEEDBACK_ACTIVE`](crate::enums::GL_TRANSFORM_FEEDBACK_ACTIVE))
///
///
/// The latter class, which includes [**`glGetTransformFeedbacki_v`**](crate::context::Context::oxidegl_get_transform_feedbacki_v)
/// and [**`glGetTransformFeedbacki64_v`**](crate::context::Context::oxidegl_get_transform_feedbacki64_v)
/// functions, can be used to check what the current configuration of each
/// of the buffer object regions bound to Transform Feedback Buffer binding
/// points is. This allows you to query for the following information:
///
/// > [**glGetTransformFeedbacki_v**](crate::context::Context::oxidegl_get_transform_feedbacki_v)
/// > only: What the ID of the Buffer Object bound to a Transform Feedback Binding
/// > Point of user-specified index is;( [`GL_TRANSFORM_FEEDBACK_BUFFER_BINDING`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER_BINDING)
/// > ).
///
/// > [**glGetTransformFeedbacki64_v**](crate::context::Context::oxidegl_get_transform_feedbacki64_v)
/// > only: What the start offset configured for the binding is;( [`GL_TRANSFORM_FEEDBACK_BUFFER_START`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER_START)
/// > );
///
/// > [**glGetTransformFeedbacki64_v**](crate::context::Context::oxidegl_get_transform_feedbacki64_v)
/// > only: What the length of the region used for the binding is;( [`GL_TRANSFORM_FEEDBACK_BUFFER_SIZE`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER_SIZE)
/// > );
///
impl Context {
    pub unsafe fn oxidegl_get_transform_feedbackiv(
        &mut self,
        xfb: GLuint,
        pname: TransformFeedbackPName,
        param: *mut GLint,
    ) {
        panic!("command oxidegl_get_transform_feedbackiv not yet implemented");
    }
    pub unsafe fn oxidegl_get_transform_feedbacki_v(
        &mut self,
        xfb: GLuint,
        pname: TransformFeedbackPName,
        index: GLuint,
        param: *mut GLint,
    ) {
        panic!("command oxidegl_get_transform_feedbacki_v not yet implemented");
    }
    pub unsafe fn oxidegl_get_transform_feedbacki64_v(
        &mut self,
        xfb: GLuint,
        pname: TransformFeedbackPName,
        index: GLuint,
        param: *mut GLint64,
    ) {
        panic!("command oxidegl_get_transform_feedbacki64_v not yet implemented");
    }
}
/// ### Parameters
/// `program`
///
/// > Specifies the program object to be queried.
///
/// `location`
///
/// > Specifies the location of the uniform variable to be queried.
///
/// `bufSize`
///
/// > Specifies the size of the buffer `params`.
///
/// `params`
///
/// > Returns the value of the specified uniform variable.
///
/// ### Description
/// [**glGetUniform**](crate::context::Context::oxidegl_get_uniform) and [**glGetnUniform**](crate::context::Context::oxidegl_getn_uniform)
/// return in `params` the value(s) of the specified uniform variable. The
/// type of the uniform variable specified by `location` determines the number
/// of values returned. If the uniform variable is defined in the shader as
/// a boolean, int, or float, a single value will be returned. If it is defined
/// as a vec2, ivec2, or bvec2, two values will be returned. If it is defined
/// as a vec3, ivec3, or bvec3, three values will be returned, and so on. To
/// query values stored in uniform variables declared as arrays, call [**glGetUniform**](crate::context::Context::oxidegl_get_uniform)
/// for each element of the array. To query values stored in uniform variables
/// declared as structures, call [**glGetUniform**](crate::context::Context::oxidegl_get_uniform)
/// for each field in the structure. The values for uniform variables declared
/// as a matrix will be returned in column major order.
///
/// The locations assigned to uniform variables are not known until the program
/// object is linked. After linking has occurred, the command [**glGetUniformLocation**](crate::context::Context::oxidegl_get_uniform_location)
/// can be used to obtain the location of a uniform variable. This location
/// value can then be passed to [**glGetUniform**](crate::context::Context::oxidegl_get_uniform)
/// or [**glGetnUniform**](crate::context::Context::oxidegl_getn_uniform) in
/// order to query the current value of the uniform variable. After a program
/// object has been linked successfully, the index values for uniform variables
/// remain fixed until the next link command occurs. The uniform variable values
/// can only be queried after a link if the link was successful.
///
/// The only difference between [**glGetUniform**](crate::context::Context::oxidegl_get_uniform)
/// and [**glGetnUniform**](crate::context::Context::oxidegl_getn_uniform)
/// is that [**glGetnUniform**](crate::context::Context::oxidegl_getn_uniform)
/// will generate an error if size of the `params` buffer,as described by `bufSize`,
/// is not large enough to hold the result data.
///
/// ### Notes
/// If an error is generated, no change is made to the contents of `params`.
///
/// ### Associated Gets
/// [**glGetActiveUniform**](crate::context::Context::oxidegl_get_active_uniform)
/// with arguments `program` and the index of an active uniform variable
///
/// [**glGetProgram**](crate::context::Context::oxidegl_get_program) with arguments
/// `program` and [`GL_ACTIVE_UNIFORMS`](crate::enums::GL_ACTIVE_UNIFORMS)
/// or [`GL_ACTIVE_UNIFORM_MAX_LENGTH`](crate::enums::GL_ACTIVE_UNIFORM_MAX_LENGTH)
///
/// [**glGetUniformLocation**](crate::context::Context::oxidegl_get_uniform_location)
/// with arguments `program` and the name of a uniform variable
///
/// [**glIsProgram**](crate::context::Context::oxidegl_is_program)
impl Context {
    pub unsafe fn oxidegl_get_uniformfv(
        &mut self,
        program: GLuint,
        location: GLint,
        params: *mut GLfloat,
    ) {
        panic!("command oxidegl_get_uniformfv not yet implemented");
    }
    pub unsafe fn oxidegl_get_uniformiv(
        &mut self,
        program: GLuint,
        location: GLint,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_uniformiv not yet implemented");
    }
    pub unsafe fn oxidegl_get_uniformuiv(
        &mut self,
        program: GLuint,
        location: GLint,
        params: *mut GLuint,
    ) {
        panic!("command oxidegl_get_uniformuiv not yet implemented");
    }
    pub unsafe fn oxidegl_get_uniformdv(
        &mut self,
        program: GLuint,
        location: GLint,
        params: *mut GLdouble,
    ) {
        panic!("command oxidegl_get_uniformdv not yet implemented");
    }
    pub unsafe fn oxidegl_getn_uniformdv(
        &mut self,
        program: GLuint,
        location: GLint,
        buf_size: GLsizei,
        params: *mut GLdouble,
    ) {
        panic!("command oxidegl_getn_uniformdv not yet implemented");
    }
    pub unsafe fn oxidegl_getn_uniformfv(
        &mut self,
        program: GLuint,
        location: GLint,
        buf_size: GLsizei,
        params: *mut GLfloat,
    ) {
        panic!("command oxidegl_getn_uniformfv not yet implemented");
    }
    pub unsafe fn oxidegl_getn_uniformiv(
        &mut self,
        program: GLuint,
        location: GLint,
        buf_size: GLsizei,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_getn_uniformiv not yet implemented");
    }
    pub unsafe fn oxidegl_getn_uniformuiv(
        &mut self,
        program: GLuint,
        location: GLint,
        buf_size: GLsizei,
        params: *mut GLuint,
    ) {
        panic!("command oxidegl_getn_uniformuiv not yet implemented");
    }
}
/// ### Parameters
/// `vaobj`
///
/// > Specifies the name of a vertex array object.
///
/// `index`
///
/// > Specifies the index of the vertex array object attribute. Must be a number
/// > between 0 and( [`GL_MAX_VERTEX_ATTRIBS`](crate::enums::GL_MAX_VERTEX_ATTRIBS)-
/// > 1).
///
/// `pname`
///
/// > Specifies the property to be used for the query. For [**glGetVertexArrayIndexediv**](crate::context::Context::oxidegl_get_vertex_array_indexediv),
/// > it must be one of the following values: [`GL_VERTEX_ATTRIB_ARRAY_ENABLED`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_ENABLED),
/// > [`GL_VERTEX_ATTRIB_ARRAY_SIZE`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_SIZE),
/// > [`GL_VERTEX_ATTRIB_ARRAY_STRIDE`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_STRIDE),
/// > [`GL_VERTEX_ATTRIB_ARRAY_TYPE`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_TYPE),
/// > [`GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_NORMALIZED),
/// > [`GL_VERTEX_ATTRIB_ARRAY_INTEGER`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_INTEGER),
/// > [`GL_VERTEX_ATTRIB_ARRAY_LONG`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_LONG),
/// > [`GL_VERTEX_ATTRIB_ARRAY_DIVISOR`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_DIVISOR),
/// > or [`GL_VERTEX_ATTRIB_RELATIVE_OFFSET`](crate::enums::GL_VERTEX_ATTRIB_RELATIVE_OFFSET).
/// > For [**glGetVertexArrayIndexed64v**](crate::context::Context::oxidegl_get_vertex_array_indexed64v),
/// > it must be equal to [`GL_VERTEX_BINDING_OFFSET`](crate::enums::GL_VERTEX_BINDING_OFFSET).
///
/// `param`
///
/// > Returns the requested value.
///
/// ### Description
/// [**glGetVertexArrayIndexediv**](crate::context::Context::oxidegl_get_vertex_array_indexediv)
/// and [**glGetVertexArrayIndexed64iv**](crate::context::Context::oxidegl_get_vertex_array_indexed64iv)
/// provide a way of querying parameters of an attribute at an user-specified
/// index of a vertex array object. The vertex array object does not have to
/// be bound to the rendering context at the time of the call, but must have
/// been bound at least once prior to this call.
///
/// The following parameter values can be retrieved with [**glGetVertexArrayIndexediv**](crate::context::Context::oxidegl_get_vertex_array_indexediv)
/// for each of the attributes defined for a vertex array object:
///
/// > [`GL_VERTEX_ATTRIB_ARRAY_ENABLED`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_ENABLED):
/// > `param` returns a value that is non-zero (true) if the vertex attribute
/// > array for index is enabled and 0 (false) if it is disabled. The initial
/// > value is [`GL_FALSE`](crate::enums::GL_FALSE).
///
/// > [`GL_VERTEX_ATTRIB_ARRAY_SIZE`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_SIZE):
/// > `param` returns a single value, the size of the vertex attribute array
/// > for index. The size is the number of values for each element of the vertex
/// > attribute array, and it will be 1, 2, 3 or 4. The initial value is 4.
///
/// > [`GL_VERTEX_ATTRIB_ARRAY_STRIDE`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_STRIDE):
/// > `param` returns a single value, the array stride for (number of bytes between
/// > successive elements in) the vertex attribute array for index. A value of
/// > 0 indicates the array elements are stored sequentially in memory. The initial
/// > value is 0.
///
/// > [`GL_VERTEX_ATTRIB_ARRAY_TYPE`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_TYPE):
/// > `param` returns a single value, a symbolic constant indicating the array
/// > type for the vertex attribute array for index. Possible values are [`GL_BYTE`](crate::enums::GL_BYTE),
/// > [`GL_DOUBLE`](crate::enums::GL_DOUBLE), [`GL_FIXED`](crate::enums::GL_FIXED),
/// > [`GL_FLOAT`](crate::enums::GL_FLOAT), [`GL_HALF_FLOAT`](crate::enums::GL_HALF_FLOAT),
/// > [`GL_INT`](crate::enums::GL_INT), [`GL_INT_2_10_10_10_REV`](crate::enums::GL_INT_2_10_10_10_REV),
/// > [`GL_SHORT`](crate::enums::GL_SHORT), [`GL_UNSIGNED_BYTE`](crate::enums::GL_UNSIGNED_BYTE),
/// > [`GL_UNSIGNED_SHORT`](crate::enums::GL_UNSIGNED_SHORT), [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT),
/// > [`GL_UNSIGNED_INT_2_10_10_10_REV`](crate::enums::GL_UNSIGNED_INT_2_10_10_10_REV),
/// > and [`GL_UNSIGNED_INT_10F_11F_11F_REV`](crate::enums::GL_UNSIGNED_INT_10F_11F_11F_REV).
/// > The initial value is [`GL_FLOAT`](crate::enums::GL_FLOAT).
///
/// > [`GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_NORMALIZED):
/// > `param` returns a single value that is non-zero (true) if fixed-point data
/// > types for the vertex attribute array indicated by index are normalized
/// > when they are converted to floating-point, and 0 (false) otherwise. The
/// > initial value is [`GL_FALSE`](crate::enums::GL_FALSE).
///
/// > [`GL_VERTEX_ATTRIB_ARRAY_INTEGER`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_INTEGER):
/// > `param` returns a single value that is non-zero (true) if fixed-point data
/// > types for the vertex attribute array indicated by index have integer data
/// > type, and 0 (false) otherwise. The initial value is 0( [`GL_FALSE`](crate::enums::GL_FALSE)
/// > ).
///
/// > [`GL_VERTEX_ATTRIB_ARRAY_LONG`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_LONG):
/// > `param` returns a single value that is non-zero (true) if a vertex attribute
/// > is stored as an unconverted double, and 0 (false) otherwise. The initial
/// > value is 0( [`GL_FALSE`](crate::enums::GL_FALSE) ).
///
/// > [`GL_VERTEX_ATTRIB_ARRAY_DIVISOR`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_DIVISOR):
/// > `param` returns a single value that is the frequency divisor used for instanced
/// > rendering. See glVertexAttribDivisor. The initial value is 0.
///
/// > [`GL_VERTEX_ATTRIB_RELATIVE_OFFSET`](crate::enums::GL_VERTEX_ATTRIB_RELATIVE_OFFSET):
/// > `param` returns a single value that is the byte offset of the first element
/// > relative to the start of the vertex buffer binding specified attribute
/// > fetches from. The initial value is 0.
///
/// [**glGetVertexArrayIndexed64iv**](crate::context::Context::oxidegl_get_vertex_array_indexed64iv)
/// can be used to retrieve [`GL_VERTEX_BINDING_OFFSET`](crate::enums::GL_VERTEX_BINDING_OFFSET)
/// parameter value for any of the attributes defined for a vertex array object.
/// When `pname` is set to [`GL_VERTEX_BINDING_OFFSET`](crate::enums::GL_VERTEX_BINDING_OFFSET),
/// `param` returns a single value that is the byte offset of the first element
/// in the bound buffer's data store. The initial value for this parameter
/// is 0.
impl Context {
    pub unsafe fn oxidegl_get_vertex_array_indexediv(
        &mut self,
        vaobj: GLuint,
        index: GLuint,
        pname: VertexArrayPName,
        param: *mut GLint,
    ) {
        panic!("command oxidegl_get_vertex_array_indexediv not yet implemented");
    }
    pub unsafe fn oxidegl_get_vertex_array_indexed64iv(
        &mut self,
        vaobj: GLuint,
        index: GLuint,
        pname: VertexArrayPName,
        param: *mut GLint64,
    ) {
        panic!("command oxidegl_get_vertex_array_indexed64iv not yet implemented");
    }
}
/// ### Parameters
/// `index`
///
/// > Specifies the generic vertex attribute parameter to be queried.
///
/// `pname`
///
/// > Specifies the symbolic name of the vertex attribute parameter to be queried.
/// > Accepted values are [`GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING),
/// > [`GL_VERTEX_ATTRIB_ARRAY_ENABLED`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_ENABLED),
/// > [`GL_VERTEX_ATTRIB_ARRAY_SIZE`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_SIZE),
/// > [`GL_VERTEX_ATTRIB_ARRAY_STRIDE`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_STRIDE),
/// > [`GL_VERTEX_ATTRIB_ARRAY_TYPE`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_TYPE),
/// > [`GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_NORMALIZED),
/// > [`GL_VERTEX_ATTRIB_ARRAY_INTEGER`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_INTEGER),
/// > [`GL_VERTEX_ATTRIB_ARRAY_LONG`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_LONG),
/// > [`GL_VERTEX_ATTRIB_ARRAY_DIVISOR`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_DIVISOR),
/// > [`GL_VERTEX_ATTRIB_BINDING`](crate::enums::GL_VERTEX_ATTRIB_BINDING), [`GL_VERTEX_ATTRIB_RELATIVE_OFFSET`](crate::enums::GL_VERTEX_ATTRIB_RELATIVE_OFFSET)
/// > or [`GL_CURRENT_VERTEX_ATTRIB`](crate::enums::GL_CURRENT_VERTEX_ATTRIB).
///
/// `params`
///
/// > Returns the requested data.
///
/// ### Description
/// [**glGetVertexAttrib**](crate::context::Context::oxidegl_get_vertex_attrib)
/// returns in `params` the value of a generic vertex attribute parameter.
/// The generic vertex attribute to be queried is specified by `index`, and
/// the parameter to be queried is specified by `pname`.
///
/// The accepted parameter names are as follows:
///
/// [`GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING)
///
///
/// > `params` returns a single value, the name of the buffer object currently
/// > bound to the binding point corresponding to generic vertex attribute array
/// > `index`. If no buffer object is bound, 0 is returned. The initial value
/// > is 0.
///
/// [`GL_VERTEX_ATTRIB_ARRAY_ENABLED`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_ENABLED)
///
///
/// > `params` returns a single value that is non-zero (true) if the vertex attribute
/// > array for `index` is enabled and 0 (false) if it is disabled. The initial
/// > value is [`GL_FALSE`](crate::enums::GL_FALSE).
///
/// [`GL_VERTEX_ATTRIB_ARRAY_SIZE`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_SIZE)
///
///
/// > `params` returns a single value, the size of the vertex attribute array
/// > for `index`. The size is the number of values for each element of the vertex
/// > attribute array, and it will be 1, 2, 3, or 4. The initial value is 4.
///
/// [`GL_VERTEX_ATTRIB_ARRAY_STRIDE`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_STRIDE)
///
///
/// > `params` returns a single value, the array stride for (number of bytes
/// > between successive elements in) the vertex attribute array for `index`.
/// > A value of 0 indicates that the array elements are stored sequentially
/// > in memory. The initial value is 0.
///
/// [`GL_VERTEX_ATTRIB_ARRAY_TYPE`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_TYPE)
///
///
/// > `params` returns a single value, a symbolic constant indicating the array
/// > type for the vertex attribute array for `index`. Possible values are [`GL_BYTE`](crate::enums::GL_BYTE),
/// > [`GL_UNSIGNED_BYTE`](crate::enums::GL_UNSIGNED_BYTE), [`GL_SHORT`](crate::enums::GL_SHORT),
/// > [`GL_UNSIGNED_SHORT`](crate::enums::GL_UNSIGNED_SHORT), [`GL_INT`](crate::enums::GL_INT),
/// > [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT), [`GL_FLOAT`](crate::enums::GL_FLOAT),
/// > and [`GL_DOUBLE`](crate::enums::GL_DOUBLE). The initial value is [`GL_FLOAT`](crate::enums::GL_FLOAT).
///
/// [`GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_NORMALIZED)
///
///
/// > `params` returns a single value that is non-zero (true) if fixed-point
/// > data types for the vertex attribute array indicated by `index` are normalized
/// > when they are converted to floating point, and 0 (false) otherwise. The
/// > initial value is [`GL_FALSE`](crate::enums::GL_FALSE).
///
/// [`GL_VERTEX_ATTRIB_ARRAY_INTEGER`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_INTEGER)
///
///
/// > `params` returns a single value that is non-zero (true) if fixed-point
/// > data types for the vertex attribute array indicated by `index` have integer
/// > data types, and 0 (false) otherwise. The initial value is 0( [`GL_FALSE`](crate::enums::GL_FALSE)
/// > ).
///
/// [`GL_VERTEX_ATTRIB_ARRAY_LONG`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_LONG)
///
///
/// > `param` returns a single value that is non-zero (true) if a vertex attribute
/// > is stored as an unconverted double, and 0 (false) otherwise. The initial
/// > value is 0( [`GL_FALSE`](crate::enums::GL_FALSE) ).
///
/// [`GL_VERTEX_ATTRIB_ARRAY_DIVISOR`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_DIVISOR)
///
///
/// > `params` returns a single value that is the frequency divisor used for
/// > instanced rendering. See [**glVertexAttribDivisor**](crate::context::Context::oxidegl_vertex_attrib_divisor).
/// > The initial value is 0.
///
/// [`GL_VERTEX_ATTRIB_BINDING`](crate::enums::GL_VERTEX_ATTRIB_BINDING)
///
///
/// > `params` returns a single value, the vertex buffer binding of the vertex
/// > attribute array `index`.
///
/// [`GL_VERTEX_ATTRIB_RELATIVE_OFFSET`](crate::enums::GL_VERTEX_ATTRIB_RELATIVE_OFFSET)
///
///
/// > `params` returns a single value that is the byte offset of the first element
/// > relative to the start of the vertex buffer binding specified attribute
/// > fetches from. The initial value is 0.
///
/// [`GL_CURRENT_VERTEX_ATTRIB`](crate::enums::GL_CURRENT_VERTEX_ATTRIB)
///
///
/// > `params` returns four values that represent the current value for the generic
/// > vertex attribute specified by index. Generic vertex attribute 0 is unique
/// > in that it has no current state, so an error will be generated if `index`
/// > is 0. The initial value for all other generic vertex attributes is (0,0,0,1).
///
/// > [**glGetVertexAttribdv**](crate::context::Context::oxidegl_get_vertex_attribdv)
/// > and [**glGetVertexAttribfv**](crate::context::Context::oxidegl_get_vertex_attribfv)
/// > return the current attribute values as four single-precision floating-point
/// > values; [**glGetVertexAttribiv**](crate::context::Context::oxidegl_get_vertex_attribiv)
/// > reads them as floating-point values and converts them to four integer values;
/// > [**glGetVertexAttribIiv**](crate::context::Context::oxidegl_get_vertex_attrib_iiv)
/// > and [**glGetVertexAttribIuiv**](crate::context::Context::oxidegl_get_vertex_attrib_iuiv)
/// > read and return them as signed or unsigned integer values, respectively;
/// > [**glGetVertexAttribLdv**](crate::context::Context::oxidegl_get_vertex_attrib_ldv)
/// > reads and returns them as four double-precision floating-point values.
///
/// All of the parameters except [`GL_CURRENT_VERTEX_ATTRIB`](crate::enums::GL_CURRENT_VERTEX_ATTRIB)
/// represent state stored in the currently bound vertex array object.
///
/// ### Notes
/// If an error is generated, no change is made to the contents of `params`.
///
/// ### Associated Gets
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_VERTEX_ATTRIBS`](crate::enums::GL_MAX_VERTEX_ATTRIBS)
///
/// [**glGetVertexAttribPointerv**](crate::context::Context::oxidegl_get_vertex_attrib_pointerv)
/// with arguments `index` and [`GL_VERTEX_ATTRIB_ARRAY_POINTER`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_POINTER)
impl Context {
    pub unsafe fn oxidegl_get_vertex_attribdv(
        &mut self,
        index: GLuint,
        pname: VertexAttribProperty,
        params: *mut GLdouble,
    ) {
        panic!("command oxidegl_get_vertex_attribdv not yet implemented");
    }
    pub unsafe fn oxidegl_get_vertex_attribfv(
        &mut self,
        index: GLuint,
        pname: VertexAttribProperty,
        params: *mut GLfloat,
    ) {
        panic!("command oxidegl_get_vertex_attribfv not yet implemented");
    }
    pub unsafe fn oxidegl_get_vertex_attribiv(
        &mut self,
        index: GLuint,
        pname: VertexAttribProperty,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_vertex_attribiv not yet implemented");
    }
    pub unsafe fn oxidegl_get_vertex_attrib_iiv(
        &mut self,
        index: GLuint,
        pname: VertexAttribEnum,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_vertex_attrib_iiv not yet implemented");
    }
    pub unsafe fn oxidegl_get_vertex_attrib_iuiv(
        &mut self,
        index: GLuint,
        pname: VertexAttribEnum,
        params: *mut GLuint,
    ) {
        panic!("command oxidegl_get_vertex_attrib_iuiv not yet implemented");
    }
    pub unsafe fn oxidegl_get_vertex_attrib_ldv(
        &mut self,
        index: GLuint,
        pname: VertexAttribEnum,
        params: *mut GLdouble,
    ) {
        panic!("command oxidegl_get_vertex_attrib_ldv not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the framebuffer object is attached for [**glInvalidateFramebuffer**](crate::context::Context::oxidegl_invalidate_framebuffer).
///
/// `framebuffer`
///
/// > Specifies the name of the framebuffer object for [**glInvalidateNamedFramebufferData**](crate::context::Context::oxidegl_invalidate_named_framebuffer_data).
///
/// `numAttachments`
///
/// > Specifies the number of entries in the `attachments` array.
///
/// `attachments`
///
/// > Specifies a pointer to an array identifying the attachments to be invalidated.
///
/// ### Description
/// [**glInvalidateFramebuffer**](crate::context::Context::oxidegl_invalidate_framebuffer)
/// and [**glInvalidateNamedFramebufferData**](crate::context::Context::oxidegl_invalidate_named_framebuffer_data)
/// invalidate the entire contents of a specified set of attachments of a framebuffer.
///
/// For [**glInvalidateFramebuffer**](crate::context::Context::oxidegl_invalidate_framebuffer),
/// the framebuffer object is that bound to `target`. `target` must be [`GL_FRAMEBUFFER`](crate::enums::GL_FRAMEBUFFER),
/// [`GL_READ_FRAMEBUFFER`](crate::enums::GL_READ_FRAMEBUFFER) or [`GL_DRAW_FRAMEBUFFER`](crate::enums::GL_DRAW_FRAMEBUFFER).
/// [`GL_FRAMEBUFFER`](crate::enums::GL_FRAMEBUFFER) is equivalent to [`GL_DRAW_FRAMEBUFFER`](crate::enums::GL_DRAW_FRAMEBUFFER).
/// Default framebuffers may also be invalidated if bound to `target`.
///
/// For [**glInvalidateNamedFramebufferData**](crate::context::Context::oxidegl_invalidate_named_framebuffer_data),
/// `framebuffer` is the name of the framebuffer object. If `framebuffer` is
/// zero, the default draw framebuffer is affected.
///
/// The set of attachments whose contents are to be invalidated are specified
/// in the `attachments` array, which contains `numAttachments` elements.
///
/// If the specified framebuffer is a framebuffer object, each element of `attachments`
/// must be one of [`GL_DEPTH_ATTACHMENT`](crate::enums::GL_DEPTH_ATTACHMENT),
/// [`GL_STENCIL_ATTACHMENT`](crate::enums::GL_STENCIL_ATTACHMENT) [`GL_DEPTH_STENCIL_ATTACHMENT`](crate::enums::GL_DEPTH_STENCIL_ATTACHMENT),
/// or [`GL_COLOR_ATTACHMENT`](crate::enums::GL_COLOR_ATTACHMENT) *i*, where
/// *i* is between zero and the value of [`GL_MAX_FRAMEBUFFER_ATTACHMENTS`](crate::enums::GL_MAX_FRAMEBUFFER_ATTACHMENTS)
/// minus one.
///
/// If the specified framebuffer is a default framebuffer, each element of
/// `attachments` must be one of [`GL_FRONT_LEFT`](crate::enums::GL_FRONT_LEFT),
/// [`GL_FRONT_RIGHT`](crate::enums::GL_FRONT_RIGHT), [`GL_BACK_LEFT`](crate::enums::GL_BACK_LEFT),
/// [`GL_BACK_RIGHT`](crate::enums::GL_BACK_RIGHT), [`GL_AUX`](crate::enums::GL_AUX)
/// *i*, [`GL_ACCUM`](crate::enums::GL_ACCUM), [`GL_COLOR`](crate::enums::GL_COLOR),
/// [`GL_DEPTH`](crate::enums::GL_DEPTH), or [`GL_STENCIL`](crate::enums::GL_STENCIL).
/// [`GL_COLOR`](crate::enums::GL_COLOR), is treated as [`GL_BACK_LEFT`](crate::enums::GL_BACK_LEFT)
/// for a double-buffered context and [`GL_FRONT_LEFT`](crate::enums::GL_FRONT_LEFT)
/// for a single-buffered context. The other attachments identify the corresponding
/// specific buffer.
///
/// The entire contents of each specified attachment become undefined after
/// execution of [**glInvalidateFramebuffer**](crate::context::Context::oxidegl_invalidate_framebuffer)
/// or [**glInvalidateNamedFramebufferData**](crate::context::Context::oxidegl_invalidate_named_framebuffer_data).
///
/// If the framebuffer object is not complete, [**glInvalidateFramebuffer**](crate::context::Context::oxidegl_invalidate_framebuffer)
/// and [**glInvalidateNamedFramebufferData**](crate::context::Context::oxidegl_invalidate_named_framebuffer_data)
/// may be ignored. This is not an error.
///
/// ### Associated Gets
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_COLOR_ATTACHMENTS`](crate::enums::GL_MAX_COLOR_ATTACHMENTS)
impl Context {
    pub fn oxidegl_invalidate_framebuffer(
        &mut self,
        target: FramebufferTarget,
        num_attachments: GLsizei,
        attachments: InvalidateFramebufferAttachment,
    ) {
        panic!("command oxidegl_invalidate_framebuffer not yet implemented");
    }
    pub fn oxidegl_invalidate_named_framebuffer_data(
        &mut self,
        framebuffer: GLuint,
        num_attachments: GLsizei,
        attachments: FramebufferAttachment,
    ) {
        panic!("command oxidegl_invalidate_named_framebuffer_data not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the framebuffer object is attached for [**glInvalidateSubFramebuffer**](crate::context::Context::oxidegl_invalidate_sub_framebuffer).
///
/// `framebuffer`
///
/// > Specifies the name of the framebuffer object for [**glInvalidateNamedFramebufferSubData**](crate::context::Context::oxidegl_invalidate_named_framebuffer_sub_data).
///
/// `numAttachments`
///
/// > Specifies the number of entries in the `attachments` array.
///
/// `attachments`
///
/// > Specifies a pointer to an array identifying the attachments to be invalidated.
///
/// `x`
///
/// > Specifies the X offset of the region to be invalidated.
///
/// `y`
///
/// > Specifies the Y offset of the region to be invalidated.
///
/// `width`
///
/// > Specifies the width of the region to be invalidated.
///
/// `height`
///
/// > Specifies the height of the region to be invalidated.
///
/// ### Description
/// [**glInvalidateSubFramebuffer**](crate::context::Context::oxidegl_invalidate_sub_framebuffer)
/// and [**glInvalidateNamedFramebufferSubData**](crate::context::Context::oxidegl_invalidate_named_framebuffer_sub_data)
/// invalidate the contents of a specified region of a specified set of attachments
/// of a framebuffer.
///
/// For [**glInvalidateSubFramebuffer**](crate::context::Context::oxidegl_invalidate_sub_framebuffer),
/// the framebuffer object is that bound to `target`, which must be one of
/// [`GL_FRAMEBUFFER`](crate::enums::GL_FRAMEBUFFER), [`GL_READ_FRAMEBUFFER`](crate::enums::GL_READ_FRAMEBUFFER)
/// or [`GL_DRAW_FRAMEBUFFER`](crate::enums::GL_DRAW_FRAMEBUFFER). [`GL_FRAMEBUFFER`](crate::enums::GL_FRAMEBUFFER)
/// is equivalent to [`GL_DRAW_FRAMEBUFFER`](crate::enums::GL_DRAW_FRAMEBUFFER).
/// Default framebuffers may also be invalidated if bound to `target`.
///
/// For [**glInvalidateNamedFramebufferSubData**](crate::context::Context::oxidegl_invalidate_named_framebuffer_sub_data),
/// `framebuffer` is the name of the framebuffer object. If `framebuffer` is
/// zero, the default draw framebuffer is affected.
///
/// The set of attachments of which a region is to be invalidated are specified
/// in the `attachments` array, which contains `numAttachments` elements.
///
/// If the specified framebuffer is a framebuffer object, each element of `attachments`
/// must be one of [`GL_DEPTH_ATTACHMENT`](crate::enums::GL_DEPTH_ATTACHMENT),
/// [`GL_STENCIL_ATTACHMENT`](crate::enums::GL_STENCIL_ATTACHMENT) [`GL_DEPTH_STENCIL_ATTACHMENT`](crate::enums::GL_DEPTH_STENCIL_ATTACHMENT),
/// or [`GL_COLOR_ATTACHMENT`](crate::enums::GL_COLOR_ATTACHMENT) *i*, where
/// *i* is between zero and the value of [`GL_MAX_FRAMEBUFFER_ATTACHMENTS`](crate::enums::GL_MAX_FRAMEBUFFER_ATTACHMENTS)
/// minus one.
///
/// If the specified framebuffer is a default framebuffer, each element of
/// `attachments` must be one of [`GL_FRONT_LEFT`](crate::enums::GL_FRONT_LEFT),
/// [`GL_FRONT_RIGHT`](crate::enums::GL_FRONT_RIGHT), [`GL_BACK_LEFT`](crate::enums::GL_BACK_LEFT),
/// [`GL_BACK_RIGHT`](crate::enums::GL_BACK_RIGHT), [`GL_AUX`](crate::enums::GL_AUX)
/// *i*, [`GL_ACCUM`](crate::enums::GL_ACCUM), [`GL_COLOR`](crate::enums::GL_COLOR),
/// [`GL_DEPTH`](crate::enums::GL_DEPTH), or [`GL_STENCIL`](crate::enums::GL_STENCIL).
/// [`GL_COLOR`](crate::enums::GL_COLOR), is treated as [`GL_BACK_LEFT`](crate::enums::GL_BACK_LEFT)
/// for a double-buffered context and [`GL_FRONT_LEFT`](crate::enums::GL_FRONT_LEFT)
/// for a single-buffered context. The other attachments identify the corresponding
/// specific buffer.
///
/// The contents of the specified region of each specified attachment become
/// undefined after execution of [**glInvalidateSubFramebuffer**](crate::context::Context::oxidegl_invalidate_sub_framebuffer)
/// or [**glInvalidateNamedFramebufferSubData**](crate::context::Context::oxidegl_invalidate_named_framebuffer_sub_data).
/// The region to be invalidated is specified by `x`, `y`, `width` and `height`
/// where `x` and `y` give the offset from the origin (with lower-left corner
/// at $(0,0)$) and `width` and `height` are the width and height, respectively,
/// of the region. Any pixels lying outside of the window allocated to the
/// current GL context (for the default framebuffer), or outside of the attachments
/// of the framebuffer object, are ignored. If the framebuffer object is not
/// complete, these commands may be ignored.
///
/// If the framebuffer object is not complete, [**glInvalidateSubFramebuffer**](crate::context::Context::oxidegl_invalidate_sub_framebuffer)
/// and [**glInvalidateNamedFramebufferSubData**](crate::context::Context::oxidegl_invalidate_named_framebuffer_sub_data)
/// may be ignored. This is not an error.
///
/// ### Associated Gets
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_COLOR_ATTACHMENTS`](crate::enums::GL_MAX_COLOR_ATTACHMENTS)
impl Context {
    pub fn oxidegl_invalidate_sub_framebuffer(
        &mut self,
        target: FramebufferTarget,
        num_attachments: GLsizei,
        attachments: InvalidateFramebufferAttachment,
        x: GLint,
        y: GLint,
        width: GLsizei,
        height: GLsizei,
    ) {
        panic!("command oxidegl_invalidate_sub_framebuffer not yet implemented");
    }
    pub fn oxidegl_invalidate_named_framebuffer_sub_data(
        &mut self,
        framebuffer: GLuint,
        num_attachments: GLsizei,
        attachments: FramebufferAttachment,
        x: GLint,
        y: GLint,
        width: GLsizei,
        height: GLsizei,
    ) {
        panic!("command oxidegl_invalidate_named_framebuffer_sub_data not yet implemented");
    }
}
/// ### Parameters
/// `cap`
///
/// > Specifies a symbolic constant indicating a GL capability.
///
/// `index`
///
/// > Specifies the index of the capability.
///
/// ### Description
/// [**glIsEnabled**](crate::context::Context::oxidegl_is_enabled) returns
/// [`GL_TRUE`](crate::enums::GL_TRUE) if `cap` is an enabled capability and
/// returns [`GL_FALSE`](crate::enums::GL_FALSE) otherwise. Boolean states
/// that are indexed may be tested with [**glIsEnabledi**](crate::context::Context::oxidegl_is_enabledi).
/// For [**glIsEnabledi**](crate::context::Context::oxidegl_is_enabledi), `index`
/// specifies the index of the capability to test. `index` must be between
/// zero and the count of indexed capabilities for `cap`. Initially all capabilities
/// except [`GL_DITHER`](crate::enums::GL_DITHER) are disabled; [`GL_DITHER`](crate::enums::GL_DITHER)
/// is initially enabled.
///
/// The following capabilities are accepted for `cap`:
///
///
/// |* Constant*       |* See*    |
/// |------------------|----------|
/// | [`GL_BLEND`](crate::enums::GL_BLEND) | [**glBlendFunc**](crate::context::Context::oxidegl_blend_func), [**glLogicOp**](crate::context::Context::oxidegl_logic_op) |
/// | [`GL_CLIP_DISTANCE`](crate::enums::GL_CLIP_DISTANCE) *i* | [**glEnable**](crate::context::Context::oxidegl_enable) |
/// | [`GL_COLOR_LOGIC_OP`](crate::enums::GL_COLOR_LOGIC_OP) | [**glLogicOp**](crate::context::Context::oxidegl_logic_op) |
/// | [`GL_CULL_FACE`](crate::enums::GL_CULL_FACE) | [**glCullFace**](crate::context::Context::oxidegl_cull_face) |
/// | [`GL_DEPTH_CLAMP`](crate::enums::GL_DEPTH_CLAMP) | [**glEnable**](crate::context::Context::oxidegl_enable) |
/// | [`GL_DEBUG_OUTPUT`](crate::enums::GL_DEBUG_OUTPUT) | [**glEnable**](crate::context::Context::oxidegl_enable) |
/// | [`GL_DEBUG_OUTPUT_SYNCHRONOUS`](crate::enums::GL_DEBUG_OUTPUT_SYNCHRONOUS) | [**glEnable**](crate::context::Context::oxidegl_enable) |
/// | [`GL_DEPTH_TEST`](crate::enums::GL_DEPTH_TEST) | [**glDepthFunc**](crate::context::Context::oxidegl_depth_func), [**glDepthRange**](crate::context::Context::oxidegl_depth_range) |
/// | [`GL_DITHER`](crate::enums::GL_DITHER) | [**glEnable**](crate::context::Context::oxidegl_enable) |
/// | [`GL_FRAMEBUFFER_SRGB`](crate::enums::GL_FRAMEBUFFER_SRGB) | [**glEnable**](crate::context::Context::oxidegl_enable) |
/// | [`GL_LINE_SMOOTH`](crate::enums::GL_LINE_SMOOTH) | [**glLineWidth**](crate::context::Context::oxidegl_line_width) |
/// | [`GL_MULTISAMPLE`](crate::enums::GL_MULTISAMPLE) | [**glSampleCoverage**](crate::context::Context::oxidegl_sample_coverage) |
/// | [`GL_POLYGON_SMOOTH`](crate::enums::GL_POLYGON_SMOOTH) | [**glPolygonMode**](crate::context::Context::oxidegl_polygon_mode) |
/// | [`GL_POLYGON_OFFSET_FILL`](crate::enums::GL_POLYGON_OFFSET_FILL) | [**glPolygonOffset**](crate::context::Context::oxidegl_polygon_offset) |
/// | [`GL_POLYGON_OFFSET_LINE`](crate::enums::GL_POLYGON_OFFSET_LINE) | [**glPolygonOffset**](crate::context::Context::oxidegl_polygon_offset) |
/// | [`GL_POLYGON_OFFSET_POINT`](crate::enums::GL_POLYGON_OFFSET_POINT) | [**glPolygonOffset**](crate::context::Context::oxidegl_polygon_offset) |
/// | [`GL_PROGRAM_POINT_SIZE`](crate::enums::GL_PROGRAM_POINT_SIZE) | [**glEnable**](crate::context::Context::oxidegl_enable) |
/// | [`GL_PRIMITIVE_RESTART`](crate::enums::GL_PRIMITIVE_RESTART) | [**glEnable**](crate::context::Context::oxidegl_enable), [**glPrimitiveRestartIndex**](crate::context::Context::oxidegl_primitive_restart_index) |
/// | [`GL_PRIMITIVE_RESTART_FIXED_INDEX`](crate::enums::GL_PRIMITIVE_RESTART_FIXED_INDEX) | [**glEnable**](crate::context::Context::oxidegl_enable), |
/// | [`GL_SAMPLE_ALPHA_TO_COVERAGE`](crate::enums::GL_SAMPLE_ALPHA_TO_COVERAGE) | [**glSampleCoverage**](crate::context::Context::oxidegl_sample_coverage) |
/// | [`GL_SAMPLE_ALPHA_TO_ONE`](crate::enums::GL_SAMPLE_ALPHA_TO_ONE) | [**glSampleCoverage**](crate::context::Context::oxidegl_sample_coverage) |
/// | [`GL_SAMPLE_COVERAGE`](crate::enums::GL_SAMPLE_COVERAGE) | [**glSampleCoverage**](crate::context::Context::oxidegl_sample_coverage) |
/// | [`GL_SAMPLE_MASK`](crate::enums::GL_SAMPLE_MASK) | [**glEnable**](crate::context::Context::oxidegl_enable) |
/// | [`GL_SCISSOR_TEST`](crate::enums::GL_SCISSOR_TEST) | [**glScissor**](crate::context::Context::oxidegl_scissor) |
/// | [`GL_STENCIL_TEST`](crate::enums::GL_STENCIL_TEST) | [**glStencilFunc**](crate::context::Context::oxidegl_stencil_func), [**glStencilOp**](crate::context::Context::oxidegl_stencil_op) |
/// | [`GL_TEXTURE_CUBE_MAP_SEAMLESS`](crate::enums::GL_TEXTURE_CUBE_MAP_SEAMLESS) | [**glEnable**](crate::context::Context::oxidegl_enable) |
///
///
/// ### Notes
/// If an error is generated, [**glIsEnabled**](crate::context::Context::oxidegl_is_enabled)
/// and [**glIsEnabledi**](crate::context::Context::oxidegl_is_enabledi) return
/// [`GL_FALSE`](crate::enums::GL_FALSE).
///
/// [`GL_PRIMITIVE_RESTART_FIXED_INDEX`](crate::enums::GL_PRIMITIVE_RESTART_FIXED_INDEX)
/// are available only if the GL version is 4.3 or greater.
///
/// [`GL_DEBUG_OUTPUT`](crate::enums::GL_DEBUG_OUTPUT) and [`GL_DEBUG_OUTPUT_SYNCHRONOUS`](crate::enums::GL_DEBUG_OUTPUT_SYNCHRONOUS)
/// are available only if the GL version is 4.3 or greater.
impl Context {
    pub fn oxidegl_is_enabled(&mut self, cap: EnableCap) -> GLboolean {
        panic!("command oxidegl_is_enabled not yet implemented");
    }
    pub fn oxidegl_is_enabledi(&mut self, target: EnableCap, index: GLuint) -> GLboolean {
        panic!("command oxidegl_is_enabledi not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the buffer object is bound for [**glMapBuffer**](crate::context::Context::oxidegl_map_buffer),
/// > which must be one of the buffer binding targets in the following table:
///
/// > | *Buffer Binding Target*                               | *Purpose*      |
/// > |-------------------------------------------------------|----------------|
/// > | [`GL_ARRAY_BUFFER`](crate::enums::GL_ARRAY_BUFFER)    | Vertex attributes |
/// > | [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER) | Atomic counter storage |
/// > | [`GL_COPY_READ_BUFFER`](crate::enums::GL_COPY_READ_BUFFER) | Buffer copy source |
/// > | [`GL_COPY_WRITE_BUFFER`](crate::enums::GL_COPY_WRITE_BUFFER) | Buffer copy destination |
/// > | [`GL_DISPATCH_INDIRECT_BUFFER`](crate::enums::GL_DISPATCH_INDIRECT_BUFFER) | Indirect compute dispatch commands |
/// > | [`GL_DRAW_INDIRECT_BUFFER`](crate::enums::GL_DRAW_INDIRECT_BUFFER) | Indirect command arguments |
/// > | [`GL_ELEMENT_ARRAY_BUFFER`](crate::enums::GL_ELEMENT_ARRAY_BUFFER) | Vertex array indices |
/// > | [`GL_PIXEL_PACK_BUFFER`](crate::enums::GL_PIXEL_PACK_BUFFER) | Pixel read target |
/// > | [`GL_PIXEL_UNPACK_BUFFER`](crate::enums::GL_PIXEL_UNPACK_BUFFER) | Texture data source |
/// > | [`GL_QUERY_BUFFER`](crate::enums::GL_QUERY_BUFFER)    | Query result buffer |
/// > | [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER) | Read-write storage for shaders |
/// > | [`GL_TEXTURE_BUFFER`](crate::enums::GL_TEXTURE_BUFFER) | Texture data buffer |
/// > | [`GL_TRANSFORM_FEEDBACK_BUFFER`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER) | Transform feedback buffer |
/// > | [`GL_UNIFORM_BUFFER`](crate::enums::GL_UNIFORM_BUFFER) | Uniform block storage |
///
/// `buffer`
///
/// > Specifies the name of the buffer object for [**glMapNamedBuffer**](crate::context::Context::oxidegl_map_named_buffer).
///
/// `access`
///
/// > Specifies the access policy for [**glMapBuffer**](crate::context::Context::oxidegl_map_buffer)
/// > and [**glMapNamedBuffer**](crate::context::Context::oxidegl_map_named_buffer),
/// > indicating whether it will be possible to read from, write to, or both
/// > read from and write to the buffer object's mapped data store. The symbolic
/// > constant must be [`GL_READ_ONLY`](crate::enums::GL_READ_ONLY), [`GL_WRITE_ONLY`](crate::enums::GL_WRITE_ONLY),
/// > or [`GL_READ_WRITE`](crate::enums::GL_READ_WRITE).
///
/// ### Description
/// [**glMapBuffer**](crate::context::Context::oxidegl_map_buffer) and [**glMapNamedBuffer**](crate::context::Context::oxidegl_map_named_buffer)
/// map the entire data store of a specified buffer object into the client's
/// address space. The data can then be directly read and/or written relative
/// to the returned pointer, depending on the specified `access` policy.
///
/// A pointer to the beginning of the mapped range is returned once all pending
/// operations on that buffer object have completed, and may be used to modify
/// and/or query the corresponding range of the data store according to the
/// value of `access`: [`GL_READ_ONLY`](crate::enums::GL_READ_ONLY) indicates
/// > that the returned pointer may be used to read buffer object data.
///
/// > [`GL_WRITE_ONLY`](crate::enums::GL_WRITE_ONLY) indicates that the returned
/// > pointer may be used to modify buffer object data.
///
/// > [`GL_READ_WRITE`](crate::enums::GL_READ_WRITE) indicates that the returned
/// > pointer may be used to read and to modify buffer object data.
///
///
/// If an error is generated, a
///
/// If no error occurs, the returned pointer will reflect an allocation aligned
/// to the value of [`GL_MIN_MAP_BUFFER_ALIGNMENT`](crate::enums::GL_MIN_MAP_BUFFER_ALIGNMENT)
/// basic machine units.
///
/// The returned pointer values may not be passed as parameter values to GL
/// commands. For example, they may not be used to specify array pointers,
/// or to specify or query pixel or texture image data; such actions produce
/// undefined results, although implementations may not check for such behavior
/// for performance reasons.
///
/// No GL error is generated if the returned pointer is accessed in a way inconsistent
/// with `access` (e.g. used to read from a mapping made with `access` [`GL_WRITE_ONLY`](crate::enums::GL_WRITE_ONLY)
/// or write to a mapping made with `access` [`GL_READ_ONLY`](crate::enums::GL_READ_ONLY)
/// ), but the result is undefined and system errors (possibly including program
/// termination) may occur.
///
/// Mappings to the data stores of buffer objects may have nonstandard performance
/// characteristics. For example, such mappings may be marked as uncacheable
/// regions of memory, and in such cases reading from them may be very slow.
/// To ensure optimal performance, the client should use the mapping in a fashion
/// consistent with the values of [`GL_BUFFER_USAGE`](crate::enums::GL_BUFFER_USAGE)
/// for the buffer object and of `access`. Using a mapping in a fashion inconsistent
/// with these values is liable to be multiple orders of magnitude slower than
/// using normal memory.
///
/// ### Notes
/// Alignment of the returned pointer is guaranteed only if the version of
/// the GL version is 4.2 or greater. Also, the [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER)
/// target is accepted only if the GL version is 4.2 or greater.
///
/// The [`GL_DISPATCH_INDIRECT_BUFFER`](crate::enums::GL_DISPATCH_INDIRECT_BUFFER)
/// and [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER)
/// targets are available only if the GL version is 4.3 or greater.
///
/// The [`GL_QUERY_BUFFER`](crate::enums::GL_QUERY_BUFFER) target is available
/// only if the GL version is 4.4 or greater.
///
/// ### Associated Gets
/// [**glGetBufferPointerv**](crate::context::Context::oxidegl_get_buffer_pointerv)
/// with argument [`GL_BUFFER_MAP_POINTER`](crate::enums::GL_BUFFER_MAP_POINTER)
///
/// [**glGetBufferParameter**](crate::context::Context::oxidegl_get_buffer_parameter)
/// with argument [`GL_BUFFER_MAPPED`](crate::enums::GL_BUFFER_MAPPED), [`GL_BUFFER_ACCESS`](crate::enums::GL_BUFFER_ACCESS),
/// or [`GL_BUFFER_USAGE`](crate::enums::GL_BUFFER_USAGE)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with `pname` [`GL_MIN_MAP_BUFFER_ALIGNMENT`](crate::enums::GL_MIN_MAP_BUFFER_ALIGNMENT).
/// The value must be a power of two that is at least 64.
impl Context {
    pub fn oxidegl_map_buffer(
        &mut self,
        target: BufferTarget,
        access: BufferAccess,
    ) -> *mut GLvoid {
        panic!("command oxidegl_map_buffer not yet implemented");
    }
    pub fn oxidegl_map_named_buffer(
        &mut self,
        buffer: GLuint,
        access: BufferAccess,
    ) -> *mut GLvoid {
        panic!("command oxidegl_map_named_buffer not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the buffer object is bound for [**glMapBufferRange**](crate::context::Context::oxidegl_map_buffer_range),
/// > which must be one of the buffer binding targets in the following table:
///
/// > | *Buffer Binding Target*                               | *Purpose*      |
/// > |-------------------------------------------------------|----------------|
/// > | [`GL_ARRAY_BUFFER`](crate::enums::GL_ARRAY_BUFFER)    | Vertex attributes |
/// > | [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER) | Atomic counter storage |
/// > | [`GL_COPY_READ_BUFFER`](crate::enums::GL_COPY_READ_BUFFER) | Buffer copy source |
/// > | [`GL_COPY_WRITE_BUFFER`](crate::enums::GL_COPY_WRITE_BUFFER) | Buffer copy destination |
/// > | [`GL_DISPATCH_INDIRECT_BUFFER`](crate::enums::GL_DISPATCH_INDIRECT_BUFFER) | Indirect compute dispatch commands |
/// > | [`GL_DRAW_INDIRECT_BUFFER`](crate::enums::GL_DRAW_INDIRECT_BUFFER) | Indirect command arguments |
/// > | [`GL_ELEMENT_ARRAY_BUFFER`](crate::enums::GL_ELEMENT_ARRAY_BUFFER) | Vertex array indices |
/// > | [`GL_PIXEL_PACK_BUFFER`](crate::enums::GL_PIXEL_PACK_BUFFER) | Pixel read target |
/// > | [`GL_PIXEL_UNPACK_BUFFER`](crate::enums::GL_PIXEL_UNPACK_BUFFER) | Texture data source |
/// > | [`GL_QUERY_BUFFER`](crate::enums::GL_QUERY_BUFFER)    | Query result buffer |
/// > | [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER) | Read-write storage for shaders |
/// > | [`GL_TEXTURE_BUFFER`](crate::enums::GL_TEXTURE_BUFFER) | Texture data buffer |
/// > | [`GL_TRANSFORM_FEEDBACK_BUFFER`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER) | Transform feedback buffer |
/// > | [`GL_UNIFORM_BUFFER`](crate::enums::GL_UNIFORM_BUFFER) | Uniform block storage |
///
/// `buffer`
///
/// > Specifies the name of the buffer object for [**glMapNamedBufferRange**](crate::context::Context::oxidegl_map_named_buffer_range).
///
/// `offset`
///
/// > Specifies the starting offset within the buffer of the range to be mapped.
///
/// `length`
///
/// > Specifies the length of the range to be mapped.
///
/// `access`
///
/// > Specifies a combination of access flags indicating the desired access to
/// > the mapped range.
///
/// ### Description
/// [**glMapBufferRange**](crate::context::Context::oxidegl_map_buffer_range)
/// and [**glMapNamedBufferRange**](crate::context::Context::oxidegl_map_named_buffer_range)
/// map all or part of the data store of a specified buffer object into the
/// client's address space. `offset` and `length` indicate the range of data
/// in the buffer object that is to be mapped, in terms of basic machine units.
/// `access` is a bitfield containing flags which describe the requested mapping.
/// These flags are described below.
///
/// A pointer to the beginning of the mapped range is returned once all pending
/// operations on the buffer object have completed, and may be used to modify
/// and/or query the corresponding range of the data store according to the
/// following flag bits set in `access`: [`GL_MAP_READ_BIT`](crate::enums::GL_MAP_READ_BIT)
/// > indicates that the returned pointer may be used to read buffer object data.
/// > No GL error is generated if the pointer is used to query a mapping which
/// > excludes this flag, but the result is undefined and system errors (possibly
/// > including program termination) may occur.
///
/// > [`GL_MAP_WRITE_BIT`](crate::enums::GL_MAP_WRITE_BIT) indicates that the
/// > returned pointer may be used to modify buffer object data. No GL error
/// > is generated if the pointer is used to modify a mapping which excludes
/// > this flag, but the result is undefined and system errors (possibly including
/// > program termination) may occur.
///
/// > [`GL_MAP_PERSISTENT_BIT`](crate::enums::GL_MAP_PERSISTENT_BIT) indicates
/// > that the mapping is to be made in a persistent fashion and that the client
/// > intends to hold and use the returned pointer during subsequent GL operation.
/// > It is not an error to call drawing commands (render) while buffers are
/// > mapped using this flag. It is an error to specify this flag if the buffer's
/// > data store was not allocated through a call to the [**glBufferStorage**](crate::context::Context::oxidegl_buffer_storage)
/// > command in which the [`GL_MAP_PERSISTENT_BIT`](crate::enums::GL_MAP_PERSISTENT_BIT)
/// > was also set.
///
/// > [`GL_MAP_COHERENT_BIT`](crate::enums::GL_MAP_COHERENT_BIT) indicates that
/// > a persistent mapping is also to be coherent. Coherent maps guarantee that
/// > the effect of writes to a buffer's data store by either the client or server
/// > will eventually become visible to the other without further intervention
/// > from the application. In the absence of this bit, persistent mappings are
/// > not coherent and modified ranges of the buffer store must be explicitly
/// > communicated to the GL, either by unmapping the buffer, or through a call
/// > to [**glFlushMappedBufferRange**](crate::context::Context::oxidegl_flush_mapped_buffer_range)
/// > or [**glMemoryBarrier**](crate::context::Context::oxidegl_memory_barrier).
///
///
/// The following *optional* flag bits in `access` may be used to modify the
/// mapping: [`GL_MAP_INVALIDATE_RANGE_BIT`](crate::enums::GL_MAP_INVALIDATE_RANGE_BIT)
/// > indicates that the previous contents of the specified range may be discarded.
/// > Data within this range are undefined with the exception of subsequently
/// > written data. No GL error is generated if subsequent GL operations access
/// > unwritten data, but the result is undefined and system errors (possibly
/// > including program termination) may occur. This flag may not be used in
/// > combination with [`GL_MAP_READ_BIT`](crate::enums::GL_MAP_READ_BIT).
///
/// > [`GL_MAP_INVALIDATE_BUFFER_BIT`](crate::enums::GL_MAP_INVALIDATE_BUFFER_BIT)
/// > indicates that the previous contents of the entire buffer may be discarded.
/// > Data within the entire buffer are undefined with the exception of subsequently
/// > written data. No GL error is generated if subsequent GL operations access
/// > unwritten data, but the result is undefined and system errors (possibly
/// > including program termination) may occur. This flag may not be used in
/// > combination with [`GL_MAP_READ_BIT`](crate::enums::GL_MAP_READ_BIT).
///
/// > [`GL_MAP_FLUSH_EXPLICIT_BIT`](crate::enums::GL_MAP_FLUSH_EXPLICIT_BIT)
/// > indicates that one or more discrete subranges of the mapping may be modified.
/// > When this flag is set, modifications to each subrange must be explicitly
/// > flushed by calling [**glFlushMappedBufferRange**](crate::context::Context::oxidegl_flush_mapped_buffer_range).
/// > No GL error is set if a subrange of the mapping is modified and not flushed,
/// > but data within the corresponding subrange of the buffer are undefined.
/// > This flag may only be used in conjunction with [`GL_MAP_WRITE_BIT`](crate::enums::GL_MAP_WRITE_BIT).
/// > When this option is selected, flushing is strictly limited to regions
/// > that are explicitly indicated with calls to [**glFlushMappedBufferRange**](crate::context::Context::oxidegl_flush_mapped_buffer_range)
/// > prior to unmap; if this option is not selected [**glUnmapBuffer**](crate::context::Context::oxidegl_unmap_buffer)
/// > will automatically flush the entire mapped range when called.
///
/// > [`GL_MAP_UNSYNCHRONIZED_BIT`](crate::enums::GL_MAP_UNSYNCHRONIZED_BIT)
/// > indicates that the GL should not attempt to synchronize pending operations
/// > on the buffer prior to returning from [**glMapBufferRange**](crate::context::Context::oxidegl_map_buffer_range)
/// > or [**glMapNamedBufferRange**](crate::context::Context::oxidegl_map_named_buffer_range).
/// > No GL error is generated if pending operations which source or modify
/// > the buffer overlap the mapped region, but the result of such previous and
/// > any subsequent operations is undefined.
///
///
/// If an error occurs, a
///
/// If no error occurs, the returned pointer will reflect an allocation aligned
/// to the value of [`GL_MIN_MAP_BUFFER_ALIGNMENT`](crate::enums::GL_MIN_MAP_BUFFER_ALIGNMENT)
/// basic machine units. Subtracting `offset` from this returned pointer will
/// always produce a multiple of the value of [`GL_MIN_MAP_BUFFER_ALIGNMENT`](crate::enums::GL_MIN_MAP_BUFFER_ALIGNMENT).
///
/// The returned pointer values may not be passed as parameter values to GL
/// commands. For example, they may not be used to specify array pointers,
/// or to specify or query pixel or texture image data; such actions produce
/// undefined results, although implementations may not check for such behavior
/// for performance reasons.
///
/// Mappings to the data stores of buffer objects may have nonstandard performance
/// characteristics. For example, such mappings may be marked as uncacheable
/// regions of memory, and in such cases reading from them may be very slow.
/// To ensure optimal performance, the client should use the mapping in a fashion
/// consistent with the values of [`GL_BUFFER_USAGE`](crate::enums::GL_BUFFER_USAGE)
/// for the buffer object and of `access`. Using a mapping in a fashion inconsistent
/// with these values is liable to be multiple orders of magnitude slower than
/// using normal memory.
///
/// ### Notes
/// Alignment of the returned pointer is guaranteed only if the version of
/// the GL version is 4.2 or greater. Also, the [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER)
/// target is accepted only if the GL version is 4.2 or greater.
///
/// The [`GL_DISPATCH_INDIRECT_BUFFER`](crate::enums::GL_DISPATCH_INDIRECT_BUFFER)
/// and [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER)
/// targets are accepted only if the GL version is 4.3 or greater.
///
/// The [`GL_QUERY_BUFFER`](crate::enums::GL_QUERY_BUFFER) target is available
/// only if the GL version is 4.4 or greater.
///
/// The [`GL_MAP_PERSISTENT_BIT`](crate::enums::GL_MAP_PERSISTENT_BIT) and
/// [`GL_MAP_COHERENT_BIT`](crate::enums::GL_MAP_COHERENT_BIT) flags are available
/// only if the GL version is 4.4 or greater.
///
/// ### Associated Gets
/// [**glGet**](crate::context::Context::oxidegl_get) with `pname` [`GL_MIN_MAP_BUFFER_ALIGNMENT`](crate::enums::GL_MIN_MAP_BUFFER_ALIGNMENT).
/// The value must be a power of two that is at least 64.
impl Context {
    pub fn oxidegl_map_buffer_range(
        &mut self,
        target: BufferTarget,
        offset: GLintptr,
        length: GLsizeiptr,
        access: MapBufferAccessMask,
    ) -> *mut GLvoid {
        panic!("command oxidegl_map_buffer_range not yet implemented");
    }
    pub fn oxidegl_map_named_buffer_range(
        &mut self,
        buffer: GLuint,
        offset: GLintptr,
        length: GLsizeiptr,
        access: MapBufferAccessMask,
    ) -> *mut GLvoid {
        panic!("command oxidegl_map_named_buffer_range not yet implemented");
    }
}
/// ### Parameters
/// `barriers`
///
/// > Specifies the barriers to insert.
///
/// > For [**glMemoryBarrier**](crate::context::Context::oxidegl_memory_barrier),
/// > must be a bitwise combination of any of [`GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT),
/// > [`GL_ELEMENT_ARRAY_BARRIER_BIT`](crate::enums::GL_ELEMENT_ARRAY_BARRIER_BIT),
/// > [`GL_UNIFORM_BARRIER_BIT`](crate::enums::GL_UNIFORM_BARRIER_BIT), [`GL_TEXTURE_FETCH_BARRIER_BIT`](crate::enums::GL_TEXTURE_FETCH_BARRIER_BIT),
/// > [`GL_SHADER_IMAGE_ACCESS_BARRIER_BIT`](crate::enums::GL_SHADER_IMAGE_ACCESS_BARRIER_BIT),
/// > [`GL_COMMAND_BARRIER_BIT`](crate::enums::GL_COMMAND_BARRIER_BIT), [`GL_PIXEL_BUFFER_BARRIER_BIT`](crate::enums::GL_PIXEL_BUFFER_BARRIER_BIT),
/// > [`GL_TEXTURE_UPDATE_BARRIER_BIT`](crate::enums::GL_TEXTURE_UPDATE_BARRIER_BIT),
/// > [`GL_BUFFER_UPDATE_BARRIER_BIT`](crate::enums::GL_BUFFER_UPDATE_BARRIER_BIT),
/// > [`GL_FRAMEBUFFER_BARRIER_BIT`](crate::enums::GL_FRAMEBUFFER_BARRIER_BIT),
/// > [`GL_TRANSFORM_FEEDBACK_BARRIER_BIT`](crate::enums::GL_TRANSFORM_FEEDBACK_BARRIER_BIT),
/// > [`GL_ATOMIC_COUNTER_BARRIER_BIT`](crate::enums::GL_ATOMIC_COUNTER_BARRIER_BIT),
/// > or [`GL_SHADER_STORAGE_BARRIER_BIT`](crate::enums::GL_SHADER_STORAGE_BARRIER_BIT).
///
/// > For [**glMemoryBarrier**](crate::context::Context::oxidegl_memory_barrier),
/// > must be a bitwise combination of any of [`GL_ATOMIC_COUNTER_BARRIER_BIT`](crate::enums::GL_ATOMIC_COUNTER_BARRIER_BIT),
/// > or [`GL_FRAMEBUFFER_BARRIER_BIT`](crate::enums::GL_FRAMEBUFFER_BARRIER_BIT),
/// > [`GL_SHADER_IMAGE_ACCESS_BARRIER_BIT`](crate::enums::GL_SHADER_IMAGE_ACCESS_BARRIER_BIT),
/// > [`GL_SHADER_STORAGE_BARRIER_BIT`](crate::enums::GL_SHADER_STORAGE_BARRIER_BIT).
/// > [`GL_TEXTURE_FETCH_BARRIER_BIT`](crate::enums::GL_TEXTURE_FETCH_BARRIER_BIT),
/// > or [`GL_UNIFORM_BARRIER_BIT`](crate::enums::GL_UNIFORM_BARRIER_BIT).
///
/// > If the special value [`GL_ALL_BARRIER_BITS`](crate::enums::GL_ALL_BARRIER_BITS)
/// > is specified, all supported barriers for the corresponding command will
/// > be inserted.
///
/// ### Description
/// [**glMemoryBarrier**](crate::context::Context::oxidegl_memory_barrier)
/// defines a barrier ordering the memory transactions issued prior to the
/// command relative to those issued after the barrier. For the purposes of
/// this ordering, memory transactions performed by shaders are considered
/// to be issued by the rendering command that triggered the execution of the
/// shader. `barriers` is a bitfield indicating the set of operations that
/// are synchronized with shader stores; the bits used in `barriers` are as
/// follows:
///
/// [`GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT)
///
/// > If set, vertex data sourced from buffer objects after the barrier will
/// > reflect data written by shaders prior to the barrier. The set of buffer
/// > objects affected by this bit is derived from the buffer object bindings
/// > used for generic vertex attributes derived from the [`GL_VERTEX_ATTRIB_ARRAY_BUFFER`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_BUFFER)
/// > bindings.
///
/// [`GL_ELEMENT_ARRAY_BARRIER_BIT`](crate::enums::GL_ELEMENT_ARRAY_BARRIER_BIT)
///
/// > If set, vertex array indices sourced from buffer objects after the barrier
/// > will reflect data written by shaders prior to the barrier. The buffer objects
/// > affected by this bit are derived from the [`GL_ELEMENT_ARRAY_BUFFER`](crate::enums::GL_ELEMENT_ARRAY_BUFFER)
/// > binding.
///
/// [`GL_UNIFORM_BARRIER_BIT`](crate::enums::GL_UNIFORM_BARRIER_BIT)
///
/// > Shader uniforms sourced from buffer objects after the barrier will reflect
/// > data written by shaders prior to the barrier.
///
/// [`GL_TEXTURE_FETCH_BARRIER_BIT`](crate::enums::GL_TEXTURE_FETCH_BARRIER_BIT)
///
/// > Texture fetches from shaders, including fetches from buffer object memory
/// > via buffer textures, after the barrier will reflect data written by shaders
/// > prior to the barrier.
///
/// [`GL_SHADER_IMAGE_ACCESS_BARRIER_BIT`](crate::enums::GL_SHADER_IMAGE_ACCESS_BARRIER_BIT)
///
/// > Memory accesses using shader image load, store, and atomic built-in functions
/// > issued after the barrier will reflect data written by shaders prior to
/// > the barrier. Additionally, image stores and atomics issued after the barrier
/// > will not execute until all memory accesses (e.g., loads, stores, texture
/// > fetches, vertex fetches) initiated prior to the barrier complete.
///
/// [`GL_COMMAND_BARRIER_BIT`](crate::enums::GL_COMMAND_BARRIER_BIT)
///
/// > Command data sourced from buffer objects by Draw*Indirect commands after
/// > the barrier will reflect data written by shaders prior to the barrier.
/// > The buffer objects affected by this bit are derived from the [`GL_DRAW_INDIRECT_BUFFER`](crate::enums::GL_DRAW_INDIRECT_BUFFER)
/// > binding.
///
/// [`GL_PIXEL_BUFFER_BARRIER_BIT`](crate::enums::GL_PIXEL_BUFFER_BARRIER_BIT)
///
/// > Reads and writes of buffer objects via the [`GL_PIXEL_PACK_BUFFER`](crate::enums::GL_PIXEL_PACK_BUFFER)
/// > and [`GL_PIXEL_UNPACK_BUFFER`](crate::enums::GL_PIXEL_UNPACK_BUFFER) bindings
/// > (via [**glReadPixels**](crate::context::Context::oxidegl_read_pixels), [**glTexSubImage1D**](crate::context::Context::oxidegl_tex_sub_image1_d),
/// > etc.) after the barrier will reflect data written by shaders prior to
/// > the barrier. Additionally, buffer object writes issued after the barrier
/// > will wait on the completion of all shader writes initiated prior to the
/// > barrier.
///
/// [`GL_TEXTURE_UPDATE_BARRIER_BIT`](crate::enums::GL_TEXTURE_UPDATE_BARRIER_BIT)
///
/// > Writes to a texture via [**glTex(Sub)Image***](crate::context::Context::oxidegl_tex(_sub)_image*),
/// > [**glCopyTex(Sub)Image***](crate::context::Context::oxidegl_copy_tex(_sub)_image*),
/// > [**glCompressedTex(Sub)Image***](crate::context::Context::oxidegl_compressed_tex(_sub)_image*),
/// > and reads via [**glGetTexImage**](crate::context::Context::oxidegl_get_tex_image)
/// > after the barrier will reflect data written by shaders prior to the barrier.
/// > Additionally, texture writes from these commands issued after the barrier
/// > will not execute until all shader writes initiated prior to the barrier
/// > complete.
///
/// [`GL_BUFFER_UPDATE_BARRIER_BIT`](crate::enums::GL_BUFFER_UPDATE_BARRIER_BIT)
///
/// > Reads or writes via [**glBufferSubData**](crate::context::Context::oxidegl_buffer_sub_data),
/// > [**glCopyBufferSubData**](crate::context::Context::oxidegl_copy_buffer_sub_data),
/// > or [**glGetBufferSubData**](crate::context::Context::oxidegl_get_buffer_sub_data),
/// > or to buffer object memory mapped by [**glMapBuffer**](crate::context::Context::oxidegl_map_buffer)
/// > or [**glMapBufferRange**](crate::context::Context::oxidegl_map_buffer_range)
/// > after the barrier will reflect data written by shaders prior to the barrier.
/// > Additionally, writes via these commands issued after the barrier will wait
/// > on the completion of any shader writes to the same memory initiated prior
/// > to the barrier.
///
/// [`GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT`](crate::enums::GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT)
///
/// > Access by the client to persistent mapped regions of buffer objects will
/// > reflect data written by shaders prior to the barrier. Note that this may
/// > cause additional synchronization operations.
///
/// [`GL_FRAMEBUFFER_BARRIER_BIT`](crate::enums::GL_FRAMEBUFFER_BARRIER_BIT)
///
/// > Reads and writes via framebuffer object attachments after the barrier will
/// > reflect data written by shaders prior to the barrier. Additionally, framebuffer
/// > writes issued after the barrier will wait on the completion of all shader
/// > writes issued prior to the barrier.
///
/// [`GL_TRANSFORM_FEEDBACK_BARRIER_BIT`](crate::enums::GL_TRANSFORM_FEEDBACK_BARRIER_BIT)
///
/// > Writes via transform feedback bindings after the barrier will reflect data
/// > written by shaders prior to the barrier. Additionally, transform feedback
/// > writes issued after the barrier will wait on the completion of all shader
/// > writes issued prior to the barrier.
///
/// [`GL_ATOMIC_COUNTER_BARRIER_BIT`](crate::enums::GL_ATOMIC_COUNTER_BARRIER_BIT)
///
/// > Accesses to atomic counters after the barrier will reflect writes prior
/// > to the barrier.
///
/// [`GL_SHADER_STORAGE_BARRIER_BIT`](crate::enums::GL_SHADER_STORAGE_BARRIER_BIT)
///
/// > Accesses to shader storage blocks after the barrier will reflect writes
/// > prior to the barrier.
///
/// [`GL_QUERY_BUFFER_BARRIER_BIT`](crate::enums::GL_QUERY_BUFFER_BARRIER_BIT)
///
/// > Writes of buffer objects via the [`GL_QUERY_BUFFER`](crate::enums::GL_QUERY_BUFFER)
/// > binding after the barrier will reflect data written by shaders prior to
/// > the barrier. Additionally, buffer object writes issued after the barrier
/// > will wait on the completion of all shader writes initiated prior to the
/// > barrier.
///
///
/// If `barriers` is [`GL_ALL_BARRIER_BITS`](crate::enums::GL_ALL_BARRIER_BITS),
/// shader memory accesses will be synchronized relative to all the operations
/// described above.
///
/// Implementations may cache buffer object and texture image memory that could
/// be written by shaders in multiple caches; for example, there may be separate
/// caches for texture, vertex fetching, and one or more caches for shader
/// memory accesses. Implementations are not required to keep these caches
/// coherent with shader memory writes. Stores issued by one invocation may
/// not be immediately observable by other pipeline stages or other shader
/// invocations because the value stored may remain in a cache local to the
/// processor executing the store, or because data overwritten by the store
/// is still in a cache elsewhere in the system. When [**glMemoryBarrier**](crate::context::Context::oxidegl_memory_barrier)
/// is called, the GL flushes and/or invalidates any caches relevant to the
/// operations specified by the `barriers` parameter to ensure consistent ordering
/// of operations across the barrier.
///
/// To allow for independent shader invocations to communicate by reads and
/// writes to a common memory address, image variables in the OpenGL Shading
/// Language may be declared as "coherent". Buffer object or texture image
/// memory accessed through such variables may be cached only if caches are
/// automatically updated due to stores issued by any other shader invocation.
/// If the same address is accessed using both coherent and non-coherent variables,
/// the accesses using variables declared as coherent will observe the results
/// stored using coherent variables in other invocations. Using variables declared
/// as "coherent" guarantees only that the results of stores will be immediately
/// visible to shader invocations using similarly-declared variables; calling
/// [**glMemoryBarrier**](crate::context::Context::oxidegl_memory_barrier)
/// is required to ensure that the stores are visible to other operations.
///
/// The following guidelines may be helpful in choosing when to use coherent
/// memory accesses and when to use barriers.
///
/// > Data that are read-only or constant may be accessed without using coherent
/// > variables or calling [**MemoryBarrier**](crate::context::Context::oxide_memory_barrier)
/// > (). Updates to the read-only data via API calls such as [**glBufferSubData**](crate::context::Context::oxidegl_buffer_sub_data)
/// > will invalidate shader caches implicitly as required.
///
/// > Data that are shared between shader invocations at a fine granularity (e.g.,
/// > written by one invocation, consumed by another invocation) should use coherent
/// > variables to read and write the shared data.
///
/// > Data written by one shader invocation and consumed by other shader invocations
/// > launched as a result of its execution ("dependent invocations") should
/// > use coherent variables in the producing shader invocation and call [**memoryBarrier**](crate::context::Context::oxidememory_barrier)
/// > () after the last write. The consuming shader invocation should also use
/// > coherent variables.
///
/// > Data written to image variables in one rendering pass and read by the shader
/// > in a later pass need not use coherent variables or memoryBarrier(). Calling
/// > [**glMemoryBarrier**](crate::context::Context::oxidegl_memory_barrier)
/// > with the SHADER_IMAGE_ACCESS_BARRIER_BIT set in `barriers` between passes
/// > is necessary.
///
/// > Data written by the shader in one rendering pass and read by another mechanism
/// > (e.g., vertex or index buffer pulling) in a later pass need not use coherent
/// > variables or [**memoryBarrier**](crate::context::Context::oxidememory_barrier)
/// > (). Calling [**glMemoryBarrier**](crate::context::Context::oxidegl_memory_barrier)
/// > with the appropriate bits set in `barriers` between passes is necessary.
///
///
/// ### Notes
/// [`GL_SHADER_STORAGE_BARRIER_BIT`](crate::enums::GL_SHADER_STORAGE_BARRIER_BIT)
/// is available only if the GL version is 4.3 or higher.
///
/// [`GL_QUERY_BUFFER_BARRIER_BIT`](crate::enums::GL_QUERY_BUFFER_BARRIER_BIT)
/// is available only if the GL version is 4.4 or higher.
impl Context {
    pub fn oxidegl_memory_barrier(&mut self, barriers: MemoryBarrierMask) {
        panic!("command oxidegl_memory_barrier not yet implemented");
    }
    pub fn oxidegl_memory_barrier_by_region(&mut self, barriers: MemoryBarrierMask) {
        panic!("command oxidegl_memory_barrier_by_region not yet implemented");
    }
}
/// ### Parameters
/// `pname`
///
/// > Specifies the name of the parameter to set. The symbolc constants [`GL_PATCH_VERTICES`](crate::enums::GL_PATCH_VERTICES),
/// > [`GL_PATCH_DEFAULT_OUTER_LEVEL`](crate::enums::GL_PATCH_DEFAULT_OUTER_LEVEL),
/// > and [`GL_PATCH_DEFAULT_INNER_LEVEL`](crate::enums::GL_PATCH_DEFAULT_INNER_LEVEL)
/// > are accepted.
///
/// `value`
///
/// > Specifies the new value for the parameter given by `pname`.
///
/// `values`
///
/// > Specifies the address of an array containing the new values for the parameter
/// > given by `pname`.
///
/// ### Description
/// [**glPatchParameter**](crate::context::Context::oxidegl_patch_parameter)
/// specifies the parameters that will be used for patch primitives. `pname`
/// specifies the parameter to modify and must be either [`GL_PATCH_VERTICES`](crate::enums::GL_PATCH_VERTICES),
/// [`GL_PATCH_DEFAULT_OUTER_LEVEL`](crate::enums::GL_PATCH_DEFAULT_OUTER_LEVEL)
/// or [`GL_PATCH_DEFAULT_INNER_LEVEL`](crate::enums::GL_PATCH_DEFAULT_INNER_LEVEL).
/// For [**glPatchParameteri**](crate::context::Context::oxidegl_patch_parameteri),
/// `value` specifies the new value for the parameter specified by `pname`.
/// For [**glPatchParameterfv**](crate::context::Context::oxidegl_patch_parameterfv),
/// `values` specifies the address of an array containing the new values for
/// the parameter specified by `pname`.
///
/// When `pname` is [`GL_PATCH_VERTICES`](crate::enums::GL_PATCH_VERTICES),
/// `value` specifies the number of vertices that will be used to make up a
/// single patch primitive. Patch primitives are consumed by the tessellation
/// control shader (if present) and subsequently used for tessellation. When
/// primitives are specified using [**glDrawArrays**](crate::context::Context::oxidegl_draw_arrays)
/// or a similar function, each patch will be made from `parameter` control
/// points, each represented by a vertex taken from the enabeld vertex arrays.
/// `parameter` must be greater than zero, and less than or equal to the value
/// of [`GL_MAX_PATCH_VERTICES`](crate::enums::GL_MAX_PATCH_VERTICES).
///
/// When `pname` is [`GL_PATCH_DEFAULT_OUTER_LEVEL`](crate::enums::GL_PATCH_DEFAULT_OUTER_LEVEL)
/// or [`GL_PATCH_DEFAULT_INNER_LEVEL`](crate::enums::GL_PATCH_DEFAULT_INNER_LEVEL),
/// `values` contains the address of an array contiaining the default outer
/// or inner tessellation levels, respectively, to be used when no tessellation
/// control shader is present.
impl Context {
    pub fn oxidegl_patch_parameteri(&mut self, pname: PatchParameterName, value: GLint) {
        panic!("command oxidegl_patch_parameteri not yet implemented");
    }
    pub unsafe fn oxidegl_patch_parameterfv(
        &mut self,
        pname: PatchParameterName,
        values: *const GLfloat,
    ) {
        panic!("command oxidegl_patch_parameterfv not yet implemented");
    }
}
/// ### Parameters
/// `pname`
///
/// > Specifies the symbolic name of the parameter to be set. Six values affect
/// > the packing of pixel data into memory: [`GL_PACK_SWAP_BYTES`](crate::enums::GL_PACK_SWAP_BYTES),
/// > [`GL_PACK_LSB_FIRST`](crate::enums::GL_PACK_LSB_FIRST), [`GL_PACK_ROW_LENGTH`](crate::enums::GL_PACK_ROW_LENGTH),
/// > [`GL_PACK_IMAGE_HEIGHT`](crate::enums::GL_PACK_IMAGE_HEIGHT), [`GL_PACK_SKIP_PIXELS`](crate::enums::GL_PACK_SKIP_PIXELS),
/// > [`GL_PACK_SKIP_ROWS`](crate::enums::GL_PACK_SKIP_ROWS), [`GL_PACK_SKIP_IMAGES`](crate::enums::GL_PACK_SKIP_IMAGES),
/// > and [`GL_PACK_ALIGNMENT`](crate::enums::GL_PACK_ALIGNMENT). Six more affect
/// > the unpacking of pixel data *from* memory: [`GL_UNPACK_SWAP_BYTES`](crate::enums::GL_UNPACK_SWAP_BYTES),
/// > [`GL_UNPACK_LSB_FIRST`](crate::enums::GL_UNPACK_LSB_FIRST), [`GL_UNPACK_ROW_LENGTH`](crate::enums::GL_UNPACK_ROW_LENGTH),
/// > [`GL_UNPACK_IMAGE_HEIGHT`](crate::enums::GL_UNPACK_IMAGE_HEIGHT), [`GL_UNPACK_SKIP_PIXELS`](crate::enums::GL_UNPACK_SKIP_PIXELS),
/// > [`GL_UNPACK_SKIP_ROWS`](crate::enums::GL_UNPACK_SKIP_ROWS), [`GL_UNPACK_SKIP_IMAGES`](crate::enums::GL_UNPACK_SKIP_IMAGES),
/// > and [`GL_UNPACK_ALIGNMENT`](crate::enums::GL_UNPACK_ALIGNMENT).
///
/// `param`
///
/// > Specifies the value that `pname` is set to.
///
/// ### Description
/// [**glPixelStore**](crate::context::Context::oxidegl_pixel_store) sets pixel
/// storage modes that affect the operation of subsequent [**glReadPixels**](crate::context::Context::oxidegl_read_pixels)
/// as well as the unpacking of texture patterns (see [**glTexImage1D**](crate::context::Context::oxidegl_tex_image1_d),
/// [**glTexImage2D**](crate::context::Context::oxidegl_tex_image2_d), [**glTexImage3D**](crate::context::Context::oxidegl_tex_image3_d),
/// [**glTexSubImage1D**](crate::context::Context::oxidegl_tex_sub_image1_d),
/// [**glTexSubImage2D**](crate::context::Context::oxidegl_tex_sub_image2_d),
/// [**glTexSubImage3D**](crate::context::Context::oxidegl_tex_sub_image3_d)
/// ), [**glCompressedTexImage1D**](crate::context::Context::oxidegl_compressed_tex_image1_d),
/// [**glCompressedTexImage2D**](crate::context::Context::oxidegl_compressed_tex_image2_d),
/// [**glCompressedTexImage3D**](crate::context::Context::oxidegl_compressed_tex_image3_d),
/// [**glCompressedTexSubImage1D**](crate::context::Context::oxidegl_compressed_tex_sub_image1_d),
/// [**glCompressedTexSubImage2D**](crate::context::Context::oxidegl_compressed_tex_sub_image2_d)
/// or [**glCompressedTexSubImage1D**](crate::context::Context::oxidegl_compressed_tex_sub_image1_d).
///
/// `pname` is a symbolic constant indicating the parameter to be set, and
/// `param` is the new value. Six of the twelve storage parameters affect how
/// pixel data is returned to client memory. They are as follows:
///
/// [`GL_PACK_SWAP_BYTES`](crate::enums::GL_PACK_SWAP_BYTES)
///
/// > If true, byte ordering for multibyte color components, depth components,
/// > or stencil indices is reversed. That is, if a four-byte component consists
/// > of bytes `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]`
/// > `[inlineq]` `[inlineq]` [`GL_PACK_SWAP_BYTES`](crate::enums::GL_PACK_SWAP_BYTES)
/// > is true. [`GL_PACK_SWAP_BYTES`](crate::enums::GL_PACK_SWAP_BYTES) has no
/// > effect on the memory order of components within a pixel, only on the order
/// > of bytes within components or indices. For example, the three components
/// > of a [`GL_RGB`](crate::enums::GL_RGB) format pixel are always stored with
/// > red first, green second, and blue third, regardless of the value of [`GL_PACK_SWAP_BYTES`](crate::enums::GL_PACK_SWAP_BYTES).
///
/// [`GL_PACK_LSB_FIRST`](crate::enums::GL_PACK_LSB_FIRST)
///
/// > If true, bits are ordered within a byte from least significant to most
/// > significant; otherwise, the first bit in each byte is the most significant
/// > one.
///
/// [`GL_PACK_ROW_LENGTH`](crate::enums::GL_PACK_ROW_LENGTH)
///
/// > If greater than 0, [`GL_PACK_ROW_LENGTH`](crate::enums::GL_PACK_ROW_LENGTH)
/// > defines the number of pixels in a row. If the first pixel of a row is placed
/// > at location `[inlineq]`
///
///
/// > components or indices, where `[inlineq]` `[inlineq]` [`GL_PACK_ROW_LENGTH`](crate::enums::GL_PACK_ROW_LENGTH)
/// > if it is greater than 0, the `[inlineq]` `[inlineq]` [`GL_PACK_ALIGNMENT`](crate::enums::GL_PACK_ALIGNMENT),
/// > and `[inlineq]` `[inlineq]` `[inlineq]`
///
/// > `[inlineq]`
///
/// > components or indices.
///
/// > The word *component* in this description refers to the nonindex values
/// > red, green, blue, alpha, and depth. Storage format [`GL_RGB`](crate::enums::GL_RGB),
/// > for example, has three components per pixel: first red, then green, and
/// > finally blue.
///
/// [`GL_PACK_IMAGE_HEIGHT`](crate::enums::GL_PACK_IMAGE_HEIGHT)
///
/// > If greater than 0, [`GL_PACK_IMAGE_HEIGHT`](crate::enums::GL_PACK_IMAGE_HEIGHT)
/// > defines the number of pixels in an image three-dimensional texture volume,
/// > where ``image`` is defined by all pixels sharing the same third dimension
/// > index. If the first pixel of a row is placed at location `[inlineq]`
///
///
/// > components or indices, where `[inlineq]` `[inlineq]` [`GL_PACK_ROW_LENGTH`](crate::enums::GL_PACK_ROW_LENGTH)
/// > if it is greater than 0, the `[inlineq]` [**glTexImage3D**](crate::context::Context::oxidegl_tex_image3_d)
/// > otherwise), `[inlineq]` [`GL_PACK_IMAGE_HEIGHT`](crate::enums::GL_PACK_IMAGE_HEIGHT)
/// > if it is greater than 0, the `[inlineq]` [**glTexImage3D**](crate::context::Context::oxidegl_tex_image3_d)
/// > routine otherwise), `[inlineq]` [`GL_PACK_ALIGNMENT`](crate::enums::GL_PACK_ALIGNMENT),
/// > and `[inlineq]` `[inlineq]` `[inlineq]`
///
/// > The word *component* in this description refers to the nonindex values
/// > red, green, blue, alpha, and depth. Storage format [`GL_RGB`](crate::enums::GL_RGB),
/// > for example, has three components per pixel: first red, then green, and
/// > finally blue.
///
/// [`GL_PACK_SKIP_PIXELS`](crate::enums::GL_PACK_SKIP_PIXELS), [`GL_PACK_SKIP_ROWS`](crate::enums::GL_PACK_SKIP_ROWS),
/// and [`GL_PACK_SKIP_IMAGES`](crate::enums::GL_PACK_SKIP_IMAGES)
///
/// > These values are provided as a convenience to the programmer; they provide
/// > no functionality that cannot be duplicated simply by incrementing the pointer
/// > passed to [**glReadPixels**](crate::context::Context::oxidegl_read_pixels).
/// > Setting [`GL_PACK_SKIP_PIXELS`](crate::enums::GL_PACK_SKIP_PIXELS) to
/// > `[inlineq]` `[inlineq]` `[inlineq]` [`GL_PACK_SKIP_ROWS`](crate::enums::GL_PACK_SKIP_ROWS)
/// > to `[inlineq]` `[inlineq]` `[inlineq]` [`GL_PACK_ROW_LENGTH`](crate::enums::GL_PACK_ROW_LENGTH)
/// > section. Setting [`GL_PACK_SKIP_IMAGES`](crate::enums::GL_PACK_SKIP_IMAGES)
/// > to `[inlineq]` `[inlineq]` `[inlineq]` [`GL_PACK_IMAGE_HEIGHT`](crate::enums::GL_PACK_IMAGE_HEIGHT)
/// > section.
///
/// [`GL_PACK_ALIGNMENT`](crate::enums::GL_PACK_ALIGNMENT)
///
/// > Specifies the alignment requirements for the start of each pixel row in
/// > memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to
/// > even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word
/// > boundaries).
///
/// The other six of the twelve storage parameters affect how pixel data is
/// read from client memory. These values are significant for [**glTexImage1D**](crate::context::Context::oxidegl_tex_image1_d),
/// [**glTexImage2D**](crate::context::Context::oxidegl_tex_image2_d), [**glTexImage3D**](crate::context::Context::oxidegl_tex_image3_d),
/// [**glTexSubImage1D**](crate::context::Context::oxidegl_tex_sub_image1_d),
/// [**glTexSubImage2D**](crate::context::Context::oxidegl_tex_sub_image2_d),
/// and [**glTexSubImage3D**](crate::context::Context::oxidegl_tex_sub_image3_d)
///
/// They are as follows:
///
/// [`GL_UNPACK_SWAP_BYTES`](crate::enums::GL_UNPACK_SWAP_BYTES)
///
/// > If true, byte ordering for multibyte color components, depth components,
/// > or stencil indices is reversed. That is, if a four-byte component consists
/// > of bytes `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]`
/// > `[inlineq]` `[inlineq]` [`GL_UNPACK_SWAP_BYTES`](crate::enums::GL_UNPACK_SWAP_BYTES)
/// > is true. [`GL_UNPACK_SWAP_BYTES`](crate::enums::GL_UNPACK_SWAP_BYTES) has
/// > no effect on the memory order of components within a pixel, only on the
/// > order of bytes within components or indices. For example, the three components
/// > of a [`GL_RGB`](crate::enums::GL_RGB) format pixel are always stored with
/// > red first, green second, and blue third, regardless of the value of [`GL_UNPACK_SWAP_BYTES`](crate::enums::GL_UNPACK_SWAP_BYTES).
///
/// [`GL_UNPACK_LSB_FIRST`](crate::enums::GL_UNPACK_LSB_FIRST)
///
/// > If true, bits are ordered within a byte from least significant to most
/// > significant; otherwise, the first bit in each byte is the most significant
/// > one.
///
/// [`GL_UNPACK_ROW_LENGTH`](crate::enums::GL_UNPACK_ROW_LENGTH)
///
/// > If greater than 0, [`GL_UNPACK_ROW_LENGTH`](crate::enums::GL_UNPACK_ROW_LENGTH)
/// > defines the number of pixels in a row. If the first pixel of a row is placed
/// > at location `[inlineq]`
///
///
/// > components or indices, where `[inlineq]` `[inlineq]` [`GL_UNPACK_ROW_LENGTH`](crate::enums::GL_UNPACK_ROW_LENGTH)
/// > if it is greater than 0, the `[inlineq]` `[inlineq]` [`GL_UNPACK_ALIGNMENT`](crate::enums::GL_UNPACK_ALIGNMENT),
/// > and `[inlineq]` `[inlineq]` `[inlineq]`
///
/// > `[inlineq]`
///
/// > components or indices.
///
/// > The word *component* in this description refers to the nonindex values
/// > red, green, blue, alpha, and depth. Storage format [`GL_RGB`](crate::enums::GL_RGB),
/// > for example, has three components per pixel: first red, then green, and
/// > finally blue.
///
/// [`GL_UNPACK_IMAGE_HEIGHT`](crate::enums::GL_UNPACK_IMAGE_HEIGHT)
///
/// > If greater than 0, [`GL_UNPACK_IMAGE_HEIGHT`](crate::enums::GL_UNPACK_IMAGE_HEIGHT)
/// > defines the number of pixels in an image of a three-dimensional texture
/// > volume. Where ``image`` is defined by all pixel sharing the same third
/// > dimension index. If the first pixel of a row is placed at location `[inlineq]`
///
///
/// > components or indices, where `[inlineq]` `[inlineq]` [`GL_UNPACK_ROW_LENGTH`](crate::enums::GL_UNPACK_ROW_LENGTH)
/// > if it is greater than 0, the `[inlineq]` [**glTexImage3D**](crate::context::Context::oxidegl_tex_image3_d)
/// > otherwise), `[inlineq]` [`GL_UNPACK_IMAGE_HEIGHT`](crate::enums::GL_UNPACK_IMAGE_HEIGHT)
/// > if it is greater than 0, the `[inlineq]` [**glTexImage3D**](crate::context::Context::oxidegl_tex_image3_d)
/// > otherwise), `[inlineq]` [`GL_UNPACK_ALIGNMENT`](crate::enums::GL_UNPACK_ALIGNMENT),
/// > and `[inlineq]` `[inlineq]` `[inlineq]`
///
/// > The word *component* in this description refers to the nonindex values
/// > red, green, blue, alpha, and depth. Storage format [`GL_RGB`](crate::enums::GL_RGB),
/// > for example, has three components per pixel: first red, then green, and
/// > finally blue.
///
/// [`GL_UNPACK_SKIP_PIXELS`](crate::enums::GL_UNPACK_SKIP_PIXELS) and [`GL_UNPACK_SKIP_ROWS`](crate::enums::GL_UNPACK_SKIP_ROWS)
///
/// > These values are provided as a convenience to the programmer; they provide
/// > no functionality that cannot be duplicated by incrementing the pointer
/// > passed to [**glTexImage1D**](crate::context::Context::oxidegl_tex_image1_d),
/// > [**glTexImage2D**](crate::context::Context::oxidegl_tex_image2_d), [**glTexSubImage1D**](crate::context::Context::oxidegl_tex_sub_image1_d)
/// > or [**glTexSubImage2D**](crate::context::Context::oxidegl_tex_sub_image2_d).
/// > Setting [`GL_UNPACK_SKIP_PIXELS`](crate::enums::GL_UNPACK_SKIP_PIXELS)
/// > to `[inlineq]` `[inlineq]` `[inlineq]` [`GL_UNPACK_SKIP_ROWS`](crate::enums::GL_UNPACK_SKIP_ROWS)
/// > to `[inlineq]` `[inlineq]` `[inlineq]` [`GL_UNPACK_ROW_LENGTH`](crate::enums::GL_UNPACK_ROW_LENGTH)
/// > section.
///
/// [`GL_UNPACK_ALIGNMENT`](crate::enums::GL_UNPACK_ALIGNMENT)
///
/// > Specifies the alignment requirements for the start of each pixel row in
/// > memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to
/// > even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word
/// > boundaries).
///
/// The following table gives the type, initial value, and range of valid values
/// for each storage parameter that can be set with [**glPixelStore**](crate::context::Context::oxidegl_pixel_store).
///
///
/// |**  |* Type*     |* Initial Value*                           |* Valid Range*        |
/// |----|------------|-------------------------------------------|----------------------|
/// | [`GL_PACK_SWAP_BYTES`](crate::enums::GL_PACK_SWAP_BYTES) | boolean | false | true or false |
/// | [`GL_PACK_LSB_FIRST`](crate::enums::GL_PACK_LSB_FIRST) | boolean | false | true or false |
/// | [`GL_PACK_ROW_LENGTH`](crate::enums::GL_PACK_ROW_LENGTH) | integer | 0 | `[inlineq]` |
/// | [`GL_PACK_IMAGE_HEIGHT`](crate::enums::GL_PACK_IMAGE_HEIGHT) | integer | 0 | `[inlineq]` |
/// | [`GL_PACK_SKIP_ROWS`](crate::enums::GL_PACK_SKIP_ROWS) | integer | 0 | `[inlineq]` |
/// | [`GL_PACK_SKIP_PIXELS`](crate::enums::GL_PACK_SKIP_PIXELS) | integer | 0 | `[inlineq]` |
/// | [`GL_PACK_SKIP_IMAGES`](crate::enums::GL_PACK_SKIP_IMAGES) | integer | 0 | `[inlineq]` |
/// | [`GL_PACK_ALIGNMENT`](crate::enums::GL_PACK_ALIGNMENT) | integer | 4 | 1, 2, 4, or 8 |
/// | [`GL_UNPACK_SWAP_BYTES`](crate::enums::GL_UNPACK_SWAP_BYTES) | boolean | false | true or false |
/// | [`GL_UNPACK_LSB_FIRST`](crate::enums::GL_UNPACK_LSB_FIRST) | boolean | false | true or false |
/// | [`GL_UNPACK_ROW_LENGTH`](crate::enums::GL_UNPACK_ROW_LENGTH) | integer | 0 | `[inlineq]` |
/// | [`GL_UNPACK_IMAGE_HEIGHT`](crate::enums::GL_UNPACK_IMAGE_HEIGHT) | integer | 0 | `[inlineq]` |
/// | [`GL_UNPACK_SKIP_ROWS`](crate::enums::GL_UNPACK_SKIP_ROWS) | integer | 0 | `[inlineq]` |
/// | [`GL_UNPACK_SKIP_PIXELS`](crate::enums::GL_UNPACK_SKIP_PIXELS) | integer | 0 | `[inlineq]` |
/// | [`GL_UNPACK_SKIP_IMAGES`](crate::enums::GL_UNPACK_SKIP_IMAGES) | integer | 0 | `[inlineq]` |
/// | [`GL_UNPACK_ALIGNMENT`](crate::enums::GL_UNPACK_ALIGNMENT) | integer | 4 | 1, 2, 4, or 8 |
///
/// [**glPixelStoref**](crate::context::Context::oxidegl_pixel_storef) can
/// be used to set any pixel store parameter. If the parameter type is boolean,
/// then if `param` is 0, the parameter is false; otherwise it is set to true.
/// If `pname` is an integer type parameter, `param` is rounded to the nearest
/// integer.
///
/// Likewise, [**glPixelStorei**](crate::context::Context::oxidegl_pixel_storei)
/// can also be used to set any of the pixel store parameters. Boolean parameters
/// are set to false if `param` is 0 and true otherwise.
///
/// ### Associated Gets
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_PACK_SWAP_BYTES`](crate::enums::GL_PACK_SWAP_BYTES)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_PACK_LSB_FIRST`](crate::enums::GL_PACK_LSB_FIRST)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_PACK_ROW_LENGTH`](crate::enums::GL_PACK_ROW_LENGTH)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_PACK_IMAGE_HEIGHT`](crate::enums::GL_PACK_IMAGE_HEIGHT)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_PACK_SKIP_ROWS`](crate::enums::GL_PACK_SKIP_ROWS)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_PACK_SKIP_PIXELS`](crate::enums::GL_PACK_SKIP_PIXELS)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_PACK_SKIP_IMAGES`](crate::enums::GL_PACK_SKIP_IMAGES)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_PACK_ALIGNMENT`](crate::enums::GL_PACK_ALIGNMENT)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_UNPACK_SWAP_BYTES`](crate::enums::GL_UNPACK_SWAP_BYTES)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_UNPACK_LSB_FIRST`](crate::enums::GL_UNPACK_LSB_FIRST)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_UNPACK_ROW_LENGTH`](crate::enums::GL_UNPACK_ROW_LENGTH)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_UNPACK_IMAGE_HEIGHT`](crate::enums::GL_UNPACK_IMAGE_HEIGHT)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_UNPACK_SKIP_ROWS`](crate::enums::GL_UNPACK_SKIP_ROWS)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_UNPACK_SKIP_PIXELS`](crate::enums::GL_UNPACK_SKIP_PIXELS)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_UNPACK_SKIP_IMAGES`](crate::enums::GL_UNPACK_SKIP_IMAGES)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_UNPACK_ALIGNMENT`](crate::enums::GL_UNPACK_ALIGNMENT)
impl Context {
    pub fn oxidegl_pixel_storef(&mut self, pname: PixelStoreParameter, param: GLfloat) {
        panic!("command oxidegl_pixel_storef not yet implemented");
    }
    pub fn oxidegl_pixel_storei(&mut self, pname: PixelStoreParameter, param: GLint) {
        panic!("command oxidegl_pixel_storei not yet implemented");
    }
}
/// ### Parameters
/// `pname`
///
/// > Specifies a single-valued point parameter. [`GL_POINT_FADE_THRESHOLD_SIZE`](crate::enums::GL_POINT_FADE_THRESHOLD_SIZE),
/// > and [`GL_POINT_SPRITE_COORD_ORIGIN`](crate::enums::GL_POINT_SPRITE_COORD_ORIGIN)
/// > are accepted.
///
/// `param`
///
/// > For [**glPointParameterf**](crate::context::Context::oxidegl_point_parameterf)
/// > and [**glPointParameteri**](crate::context::Context::oxidegl_point_parameteri),
/// > specifies the value that `pname` will be set to.
///
/// `params`
///
/// > For [**glPointParameterfv**](crate::context::Context::oxidegl_point_parameterfv)
/// > and [**glPointParameteriv**](crate::context::Context::oxidegl_point_parameteriv),
/// > specifies a pointer to an array where the value or values to be assigned
/// > to `pname` are stored.
///
/// ### Description
/// The following values are accepted for `pname`:
///
/// [`GL_POINT_FADE_THRESHOLD_SIZE`](crate::enums::GL_POINT_FADE_THRESHOLD_SIZE)
///
///
/// > `params` is a single floating-point value that specifies the threshold
/// > value to which point sizes are clamped if they exceed the specified value.
/// > The default value is 1.0.
///
/// [`GL_POINT_SPRITE_COORD_ORIGIN`](crate::enums::GL_POINT_SPRITE_COORD_ORIGIN)
///
///
/// > `params` is a single enum specifying the point sprite texture coordinate
/// > origin, either [`GL_LOWER_LEFT`](crate::enums::GL_LOWER_LEFT) or [`GL_UPPER_LEFT`](crate::enums::GL_UPPER_LEFT).
/// > The default value is [`GL_UPPER_LEFT`](crate::enums::GL_UPPER_LEFT).
///
/// ### Associated Gets
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_POINT_FADE_THRESHOLD_SIZE`](crate::enums::GL_POINT_FADE_THRESHOLD_SIZE)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_POINT_SPRITE_COORD_ORIGIN`](crate::enums::GL_POINT_SPRITE_COORD_ORIGIN)
impl Context {
    pub fn oxidegl_point_parameterf(&mut self, pname: GLenum, param: GLfloat) {
        panic!("command oxidegl_point_parameterf not yet implemented");
    }
    pub unsafe fn oxidegl_point_parameterfv(&mut self, pname: GLenum, params: *const GLfloat) {
        panic!("command oxidegl_point_parameterfv not yet implemented");
    }
    pub fn oxidegl_point_parameteri(&mut self, pname: GLenum, param: GLint) {
        panic!("command oxidegl_point_parameteri not yet implemented");
    }
    pub unsafe fn oxidegl_point_parameteriv(&mut self, pname: GLenum, params: *const GLint) {
        panic!("command oxidegl_point_parameteriv not yet implemented");
    }
}
/// ### Parameters
/// `program`
///
/// > Specifies the handle of the program containing the uniform variable to
/// > be modified.
///
/// `location`
///
/// > Specifies the location of the uniform variable to be modified.
///
/// `count`
///
/// > For the vector commands( [**glProgramUniform*v**](crate::context::Context::oxidegl_program_uniform*v)
/// > ), specifies the number of elements that are to be modified. This should
/// > be 1 if the targeted uniform variable is not an array, and 1 or more if
/// > it is an array.
///
/// > For the matrix commands( [**glProgramUniformMatrix***](crate::context::Context::oxidegl_program_uniform_matrix*)
/// > ), specifies the number of matrices that are to be modified. This should
/// > be 1 if the targeted uniform variable is not an array of matrices, and
/// > 1 or more if it is an array of matrices.
///
/// `transpose`
///
/// > For the matrix commands, specifies whether to transpose the matrix as the
/// > values are loaded into the uniform variable.
///
/// `v0`, `v1`, `v2`, `v3`
///
/// > For the scalar commands, specifies the new values to be used for the specified
/// > uniform variable.
///
/// `value`
///
/// > For the vector and matrix commands, specifies a pointer to an array of
/// > `count` values that will be used to update the specified uniform variable.
///
/// ### Description
/// [**glProgramUniform**](crate::context::Context::oxidegl_program_uniform)
/// modifies the value of a uniform variable or a uniform variable array. The
/// location of the uniform variable to be modified is specified by `location`,
/// which should be a value returned by [**glGetUniformLocation**](crate::context::Context::oxidegl_get_uniform_location).
/// [**glProgramUniform**](crate::context::Context::oxidegl_program_uniform)
/// operates on the program object specified by `program`.
///
/// The commands [**glProgramUniform{1|2|3|4}{f|i|ui}**](crate::context::Context::oxidegl_program_uniform{1|2|3|4}{f|i|ui})
/// are used to change the value of the uniform variable specified by `location`
/// using the values passed as arguments. The number specified in the command
/// should match the number of components in the data type of the specified
/// uniform variable (e.g., [**1**](crate::context::Context::oxide1) for [**2**](crate::context::Context::oxide2)
/// for [**f**](crate::context::Context::oxidef) indicates that floating-point
/// values are being passed; the suffix [**i**](crate::context::Context::oxidei)
/// indicates that integer values are being passed; the suffix [**ui**](crate::context::Context::oxideui)
/// indicates that unsigned integer values are being passed, and this type
/// should also match the data type of the specified uniform variable. The
/// [**i**](crate::context::Context::oxidei) variants of this function should
/// be used to provide values for uniform variables defined as [**ui**](crate::context::Context::oxideui)
/// variants of this function should be used to provide values for uniform
/// variables defined as [**f**](crate::context::Context::oxidef) variants
/// should be used to provide values for uniform variables of type [**i**](crate::context::Context::oxidei),
/// [**ui**](crate::context::Context::oxideui) or [**f**](crate::context::Context::oxidef)
/// variants may be used to provide values for uniform variables of type
///
/// All active uniform variables defined in a program object are initialized
/// to 0 when the program object is linked successfully. They retain the values
/// assigned to them by a call to [**glProgramUniform**](crate::context::Context::oxidegl_program_uniform)
/// until the next successful link operation occurs on the program object,
/// when they are once again initialized to 0.
///
/// The commands [**glProgramUniform{1|2|3|4}{f|i|ui}v**](crate::context::Context::oxidegl_program_uniform{1|2|3|4}{f|i|ui}v)
/// can be used to modify a single uniform variable or a uniform variable array.
/// These commands pass a count and a pointer to the values to be loaded into
/// a uniform variable or a uniform variable array. A count of 1 should be
/// used if modifying the value of a single uniform variable, and a count of
/// 1 or greater can be used to modify an entire array or part of an array.
/// When loading *n* elements starting at an arbitrary position *m* in a uniform
/// variable array, elements *m*+ *n*- 1 in the array will be replaced with
/// the new values. If `m`+ `n`- 1 is larger than the size of the uniform variable
/// array, values for all array elements beyond the end of the array will be
/// ignored. The number specified in the name of the command indicates the
/// number of components for each element in `value`, and it should match the
/// number of components in the data type of the specified uniform variable
/// (e.g., [**1**](crate::context::Context::oxide1) for [**2**](crate::context::Context::oxide2)
/// for [**glProgramUniform{1|2|3|4}{f|i|ui}**](crate::context::Context::oxidegl_program_uniform{1|2|3|4}{f|i|ui}).
///
/// For uniform variable arrays, each element of the array is considered to
/// be of the type indicated in the name of the command (e.g., [**glProgramUniform3f**](crate::context::Context::oxidegl_program_uniform3f)
/// or [**glProgramUniform3fv**](crate::context::Context::oxidegl_program_uniform3fv)
/// can be used to load a uniform variable array of type vec3). The number
/// of elements of the uniform variable array to be modified is specified by
/// `count`
///
/// The commands [**glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv**](crate::context::Context::oxidegl_program_uniform_matrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv)
/// are used to modify a matrix or an array of matrices. The numbers in the
/// command name are interpreted as the dimensionality of the matrix. The number
/// [**2**](crate::context::Context::oxide2) indicates a 2 × 2 matrix (i.e.,
/// 4 values), the number [**3**](crate::context::Context::oxide3) indicates
/// a 3 × 3 matrix (i.e., 9 values), and the number [**4**](crate::context::Context::oxide4)
/// indicates a 4 × 4 matrix (i.e., 16 values). Non-square matrix dimensionality
/// is explicit, with the first number representing the number of columns and
/// the second number representing the number of rows. For example, [**2x4**](crate::context::Context::oxide2x4)
/// indicates a 2 × 4 matrix with 2 columns and 4 rows (i.e., 8 values). If
/// `transpose` is [`GL_FALSE`](crate::enums::GL_FALSE), each matrix is assumed
/// to be supplied in column major order. If `transpose` is [`GL_TRUE`](crate::enums::GL_TRUE),
/// each matrix is assumed to be supplied in row major order. The `count`
/// argument indicates the number of matrices to be passed. A count of 1 should
/// be used if modifying the value of a single matrix, and a count greater
/// than 1 can be used to modify an array of matrices.
///
/// ### Notes
/// [**glProgramUniform1i**](crate::context::Context::oxidegl_program_uniform1i)
/// and [**glProgramUniform1iv**](crate::context::Context::oxidegl_program_uniform1iv)
/// are the only two functions that may be used to load uniform variables defined
/// as sampler types. Loading samplers with any other function will result
/// in a [`GL_INVALID_OPERATION`](crate::enums::GL_INVALID_OPERATION) error.
///
/// If `count` is greater than 1 and the indicated uniform variable is not
/// an array, a [`GL_INVALID_OPERATION`](crate::enums::GL_INVALID_OPERATION)
/// error is generated and the specified uniform variable will remain unchanged.
///
/// Other than the preceding exceptions, if the type and size of the uniform
/// variable as defined in the shader do not match the type and size specified
/// in the name of the command used to load its value, a [`GL_INVALID_OPERATION`](crate::enums::GL_INVALID_OPERATION)
/// error will be generated and the specified uniform variable will remain
/// unchanged.
///
/// If `location` is a value other than -1 and it does not represent a valid
/// uniform variable location in within `program`, an error will be generated,
/// and no changes will be made to the uniform variable storage of `program`.
/// If `location` is equal to -1, the data passed in will be silently ignored
/// and the specified uniform variable will not be changed.
///
/// ### Associated Gets
/// [**glGetActiveUniform**](crate::context::Context::oxidegl_get_active_uniform)
/// with the handle of a program object and the index of an active uniform
/// variable
///
/// [**glGetUniform**](crate::context::Context::oxidegl_get_uniform) with the
/// handle of a program object and the location of a uniform variable
///
/// [**glGetUniformLocation**](crate::context::Context::oxidegl_get_uniform_location)
/// with the handle of a program object and the name of a uniform variable
impl Context {
    pub fn oxidegl_program_uniform1i(&mut self, program: GLuint, location: GLint, v0: GLint) {
        panic!("command oxidegl_program_uniform1i not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform1iv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLint,
    ) {
        panic!("command oxidegl_program_uniform1iv not yet implemented");
    }
    pub fn oxidegl_program_uniform1f(&mut self, program: GLuint, location: GLint, v0: GLfloat) {
        panic!("command oxidegl_program_uniform1f not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform1fv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_program_uniform1fv not yet implemented");
    }
    pub fn oxidegl_program_uniform1ui(&mut self, program: GLuint, location: GLint, v0: GLuint) {
        panic!("command oxidegl_program_uniform1ui not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform1uiv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLuint,
    ) {
        panic!("command oxidegl_program_uniform1uiv not yet implemented");
    }
    pub fn oxidegl_program_uniform2i(
        &mut self,
        program: GLuint,
        location: GLint,
        v0: GLint,
        v1: GLint,
    ) {
        panic!("command oxidegl_program_uniform2i not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform2iv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLint,
    ) {
        panic!("command oxidegl_program_uniform2iv not yet implemented");
    }
    pub fn oxidegl_program_uniform2f(
        &mut self,
        program: GLuint,
        location: GLint,
        v0: GLfloat,
        v1: GLfloat,
    ) {
        panic!("command oxidegl_program_uniform2f not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform2fv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_program_uniform2fv not yet implemented");
    }
    pub fn oxidegl_program_uniform2ui(
        &mut self,
        program: GLuint,
        location: GLint,
        v0: GLuint,
        v1: GLuint,
    ) {
        panic!("command oxidegl_program_uniform2ui not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform2uiv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLuint,
    ) {
        panic!("command oxidegl_program_uniform2uiv not yet implemented");
    }
    pub fn oxidegl_program_uniform3i(
        &mut self,
        program: GLuint,
        location: GLint,
        v0: GLint,
        v1: GLint,
        v2: GLint,
    ) {
        panic!("command oxidegl_program_uniform3i not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform3iv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLint,
    ) {
        panic!("command oxidegl_program_uniform3iv not yet implemented");
    }
    pub fn oxidegl_program_uniform3f(
        &mut self,
        program: GLuint,
        location: GLint,
        v0: GLfloat,
        v1: GLfloat,
        v2: GLfloat,
    ) {
        panic!("command oxidegl_program_uniform3f not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform3fv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_program_uniform3fv not yet implemented");
    }
    pub fn oxidegl_program_uniform3ui(
        &mut self,
        program: GLuint,
        location: GLint,
        v0: GLuint,
        v1: GLuint,
        v2: GLuint,
    ) {
        panic!("command oxidegl_program_uniform3ui not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform3uiv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLuint,
    ) {
        panic!("command oxidegl_program_uniform3uiv not yet implemented");
    }
    pub fn oxidegl_program_uniform4i(
        &mut self,
        program: GLuint,
        location: GLint,
        v0: GLint,
        v1: GLint,
        v2: GLint,
        v3: GLint,
    ) {
        panic!("command oxidegl_program_uniform4i not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform4iv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLint,
    ) {
        panic!("command oxidegl_program_uniform4iv not yet implemented");
    }
    pub fn oxidegl_program_uniform4f(
        &mut self,
        program: GLuint,
        location: GLint,
        v0: GLfloat,
        v1: GLfloat,
        v2: GLfloat,
        v3: GLfloat,
    ) {
        panic!("command oxidegl_program_uniform4f not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform4fv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_program_uniform4fv not yet implemented");
    }
    pub fn oxidegl_program_uniform4ui(
        &mut self,
        program: GLuint,
        location: GLint,
        v0: GLuint,
        v1: GLuint,
        v2: GLuint,
        v3: GLuint,
    ) {
        panic!("command oxidegl_program_uniform4ui not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform4uiv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLuint,
    ) {
        panic!("command oxidegl_program_uniform4uiv not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform_matrix2fv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_program_uniform_matrix2fv not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform_matrix3fv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_program_uniform_matrix3fv not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform_matrix4fv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_program_uniform_matrix4fv not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform_matrix2x3fv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_program_uniform_matrix2x3fv not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform_matrix3x2fv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_program_uniform_matrix3x2fv not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform_matrix2x4fv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_program_uniform_matrix2x4fv not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform_matrix4x2fv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_program_uniform_matrix4x2fv not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform_matrix3x4fv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_program_uniform_matrix3x4fv not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform_matrix4x3fv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_program_uniform_matrix4x3fv not yet implemented");
    }
}
/// ### Parameters
/// `framebuffer`
///
/// > Specifies the name of the framebuffer object for [**glNamedFramebufferReadBuffer**](crate::context::Context::oxidegl_named_framebuffer_read_buffer)
/// > function.
///
/// `mode`
///
/// > Specifies a color buffer. Accepted values are [`GL_FRONT_LEFT`](crate::enums::GL_FRONT_LEFT),
/// > [`GL_FRONT_RIGHT`](crate::enums::GL_FRONT_RIGHT), [`GL_BACK_LEFT`](crate::enums::GL_BACK_LEFT),
/// > [`GL_BACK_RIGHT`](crate::enums::GL_BACK_RIGHT), [`GL_FRONT`](crate::enums::GL_FRONT),
/// > [`GL_BACK`](crate::enums::GL_BACK), [`GL_LEFT`](crate::enums::GL_LEFT),
/// > [`GL_RIGHT`](crate::enums::GL_RIGHT), and the constants [`GL_COLOR_ATTACHMENT`](crate::enums::GL_COLOR_ATTACHMENT)
/// > *i*.
///
/// ### Description
/// [**glReadBuffer**](crate::context::Context::oxidegl_read_buffer) specifies
/// a color buffer as the source for subsequent [**glReadPixels**](crate::context::Context::oxidegl_read_pixels),
/// [**glCopyTexImage1D**](crate::context::Context::oxidegl_copy_tex_image1_d),
/// [**glCopyTexImage2D**](crate::context::Context::oxidegl_copy_tex_image2_d),
/// [**glCopyTexSubImage1D**](crate::context::Context::oxidegl_copy_tex_sub_image1_d),
/// [**glCopyTexSubImage2D**](crate::context::Context::oxidegl_copy_tex_sub_image2_d),
/// and [**glCopyTexSubImage3D**](crate::context::Context::oxidegl_copy_tex_sub_image3_d)
/// commands. `mode` accepts one of twelve or more predefined values. In a
/// fully configured system, [`GL_FRONT`](crate::enums::GL_FRONT), [`GL_LEFT`](crate::enums::GL_LEFT),
/// and [`GL_FRONT_LEFT`](crate::enums::GL_FRONT_LEFT) all name the front
/// left buffer, [`GL_FRONT_RIGHT`](crate::enums::GL_FRONT_RIGHT) and [`GL_RIGHT`](crate::enums::GL_RIGHT)
/// name the front right buffer, and [`GL_BACK_LEFT`](crate::enums::GL_BACK_LEFT)
/// and [`GL_BACK`](crate::enums::GL_BACK) name the back left buffer. Further
/// more, the constants [`GL_COLOR_ATTACHMENT`](crate::enums::GL_COLOR_ATTACHMENT)
/// *i* may be used to indicate the *i* *i* ranges from zero to the value of
/// [`GL_MAX_COLOR_ATTACHMENTS`](crate::enums::GL_MAX_COLOR_ATTACHMENTS) minus
/// one.
///
/// Nonstereo double-buffered configurations have only a front left and a back
/// left buffer. Single-buffered configurations have a front left and a front
/// right buffer if stereo, and only a front left buffer if nonstereo. It is
/// an error to specify a nonexistent buffer to [**glReadBuffer**](crate::context::Context::oxidegl_read_buffer).
///
/// `mode` is initially [`GL_FRONT`](crate::enums::GL_FRONT) in single-buffered
/// configurations and [`GL_BACK`](crate::enums::GL_BACK) in double-buffered
/// configurations.
///
/// For [**glReadBuffer**](crate::context::Context::oxidegl_read_buffer), the
/// target framebuffer object is that bound to [`GL_READ_FRAMEBUFFER`](crate::enums::GL_READ_FRAMEBUFFER).
/// For [**glNamedFramebufferReadBuffer**](crate::context::Context::oxidegl_named_framebuffer_read_buffer),
/// `framebuffer` must either be zero or the name of the target framebuffer
/// object. If `framebuffer` is zero, then the default read framebuffer is
/// affected.
///
/// ### Associated Gets
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_READ_BUFFER`](crate::enums::GL_READ_BUFFER)
impl Context {
    pub fn oxidegl_read_buffer(&mut self, src: ReadBufferMode) {
        panic!("command oxidegl_read_buffer not yet implemented");
    }
    pub fn oxidegl_named_framebuffer_read_buffer(&mut self, framebuffer: GLuint, src: ColorBuffer) {
        panic!("command oxidegl_named_framebuffer_read_buffer not yet implemented");
    }
}
/// ### Parameters
/// `x`
///
/// `y`
///
/// > Specify the window coordinates of the first pixel that is read from the
/// > frame buffer. This location is the lower left corner of a rectangular block
/// > of pixels.
///
/// `width`
///
/// `height`
///
/// > Specify the dimensions of the pixel rectangle. `width` and `height` of
/// > one correspond to a single pixel.
///
/// `format`
///
/// > Specifies the format of the pixel data. The following symbolic values are
/// > accepted: [`GL_STENCIL_INDEX`](crate::enums::GL_STENCIL_INDEX), [`GL_DEPTH_COMPONENT`](crate::enums::GL_DEPTH_COMPONENT),
/// > [`GL_DEPTH_STENCIL`](crate::enums::GL_DEPTH_STENCIL), [`GL_RED`](crate::enums::GL_RED),
/// > [`GL_GREEN`](crate::enums::GL_GREEN), [`GL_BLUE`](crate::enums::GL_BLUE),
/// > [`GL_RGB`](crate::enums::GL_RGB), [`GL_BGR`](crate::enums::GL_BGR), [`GL_RGBA`](crate::enums::GL_RGBA),
/// > and [`GL_BGRA`](crate::enums::GL_BGRA).
///
/// `type`
///
/// > Specifies the data type of the pixel data. Must be one of [`GL_UNSIGNED_BYTE`](crate::enums::GL_UNSIGNED_BYTE),
/// > [`GL_BYTE`](crate::enums::GL_BYTE), [`GL_UNSIGNED_SHORT`](crate::enums::GL_UNSIGNED_SHORT),
/// > [`GL_SHORT`](crate::enums::GL_SHORT), [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT),
/// > [`GL_INT`](crate::enums::GL_INT), [`GL_HALF_FLOAT`](crate::enums::GL_HALF_FLOAT),
/// > [`GL_FLOAT`](crate::enums::GL_FLOAT), [`GL_UNSIGNED_BYTE_3_3_2`](crate::enums::GL_UNSIGNED_BYTE_3_3_2),
/// > [`GL_UNSIGNED_BYTE_2_3_3_REV`](crate::enums::GL_UNSIGNED_BYTE_2_3_3_REV),
/// > [`GL_UNSIGNED_SHORT_5_6_5`](crate::enums::GL_UNSIGNED_SHORT_5_6_5), [`GL_UNSIGNED_SHORT_5_6_5_REV`](crate::enums::GL_UNSIGNED_SHORT_5_6_5_REV),
/// > [`GL_UNSIGNED_SHORT_4_4_4_4`](crate::enums::GL_UNSIGNED_SHORT_4_4_4_4),
/// > [`GL_UNSIGNED_SHORT_4_4_4_4_REV`](crate::enums::GL_UNSIGNED_SHORT_4_4_4_4_REV),
/// > [`GL_UNSIGNED_SHORT_5_5_5_1`](crate::enums::GL_UNSIGNED_SHORT_5_5_5_1),
/// > [`GL_UNSIGNED_SHORT_1_5_5_5_REV`](crate::enums::GL_UNSIGNED_SHORT_1_5_5_5_REV),
/// > [`GL_UNSIGNED_INT_8_8_8_8`](crate::enums::GL_UNSIGNED_INT_8_8_8_8), [`GL_UNSIGNED_INT_8_8_8_8_REV`](crate::enums::GL_UNSIGNED_INT_8_8_8_8_REV),
/// > [`GL_UNSIGNED_INT_10_10_10_2`](crate::enums::GL_UNSIGNED_INT_10_10_10_2),
/// > [`GL_UNSIGNED_INT_2_10_10_10_REV`](crate::enums::GL_UNSIGNED_INT_2_10_10_10_REV),
/// > [`GL_UNSIGNED_INT_24_8`](crate::enums::GL_UNSIGNED_INT_24_8), [`GL_UNSIGNED_INT_10F_11F_11F_REV`](crate::enums::GL_UNSIGNED_INT_10F_11F_11F_REV),
/// > [`GL_UNSIGNED_INT_5_9_9_9_REV`](crate::enums::GL_UNSIGNED_INT_5_9_9_9_REV),
/// > or [`GL_FLOAT_32_UNSIGNED_INT_24_8_REV`](crate::enums::GL_FLOAT_32_UNSIGNED_INT_24_8_REV).
///
/// `bufSize`
///
/// > Specifies the size of the buffer `data` for [**glReadnPixels**](crate::context::Context::oxidegl_readn_pixels)
/// > function.
///
/// `data`
///
/// > Returns the pixel data.
///
/// ### Description
/// [**glReadPixels**](crate::context::Context::oxidegl_read_pixels) and [**glReadnPixels**](crate::context::Context::oxidegl_readn_pixels)
/// return pixel data from the frame buffer, starting with the pixel whose
/// lower left corner is at location( `x`, `y` ), into client memory starting
/// at location `data`. Several parameters control the processing of the pixel
/// data before it is placed into client memory. These parameters are set with
/// [**glPixelStore**](crate::context::Context::oxidegl_pixel_store). This
/// reference page describes the effects on [**glReadPixels**](crate::context::Context::oxidegl_read_pixels)
/// and [**glReadnPixels**](crate::context::Context::oxidegl_readn_pixels)
/// of most, but not all of the parameters specified by these three commands.
///
/// If a non-zero named buffer object is bound to the [`GL_PIXEL_PACK_BUFFER`](crate::enums::GL_PIXEL_PACK_BUFFER)
/// target (see [**glBindBuffer**](crate::context::Context::oxidegl_bind_buffer))
/// while a block of pixels is requested, `data` is treated as a byte offset
/// into the buffer object's data store rather than a pointer to client memory.
///
/// [**glReadPixels**](crate::context::Context::oxidegl_read_pixels) and [**glReadnPixels**](crate::context::Context::oxidegl_readn_pixels)
/// return values from each pixel with lower left corner at `[inlineq]` `[inlineq]`
/// `[inlineq]` `[inlineq]` `[inlineq]`
///
/// `format` specifies the format for the returned pixel values; accepted values
/// are:
///
/// [`GL_STENCIL_INDEX`](crate::enums::GL_STENCIL_INDEX)
///
/// > Stencil values are read from the stencil buffer.
///
/// [`GL_DEPTH_COMPONENT`](crate::enums::GL_DEPTH_COMPONENT)
///
/// > Depth values are read from the depth buffer. Each component is converted
/// > to floating point such that the minimum depth value maps to 0 and the maximum
/// > value maps to 1. Each component is clamped to the range `[inlineq]`
///
/// [`GL_DEPTH_STENCIL`](crate::enums::GL_DEPTH_STENCIL)
///
/// > Values are taken from both the depth and stencil buffers. The `type` parameter
/// > must be [`GL_UNSIGNED_INT_24_8`](crate::enums::GL_UNSIGNED_INT_24_8) or
/// > [`GL_FLOAT_32_UNSIGNED_INT_24_8_REV`](crate::enums::GL_FLOAT_32_UNSIGNED_INT_24_8_REV).
///
/// [`GL_RED`](crate::enums::GL_RED), [`GL_GREEN`](crate::enums::GL_GREEN),
/// [`GL_BLUE`](crate::enums::GL_BLUE), [`GL_RGB`](crate::enums::GL_RGB), [`GL_BGR`](crate::enums::GL_BGR),
/// [`GL_RGBA`](crate::enums::GL_RGBA), [`GL_BGRA`](crate::enums::GL_BGRA)
///
/// > Color values are taken from the color buffer.
///
/// Finally, the indices or components are converted to the proper format,
/// as specified by `type`. If `format` is [`GL_STENCIL_INDEX`](crate::enums::GL_STENCIL_INDEX)
/// and `type` is not [`GL_FLOAT`](crate::enums::GL_FLOAT), each index is masked
/// with the mask value given in the following table. If `type` is [`GL_FLOAT`](crate::enums::GL_FLOAT),
/// then each integer index is converted to single-precision floating-point
/// format.
///
/// If `format` is [`GL_RED`](crate::enums::GL_RED), [`GL_GREEN`](crate::enums::GL_GREEN),
/// [`GL_BLUE`](crate::enums::GL_BLUE), [`GL_RGB`](crate::enums::GL_RGB), [`GL_BGR`](crate::enums::GL_BGR),
/// [`GL_RGBA`](crate::enums::GL_RGBA), or [`GL_BGRA`](crate::enums::GL_BGRA)
/// and `type` is not [`GL_FLOAT`](crate::enums::GL_FLOAT), each component
/// is multiplied by the multiplier shown in the following table. If type is
/// [`GL_FLOAT`](crate::enums::GL_FLOAT), then each component is passed as
/// is (or converted to the client's single-precision floating-point format
/// if it is different from the one used by the GL).
///
///
/// | `type`     |* Index Mask*        |* Component Conversion*                               |
/// |------------|---------------------|------------------------------------------------------|
/// | [`GL_UNSIGNED_BYTE`](crate::enums::GL_UNSIGNED_BYTE) | `[inlineq]` | `[inlineq]`        |
/// | [`GL_BYTE`](crate::enums::GL_BYTE) | `[inlineq]` | `[inlineq]`                          |
/// | [`GL_UNSIGNED_SHORT`](crate::enums::GL_UNSIGNED_SHORT) | `[inlineq]` | `[inlineq]`      |
/// | [`GL_SHORT`](crate::enums::GL_SHORT) | `[inlineq]` | `[inlineq]`                        |
/// | [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT) | `[inlineq]` | `[inlineq]`          |
/// | [`GL_INT`](crate::enums::GL_INT) | `[inlineq]` | `[inlineq]`                            |
/// | [`GL_HALF_FLOAT`](crate::enums::GL_HALF_FLOAT) | none | `[inlineq]`                     |
/// | [`GL_FLOAT`](crate::enums::GL_FLOAT) | none | `[inlineq]`                               |
/// | [`GL_UNSIGNED_BYTE_3_3_2`](crate::enums::GL_UNSIGNED_BYTE_3_3_2) | `[inlineq]` | `[inlineq]` |
/// | [`GL_UNSIGNED_BYTE_2_3_3_REV`](crate::enums::GL_UNSIGNED_BYTE_2_3_3_REV) | `[inlineq]` | `[inlineq]` |
/// | [`GL_UNSIGNED_SHORT_5_6_5`](crate::enums::GL_UNSIGNED_SHORT_5_6_5) | `[inlineq]` | `[inlineq]` |
/// | [`GL_UNSIGNED_SHORT_5_6_5_REV`](crate::enums::GL_UNSIGNED_SHORT_5_6_5_REV) | `[inlineq]` | `[inlineq]` |
/// | [`GL_UNSIGNED_SHORT_4_4_4_4`](crate::enums::GL_UNSIGNED_SHORT_4_4_4_4) | `[inlineq]` | `[inlineq]` |
/// | [`GL_UNSIGNED_SHORT_4_4_4_4_REV`](crate::enums::GL_UNSIGNED_SHORT_4_4_4_4_REV) | `[inlineq]` | `[inlineq]` |
/// | [`GL_UNSIGNED_SHORT_5_5_5_1`](crate::enums::GL_UNSIGNED_SHORT_5_5_5_1) | `[inlineq]` | `[inlineq]` |
/// | [`GL_UNSIGNED_SHORT_1_5_5_5_REV`](crate::enums::GL_UNSIGNED_SHORT_1_5_5_5_REV) | `[inlineq]` | `[inlineq]` |
/// | [`GL_UNSIGNED_INT_8_8_8_8`](crate::enums::GL_UNSIGNED_INT_8_8_8_8) | `[inlineq]` | `[inlineq]` |
/// | [`GL_UNSIGNED_INT_8_8_8_8_REV`](crate::enums::GL_UNSIGNED_INT_8_8_8_8_REV) | `[inlineq]` | `[inlineq]` |
/// | [`GL_UNSIGNED_INT_10_10_10_2`](crate::enums::GL_UNSIGNED_INT_10_10_10_2) | `[inlineq]` | `[inlineq]` |
/// | [`GL_UNSIGNED_INT_2_10_10_10_REV`](crate::enums::GL_UNSIGNED_INT_2_10_10_10_REV) | `[inlineq]` | `[inlineq]` |
/// | [`GL_UNSIGNED_INT_24_8`](crate::enums::GL_UNSIGNED_INT_24_8) | `[inlineq]` | `[inlineq]` |
/// | [`GL_UNSIGNED_INT_10F_11F_11F_REV`](crate::enums::GL_UNSIGNED_INT_10F_11F_11F_REV) | -- | Special |
/// | [`GL_UNSIGNED_INT_5_9_9_9_REV`](crate::enums::GL_UNSIGNED_INT_5_9_9_9_REV) | -- | Special |
/// | [`GL_FLOAT_32_UNSIGNED_INT_24_8_REV`](crate::enums::GL_FLOAT_32_UNSIGNED_INT_24_8_REV) | none | `[inlineq]` |
///
/// Return values are placed in memory as follows. If `format` is [`GL_STENCIL_INDEX`](crate::enums::GL_STENCIL_INDEX),
/// [`GL_DEPTH_COMPONENT`](crate::enums::GL_DEPTH_COMPONENT), [`GL_RED`](crate::enums::GL_RED),
/// [`GL_GREEN`](crate::enums::GL_GREEN), or [`GL_BLUE`](crate::enums::GL_BLUE),
/// a single value is returned and the data for the `[inlineq]` `[inlineq]`
/// `[inlineq]` [`GL_RGB`](crate::enums::GL_RGB) and [`GL_BGR`](crate::enums::GL_BGR)
/// return three values, [`GL_RGBA`](crate::enums::GL_RGBA) and [`GL_BGRA`](crate::enums::GL_BGRA)
/// return four values for each pixel, with all values corresponding to a single
/// pixel occupying contiguous space in `data`. Storage parameters set by [**glPixelStore**](crate::context::Context::oxidegl_pixel_store),
/// such as [`GL_PACK_LSB_FIRST`](crate::enums::GL_PACK_LSB_FIRST) and [`GL_PACK_SWAP_BYTES`](crate::enums::GL_PACK_SWAP_BYTES),
/// affect the way that data is written into memory. See [**glPixelStore**](crate::context::Context::oxidegl_pixel_store)
/// for a description.
///
/// [**glReadnPixels**](crate::context::Context::oxidegl_readn_pixels) function
/// will only handle the call if `bufSize` is at least of the size required
/// to store the requested data. Otherwise, it will generate a [`GL_INVALID_OPERATION`](crate::enums::GL_INVALID_OPERATION)
/// error.
///
/// ### Notes
/// Values for pixels that lie outside the window connected to the current
/// GL context are undefined.
///
/// If an error is generated, no change is made to the contents of `data`.
///
/// ### Associated Gets
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_PIXEL_PACK_BUFFER_BINDING`](crate::enums::GL_PIXEL_PACK_BUFFER_BINDING)
impl Context {
    pub unsafe fn oxidegl_read_pixels(
        &mut self,
        x: GLint,
        y: GLint,
        width: GLsizei,
        height: GLsizei,
        format: PixelFormat,
        r#type: PixelType,
        pixels: *mut GLvoid,
    ) {
        panic!("command oxidegl_read_pixels not yet implemented");
    }
    pub unsafe fn oxidegl_readn_pixels(
        &mut self,
        x: GLint,
        y: GLint,
        width: GLsizei,
        height: GLsizei,
        format: PixelFormat,
        r#type: PixelType,
        buf_size: GLsizei,
        data: *mut GLvoid,
    ) {
        panic!("command oxidegl_readn_pixels not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies a binding target of the allocation for [**glRenderbufferStorage**](crate::context::Context::oxidegl_renderbuffer_storage)
/// > function. Must be [`GL_RENDERBUFFER`](crate::enums::GL_RENDERBUFFER).
///
/// `renderbuffer`
///
/// > Specifies the name of the renderbuffer object for [**glNamedRenderbufferStorage**](crate::context::Context::oxidegl_named_renderbuffer_storage)
/// > function.
///
/// `internalformat`
///
/// > Specifies the internal format to use for the renderbuffer object's image.
///
/// `width`
///
/// > Specifies the width of the renderbuffer, in pixels.
///
/// `height`
///
/// > Specifies the height of the renderbuffer, in pixels.
///
/// ### Description
/// [**glRenderbufferStorage**](crate::context::Context::oxidegl_renderbuffer_storage)
/// is equivalent to calling [**glRenderbufferStorageMultisample**](crate::context::Context::oxidegl_renderbuffer_storage_multisample)
/// with the `samples` set to zero, and [**glNamedRenderbufferStorage**](crate::context::Context::oxidegl_named_renderbuffer_storage)
/// is equivalent to calling [**glNamedRenderbufferStorageMultisample**](crate::context::Context::oxidegl_named_renderbuffer_storage_multisample)
/// with the samples set to zero.
///
/// For [**glRenderbufferStorage**](crate::context::Context::oxidegl_renderbuffer_storage),
/// the target of the operation, specified by `target` must be [`GL_RENDERBUFFER`](crate::enums::GL_RENDERBUFFER).
/// For [**glNamedRenderbufferStorage**](crate::context::Context::oxidegl_named_renderbuffer_storage),
/// `renderbuffer` must be a name of an existing renderbuffer object. `internalformat`
/// specifies the internal format to be used for the renderbuffer object's
/// storage and must be a color-renderable, depth-renderable, or stencil-renderable
/// format. `width` and `height` are the dimensions, in pixels, of the renderbuffer.
/// Both `width` and `height` must be less than or equal to the value of [`GL_MAX_RENDERBUFFER_SIZE`](crate::enums::GL_MAX_RENDERBUFFER_SIZE).
///
/// Upon success, [**glRenderbufferStorage**](crate::context::Context::oxidegl_renderbuffer_storage)
/// and [**glNamedRenderbufferStorage**](crate::context::Context::oxidegl_named_renderbuffer_storage)
/// delete any existing data store for the renderbuffer image and the contents
/// of the data store after calling [**glRenderbufferStorage**](crate::context::Context::oxidegl_renderbuffer_storage)
/// are undefined.
impl Context {
    pub fn oxidegl_renderbuffer_storage(
        &mut self,
        target: GLenum,
        internalformat: InternalFormat,
        width: GLsizei,
        height: GLsizei,
    ) {
        panic!("command oxidegl_renderbuffer_storage not yet implemented");
    }
    pub fn oxidegl_named_renderbuffer_storage(
        &mut self,
        renderbuffer: GLuint,
        internalformat: InternalFormat,
        width: GLsizei,
        height: GLsizei,
    ) {
        panic!("command oxidegl_named_renderbuffer_storage not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies a binding target of the allocation for [**glRenderbufferStorageMultisample**](crate::context::Context::oxidegl_renderbuffer_storage_multisample)
/// > function. Must be [`GL_RENDERBUFFER`](crate::enums::GL_RENDERBUFFER).
///
/// `renderbuffer`
///
/// > Specifies the name of the renderbuffer object for [**glNamedRenderbufferStorageMultisample**](crate::context::Context::oxidegl_named_renderbuffer_storage_multisample)
/// > function.
///
/// `samples`
///
/// > Specifies the number of samples to be used for the renderbuffer object's
/// > storage.
///
/// `internalformat`
///
/// > Specifies the internal format to use for the renderbuffer object's image.
///
/// `width`
///
/// > Specifies the width of the renderbuffer, in pixels.
///
/// `height`
///
/// > Specifies the height of the renderbuffer, in pixels.
///
/// ### Description
/// [**glRenderbufferStorageMultisample**](crate::context::Context::oxidegl_renderbuffer_storage_multisample)
/// and [**glNamedRenderbufferStorageMultisample**](crate::context::Context::oxidegl_named_renderbuffer_storage_multisample)
/// establish the data storage, format, dimensions and number of samples of
/// a renderbuffer object's image.
///
/// For [**glRenderbufferStorageMultisample**](crate::context::Context::oxidegl_renderbuffer_storage_multisample),
/// the target of the operation, specified by `target` must be [`GL_RENDERBUFFER`](crate::enums::GL_RENDERBUFFER).
/// For [**glNamedRenderbufferStorageMultisample**](crate::context::Context::oxidegl_named_renderbuffer_storage_multisample),
/// `renderbuffer` must be an ID of an existing renderbuffer object. `internalformat`
/// specifies the internal format to be used for the renderbuffer object's
/// storage and must be a color-renderable, depth-renderable, or stencil-renderable
/// format. `width` and `height` are the dimensions, in pixels, of the renderbuffer.
/// Both `width` and `height` must be less than or equal to the value of [`GL_MAX_RENDERBUFFER_SIZE`](crate::enums::GL_MAX_RENDERBUFFER_SIZE).
/// `samples` specifies the number of samples to be used for the renderbuffer
/// object's image, and must be less than or equal to the value of [`GL_MAX_SAMPLES`](crate::enums::GL_MAX_SAMPLES).
/// If `internalformat` is a signed or unsigned integer format then `samples`
/// must be less than or equal to the value of [`GL_MAX_INTEGER_SAMPLES`](crate::enums::GL_MAX_INTEGER_SAMPLES).
///
/// Upon success, [**glRenderbufferStorageMultisample**](crate::context::Context::oxidegl_renderbuffer_storage_multisample)
/// and [**glNamedRenderbufferStorageMultisample**](crate::context::Context::oxidegl_named_renderbuffer_storage_multisample)
/// delete any existing data store for the renderbuffer image and the contents
/// of the data store after calling either of the functions are undefined.
impl Context {
    pub fn oxidegl_renderbuffer_storage_multisample(
        &mut self,
        target: GLenum,
        samples: GLsizei,
        internalformat: InternalFormat,
        width: GLsizei,
        height: GLsizei,
    ) {
        panic!("command oxidegl_renderbuffer_storage_multisample not yet implemented");
    }
    pub fn oxidegl_named_renderbuffer_storage_multisample(
        &mut self,
        renderbuffer: GLuint,
        samples: GLsizei,
        internalformat: InternalFormat,
        width: GLsizei,
        height: GLsizei,
    ) {
        panic!("command oxidegl_named_renderbuffer_storage_multisample not yet implemented");
    }
}
/// ### Parameters
/// `sampler`
///
/// > Specifies the sampler object whose parameter to modify.
///
/// `pname`
///
/// > Specifies the symbolic name of a sampler parameter. `pname` can be one
/// > of the following: [`GL_TEXTURE_WRAP_S`](crate::enums::GL_TEXTURE_WRAP_S),
/// > [`GL_TEXTURE_WRAP_T`](crate::enums::GL_TEXTURE_WRAP_T), [`GL_TEXTURE_WRAP_R`](crate::enums::GL_TEXTURE_WRAP_R),
/// > [`GL_TEXTURE_MIN_FILTER`](crate::enums::GL_TEXTURE_MIN_FILTER), [`GL_TEXTURE_MAG_FILTER`](crate::enums::GL_TEXTURE_MAG_FILTER),
/// > [`GL_TEXTURE_BORDER_COLOR`](crate::enums::GL_TEXTURE_BORDER_COLOR), [`GL_TEXTURE_MIN_LOD`](crate::enums::GL_TEXTURE_MIN_LOD),
/// > [`GL_TEXTURE_MAX_LOD`](crate::enums::GL_TEXTURE_MAX_LOD), [`GL_TEXTURE_LOD_BIAS`](crate::enums::GL_TEXTURE_LOD_BIAS)
/// > [`GL_TEXTURE_COMPARE_MODE`](crate::enums::GL_TEXTURE_COMPARE_MODE), or
/// > [`GL_TEXTURE_COMPARE_FUNC`](crate::enums::GL_TEXTURE_COMPARE_FUNC).
///
/// `param`
///
/// > For the scalar commands, specifies the value of `pname`.
///
/// `params`
///
/// > For the vector commands( [**glSamplerParameter*v**](crate::context::Context::oxidegl_sampler_parameter*v)
/// > ), specifies a pointer to an array where the value or values of `pname`
/// > are stored.
///
/// ### Description
/// [**glSamplerParameter**](crate::context::Context::oxidegl_sampler_parameter)
/// assigns the value or values in `params` to the sampler parameter specified
/// as `pname`. `sampler` specifies the sampler object to be modified, and
/// must be the name of a sampler object previously returned from a call to
/// [**glGenSamplers**](crate::context::Context::oxidegl_gen_samplers). The
/// following symbols are accepted in `pname`:
///
/// [`GL_TEXTURE_MIN_FILTER`](crate::enums::GL_TEXTURE_MIN_FILTER)
///
/// > The texture minifying function is used whenever the pixel being textured
/// > maps to an area greater than one texture element. There are six defined
/// > minifying functions. Two of them use the nearest one or nearest four texture
/// > elements to compute the texture value. The other four use mipmaps.
///
/// > A mipmap is an ordered set of arrays representing the same image at progressively
/// > lower resolutions. If the texture has dimensions `[inlineq]` `[inlineq]`
/// > `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]`
/// > `[inlineq]` `[inlineq]` [**glTexImage1D**](crate::context::Context::oxidegl_tex_image1_d),
/// > [**glTexImage2D**](crate::context::Context::oxidegl_tex_image2_d), [**glTexImage3D**](crate::context::Context::oxidegl_tex_image3_d),
/// > [**glCopyTexImage1D**](crate::context::Context::oxidegl_copy_tex_image1_d),
/// > or [**glCopyTexImage2D**](crate::context::Context::oxidegl_copy_tex_image2_d)
/// > with the *level* argument indicating the order of the mipmaps. Level 0
/// > is the original texture; level `[inlineq]` `[inlineq]`
///
/// > `params` supplies a function for minifying the texture as one of the following:
/// > [`GL_NEAREST`](crate::enums::GL_NEAREST)
///
/// >> Returns the value of the texture element that is nearest (in Manhattan
/// >> distance) to the center of the pixel being textured.
///
/// > [`GL_LINEAR`](crate::enums::GL_LINEAR)
///
/// >> Returns the weighted average of the four texture elements that are closest
/// >> to the center of the pixel being textured. These can include border texture
/// >> elements, depending on the values of [`GL_TEXTURE_WRAP_S`](crate::enums::GL_TEXTURE_WRAP_S)
/// >> and [`GL_TEXTURE_WRAP_T`](crate::enums::GL_TEXTURE_WRAP_T), and on the
/// >> exact mapping.
///
/// > [`GL_NEAREST_MIPMAP_NEAREST`](crate::enums::GL_NEAREST_MIPMAP_NEAREST)
///
/// >> Chooses the mipmap that most closely matches the size of the pixel being
/// >> textured and uses the [`GL_NEAREST`](crate::enums::GL_NEAREST) criterion
/// >> (the texture element nearest to the center of the pixel) to produce a texture
/// >> value.
///
/// > [`GL_LINEAR_MIPMAP_NEAREST`](crate::enums::GL_LINEAR_MIPMAP_NEAREST)
///
/// >> Chooses the mipmap that most closely matches the size of the pixel being
/// >> textured and uses the [`GL_LINEAR`](crate::enums::GL_LINEAR) criterion
/// >> (a weighted average of the four texture elements that are closest to the
/// >> center of the pixel) to produce a texture value.
///
/// > [`GL_NEAREST_MIPMAP_LINEAR`](crate::enums::GL_NEAREST_MIPMAP_LINEAR)
///
/// >> Chooses the two mipmaps that most closely match the size of the pixel being
/// >> textured and uses the [`GL_NEAREST`](crate::enums::GL_NEAREST) criterion
/// >> (the texture element nearest to the center of the pixel) to produce a texture
/// >> value from each mipmap. The final texture value is a weighted average of
/// >> those two values.
///
/// > [`GL_LINEAR_MIPMAP_LINEAR`](crate::enums::GL_LINEAR_MIPMAP_LINEAR)
///
/// >> Chooses the two mipmaps that most closely match the size of the pixel being
/// >> textured and uses the [`GL_LINEAR`](crate::enums::GL_LINEAR) criterion
/// >> (a weighted average of the four texture elements that are closest to the
/// >> center of the pixel) to produce a texture value from each mipmap. The final
/// >> texture value is a weighted average of those two values.
///
///
/// > As more texture elements are sampled in the minification process, fewer
/// > aliasing artifacts will be apparent. While the [`GL_NEAREST`](crate::enums::GL_NEAREST)
/// > and [`GL_LINEAR`](crate::enums::GL_LINEAR) minification functions can be
/// > faster than the other four, they sample only one or four texture elements
/// > to determine the texture value of the pixel being rendered and can produce
/// > moire patterns or ragged transitions. The initial value of [`GL_TEXTURE_MIN_FILTER`](crate::enums::GL_TEXTURE_MIN_FILTER)
/// > is [`GL_NEAREST_MIPMAP_LINEAR`](crate::enums::GL_NEAREST_MIPMAP_LINEAR).
///
/// [`GL_TEXTURE_MAG_FILTER`](crate::enums::GL_TEXTURE_MAG_FILTER)
///
/// > The texture magnification function is used when the pixel being textured
/// > maps to an area less than or equal to one texture element. It sets the
/// > texture magnification function to either [`GL_NEAREST`](crate::enums::GL_NEAREST)
/// > or [`GL_LINEAR`](crate::enums::GL_LINEAR) (see below). [`GL_NEAREST`](crate::enums::GL_NEAREST)
/// > is generally faster than [`GL_LINEAR`](crate::enums::GL_LINEAR), but it
/// > can produce textured images with sharper edges because the transition between
/// > texture elements is not as smooth. The initial value of [`GL_TEXTURE_MAG_FILTER`](crate::enums::GL_TEXTURE_MAG_FILTER)
/// > is [`GL_LINEAR`](crate::enums::GL_LINEAR). [`GL_NEAREST`](crate::enums::GL_NEAREST)
///
/// >> Returns the value of the texture element that is nearest (in Manhattan
/// >> distance) to the center of the pixel being textured.
///
/// > [`GL_LINEAR`](crate::enums::GL_LINEAR)
///
/// >> Returns the weighted average of the four texture elements that are closest
/// >> to the center of the pixel being textured. These can include border texture
/// >> elements, depending on the values of [`GL_TEXTURE_WRAP_S`](crate::enums::GL_TEXTURE_WRAP_S)
/// >> and [`GL_TEXTURE_WRAP_T`](crate::enums::GL_TEXTURE_WRAP_T), and on the
/// >> exact mapping.
///
///
///
/// [`GL_TEXTURE_MIN_LOD`](crate::enums::GL_TEXTURE_MIN_LOD)
///
/// > Sets the minimum level-of-detail parameter. This floating-point value limits
/// > the selection of highest resolution mipmap (lowest mipmap level). The initial
/// > value is -1000.
///
///
/// [`GL_TEXTURE_MAX_LOD`](crate::enums::GL_TEXTURE_MAX_LOD)
///
/// > Sets the maximum level-of-detail parameter. This floating-point value limits
/// > the selection of the lowest resolution mipmap (highest mipmap level). The
/// > initial value is 1000.
///
///
/// [`GL_TEXTURE_WRAP_S`](crate::enums::GL_TEXTURE_WRAP_S)
///
/// > Sets the wrap parameter for texture coordinate `[inlineq]` [`GL_CLAMP_TO_EDGE`](crate::enums::GL_CLAMP_TO_EDGE),
/// > [`GL_MIRRORED_REPEAT`](crate::enums::GL_MIRRORED_REPEAT), [`GL_REPEAT`](crate::enums::GL_REPEAT),
/// > or [`GL_MIRROR_CLAMP_TO_EDGE`](crate::enums::GL_MIRROR_CLAMP_TO_EDGE).
/// > [`GL_CLAMP_TO_BORDER`](crate::enums::GL_CLAMP_TO_BORDER) causes the `[inlineq]`
/// > `[inlineq]` `[inlineq]` [`GL_CLAMP_TO_EDGE`](crate::enums::GL_CLAMP_TO_EDGE)
/// > causes `[inlineq]` `[inlineq]` `[inlineq]` [`GL_REPEAT`](crate::enums::GL_REPEAT)
/// > causes the integer part of the `[inlineq]` [`GL_MIRRORED_REPEAT`](crate::enums::GL_MIRRORED_REPEAT)
/// > causes the `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]`
/// > `[inlineq]` `[inlineq]` [`GL_MIRROR_CLAMP_TO_EDGE`](crate::enums::GL_MIRROR_CLAMP_TO_EDGE)
/// > causes the `[inlineq]` [`GL_MIRRORED_REPEAT`](crate::enums::GL_MIRRORED_REPEAT)
/// > for one repetition of the texture, at which point the coordinate to be
/// > clamped as in [`GL_CLAMP_TO_EDGE`](crate::enums::GL_CLAMP_TO_EDGE). Initially,
/// > [`GL_TEXTURE_WRAP_S`](crate::enums::GL_TEXTURE_WRAP_S) is set to [`GL_REPEAT`](crate::enums::GL_REPEAT).
///
///
/// [`GL_TEXTURE_WRAP_T`](crate::enums::GL_TEXTURE_WRAP_T)
///
/// > Sets the wrap parameter for texture coordinate `[inlineq]` [`GL_CLAMP_TO_EDGE`](crate::enums::GL_CLAMP_TO_EDGE),
/// > [`GL_MIRRORED_REPEAT`](crate::enums::GL_MIRRORED_REPEAT), [`GL_REPEAT`](crate::enums::GL_REPEAT),
/// > or [`GL_MIRROR_CLAMP_TO_EDGE`](crate::enums::GL_MIRROR_CLAMP_TO_EDGE).
/// > See the discussion under [`GL_TEXTURE_WRAP_S`](crate::enums::GL_TEXTURE_WRAP_S).
/// > Initially, [`GL_TEXTURE_WRAP_T`](crate::enums::GL_TEXTURE_WRAP_T) is set
/// > to [`GL_REPEAT`](crate::enums::GL_REPEAT).
///
/// [`GL_TEXTURE_WRAP_R`](crate::enums::GL_TEXTURE_WRAP_R)
///
/// > Sets the wrap parameter for texture coordinate `[inlineq]` [`GL_CLAMP_TO_EDGE`](crate::enums::GL_CLAMP_TO_EDGE),
/// > [`GL_MIRRORED_REPEAT`](crate::enums::GL_MIRRORED_REPEAT), [`GL_REPEAT`](crate::enums::GL_REPEAT),
/// > or [`GL_MIRROR_CLAMP_TO_EDGE`](crate::enums::GL_MIRROR_CLAMP_TO_EDGE).
/// > See the discussion under [`GL_TEXTURE_WRAP_S`](crate::enums::GL_TEXTURE_WRAP_S).
/// > Initially, [`GL_TEXTURE_WRAP_R`](crate::enums::GL_TEXTURE_WRAP_R) is set
/// > to [`GL_REPEAT`](crate::enums::GL_REPEAT).
///
/// [`GL_TEXTURE_BORDER_COLOR`](crate::enums::GL_TEXTURE_BORDER_COLOR)
///
/// > The data in `params` specifies four values that define the border values
/// > that should be used for border texels. If a texel is sampled from the border
/// > of the texture, the values of [`GL_TEXTURE_BORDER_COLOR`](crate::enums::GL_TEXTURE_BORDER_COLOR)
/// > are interpreted as an RGBA color to match the texture's internal format
/// > and substituted for the non-existent texel data. If the texture contains
/// > depth components, the first component of [`GL_TEXTURE_BORDER_COLOR`](crate::enums::GL_TEXTURE_BORDER_COLOR)
/// > is interpreted as a depth value. The initial value is `[inlineq]`
///
/// [`GL_TEXTURE_COMPARE_MODE`](crate::enums::GL_TEXTURE_COMPARE_MODE)
///
/// > Specifies the texture comparison mode for currently bound textures. That
/// > is, a texture whose internal format is [`GL_DEPTH_COMPONENT_*`](crate::enums::GL_DEPTH_COMPONENT_*);
/// > see [**glTexImage2D**](crate::context::Context::oxidegl_tex_image2_d))
/// > Permissible values are: [`GL_COMPARE_REF_TO_TEXTURE`](crate::enums::GL_COMPARE_REF_TO_TEXTURE)
///
/// >> Specifies that the interpolated and clamped `[inlineq]` [`GL_TEXTURE_COMPARE_FUNC`](crate::enums::GL_TEXTURE_COMPARE_FUNC)
/// >> for details of how the comparison is evaluated. The result of the comparison
/// >> is assigned to the red channel.
///
/// > [`GL_NONE`](crate::enums::GL_NONE)
///
/// >> Specifies that the red channel should be assigned the appropriate value
/// >> from the currently bound texture.
///
///
/// [`GL_TEXTURE_COMPARE_FUNC`](crate::enums::GL_TEXTURE_COMPARE_FUNC)
///
/// > Specifies the comparison operator used when [`GL_TEXTURE_COMPARE_MODE`](crate::enums::GL_TEXTURE_COMPARE_MODE)
/// > is set to [`GL_COMPARE_REF_TO_TEXTURE`](crate::enums::GL_COMPARE_REF_TO_TEXTURE).
/// > Permissible values are:
/// > |* Texture Comparison Function*                                  |* Computed result*                            |
/// > |----------------------------------------------------------------|----------------------------------------------|
/// > | [`GL_LEQUAL`](crate::enums::GL_LEQUAL)                         | `[inlineq]`                                  |
/// > | [`GL_GEQUAL`](crate::enums::GL_GEQUAL)                         | `[inlineq]`                                  |
/// > | [`GL_LESS`](crate::enums::GL_LESS)                             | `[inlineq]`                                  |
/// > | [`GL_GREATER`](crate::enums::GL_GREATER)                       | `[inlineq]`                                  |
/// > | [`GL_EQUAL`](crate::enums::GL_EQUAL)                           | `[inlineq]`                                  |
/// > | [`GL_NOTEQUAL`](crate::enums::GL_NOTEQUAL)                     | `[inlineq]`                                  |
/// > | [`GL_ALWAYS`](crate::enums::GL_ALWAYS)                         | `[inlineq]`                                  |
/// > | [`GL_NEVER`](crate::enums::GL_NEVER)                           | `[inlineq]`                                  |
///
/// > `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]`
///
/// ### Notes
/// [**glSamplerParameter**](crate::context::Context::oxidegl_sampler_parameter)
/// is available only if the GL version is 3.3 or higher.
///
/// If a sampler object is bound to a texture unit and that unit is used to
/// sample from a texture, the parameters in the sampler are used to sample
/// from the texture, rather than the equivalent parameters in the texture
/// object bound to that unit. This introduces the possibility of sampling
/// from the same texture object with different sets of sampler state, which
/// may lead to a condition where a texture is *incomplete* with respect to
/// one sampler object and not with respect to another. Thus, completeness
/// can be considered a function of a sampler object and a texture object bound
/// to a single texture unit, rather than a property of the texture object
/// itself.
///
/// [`GL_MIRROR_CLAMP_TO_EDGE`](crate::enums::GL_MIRROR_CLAMP_TO_EDGE) is available
/// only if the GL version is 4.4 or greater.
///
/// ### Associated Gets
/// [**glGetSamplerParameter**](crate::context::Context::oxidegl_get_sampler_parameter)
impl Context {
    pub fn oxidegl_sampler_parameteri(
        &mut self,
        sampler: GLuint,
        pname: SamplerParameterI,
        param: GLint,
    ) {
        panic!("command oxidegl_sampler_parameteri not yet implemented");
    }
    pub unsafe fn oxidegl_sampler_parameteriv(
        &mut self,
        sampler: GLuint,
        pname: SamplerParameterI,
        param: *const GLint,
    ) {
        panic!("command oxidegl_sampler_parameteriv not yet implemented");
    }
    pub fn oxidegl_sampler_parameterf(
        &mut self,
        sampler: GLuint,
        pname: SamplerParameterF,
        param: GLfloat,
    ) {
        panic!("command oxidegl_sampler_parameterf not yet implemented");
    }
    pub unsafe fn oxidegl_sampler_parameterfv(
        &mut self,
        sampler: GLuint,
        pname: SamplerParameterF,
        param: *const GLfloat,
    ) {
        panic!("command oxidegl_sampler_parameterfv not yet implemented");
    }
    pub unsafe fn oxidegl_sampler_parameter_iiv(
        &mut self,
        sampler: GLuint,
        pname: SamplerParameterI,
        param: *const GLint,
    ) {
        panic!("command oxidegl_sampler_parameter_iiv not yet implemented");
    }
    pub unsafe fn oxidegl_sampler_parameter_iuiv(
        &mut self,
        sampler: GLuint,
        pname: SamplerParameterI,
        param: *const GLuint,
    ) {
        panic!("command oxidegl_sampler_parameter_iuiv not yet implemented");
    }
}
/// ### Parameters
/// `index`
///
/// > Specifies the index of the viewport whose scissor box to modify.
///
/// `left`
///
/// `bottom`
///
/// > Specify the coordinate of the bottom left corner of the scissor box, in
/// > pixels.
///
/// `width`
///
/// `height`
///
/// > Specify ths dimensions of the scissor box, in pixels.
///
/// `v`
///
/// > For [**glScissorIndexedv**](crate::context::Context::oxidegl_scissor_indexedv),
/// > specifies the address of an array containing the left, bottom, width and
/// > height of each scissor box, in that order.
///
/// ### Description
/// [**glScissorIndexed**](crate::context::Context::oxidegl_scissor_indexed)
/// defines the scissor box for a specified viewport. `index` specifies the
/// index of scissor box to modify. `index` must be less than the value of
/// [`GL_MAX_VIEWPORTS`](crate::enums::GL_MAX_VIEWPORTS). For [**glScissorIndexed**](crate::context::Context::oxidegl_scissor_indexed),
/// `left`, `bottom`, `width` and `height` specify the left, bottom, width
/// and height of the scissor box, in pixels, respectively. For [**glScissorIndexedv**](crate::context::Context::oxidegl_scissor_indexedv),
/// `v` specifies the address of an array containing integers specifying the
/// lower left corner of the scissor box, and the width and height of the scissor
/// box, in that order.
///
/// To enable and disable the scissor test, call [**glEnable**](crate::context::Context::oxidegl_enable)
/// and [**glDisable**](crate::context::Context::oxidegl_disable) with argument
/// [`GL_SCISSOR_TEST`](crate::enums::GL_SCISSOR_TEST). The test is initially
/// disabled for all viewports. While the test is enabled, only pixels that
/// lie within the scissor box can be modified by drawing commands. Window
/// coordinates have integer values at the shared corners of frame buffer pixels.
///
/// When the scissor test is disabled, it is as though the scissor box includes
/// the entire window.
///
/// ### Associated Gets
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_SCISSOR_BOX`](crate::enums::GL_SCISSOR_BOX)
///
/// [**glIsEnabled**](crate::context::Context::oxidegl_is_enabled) with argument
/// [`GL_SCISSOR_TEST`](crate::enums::GL_SCISSOR_TEST)
impl Context {
    pub fn oxidegl_scissor_indexed(
        &mut self,
        index: GLuint,
        left: GLint,
        bottom: GLint,
        width: GLsizei,
        height: GLsizei,
    ) {
        panic!("command oxidegl_scissor_indexed not yet implemented");
    }
    pub unsafe fn oxidegl_scissor_indexedv(&mut self, index: GLuint, v: *const GLint) {
        panic!("command oxidegl_scissor_indexedv not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the texture is bound for [**glTexBuffer**](crate::context::Context::oxidegl_tex_buffer).
/// > Must be [`GL_TEXTURE_BUFFER`](crate::enums::GL_TEXTURE_BUFFER).
///
/// `texture`
///
/// > Specifies the texture object name for [**glTextureBuffer**](crate::context::Context::oxidegl_texture_buffer).
///
/// `internalformat`
///
/// > Specifies the internal format of the data in the store belonging to `buffer`.
///
/// `buffer`
///
/// > Specifies the name of the buffer object whose storage to attach to the
/// > active buffer texture.
///
/// ### Description
/// [**glTexBuffer**](crate::context::Context::oxidegl_tex_buffer) and [**glTextureBuffer**](crate::context::Context::oxidegl_texture_buffer)
/// attaches the data store of a specified buffer object to a specified texture
/// object, and specify the storage format for the texture image found in the
/// buffer object. The texture object must be a buffer texture.
///
/// If `buffer` is zero, any buffer object attached to the buffer texture is
/// detached and no new buffer object is attached. If `buffer` is non-zero,
/// it must be the name of an existing buffer object.
///
/// `internalformat` specifies the storage format, and must be one of the following
/// sized internal formats:
///
/// | *Sized Internal Format*                               | *Base Type*       | *Components*        | *Norm*     | 0  | 1  | 2  | 3  |
/// |-------------------------------------------------------|-------------------|---------------------|------------|----|----|----|----|
/// | [`GL_R8`](crate::enums::GL_R8)                        | ubyte             | 1                   | YES        | R  | 0  | 0  | 1  |
/// | [`GL_R16`](crate::enums::GL_R16)                      | ushort            | 1                   | YES        | R  | 0  | 0  | 1  |
/// | [`GL_R16F`](crate::enums::GL_R16F)                    | half              | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R32F`](crate::enums::GL_R32F)                    | float             | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R8I`](crate::enums::GL_R8I)                      | byte              | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R16I`](crate::enums::GL_R16I)                    | short             | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R32I`](crate::enums::GL_R32I)                    | int               | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R8UI`](crate::enums::GL_R8UI)                    | ubyte             | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R16UI`](crate::enums::GL_R16UI)                  | ushort            | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R32UI`](crate::enums::GL_R32UI)                  | uint              | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_RG8`](crate::enums::GL_RG8)                      | ubyte             | 2                   | YES        | R  | G  | 0  | 1  |
/// | [`GL_RG16`](crate::enums::GL_RG16)                    | ushort            | 2                   | YES        | R  | G  | 0  | 1  |
/// | [`GL_RG16F`](crate::enums::GL_RG16F)                  | half              | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG32F`](crate::enums::GL_RG32F)                  | float             | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG8I`](crate::enums::GL_RG8I)                    | byte              | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG16I`](crate::enums::GL_RG16I)                  | short             | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG32I`](crate::enums::GL_RG32I)                  | int               | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG8UI`](crate::enums::GL_RG8UI)                  | ubyte             | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG16UI`](crate::enums::GL_RG16UI)                | ushort            | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG32UI`](crate::enums::GL_RG32UI)                | uint              | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RGB32F`](crate::enums::GL_RGB32F)                | float             | 3                   | NO         | R  | G  | B  | 1  |
/// | [`GL_RGB32I`](crate::enums::GL_RGB32I)                | int               | 3                   | NO         | R  | G  | B  | 1  |
/// | [`GL_RGB32UI`](crate::enums::GL_RGB32UI)              | uint              | 3                   | NO         | R  | G  | B  | 1  |
/// | [`GL_RGBA8`](crate::enums::GL_RGBA8)                  | uint              | 4                   | YES        | R  | G  | B  | A  |
/// | [`GL_RGBA16`](crate::enums::GL_RGBA16)                | short             | 4                   | YES        | R  | G  | B  | A  |
/// | [`GL_RGBA16F`](crate::enums::GL_RGBA16F)              | half              | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA32F`](crate::enums::GL_RGBA32F)              | float             | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA8I`](crate::enums::GL_RGBA8I)                | byte              | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA16I`](crate::enums::GL_RGBA16I)              | short             | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA32I`](crate::enums::GL_RGBA32I)              | int               | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA8UI`](crate::enums::GL_RGBA8UI)              | ubyte             | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA16UI`](crate::enums::GL_RGBA16UI)            | ushort            | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA32UI`](crate::enums::GL_RGBA32UI)            | uint              | 4                   | NO         | R  | G  | B  | A  |
///
/// When a buffer object is attached to a buffer texture, the buffer object's
/// data store is taken as the texture's texel array. The number of texels
/// in the buffer texture's texel array is given by $$ \left\lfloor{ size \over
///{ components \times sizeof(base\_type)}} \right\rfloor $$ where $size$ is
/// the size of the buffer object in basic machine units (the value of [`GL_BUFFER_SIZE`](crate::enums::GL_BUFFER_SIZE)
/// for `buffer` ), and $components$ and $base\_type$ are the element count
/// and base data type for elements, as specified in the table above. The number
/// of texels in the texel array is then clamped to the value of the implementation-dependent
/// limit [`GL_MAX_TEXTURE_BUFFER_SIZE`](crate::enums::GL_MAX_TEXTURE_BUFFER_SIZE).
/// When a buffer texture is accessed in a shader, the results of a texel
/// fetch are undefined if the specified texel coordinate is negative, or greater
/// than or equal to the clamped number of texels in the texel array.
///
/// ### Associated Gets
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_TEXTURE_BUFFER_SIZE`](crate::enums::GL_MAX_TEXTURE_BUFFER_SIZE)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_TEXTURE_BINDING_BUFFER`](crate::enums::GL_TEXTURE_BINDING_BUFFER)
///
/// [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter)
/// with argument [`GL_TEXTURE_BUFFER_DATA_STORE_BINDING`](crate::enums::GL_TEXTURE_BUFFER_DATA_STORE_BINDING)
impl Context {
    pub fn oxidegl_tex_buffer(
        &mut self,
        target: TextureTarget,
        internalformat: SizedInternalFormat,
        buffer: GLuint,
    ) {
        panic!("command oxidegl_tex_buffer not yet implemented");
    }
    pub fn oxidegl_texture_buffer(
        &mut self,
        texture: GLuint,
        internalformat: SizedInternalFormat,
        buffer: GLuint,
    ) {
        panic!("command oxidegl_texture_buffer not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the texture object is bound for [**glTexBufferRange**](crate::context::Context::oxidegl_tex_buffer_range).
/// > Must be [`GL_TEXTURE_BUFFER`](crate::enums::GL_TEXTURE_BUFFER).
///
/// `texture`
///
/// > Specifies the texture object name for [**glTextureBufferRange**](crate::context::Context::oxidegl_texture_buffer_range).
///
/// `internalformat`
///
/// > Specifies the internal format of the data in the store belonging to `buffer`.
///
/// `buffer`
///
/// > Specifies the name of the buffer object whose storage to attach to the
/// > active buffer texture.
///
/// `offset`
///
/// > Specifies the offset of the start of the range of the buffer's data store
/// > to attach.
///
/// `size`
///
/// > Specifies the size of the range of the buffer's data store to attach.
///
/// ### Description
/// [**glTexBufferRange**](crate::context::Context::oxidegl_tex_buffer_range)
/// and [**glTextureBufferRange**](crate::context::Context::oxidegl_texture_buffer_range)
/// attach a range of the data store of a specified buffer object to a specified
/// texture object, and specify the storage format for the texture image found
/// in the buffer object. The texture object must be a buffer texture.
///
/// If `buffer` is zero, any buffer object attached to the buffer texture is
/// detached and no new buffer object is attached. If `buffer` is non-zero,
/// it must be the name of an existing buffer object.
///
/// The start and size of the range are specified by `offset` and `size` respectively,
/// both measured in basic machine units. `offset` must be greater than or
/// equal to zero, `size` must be greater than zero, and the sum of `offset`
/// and `size` must not exceed the value of [`GL_BUFFER_SIZE`](crate::enums::GL_BUFFER_SIZE)
/// for `buffer`. Furthermore, `offset` must be an integer multiple of the
/// value of [`GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT`](crate::enums::GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT).
///
/// `internalformat` specifies the storage format, and must be one of the following
/// sized internal formats:
///
/// | *Sized Internal Format*                               | *Base Type*       | *Components*        | *Norm*     | 0  | 1  | 2  | 3  |
/// |-------------------------------------------------------|-------------------|---------------------|------------|----|----|----|----|
/// | [`GL_R8`](crate::enums::GL_R8)                        | ubyte             | 1                   | YES        | R  | 0  | 0  | 1  |
/// | [`GL_R16`](crate::enums::GL_R16)                      | ushort            | 1                   | YES        | R  | 0  | 0  | 1  |
/// | [`GL_R16F`](crate::enums::GL_R16F)                    | half              | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R32F`](crate::enums::GL_R32F)                    | float             | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R8I`](crate::enums::GL_R8I)                      | byte              | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R16I`](crate::enums::GL_R16I)                    | short             | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R32I`](crate::enums::GL_R32I)                    | int               | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R8UI`](crate::enums::GL_R8UI)                    | ubyte             | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R16UI`](crate::enums::GL_R16UI)                  | ushort            | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_R32UI`](crate::enums::GL_R32UI)                  | uint              | 1                   | NO         | R  | 0  | 0  | 1  |
/// | [`GL_RG8`](crate::enums::GL_RG8)                      | ubyte             | 2                   | YES        | R  | G  | 0  | 1  |
/// | [`GL_RG16`](crate::enums::GL_RG16)                    | ushort            | 2                   | YES        | R  | G  | 0  | 1  |
/// | [`GL_RG16F`](crate::enums::GL_RG16F)                  | half              | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG32F`](crate::enums::GL_RG32F)                  | float             | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG8I`](crate::enums::GL_RG8I)                    | byte              | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG16I`](crate::enums::GL_RG16I)                  | short             | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG32I`](crate::enums::GL_RG32I)                  | int               | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG8UI`](crate::enums::GL_RG8UI)                  | ubyte             | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG16UI`](crate::enums::GL_RG16UI)                | ushort            | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RG32UI`](crate::enums::GL_RG32UI)                | uint              | 2                   | NO         | R  | G  | 0  | 1  |
/// | [`GL_RGB32F`](crate::enums::GL_RGB32F)                | float             | 3                   | NO         | R  | G  | B  | 1  |
/// | [`GL_RGB32I`](crate::enums::GL_RGB32I)                | int               | 3                   | NO         | R  | G  | B  | 1  |
/// | [`GL_RGB32UI`](crate::enums::GL_RGB32UI)              | uint              | 3                   | NO         | R  | G  | B  | 1  |
/// | [`GL_RGBA8`](crate::enums::GL_RGBA8)                  | uint              | 4                   | YES        | R  | G  | B  | A  |
/// | [`GL_RGBA16`](crate::enums::GL_RGBA16)                | short             | 4                   | YES        | R  | G  | B  | A  |
/// | [`GL_RGBA16F`](crate::enums::GL_RGBA16F)              | half              | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA32F`](crate::enums::GL_RGBA32F)              | float             | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA8I`](crate::enums::GL_RGBA8I)                | byte              | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA16I`](crate::enums::GL_RGBA16I)              | short             | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA32I`](crate::enums::GL_RGBA32I)              | int               | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA8UI`](crate::enums::GL_RGBA8UI)              | ubyte             | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA16UI`](crate::enums::GL_RGBA16UI)            | ushort            | 4                   | NO         | R  | G  | B  | A  |
/// | [`GL_RGBA32UI`](crate::enums::GL_RGBA32UI)            | uint              | 4                   | NO         | R  | G  | B  | A  |
///
/// When a range of a buffer object is attached to a buffer texture, the specified
/// range of the buffer object's data store is taken as the texture's texel
/// array. The number of texels in the buffer texture's texel array is given
/// by $$ \left\lfloor{ size \over{ components \times sizeof(base\_type)}} \right\rfloor
/// $$ where $components$ and $base\_type$ are the element count and base data
/// type for elements, as specified in the table above. The number of texels
/// in the texel array is then clamped to the value of the implementation-dependent
/// limit [`GL_MAX_TEXTURE_BUFFER_SIZE`](crate::enums::GL_MAX_TEXTURE_BUFFER_SIZE).
/// When a buffer texture is accessed in a shader, the results of a texel
/// fetch are undefined if the specified texel coordinate is negative, or greater
/// than or equal to the clamped number of texels in the texel array.
///
/// ### Associated Gets
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT`](crate::enums::GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT)
///
/// [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter)
/// with arguments [`GL_TEXTURE_BUFFER_OFFSET`](crate::enums::GL_TEXTURE_BUFFER_OFFSET)
/// or [`GL_TEXTURE_BUFFER_SIZE`](crate::enums::GL_TEXTURE_BUFFER_SIZE).
impl Context {
    pub fn oxidegl_tex_buffer_range(
        &mut self,
        target: TextureTarget,
        internalformat: SizedInternalFormat,
        buffer: GLuint,
        offset: GLintptr,
        size: GLsizeiptr,
    ) {
        panic!("command oxidegl_tex_buffer_range not yet implemented");
    }
    pub fn oxidegl_texture_buffer_range(
        &mut self,
        texture: GLuint,
        internalformat: SizedInternalFormat,
        buffer: GLuint,
        offset: GLintptr,
        size: GLsizeiptr,
    ) {
        panic!("command oxidegl_texture_buffer_range not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the texture is bound for [**glTexParameter**](crate::context::Context::oxidegl_tex_parameter)
/// > functions. Must be one of [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D),
/// > [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY), [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D),
/// > [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY), [`GL_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE),
/// > [`GL_TEXTURE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE_ARRAY),
/// > [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D), [`GL_TEXTURE_CUBE_MAP`](crate::enums::GL_TEXTURE_CUBE_MAP),
/// > [`GL_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_CUBE_MAP_ARRAY),
/// > or [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE).
///
/// `texture`
///
/// > Specifies the texture object name for [**glTextureParameter**](crate::context::Context::oxidegl_texture_parameter)
/// > functions.
///
/// `pname`
///
/// > Specifies the symbolic name of a single-valued texture parameter. `pname`
/// > can be one of the following: [`GL_DEPTH_STENCIL_TEXTURE_MODE`](crate::enums::GL_DEPTH_STENCIL_TEXTURE_MODE),
/// > [`GL_TEXTURE_BASE_LEVEL`](crate::enums::GL_TEXTURE_BASE_LEVEL), [`GL_TEXTURE_COMPARE_FUNC`](crate::enums::GL_TEXTURE_COMPARE_FUNC),
/// > [`GL_TEXTURE_COMPARE_MODE`](crate::enums::GL_TEXTURE_COMPARE_MODE), [`GL_TEXTURE_LOD_BIAS`](crate::enums::GL_TEXTURE_LOD_BIAS),
/// > [`GL_TEXTURE_MIN_FILTER`](crate::enums::GL_TEXTURE_MIN_FILTER), [`GL_TEXTURE_MAG_FILTER`](crate::enums::GL_TEXTURE_MAG_FILTER),
/// > [`GL_TEXTURE_MIN_LOD`](crate::enums::GL_TEXTURE_MIN_LOD), [`GL_TEXTURE_MAX_LOD`](crate::enums::GL_TEXTURE_MAX_LOD),
/// > [`GL_TEXTURE_MAX_LEVEL`](crate::enums::GL_TEXTURE_MAX_LEVEL), [`GL_TEXTURE_SWIZZLE_R`](crate::enums::GL_TEXTURE_SWIZZLE_R),
/// > [`GL_TEXTURE_SWIZZLE_G`](crate::enums::GL_TEXTURE_SWIZZLE_G), [`GL_TEXTURE_SWIZZLE_B`](crate::enums::GL_TEXTURE_SWIZZLE_B),
/// > [`GL_TEXTURE_SWIZZLE_A`](crate::enums::GL_TEXTURE_SWIZZLE_A), [`GL_TEXTURE_WRAP_S`](crate::enums::GL_TEXTURE_WRAP_S),
/// > [`GL_TEXTURE_WRAP_T`](crate::enums::GL_TEXTURE_WRAP_T), or [`GL_TEXTURE_WRAP_R`](crate::enums::GL_TEXTURE_WRAP_R).
///
/// > For the vector commands( [**glTexParameter*v**](crate::context::Context::oxidegl_tex_parameter*v)
/// > ), `pname` can also be one of [`GL_TEXTURE_BORDER_COLOR`](crate::enums::GL_TEXTURE_BORDER_COLOR)
/// > or [`GL_TEXTURE_SWIZZLE_RGBA`](crate::enums::GL_TEXTURE_SWIZZLE_RGBA).
///
/// `param`
///
/// > For the scalar commands, specifies the value of `pname`.
///
/// `params`
///
/// > For the vector commands, specifies a pointer to an array where the value
/// > or values of `pname` are stored.
///
/// ### Description
/// [**glTexParameter**](crate::context::Context::oxidegl_tex_parameter) and
/// [**glTextureParameter**](crate::context::Context::oxidegl_texture_parameter)
/// assign the value or values in `params` to the texture parameter specified
/// as `pname`. For [**glTexParameter**](crate::context::Context::oxidegl_tex_parameter),
/// `target` defines the target texture, either [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D),
/// [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY), [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D),
/// [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY), [`GL_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE),
/// [`GL_TEXTURE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE_ARRAY),
/// [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D), [`GL_TEXTURE_CUBE_MAP`](crate::enums::GL_TEXTURE_CUBE_MAP),
/// [`GL_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_CUBE_MAP_ARRAY),
/// or [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE). The following
/// symbols are accepted in `pname`:
///
/// [`GL_DEPTH_STENCIL_TEXTURE_MODE`](crate::enums::GL_DEPTH_STENCIL_TEXTURE_MODE)
///
/// > Specifies the mode used to read from depth-stencil format textures. `params`
/// > must be one of [`GL_DEPTH_COMPONENT`](crate::enums::GL_DEPTH_COMPONENT)
/// > or [`GL_STENCIL_INDEX`](crate::enums::GL_STENCIL_INDEX). If the depth stencil
/// > mode is [`GL_DEPTH_COMPONENT`](crate::enums::GL_DEPTH_COMPONENT), then
/// > reads from depth-stencil format textures will return the depth component
/// > of the texel in `[inlineq]` [`GL_STENCIL_INDEX`](crate::enums::GL_STENCIL_INDEX)
/// > then the stencil component is returned in `[inlineq]` [`GL_DEPTH_COMPONENT`](crate::enums::GL_DEPTH_COMPONENT).
///
/// [`GL_TEXTURE_BASE_LEVEL`](crate::enums::GL_TEXTURE_BASE_LEVEL)
///
/// > Specifies the index of the lowest defined mipmap level. This is an integer
/// > value. The initial value is 0.
///
///
/// [`GL_TEXTURE_BORDER_COLOR`](crate::enums::GL_TEXTURE_BORDER_COLOR)
///
/// > The data in `params` specifies four values that define the border values
/// > that should be used for border texels. If a texel is sampled from the border
/// > of the texture, the values of [`GL_TEXTURE_BORDER_COLOR`](crate::enums::GL_TEXTURE_BORDER_COLOR)
/// > are interpreted as an RGBA color to match the texture's internal format
/// > and substituted for the non-existent texel data. If the texture contains
/// > depth components, the first component of [`GL_TEXTURE_BORDER_COLOR`](crate::enums::GL_TEXTURE_BORDER_COLOR)
/// > is interpreted as a depth value. The initial value is `[inlineq]`
///
/// > If the values for [`GL_TEXTURE_BORDER_COLOR`](crate::enums::GL_TEXTURE_BORDER_COLOR)
/// > are specified with [**glTexParameterIiv**](crate::context::Context::oxidegl_tex_parameter_iiv)
/// > or [**glTexParameterIuiv**](crate::context::Context::oxidegl_tex_parameter_iuiv),
/// > the values are stored unmodified with an internal data type of integer.
/// > If specified with [**glTexParameteriv**](crate::context::Context::oxidegl_tex_parameteriv),
/// > they are converted to floating point with the following equation: `[inlineq]`
/// > [**glTexParameterfv**](crate::context::Context::oxidegl_tex_parameterfv),
/// > they are stored unmodified as floating-point values.
///
/// [`GL_TEXTURE_COMPARE_FUNC`](crate::enums::GL_TEXTURE_COMPARE_FUNC)
///
/// > Specifies the comparison operator used when [`GL_TEXTURE_COMPARE_MODE`](crate::enums::GL_TEXTURE_COMPARE_MODE)
/// > is set to [`GL_COMPARE_REF_TO_TEXTURE`](crate::enums::GL_COMPARE_REF_TO_TEXTURE).
/// > Permissible values are:
/// > |* Texture Comparison Function*                                  |* Computed result*                            |
/// > |----------------------------------------------------------------|----------------------------------------------|
/// > | [`GL_LEQUAL`](crate::enums::GL_LEQUAL)                         | `[inlineq]`                                  |
/// > | [`GL_GEQUAL`](crate::enums::GL_GEQUAL)                         | `[inlineq]`                                  |
/// > | [`GL_LESS`](crate::enums::GL_LESS)                             | `[inlineq]`                                  |
/// > | [`GL_GREATER`](crate::enums::GL_GREATER)                       | `[inlineq]`                                  |
/// > | [`GL_EQUAL`](crate::enums::GL_EQUAL)                           | `[inlineq]`                                  |
/// > | [`GL_NOTEQUAL`](crate::enums::GL_NOTEQUAL)                     | `[inlineq]`                                  |
/// > | [`GL_ALWAYS`](crate::enums::GL_ALWAYS)                         | `[inlineq]`                                  |
/// > | [`GL_NEVER`](crate::enums::GL_NEVER)                           | `[inlineq]`                                  |
///
/// > `[inlineq]` `[inlineq]` `[inlineq]`
///
/// [`GL_TEXTURE_COMPARE_MODE`](crate::enums::GL_TEXTURE_COMPARE_MODE)
///
/// > Specifies the texture comparison mode for currently bound depth textures.
/// > That is, a texture whose internal format is [`GL_DEPTH_COMPONENT_*`](crate::enums::GL_DEPTH_COMPONENT_*);
/// > see [**glTexImage2D**](crate::context::Context::oxidegl_tex_image2_d))
/// > Permissible values are: [`GL_COMPARE_REF_TO_TEXTURE`](crate::enums::GL_COMPARE_REF_TO_TEXTURE)
///
/// >> Specifies that the interpolated and clamped `[inlineq]` [`GL_TEXTURE_COMPARE_FUNC`](crate::enums::GL_TEXTURE_COMPARE_FUNC)
/// >> for details of how the comparison is evaluated. The result of the comparison
/// >> is assigned to the red channel.
///
/// > [`GL_NONE`](crate::enums::GL_NONE)
///
/// >> Specifies that the red channel should be assigned the appropriate value
/// >> from the currently bound depth texture.
///
///
/// [`GL_TEXTURE_LOD_BIAS`](crate::enums::GL_TEXTURE_LOD_BIAS)
///
/// > `params` specifies a fixed bias value that is to be added to the level-of-detail
/// > parameter for the texture before texture sampling. The specified value
/// > is added to the shader-supplied bias value (if any) and subsequently clamped
/// > into the implementation-defined range `[inlineq]` `[inlineq]` [`GL_MAX_TEXTURE_LOD_BIAS`](crate::enums::GL_MAX_TEXTURE_LOD_BIAS).
/// > The initial value is 0.0.
///
/// [`GL_TEXTURE_MIN_FILTER`](crate::enums::GL_TEXTURE_MIN_FILTER)
///
/// > The texture minifying function is used whenever the level-of-detail function
/// > used when sampling from the texture determines that the texture should
/// > be minified. There are six defined minifying functions. Two of them use
/// > either the nearest texture elements or a weighted average of multiple texture
/// > elements to compute the texture value. The other four use mipmaps.
///
/// > A mipmap is an ordered set of arrays representing the same image at progressively
/// > lower resolutions. If the texture has dimensions `[inlineq]` `[inlineq]`
/// > `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]`
/// > `[inlineq]` `[inlineq]` [**glTexImage1D**](crate::context::Context::oxidegl_tex_image1_d),
/// > [**glTexImage2D**](crate::context::Context::oxidegl_tex_image2_d), [**glTexImage3D**](crate::context::Context::oxidegl_tex_image3_d),
/// > [**glCopyTexImage1D**](crate::context::Context::oxidegl_copy_tex_image1_d),
/// > or [**glCopyTexImage2D**](crate::context::Context::oxidegl_copy_tex_image2_d)
/// > with the *level* argument indicating the order of the mipmaps. Level 0
/// > is the original texture; level `[inlineq]` `[inlineq]`
///
/// > `params` supplies a function for minifying the texture as one of the following:
/// > [`GL_NEAREST`](crate::enums::GL_NEAREST)
///
/// >> Returns the value of the texture element that is nearest (in Manhattan
/// >> distance) to the specified texture coordinates.
///
/// > [`GL_LINEAR`](crate::enums::GL_LINEAR)
///
/// >> Returns the weighted average of the four texture elements that are closest
/// >> to the specified texture coordinates. These can include items wrapped or
/// >> repeated from other parts of a texture, depending on the values of [`GL_TEXTURE_WRAP_S`](crate::enums::GL_TEXTURE_WRAP_S)
/// >> and [`GL_TEXTURE_WRAP_T`](crate::enums::GL_TEXTURE_WRAP_T), and on the
/// >> exact mapping.
///
/// > [`GL_NEAREST_MIPMAP_NEAREST`](crate::enums::GL_NEAREST_MIPMAP_NEAREST)
///
/// >> Chooses the mipmap that most closely matches the size of the pixel being
/// >> textured and uses the [`GL_NEAREST`](crate::enums::GL_NEAREST) criterion
/// >> (the texture element closest to the specified texture coordinates) to produce
/// >> a texture value.
///
/// > [`GL_LINEAR_MIPMAP_NEAREST`](crate::enums::GL_LINEAR_MIPMAP_NEAREST)
///
/// >> Chooses the mipmap that most closely matches the size of the pixel being
/// >> textured and uses the [`GL_LINEAR`](crate::enums::GL_LINEAR) criterion
/// >> (a weighted average of the four texture elements that are closest to the
/// >> specified texture coordinates) to produce a texture value.
///
/// > [`GL_NEAREST_MIPMAP_LINEAR`](crate::enums::GL_NEAREST_MIPMAP_LINEAR)
///
/// >> Chooses the two mipmaps that most closely match the size of the pixel being
/// >> textured and uses the [`GL_NEAREST`](crate::enums::GL_NEAREST) criterion
/// >> (the texture element closest to the specified texture coordinates) to produce
/// >> a texture value from each mipmap. The final texture value is a weighted
/// >> average of those two values.
///
/// > [`GL_LINEAR_MIPMAP_LINEAR`](crate::enums::GL_LINEAR_MIPMAP_LINEAR)
///
/// >> Chooses the two mipmaps that most closely match the size of the pixel being
/// >> textured and uses the [`GL_LINEAR`](crate::enums::GL_LINEAR) criterion
/// >> (a weighted average of the texture elements that are closest to the specified
/// >> texture coordinates) to produce a texture value from each mipmap. The final
/// >> texture value is a weighted average of those two values.
///
///
/// > As more texture elements are sampled in the minification process, fewer
/// > aliasing artifacts will be apparent. While the [`GL_NEAREST`](crate::enums::GL_NEAREST)
/// > and [`GL_LINEAR`](crate::enums::GL_LINEAR) minification functions can be
/// > faster than the other four, they sample only one or multiple texture elements
/// > to determine the texture value of the pixel being rendered and can produce
/// > moire patterns or ragged transitions. The initial value of [`GL_TEXTURE_MIN_FILTER`](crate::enums::GL_TEXTURE_MIN_FILTER)
/// > is [`GL_NEAREST_MIPMAP_LINEAR`](crate::enums::GL_NEAREST_MIPMAP_LINEAR).
///
///
/// [`GL_TEXTURE_MAG_FILTER`](crate::enums::GL_TEXTURE_MAG_FILTER)
///
/// > The texture magnification function is used whenever the level-of-detail
/// > function used when sampling from the texture determines that the texture
/// > should be magified. It sets the texture magnification function to either
/// > [`GL_NEAREST`](crate::enums::GL_NEAREST) or [`GL_LINEAR`](crate::enums::GL_LINEAR)
/// > (see below). [`GL_NEAREST`](crate::enums::GL_NEAREST) is generally faster
/// > than [`GL_LINEAR`](crate::enums::GL_LINEAR), but it can produce textured
/// > images with sharper edges because the transition between texture elements
/// > is not as smooth. The initial value of [`GL_TEXTURE_MAG_FILTER`](crate::enums::GL_TEXTURE_MAG_FILTER)
/// > is [`GL_LINEAR`](crate::enums::GL_LINEAR). [`GL_NEAREST`](crate::enums::GL_NEAREST)
///
/// >> Returns the value of the texture element that is nearest (in Manhattan
/// >> distance) to the specified texture coordinates.
///
/// > [`GL_LINEAR`](crate::enums::GL_LINEAR)
///
/// >> Returns the weighted average of the texture elements that are closest to
/// >> the specified texture coordinates. These can include items wrapped or repeated
/// >> from other parts of a texture, depending on the values of [`GL_TEXTURE_WRAP_S`](crate::enums::GL_TEXTURE_WRAP_S)
/// >> and [`GL_TEXTURE_WRAP_T`](crate::enums::GL_TEXTURE_WRAP_T), and on the
/// >> exact mapping.
///
///
///
/// [`GL_TEXTURE_MIN_LOD`](crate::enums::GL_TEXTURE_MIN_LOD)
///
/// > Sets the minimum level-of-detail parameter. This floating-point value limits
/// > the selection of highest resolution mipmap (lowest mipmap level). The initial
/// > value is -1000.
///
///
/// [`GL_TEXTURE_MAX_LOD`](crate::enums::GL_TEXTURE_MAX_LOD)
///
/// > Sets the maximum level-of-detail parameter. This floating-point value limits
/// > the selection of the lowest resolution mipmap (highest mipmap level). The
/// > initial value is 1000.
///
///
/// [`GL_TEXTURE_MAX_LEVEL`](crate::enums::GL_TEXTURE_MAX_LEVEL)
///
/// > Sets the index of the highest defined mipmap level. This is an integer
/// > value. The initial value is 1000.
///
///
/// [`GL_TEXTURE_SWIZZLE_R`](crate::enums::GL_TEXTURE_SWIZZLE_R)
///
/// > Sets the swizzle that will be applied to the `[inlineq]` `param` are [`GL_RED`](crate::enums::GL_RED),
/// > [`GL_GREEN`](crate::enums::GL_GREEN), [`GL_BLUE`](crate::enums::GL_BLUE),
/// > [`GL_ALPHA`](crate::enums::GL_ALPHA), [`GL_ZERO`](crate::enums::GL_ZERO)
/// > and [`GL_ONE`](crate::enums::GL_ONE). If [`GL_TEXTURE_SWIZZLE_R`](crate::enums::GL_TEXTURE_SWIZZLE_R)
/// > is [`GL_RED`](crate::enums::GL_RED), the value for `[inlineq]` [`GL_TEXTURE_SWIZZLE_R`](crate::enums::GL_TEXTURE_SWIZZLE_R)
/// > is [`GL_GREEN`](crate::enums::GL_GREEN), the value for `[inlineq]` [`GL_TEXTURE_SWIZZLE_R`](crate::enums::GL_TEXTURE_SWIZZLE_R)
/// > is [`GL_BLUE`](crate::enums::GL_BLUE), the value for `[inlineq]` [`GL_TEXTURE_SWIZZLE_R`](crate::enums::GL_TEXTURE_SWIZZLE_R)
/// > is [`GL_ALPHA`](crate::enums::GL_ALPHA), the value for `[inlineq]` [`GL_TEXTURE_SWIZZLE_R`](crate::enums::GL_TEXTURE_SWIZZLE_R)
/// > is [`GL_ZERO`](crate::enums::GL_ZERO), the value for `[inlineq]` `[inlineq]`
/// > [`GL_TEXTURE_SWIZZLE_R`](crate::enums::GL_TEXTURE_SWIZZLE_R) is [`GL_ONE`](crate::enums::GL_ONE),
/// > the value for `[inlineq]` `[inlineq]` [`GL_RED`](crate::enums::GL_RED).
///
///
/// [`GL_TEXTURE_SWIZZLE_G`](crate::enums::GL_TEXTURE_SWIZZLE_G)
///
/// > Sets the swizzle that will be applied to the `[inlineq]` `param` and their
/// > effects are similar to those of [`GL_TEXTURE_SWIZZLE_R`](crate::enums::GL_TEXTURE_SWIZZLE_R).
/// > The initial value is [`GL_GREEN`](crate::enums::GL_GREEN).
///
///
/// [`GL_TEXTURE_SWIZZLE_B`](crate::enums::GL_TEXTURE_SWIZZLE_B)
///
/// > Sets the swizzle that will be applied to the `[inlineq]` `param` and their
/// > effects are similar to those of [`GL_TEXTURE_SWIZZLE_R`](crate::enums::GL_TEXTURE_SWIZZLE_R).
/// > The initial value is [`GL_BLUE`](crate::enums::GL_BLUE).
///
///
/// [`GL_TEXTURE_SWIZZLE_A`](crate::enums::GL_TEXTURE_SWIZZLE_A)
///
/// > Sets the swizzle that will be applied to the `[inlineq]` `param` and their
/// > effects are similar to those of [`GL_TEXTURE_SWIZZLE_R`](crate::enums::GL_TEXTURE_SWIZZLE_R).
/// > The initial value is [`GL_ALPHA`](crate::enums::GL_ALPHA).
///
///
/// [`GL_TEXTURE_SWIZZLE_RGBA`](crate::enums::GL_TEXTURE_SWIZZLE_RGBA)
///
/// > Sets the swizzles that will be applied to the `[inlineq]` `[inlineq]` `[inlineq]`
/// > `[inlineq]` `params` and their effects are similar to those of [`GL_TEXTURE_SWIZZLE_R`](crate::enums::GL_TEXTURE_SWIZZLE_R),
/// > except that all channels are specified simultaneously. Setting the value
/// > of [`GL_TEXTURE_SWIZZLE_RGBA`](crate::enums::GL_TEXTURE_SWIZZLE_RGBA) is
/// > equivalent (assuming no errors are generated) to setting the parameters
/// > of each of [`GL_TEXTURE_SWIZZLE_R`](crate::enums::GL_TEXTURE_SWIZZLE_R),
/// > [`GL_TEXTURE_SWIZZLE_G`](crate::enums::GL_TEXTURE_SWIZZLE_G), [`GL_TEXTURE_SWIZZLE_B`](crate::enums::GL_TEXTURE_SWIZZLE_B),
/// > and [`GL_TEXTURE_SWIZZLE_A`](crate::enums::GL_TEXTURE_SWIZZLE_A) successively.
///
///
/// [`GL_TEXTURE_WRAP_S`](crate::enums::GL_TEXTURE_WRAP_S)
///
/// > Sets the wrap parameter for texture coordinate `[inlineq]` [`GL_CLAMP_TO_EDGE`](crate::enums::GL_CLAMP_TO_EDGE),
/// > [`GL_CLAMP_TO_BORDER`](crate::enums::GL_CLAMP_TO_BORDER), [`GL_MIRRORED_REPEAT`](crate::enums::GL_MIRRORED_REPEAT),
/// > [`GL_REPEAT`](crate::enums::GL_REPEAT), or [`GL_MIRROR_CLAMP_TO_EDGE`](crate::enums::GL_MIRROR_CLAMP_TO_EDGE).
/// > [`GL_CLAMP_TO_EDGE`](crate::enums::GL_CLAMP_TO_EDGE) causes `[inlineq]`
/// > `[inlineq]` `[inlineq]` [`GL_CLAMP_TO_BORDER`](crate::enums::GL_CLAMP_TO_BORDER)
/// > evaluates `[inlineq]` [`GL_CLAMP_TO_EDGE`](crate::enums::GL_CLAMP_TO_EDGE).
/// > However, in cases where clamping would have occurred in [`GL_CLAMP_TO_EDGE`](crate::enums::GL_CLAMP_TO_EDGE)
/// > mode, the fetched texel data is substituted with the values specified by
/// > [`GL_TEXTURE_BORDER_COLOR`](crate::enums::GL_TEXTURE_BORDER_COLOR). [`GL_REPEAT`](crate::enums::GL_REPEAT)
/// > causes the integer part of the `[inlineq]` [`GL_MIRRORED_REPEAT`](crate::enums::GL_MIRRORED_REPEAT)
/// > causes the `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]`
/// > `[inlineq]` `[inlineq]` [`GL_MIRROR_CLAMP_TO_EDGE`](crate::enums::GL_MIRROR_CLAMP_TO_EDGE)
/// > causes the `[inlineq]` [`GL_MIRRORED_REPEAT`](crate::enums::GL_MIRRORED_REPEAT)
/// > for one repetition of the texture, at which point the coordinate to be
/// > clamped as in [`GL_CLAMP_TO_EDGE`](crate::enums::GL_CLAMP_TO_EDGE). Initially,
/// > [`GL_TEXTURE_WRAP_S`](crate::enums::GL_TEXTURE_WRAP_S) is set to [`GL_REPEAT`](crate::enums::GL_REPEAT).
///
///
/// [`GL_TEXTURE_WRAP_T`](crate::enums::GL_TEXTURE_WRAP_T)
///
/// > Sets the wrap parameter for texture coordinate `[inlineq]` [`GL_CLAMP_TO_EDGE`](crate::enums::GL_CLAMP_TO_EDGE),
/// > [`GL_CLAMP_TO_BORDER`](crate::enums::GL_CLAMP_TO_BORDER), [`GL_MIRRORED_REPEAT`](crate::enums::GL_MIRRORED_REPEAT),
/// > [`GL_REPEAT`](crate::enums::GL_REPEAT), or [`GL_MIRROR_CLAMP_TO_EDGE`](crate::enums::GL_MIRROR_CLAMP_TO_EDGE).
/// > See the discussion under [`GL_TEXTURE_WRAP_S`](crate::enums::GL_TEXTURE_WRAP_S).
/// > Initially, [`GL_TEXTURE_WRAP_T`](crate::enums::GL_TEXTURE_WRAP_T) is set
/// > to [`GL_REPEAT`](crate::enums::GL_REPEAT).
///
///
/// [`GL_TEXTURE_WRAP_R`](crate::enums::GL_TEXTURE_WRAP_R)
///
/// > Sets the wrap parameter for texture coordinate `[inlineq]` [`GL_CLAMP_TO_EDGE`](crate::enums::GL_CLAMP_TO_EDGE),
/// > [`GL_CLAMP_TO_BORDER`](crate::enums::GL_CLAMP_TO_BORDER), [`GL_MIRRORED_REPEAT`](crate::enums::GL_MIRRORED_REPEAT),
/// > [`GL_REPEAT`](crate::enums::GL_REPEAT), or [`GL_MIRROR_CLAMP_TO_EDGE`](crate::enums::GL_MIRROR_CLAMP_TO_EDGE).
/// > See the discussion under [`GL_TEXTURE_WRAP_S`](crate::enums::GL_TEXTURE_WRAP_S).
/// > Initially, [`GL_TEXTURE_WRAP_R`](crate::enums::GL_TEXTURE_WRAP_R) is set
/// > to [`GL_REPEAT`](crate::enums::GL_REPEAT).
///
/// ### Notes
/// Suppose that a program attempts to sample from a texture and has set [`GL_TEXTURE_MIN_FILTER`](crate::enums::GL_TEXTURE_MIN_FILTER)
/// to one of the functions that requires a mipmap. If either the dimensions
/// of the texture images currently defined (with previous calls to [**glTexImage1D**](crate::context::Context::oxidegl_tex_image1_d),
/// [**glTexImage2D**](crate::context::Context::oxidegl_tex_image2_d), [**glTexImage3D**](crate::context::Context::oxidegl_tex_image3_d),
/// [**glCopyTexImage1D**](crate::context::Context::oxidegl_copy_tex_image1_d),
/// or [**glCopyTexImage2D**](crate::context::Context::oxidegl_copy_tex_image2_d))
/// do not follow the proper sequence for mipmaps (described above), or there
/// are fewer texture images defined than are needed, or the set of texture
/// images have differing numbers of texture components, then the texture is
/// considered *incomplete*.
///
/// Linear filtering accesses the four nearest texture elements only in 2D
/// textures. In 1D textures, linear filtering accesses the two nearest texture
/// elements. In 3D textures, linear filtering accesses the eight nearest texture
/// elements.
///
/// [**glTexParameter**](crate::context::Context::oxidegl_tex_parameter) specifies
/// the texture parameters for the active texture unit, specified by calling
/// [**glActiveTexture**](crate::context::Context::oxidegl_active_texture).
/// [**glTextureParameter**](crate::context::Context::oxidegl_texture_parameter)
/// specifies the texture parameters for the texture object with ID `texture`.
///
/// [`GL_DEPTH_STENCIL_TEXTURE_MODE`](crate::enums::GL_DEPTH_STENCIL_TEXTURE_MODE)
/// is available only if the GL version is 4.3 or greater.
///
/// [`GL_MIRROR_CLAMP_TO_EDGE`](crate::enums::GL_MIRROR_CLAMP_TO_EDGE) is available
/// only if the GL version is 4.4 or greater.
///
/// ### Associated Gets
/// [**glGetTexParameter**](crate::context::Context::oxidegl_get_tex_parameter)
///
/// [**glGetTextureParameter**](crate::context::Context::oxidegl_get_texture_parameter)
///
/// [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter)
///
/// [**glGetTextureLevelParameter**](crate::context::Context::oxidegl_get_texture_level_parameter)
impl Context {
    pub fn oxidegl_tex_parameterf(
        &mut self,
        target: TextureTarget,
        pname: TextureParameterName,
        param: GLfloat,
    ) {
        panic!("command oxidegl_tex_parameterf not yet implemented");
    }
    pub unsafe fn oxidegl_tex_parameterfv(
        &mut self,
        target: TextureTarget,
        pname: TextureParameterName,
        params: *const GLfloat,
    ) {
        panic!("command oxidegl_tex_parameterfv not yet implemented");
    }
    pub fn oxidegl_tex_parameteri(
        &mut self,
        target: TextureTarget,
        pname: TextureParameterName,
        param: GLint,
    ) {
        panic!("command oxidegl_tex_parameteri not yet implemented");
    }
    pub unsafe fn oxidegl_tex_parameteriv(
        &mut self,
        target: TextureTarget,
        pname: TextureParameterName,
        params: *const GLint,
    ) {
        panic!("command oxidegl_tex_parameteriv not yet implemented");
    }
    pub unsafe fn oxidegl_tex_parameter_iiv(
        &mut self,
        target: TextureTarget,
        pname: TextureParameterName,
        params: *const GLint,
    ) {
        panic!("command oxidegl_tex_parameter_iiv not yet implemented");
    }
    pub unsafe fn oxidegl_tex_parameter_iuiv(
        &mut self,
        target: TextureTarget,
        pname: TextureParameterName,
        params: *const GLuint,
    ) {
        panic!("command oxidegl_tex_parameter_iuiv not yet implemented");
    }
    pub fn oxidegl_texture_parameterf(
        &mut self,
        texture: GLuint,
        pname: TextureParameterName,
        param: GLfloat,
    ) {
        panic!("command oxidegl_texture_parameterf not yet implemented");
    }
    pub unsafe fn oxidegl_texture_parameterfv(
        &mut self,
        texture: GLuint,
        pname: TextureParameterName,
        param: *const GLfloat,
    ) {
        panic!("command oxidegl_texture_parameterfv not yet implemented");
    }
    pub fn oxidegl_texture_parameteri(
        &mut self,
        texture: GLuint,
        pname: TextureParameterName,
        param: GLint,
    ) {
        panic!("command oxidegl_texture_parameteri not yet implemented");
    }
    pub unsafe fn oxidegl_texture_parameter_iiv(
        &mut self,
        texture: GLuint,
        pname: TextureParameterName,
        params: *const GLint,
    ) {
        panic!("command oxidegl_texture_parameter_iiv not yet implemented");
    }
    pub unsafe fn oxidegl_texture_parameter_iuiv(
        &mut self,
        texture: GLuint,
        pname: TextureParameterName,
        params: *const GLuint,
    ) {
        panic!("command oxidegl_texture_parameter_iuiv not yet implemented");
    }
    pub unsafe fn oxidegl_texture_parameteriv(
        &mut self,
        texture: GLuint,
        pname: TextureParameterName,
        param: *const GLint,
    ) {
        panic!("command oxidegl_texture_parameteriv not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the texture object is bound for [**glTexStorage1D**](crate::context::Context::oxidegl_tex_storage1_d).
/// > Must be one of [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D) or [`GL_PROXY_TEXTURE_1D`](crate::enums::GL_PROXY_TEXTURE_1D).
///
/// `texture`
///
/// > Specifies the texture object name for [**glTextureStorage1D**](crate::context::Context::oxidegl_texture_storage1_d).
/// > The effective target of `texture` must be one of the valid non-proxy `target`
/// > values above.
///
/// `levels`
///
/// > Specify the number of texture levels.
///
/// `internalformat`
///
/// > Specifies the sized internal format to be used to store texture image data.
///
/// `width`
///
/// > Specifies the width of the texture, in texels.
///
/// ### Description
/// [**glTexStorage1D**](crate::context::Context::oxidegl_tex_storage1_d) and
/// [**glTextureStorage1D**](crate::context::Context::oxidegl_texture_storage1_d)
/// specify the storage requirements for all levels of a one-dimensional texture
/// simultaneously. Once a texture is specified with this command, the format
/// and dimensions of all levels become immutable unless it is a proxy texture.
/// The contents of the image may still be modified, however, its storage requirements
/// may not change. Such a texture is referred to as an *immutable-format*
/// texture.
///
/// Calling [**glTexStorage1D**](crate::context::Context::oxidegl_tex_storage1_d)
/// is equivalent, assuming no errors are generated, to executing the following
/// pseudo-code:
///
/// Calling [**glTextureStorage1D**](crate::context::Context::oxidegl_texture_storage1_d)
/// is equivalent to the above pseudo-code, where `target` is the effective
/// target of `texture` and it is as if `texture` were bound to `target` for
/// the purposes of [**glTexImage1D**](crate::context::Context::oxidegl_tex_image1_d).
///
/// Since no texture data is actually provided, the values used in the pseudo-code
/// for `format` and `type` are irrelevant and may be considered to be any
/// values that are legal for the chosen `internalformat` enumerant. `internalformat`
/// must be one of the sized internal formats given in Table 1 below, one of
/// the sized depth-component formats [`GL_DEPTH_COMPONENT32F`](crate::enums::GL_DEPTH_COMPONENT32F),
/// [`GL_DEPTH_COMPONENT24`](crate::enums::GL_DEPTH_COMPONENT24), or [`GL_DEPTH_COMPONENT16`](crate::enums::GL_DEPTH_COMPONENT16),
/// one of the combined depth-stencil formats, [`GL_DEPTH32F_STENCIL8`](crate::enums::GL_DEPTH32F_STENCIL8),
/// or [`GL_DEPTH24_STENCIL8`](crate::enums::GL_DEPTH24_STENCIL8), or the
/// stencil-only format, [`GL_STENCIL_INDEX8`](crate::enums::GL_STENCIL_INDEX8).
/// Upon success, the value of [`GL_TEXTURE_IMMUTABLE_FORMAT`](crate::enums::GL_TEXTURE_IMMUTABLE_FORMAT)
/// becomes [`GL_TRUE`](crate::enums::GL_TRUE). The value of [`GL_TEXTURE_IMMUTABLE_FORMAT`](crate::enums::GL_TEXTURE_IMMUTABLE_FORMAT)
/// may be discovered by calling [**glGetTexParameter**](crate::context::Context::oxidegl_get_tex_parameter)
/// with `pname` set to [`GL_TEXTURE_IMMUTABLE_FORMAT`](crate::enums::GL_TEXTURE_IMMUTABLE_FORMAT).
/// No further changes to the dimensions or format of the texture object may
/// be made. Using any command that might alter the dimensions or format of
/// the texture object (such as [**glTexImage1D**](crate::context::Context::oxidegl_tex_image1_d)
/// or another call to [**glTexStorage1D**](crate::context::Context::oxidegl_tex_storage1_d))
/// will result in the generation of a [`GL_INVALID_OPERATION`](crate::enums::GL_INVALID_OPERATION)
/// error, even if it would not, in fact, alter the dimensions or format of
/// the object.
///
/// | *Sized Internal Format*                               | *Base Internal Format*                               | *Red Bits*       | *Green Bits*        | *Blue Bits*       | *Alpha Bits*        | *Shared Bits*        |
/// |-------------------------------------------------------|------------------------------------------------------|------------------|---------------------|-------------------|---------------------|----------------------|
/// | [`GL_R8`](crate::enums::GL_R8)                        | [`GL_RED`](crate::enums::GL_RED)                     | 8                |                     |                   |                     |                      |
/// | [`GL_R8_SNORM`](crate::enums::GL_R8_SNORM)            | [`GL_RED`](crate::enums::GL_RED)                     | s8               |                     |                   |                     |                      |
/// | [`GL_R16`](crate::enums::GL_R16)                      | [`GL_RED`](crate::enums::GL_RED)                     | 16               |                     |                   |                     |                      |
/// | [`GL_R16_SNORM`](crate::enums::GL_R16_SNORM)          | [`GL_RED`](crate::enums::GL_RED)                     | s16              |                     |                   |                     |                      |
/// | [`GL_RG8`](crate::enums::GL_RG8)                      | [`GL_RG`](crate::enums::GL_RG)                       | 8                | 8                   |                   |                     |                      |
/// | [`GL_RG8_SNORM`](crate::enums::GL_RG8_SNORM)          | [`GL_RG`](crate::enums::GL_RG)                       | s8               | s8                  |                   |                     |                      |
/// | [`GL_RG16`](crate::enums::GL_RG16)                    | [`GL_RG`](crate::enums::GL_RG)                       | 16               | 16                  |                   |                     |                      |
/// | [`GL_RG16_SNORM`](crate::enums::GL_RG16_SNORM)        | [`GL_RG`](crate::enums::GL_RG)                       | s16              | s16                 |                   |                     |                      |
/// | [`GL_R3_G3_B2`](crate::enums::GL_R3_G3_B2)            | [`GL_RGB`](crate::enums::GL_RGB)                     | 3                | 3                   | 2                 |                     |                      |
/// | [`GL_RGB4`](crate::enums::GL_RGB4)                    | [`GL_RGB`](crate::enums::GL_RGB)                     | 4                | 4                   | 4                 |                     |                      |
/// | [`GL_RGB5`](crate::enums::GL_RGB5)                    | [`GL_RGB`](crate::enums::GL_RGB)                     | 5                | 5                   | 5                 |                     |                      |
/// | [`GL_RGB8`](crate::enums::GL_RGB8)                    | [`GL_RGB`](crate::enums::GL_RGB)                     | 8                | 8                   | 8                 |                     |                      |
/// | [`GL_RGB8_SNORM`](crate::enums::GL_RGB8_SNORM)        | [`GL_RGB`](crate::enums::GL_RGB)                     | s8               | s8                  | s8                |                     |                      |
/// | [`GL_RGB10`](crate::enums::GL_RGB10)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 10               | 10                  | 10                |                     |                      |
/// | [`GL_RGB12`](crate::enums::GL_RGB12)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 12               | 12                  | 12                |                     |                      |
/// | [`GL_RGB16_SNORM`](crate::enums::GL_RGB16_SNORM)      | [`GL_RGB`](crate::enums::GL_RGB)                     | 16               | 16                  | 16                |                     |                      |
/// | [`GL_RGBA2`](crate::enums::GL_RGBA2)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 2                | 2                   | 2                 | 2                   |                      |
/// | [`GL_RGBA4`](crate::enums::GL_RGBA4)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 4                | 4                   | 4                 | 4                   |                      |
/// | [`GL_RGB5_A1`](crate::enums::GL_RGB5_A1)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 5                | 5                   | 5                 | 1                   |                      |
/// | [`GL_RGBA8`](crate::enums::GL_RGBA8)                  | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 8                | 8                   | 8                 | 8                   |                      |
/// | [`GL_RGBA8_SNORM`](crate::enums::GL_RGBA8_SNORM)      | [`GL_RGBA`](crate::enums::GL_RGBA)                   | s8               | s8                  | s8                | s8                  |                      |
/// | [`GL_RGB10_A2`](crate::enums::GL_RGB10_A2)            | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 10               | 10                  | 10                | 2                   |                      |
/// | [`GL_RGB10_A2UI`](crate::enums::GL_RGB10_A2UI)        | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui10             | ui10                | ui10              | ui2                 |                      |
/// | [`GL_RGBA12`](crate::enums::GL_RGBA12)                | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 12               | 12                  | 12                | 12                  |                      |
/// | [`GL_RGBA16`](crate::enums::GL_RGBA16)                | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 16               | 16                  | 16                | 16                  |                      |
/// | [`GL_SRGB8`](crate::enums::GL_SRGB8)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 8                | 8                   | 8                 |                     |                      |
/// | [`GL_SRGB8_ALPHA8`](crate::enums::GL_SRGB8_ALPHA8)    | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 8                | 8                   | 8                 | 8                   |                      |
/// | [`GL_R16F`](crate::enums::GL_R16F)                    | [`GL_RED`](crate::enums::GL_RED)                     | f16              |                     |                   |                     |                      |
/// | [`GL_RG16F`](crate::enums::GL_RG16F)                  | [`GL_RG`](crate::enums::GL_RG)                       | f16              | f16                 |                   |                     |                      |
/// | [`GL_RGB16F`](crate::enums::GL_RGB16F)                | [`GL_RGB`](crate::enums::GL_RGB)                     | f16              | f16                 | f16               |                     |                      |
/// | [`GL_RGBA16F`](crate::enums::GL_RGBA16F)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | f16              | f16                 | f16               | f16                 |                      |
/// | [`GL_R32F`](crate::enums::GL_R32F)                    | [`GL_RED`](crate::enums::GL_RED)                     | f32              |                     |                   |                     |                      |
/// | [`GL_RG32F`](crate::enums::GL_RG32F)                  | [`GL_RG`](crate::enums::GL_RG)                       | f32              | f32                 |                   |                     |                      |
/// | [`GL_RGB32F`](crate::enums::GL_RGB32F)                | [`GL_RGB`](crate::enums::GL_RGB)                     | f32              | f32                 | f32               |                     |                      |
/// | [`GL_RGBA32F`](crate::enums::GL_RGBA32F)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | f32              | f32                 | f32               | f32                 |                      |
/// | [`GL_R11F_G11F_B10F`](crate::enums::GL_R11F_G11F_B10F) | [`GL_RGB`](crate::enums::GL_RGB)                    | f11              | f11                 | f10               |                     |                      |
/// | [`GL_RGB9_E5`](crate::enums::GL_RGB9_E5)              | [`GL_RGB`](crate::enums::GL_RGB)                     | 9                | 9                   | 9                 |                     | 5                    |
/// | [`GL_R8I`](crate::enums::GL_R8I)                      | [`GL_RED`](crate::enums::GL_RED)                     | i8               |                     |                   |                     |                      |
/// | [`GL_R8UI`](crate::enums::GL_R8UI)                    | [`GL_RED`](crate::enums::GL_RED)                     | ui8              |                     |                   |                     |                      |
/// | [`GL_R16I`](crate::enums::GL_R16I)                    | [`GL_RED`](crate::enums::GL_RED)                     | i16              |                     |                   |                     |                      |
/// | [`GL_R16UI`](crate::enums::GL_R16UI)                  | [`GL_RED`](crate::enums::GL_RED)                     | ui16             |                     |                   |                     |                      |
/// | [`GL_R32I`](crate::enums::GL_R32I)                    | [`GL_RED`](crate::enums::GL_RED)                     | i32              |                     |                   |                     |                      |
/// | [`GL_R32UI`](crate::enums::GL_R32UI)                  | [`GL_RED`](crate::enums::GL_RED)                     | ui32             |                     |                   |                     |                      |
/// | [`GL_RG8I`](crate::enums::GL_RG8I)                    | [`GL_RG`](crate::enums::GL_RG)                       | i8               | i8                  |                   |                     |                      |
/// | [`GL_RG8UI`](crate::enums::GL_RG8UI)                  | [`GL_RG`](crate::enums::GL_RG)                       | ui8              | ui8                 |                   |                     |                      |
/// | [`GL_RG16I`](crate::enums::GL_RG16I)                  | [`GL_RG`](crate::enums::GL_RG)                       | i16              | i16                 |                   |                     |                      |
/// | [`GL_RG16UI`](crate::enums::GL_RG16UI)                | [`GL_RG`](crate::enums::GL_RG)                       | ui16             | ui16                |                   |                     |                      |
/// | [`GL_RG32I`](crate::enums::GL_RG32I)                  | [`GL_RG`](crate::enums::GL_RG)                       | i32              | i32                 |                   |                     |                      |
/// | [`GL_RG32UI`](crate::enums::GL_RG32UI)                | [`GL_RG`](crate::enums::GL_RG)                       | ui32             | ui32                |                   |                     |                      |
/// | [`GL_RGB8I`](crate::enums::GL_RGB8I)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | i8               | i8                  | i8                |                     |                      |
/// | [`GL_RGB8UI`](crate::enums::GL_RGB8UI)                | [`GL_RGB`](crate::enums::GL_RGB)                     | ui8              | ui8                 | ui8               |                     |                      |
/// | [`GL_RGB16I`](crate::enums::GL_RGB16I)                | [`GL_RGB`](crate::enums::GL_RGB)                     | i16              | i16                 | i16               |                     |                      |
/// | [`GL_RGB16UI`](crate::enums::GL_RGB16UI)              | [`GL_RGB`](crate::enums::GL_RGB)                     | ui16             | ui16                | ui16              |                     |                      |
/// | [`GL_RGB32I`](crate::enums::GL_RGB32I)                | [`GL_RGB`](crate::enums::GL_RGB)                     | i32              | i32                 | i32               |                     |                      |
/// | [`GL_RGB32UI`](crate::enums::GL_RGB32UI)              | [`GL_RGB`](crate::enums::GL_RGB)                     | ui32             | ui32                | ui32              |                     |                      |
/// | [`GL_RGBA8I`](crate::enums::GL_RGBA8I)                | [`GL_RGBA`](crate::enums::GL_RGBA)                   | i8               | i8                  | i8                | i8                  |                      |
/// | [`GL_RGBA8UI`](crate::enums::GL_RGBA8UI)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui8              | ui8                 | ui8               | ui8                 |                      |
/// | [`GL_RGBA16I`](crate::enums::GL_RGBA16I)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | i16              | i16                 | i16               | i16                 |                      |
/// | [`GL_RGBA16UI`](crate::enums::GL_RGBA16UI)            | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui16             | ui16                | ui16              | ui16                |                      |
/// | [`GL_RGBA32I`](crate::enums::GL_RGBA32I)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | i32              | i32                 | i32               | i32                 |                      |
/// | [`GL_RGBA32UI`](crate::enums::GL_RGBA32UI)            | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui32             | ui32                | ui32              | ui32                |                      |
///
///
/// ### Notes
/// [`GL_STENCIL_INDEX8`](crate::enums::GL_STENCIL_INDEX8) is accepted for
/// `internalformat` only if the GL version is 4.4 or higher.
impl Context {
    pub fn oxidegl_tex_storage1_d(
        &mut self,
        target: TextureTarget,
        levels: GLsizei,
        internalformat: SizedInternalFormat,
        width: GLsizei,
    ) {
        panic!("command oxidegl_tex_storage1_d not yet implemented");
    }
    pub fn oxidegl_texture_storage1_d(
        &mut self,
        texture: GLuint,
        levels: GLsizei,
        internalformat: SizedInternalFormat,
        width: GLsizei,
    ) {
        panic!("command oxidegl_texture_storage1_d not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the texture object is bound for [**glTexStorage2D**](crate::context::Context::oxidegl_tex_storage2_d).
/// > Must be one of [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D), [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY),
/// > [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE), [`GL_TEXTURE_CUBE_MAP`](crate::enums::GL_TEXTURE_CUBE_MAP),
/// > [`GL_PROXY_TEXTURE_2D`](crate::enums::GL_PROXY_TEXTURE_2D), [`GL_PROXY_TEXTURE_1D_ARRAY`](crate::enums::GL_PROXY_TEXTURE_1D_ARRAY),
/// > [`GL_PROXY_TEXTURE_RECTANGLE`](crate::enums::GL_PROXY_TEXTURE_RECTANGLE),
/// > or [`GL_PROXY_TEXTURE_CUBE_MAP`](crate::enums::GL_PROXY_TEXTURE_CUBE_MAP).
///
/// `texture`
///
/// > Specifies the texture object name for [**glTextureStorage2D**](crate::context::Context::oxidegl_texture_storage2_d).
/// > The effective target of `texture` must be one of the valid non-proxy `target`
/// > values above.
///
/// `levels`
///
/// > Specify the number of texture levels.
///
/// `internalformat`
///
/// > Specifies the sized internal format to be used to store texture image data.
///
/// `width`
///
/// > Specifies the width of the texture, in texels.
///
/// `height`
///
/// > Specifies the height of the texture, in texels.
///
/// ### Description
/// [**glTexStorage2D**](crate::context::Context::oxidegl_tex_storage2_d) and
/// [**glTextureStorage2D**](crate::context::Context::oxidegl_texture_storage2_d)
/// specify the storage requirements for all levels of a two-dimensional texture
/// or one-dimensional texture array simultaneously. Once a texture is specified
/// with this command, the format and dimensions of all levels become immutable
/// unless it is a proxy texture. The contents of the image may still be modified,
/// however, its storage requirements may not change. Such a texture is referred
/// to as an *immutable-format* texture.
///
/// The behavior of [**glTexStorage2D**](crate::context::Context::oxidegl_tex_storage2_d)
/// depends on the `target` parameter. When `target` is [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D),
/// [`GL_PROXY_TEXTURE_2D`](crate::enums::GL_PROXY_TEXTURE_2D), [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE),
/// [`GL_PROXY_TEXTURE_RECTANGLE`](crate::enums::GL_PROXY_TEXTURE_RECTANGLE)
/// or [`GL_PROXY_TEXTURE_CUBE_MAP`](crate::enums::GL_PROXY_TEXTURE_CUBE_MAP),
/// calling [**glTexStorage2D**](crate::context::Context::oxidegl_tex_storage2_d)
/// is equivalent, assuming no errors are generated, to executing the following
/// pseudo-code:
///
/// When `target` is [`GL_TEXTURE_CUBE_MAP`](crate::enums::GL_TEXTURE_CUBE_MAP),
/// [**glTexStorage2D**](crate::context::Context::oxidegl_tex_storage2_d) is
/// equivalent to:
///
/// When `target` is [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY)
/// or [`GL_PROXY_TEXTURE_1D_ARRAY`](crate::enums::GL_PROXY_TEXTURE_1D_ARRAY),
/// [**glTexStorage2D**](crate::context::Context::oxidegl_tex_storage2_d) is
/// equivalent to:
///
/// Calling [**glTextureStorage2D**](crate::context::Context::oxidegl_texture_storage2_d)
/// is equivalent to the above pseudo-code, where `target` is the effective
/// target of `texture` and it is as if `texture` were bound to `target` for
/// the purposes of [**glTexImage2D**](crate::context::Context::oxidegl_tex_image2_d).
///
/// Since no texture data is actually provided, the values used in the pseudo-code
/// for `format` and `type` are irrelevant and may be considered to be any
/// values that are legal for the chosen `internalformat` enumerant. `internalformat`
/// must be one of the sized internal formats given in Table 1 below, one of
/// the sized depth-component formats [`GL_DEPTH_COMPONENT32F`](crate::enums::GL_DEPTH_COMPONENT32F),
/// [`GL_DEPTH_COMPONENT24`](crate::enums::GL_DEPTH_COMPONENT24), or [`GL_DEPTH_COMPONENT16`](crate::enums::GL_DEPTH_COMPONENT16),
/// one of the combined depth-stencil formats, [`GL_DEPTH32F_STENCIL8`](crate::enums::GL_DEPTH32F_STENCIL8),
/// or [`GL_DEPTH24_STENCIL8`](crate::enums::GL_DEPTH24_STENCIL8), or the
/// stencil-only format, [`GL_STENCIL_INDEX8`](crate::enums::GL_STENCIL_INDEX8).
/// Upon success, the value of [`GL_TEXTURE_IMMUTABLE_FORMAT`](crate::enums::GL_TEXTURE_IMMUTABLE_FORMAT)
/// becomes [`GL_TRUE`](crate::enums::GL_TRUE). The value of [`GL_TEXTURE_IMMUTABLE_FORMAT`](crate::enums::GL_TEXTURE_IMMUTABLE_FORMAT)
/// may be discovered by calling [**glGetTexParameter**](crate::context::Context::oxidegl_get_tex_parameter)
/// with `pname` set to [`GL_TEXTURE_IMMUTABLE_FORMAT`](crate::enums::GL_TEXTURE_IMMUTABLE_FORMAT).
/// No further changes to the dimensions or format of the texture object may
/// be made. Using any command that might alter the dimensions or format of
/// the texture object (such as [**glTexImage2D**](crate::context::Context::oxidegl_tex_image2_d)
/// or another call to [**glTexStorage2D**](crate::context::Context::oxidegl_tex_storage2_d))
/// will result in the generation of a [`GL_INVALID_OPERATION`](crate::enums::GL_INVALID_OPERATION)
/// error, even if it would not, in fact, alter the dimensions or format of
/// the object.
///
/// | *Sized Internal Format*                               | *Base Internal Format*                               | *Red Bits*       | *Green Bits*        | *Blue Bits*       | *Alpha Bits*        | *Shared Bits*        |
/// |-------------------------------------------------------|------------------------------------------------------|------------------|---------------------|-------------------|---------------------|----------------------|
/// | [`GL_R8`](crate::enums::GL_R8)                        | [`GL_RED`](crate::enums::GL_RED)                     | 8                |                     |                   |                     |                      |
/// | [`GL_R8_SNORM`](crate::enums::GL_R8_SNORM)            | [`GL_RED`](crate::enums::GL_RED)                     | s8               |                     |                   |                     |                      |
/// | [`GL_R16`](crate::enums::GL_R16)                      | [`GL_RED`](crate::enums::GL_RED)                     | 16               |                     |                   |                     |                      |
/// | [`GL_R16_SNORM`](crate::enums::GL_R16_SNORM)          | [`GL_RED`](crate::enums::GL_RED)                     | s16              |                     |                   |                     |                      |
/// | [`GL_RG8`](crate::enums::GL_RG8)                      | [`GL_RG`](crate::enums::GL_RG)                       | 8                | 8                   |                   |                     |                      |
/// | [`GL_RG8_SNORM`](crate::enums::GL_RG8_SNORM)          | [`GL_RG`](crate::enums::GL_RG)                       | s8               | s8                  |                   |                     |                      |
/// | [`GL_RG16`](crate::enums::GL_RG16)                    | [`GL_RG`](crate::enums::GL_RG)                       | 16               | 16                  |                   |                     |                      |
/// | [`GL_RG16_SNORM`](crate::enums::GL_RG16_SNORM)        | [`GL_RG`](crate::enums::GL_RG)                       | s16              | s16                 |                   |                     |                      |
/// | [`GL_R3_G3_B2`](crate::enums::GL_R3_G3_B2)            | [`GL_RGB`](crate::enums::GL_RGB)                     | 3                | 3                   | 2                 |                     |                      |
/// | [`GL_RGB4`](crate::enums::GL_RGB4)                    | [`GL_RGB`](crate::enums::GL_RGB)                     | 4                | 4                   | 4                 |                     |                      |
/// | [`GL_RGB5`](crate::enums::GL_RGB5)                    | [`GL_RGB`](crate::enums::GL_RGB)                     | 5                | 5                   | 5                 |                     |                      |
/// | [`GL_RGB8`](crate::enums::GL_RGB8)                    | [`GL_RGB`](crate::enums::GL_RGB)                     | 8                | 8                   | 8                 |                     |                      |
/// | [`GL_RGB8_SNORM`](crate::enums::GL_RGB8_SNORM)        | [`GL_RGB`](crate::enums::GL_RGB)                     | s8               | s8                  | s8                |                     |                      |
/// | [`GL_RGB10`](crate::enums::GL_RGB10)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 10               | 10                  | 10                |                     |                      |
/// | [`GL_RGB12`](crate::enums::GL_RGB12)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 12               | 12                  | 12                |                     |                      |
/// | [`GL_RGB16_SNORM`](crate::enums::GL_RGB16_SNORM)      | [`GL_RGB`](crate::enums::GL_RGB)                     | 16               | 16                  | 16                |                     |                      |
/// | [`GL_RGBA2`](crate::enums::GL_RGBA2)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 2                | 2                   | 2                 | 2                   |                      |
/// | [`GL_RGBA4`](crate::enums::GL_RGBA4)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 4                | 4                   | 4                 | 4                   |                      |
/// | [`GL_RGB5_A1`](crate::enums::GL_RGB5_A1)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 5                | 5                   | 5                 | 1                   |                      |
/// | [`GL_RGBA8`](crate::enums::GL_RGBA8)                  | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 8                | 8                   | 8                 | 8                   |                      |
/// | [`GL_RGBA8_SNORM`](crate::enums::GL_RGBA8_SNORM)      | [`GL_RGBA`](crate::enums::GL_RGBA)                   | s8               | s8                  | s8                | s8                  |                      |
/// | [`GL_RGB10_A2`](crate::enums::GL_RGB10_A2)            | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 10               | 10                  | 10                | 2                   |                      |
/// | [`GL_RGB10_A2UI`](crate::enums::GL_RGB10_A2UI)        | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui10             | ui10                | ui10              | ui2                 |                      |
/// | [`GL_RGBA12`](crate::enums::GL_RGBA12)                | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 12               | 12                  | 12                | 12                  |                      |
/// | [`GL_RGBA16`](crate::enums::GL_RGBA16)                | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 16               | 16                  | 16                | 16                  |                      |
/// | [`GL_SRGB8`](crate::enums::GL_SRGB8)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 8                | 8                   | 8                 |                     |                      |
/// | [`GL_SRGB8_ALPHA8`](crate::enums::GL_SRGB8_ALPHA8)    | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 8                | 8                   | 8                 | 8                   |                      |
/// | [`GL_R16F`](crate::enums::GL_R16F)                    | [`GL_RED`](crate::enums::GL_RED)                     | f16              |                     |                   |                     |                      |
/// | [`GL_RG16F`](crate::enums::GL_RG16F)                  | [`GL_RG`](crate::enums::GL_RG)                       | f16              | f16                 |                   |                     |                      |
/// | [`GL_RGB16F`](crate::enums::GL_RGB16F)                | [`GL_RGB`](crate::enums::GL_RGB)                     | f16              | f16                 | f16               |                     |                      |
/// | [`GL_RGBA16F`](crate::enums::GL_RGBA16F)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | f16              | f16                 | f16               | f16                 |                      |
/// | [`GL_R32F`](crate::enums::GL_R32F)                    | [`GL_RED`](crate::enums::GL_RED)                     | f32              |                     |                   |                     |                      |
/// | [`GL_RG32F`](crate::enums::GL_RG32F)                  | [`GL_RG`](crate::enums::GL_RG)                       | f32              | f32                 |                   |                     |                      |
/// | [`GL_RGB32F`](crate::enums::GL_RGB32F)                | [`GL_RGB`](crate::enums::GL_RGB)                     | f32              | f32                 | f32               |                     |                      |
/// | [`GL_RGBA32F`](crate::enums::GL_RGBA32F)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | f32              | f32                 | f32               | f32                 |                      |
/// | [`GL_R11F_G11F_B10F`](crate::enums::GL_R11F_G11F_B10F) | [`GL_RGB`](crate::enums::GL_RGB)                    | f11              | f11                 | f10               |                     |                      |
/// | [`GL_RGB9_E5`](crate::enums::GL_RGB9_E5)              | [`GL_RGB`](crate::enums::GL_RGB)                     | 9                | 9                   | 9                 |                     | 5                    |
/// | [`GL_R8I`](crate::enums::GL_R8I)                      | [`GL_RED`](crate::enums::GL_RED)                     | i8               |                     |                   |                     |                      |
/// | [`GL_R8UI`](crate::enums::GL_R8UI)                    | [`GL_RED`](crate::enums::GL_RED)                     | ui8              |                     |                   |                     |                      |
/// | [`GL_R16I`](crate::enums::GL_R16I)                    | [`GL_RED`](crate::enums::GL_RED)                     | i16              |                     |                   |                     |                      |
/// | [`GL_R16UI`](crate::enums::GL_R16UI)                  | [`GL_RED`](crate::enums::GL_RED)                     | ui16             |                     |                   |                     |                      |
/// | [`GL_R32I`](crate::enums::GL_R32I)                    | [`GL_RED`](crate::enums::GL_RED)                     | i32              |                     |                   |                     |                      |
/// | [`GL_R32UI`](crate::enums::GL_R32UI)                  | [`GL_RED`](crate::enums::GL_RED)                     | ui32             |                     |                   |                     |                      |
/// | [`GL_RG8I`](crate::enums::GL_RG8I)                    | [`GL_RG`](crate::enums::GL_RG)                       | i8               | i8                  |                   |                     |                      |
/// | [`GL_RG8UI`](crate::enums::GL_RG8UI)                  | [`GL_RG`](crate::enums::GL_RG)                       | ui8              | ui8                 |                   |                     |                      |
/// | [`GL_RG16I`](crate::enums::GL_RG16I)                  | [`GL_RG`](crate::enums::GL_RG)                       | i16              | i16                 |                   |                     |                      |
/// | [`GL_RG16UI`](crate::enums::GL_RG16UI)                | [`GL_RG`](crate::enums::GL_RG)                       | ui16             | ui16                |                   |                     |                      |
/// | [`GL_RG32I`](crate::enums::GL_RG32I)                  | [`GL_RG`](crate::enums::GL_RG)                       | i32              | i32                 |                   |                     |                      |
/// | [`GL_RG32UI`](crate::enums::GL_RG32UI)                | [`GL_RG`](crate::enums::GL_RG)                       | ui32             | ui32                |                   |                     |                      |
/// | [`GL_RGB8I`](crate::enums::GL_RGB8I)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | i8               | i8                  | i8                |                     |                      |
/// | [`GL_RGB8UI`](crate::enums::GL_RGB8UI)                | [`GL_RGB`](crate::enums::GL_RGB)                     | ui8              | ui8                 | ui8               |                     |                      |
/// | [`GL_RGB16I`](crate::enums::GL_RGB16I)                | [`GL_RGB`](crate::enums::GL_RGB)                     | i16              | i16                 | i16               |                     |                      |
/// | [`GL_RGB16UI`](crate::enums::GL_RGB16UI)              | [`GL_RGB`](crate::enums::GL_RGB)                     | ui16             | ui16                | ui16              |                     |                      |
/// | [`GL_RGB32I`](crate::enums::GL_RGB32I)                | [`GL_RGB`](crate::enums::GL_RGB)                     | i32              | i32                 | i32               |                     |                      |
/// | [`GL_RGB32UI`](crate::enums::GL_RGB32UI)              | [`GL_RGB`](crate::enums::GL_RGB)                     | ui32             | ui32                | ui32              |                     |                      |
/// | [`GL_RGBA8I`](crate::enums::GL_RGBA8I)                | [`GL_RGBA`](crate::enums::GL_RGBA)                   | i8               | i8                  | i8                | i8                  |                      |
/// | [`GL_RGBA8UI`](crate::enums::GL_RGBA8UI)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui8              | ui8                 | ui8               | ui8                 |                      |
/// | [`GL_RGBA16I`](crate::enums::GL_RGBA16I)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | i16              | i16                 | i16               | i16                 |                      |
/// | [`GL_RGBA16UI`](crate::enums::GL_RGBA16UI)            | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui16             | ui16                | ui16              | ui16                |                      |
/// | [`GL_RGBA32I`](crate::enums::GL_RGBA32I)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | i32              | i32                 | i32               | i32                 |                      |
/// | [`GL_RGBA32UI`](crate::enums::GL_RGBA32UI)            | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui32             | ui32                | ui32              | ui32                |                      |
///
///
/// ### Notes
/// [`GL_STENCIL_INDEX8`](crate::enums::GL_STENCIL_INDEX8) is accepted for
/// `internalformat` only if the GL version is 4.4 or higher.
impl Context {
    pub fn oxidegl_tex_storage2_d(
        &mut self,
        target: TextureTarget,
        levels: GLsizei,
        internalformat: SizedInternalFormat,
        width: GLsizei,
        height: GLsizei,
    ) {
        panic!("command oxidegl_tex_storage2_d not yet implemented");
    }
    pub fn oxidegl_texture_storage2_d(
        &mut self,
        texture: GLuint,
        levels: GLsizei,
        internalformat: SizedInternalFormat,
        width: GLsizei,
        height: GLsizei,
    ) {
        panic!("command oxidegl_texture_storage2_d not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the texture object is bound for [**glTexStorage2DMultisample**](crate::context::Context::oxidegl_tex_storage2_d_multisample).
/// > Must be one of [`GL_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE)
/// > or [`GL_PROXY_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_PROXY_TEXTURE_2D_MULTISAMPLE).
///
/// `texture`
///
/// > Specifies the texture object name for [**glTextureStorage2DMultisample**](crate::context::Context::oxidegl_texture_storage2_d_multisample).
/// > The effective target of `texture` must be one of the valid non-proxy `target`
/// > values above.
///
/// `samples`
///
/// > Specify the number of samples in the texture.
///
/// `internalformat`
///
/// > Specifies the sized internal format to be used to store texture image data.
///
/// `width`
///
/// > Specifies the width of the texture, in texels.
///
/// `height`
///
/// > Specifies the height of the texture, in texels.
///
/// `fixedsamplelocations`
///
/// > Specifies whether the image will use identical sample locations and the
/// > same number of samples for all texels in the image, and the sample locations
/// > will not depend on the internal format or size of the image.
///
/// ### Description
/// [**glTexStorage2DMultisample**](crate::context::Context::oxidegl_tex_storage2_d_multisample)
/// and [**glTextureStorage2DMultisample**](crate::context::Context::oxidegl_texture_storage2_d_multisample)
/// specify the storage requirements for a two-dimensional multisample texture.
/// Once a texture is specified with this command, its format and dimensions
/// become immutable unless it is a proxy texture. The contents of the image
/// may still be modified, however, its storage requirements may not change.
/// Such a texture is referred to as an *immutable-format* texture.
///
/// `samples` specifies the number of samples to be used for the texture and
/// must be greater than zero and less than or equal to the value of [`GL_MAX_SAMPLES`](crate::enums::GL_MAX_SAMPLES).
/// `internalformat` must be a color-renderable, depth-renderable, or stencil-renderable
/// format. `width` and `height` specify the width and height, respectively,
/// of the texture. If `fixedsamplelocations` is [`GL_TRUE`](crate::enums::GL_TRUE),
/// the image will use identical sample locations and the same number of samples
/// for all texels in the image, and the sample locations will not depend on
/// the internal format or size of the image.
///
/// | *Sized Internal Format*                               | *Base Internal Format*                               | *Red Bits*       | *Green Bits*        | *Blue Bits*       | *Alpha Bits*        | *Shared Bits*        |
/// |-------------------------------------------------------|------------------------------------------------------|------------------|---------------------|-------------------|---------------------|----------------------|
/// | [`GL_R8`](crate::enums::GL_R8)                        | [`GL_RED`](crate::enums::GL_RED)                     | 8                |                     |                   |                     |                      |
/// | [`GL_R8_SNORM`](crate::enums::GL_R8_SNORM)            | [`GL_RED`](crate::enums::GL_RED)                     | s8               |                     |                   |                     |                      |
/// | [`GL_R16`](crate::enums::GL_R16)                      | [`GL_RED`](crate::enums::GL_RED)                     | 16               |                     |                   |                     |                      |
/// | [`GL_R16_SNORM`](crate::enums::GL_R16_SNORM)          | [`GL_RED`](crate::enums::GL_RED)                     | s16              |                     |                   |                     |                      |
/// | [`GL_RG8`](crate::enums::GL_RG8)                      | [`GL_RG`](crate::enums::GL_RG)                       | 8                | 8                   |                   |                     |                      |
/// | [`GL_RG8_SNORM`](crate::enums::GL_RG8_SNORM)          | [`GL_RG`](crate::enums::GL_RG)                       | s8               | s8                  |                   |                     |                      |
/// | [`GL_RG16`](crate::enums::GL_RG16)                    | [`GL_RG`](crate::enums::GL_RG)                       | 16               | 16                  |                   |                     |                      |
/// | [`GL_RG16_SNORM`](crate::enums::GL_RG16_SNORM)        | [`GL_RG`](crate::enums::GL_RG)                       | s16              | s16                 |                   |                     |                      |
/// | [`GL_R3_G3_B2`](crate::enums::GL_R3_G3_B2)            | [`GL_RGB`](crate::enums::GL_RGB)                     | 3                | 3                   | 2                 |                     |                      |
/// | [`GL_RGB4`](crate::enums::GL_RGB4)                    | [`GL_RGB`](crate::enums::GL_RGB)                     | 4                | 4                   | 4                 |                     |                      |
/// | [`GL_RGB5`](crate::enums::GL_RGB5)                    | [`GL_RGB`](crate::enums::GL_RGB)                     | 5                | 5                   | 5                 |                     |                      |
/// | [`GL_RGB8`](crate::enums::GL_RGB8)                    | [`GL_RGB`](crate::enums::GL_RGB)                     | 8                | 8                   | 8                 |                     |                      |
/// | [`GL_RGB8_SNORM`](crate::enums::GL_RGB8_SNORM)        | [`GL_RGB`](crate::enums::GL_RGB)                     | s8               | s8                  | s8                |                     |                      |
/// | [`GL_RGB10`](crate::enums::GL_RGB10)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 10               | 10                  | 10                |                     |                      |
/// | [`GL_RGB12`](crate::enums::GL_RGB12)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 12               | 12                  | 12                |                     |                      |
/// | [`GL_RGB16_SNORM`](crate::enums::GL_RGB16_SNORM)      | [`GL_RGB`](crate::enums::GL_RGB)                     | 16               | 16                  | 16                |                     |                      |
/// | [`GL_RGBA2`](crate::enums::GL_RGBA2)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 2                | 2                   | 2                 | 2                   |                      |
/// | [`GL_RGBA4`](crate::enums::GL_RGBA4)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 4                | 4                   | 4                 | 4                   |                      |
/// | [`GL_RGB5_A1`](crate::enums::GL_RGB5_A1)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 5                | 5                   | 5                 | 1                   |                      |
/// | [`GL_RGBA8`](crate::enums::GL_RGBA8)                  | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 8                | 8                   | 8                 | 8                   |                      |
/// | [`GL_RGBA8_SNORM`](crate::enums::GL_RGBA8_SNORM)      | [`GL_RGBA`](crate::enums::GL_RGBA)                   | s8               | s8                  | s8                | s8                  |                      |
/// | [`GL_RGB10_A2`](crate::enums::GL_RGB10_A2)            | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 10               | 10                  | 10                | 2                   |                      |
/// | [`GL_RGB10_A2UI`](crate::enums::GL_RGB10_A2UI)        | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui10             | ui10                | ui10              | ui2                 |                      |
/// | [`GL_RGBA12`](crate::enums::GL_RGBA12)                | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 12               | 12                  | 12                | 12                  |                      |
/// | [`GL_RGBA16`](crate::enums::GL_RGBA16)                | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 16               | 16                  | 16                | 16                  |                      |
/// | [`GL_SRGB8`](crate::enums::GL_SRGB8)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 8                | 8                   | 8                 |                     |                      |
/// | [`GL_SRGB8_ALPHA8`](crate::enums::GL_SRGB8_ALPHA8)    | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 8                | 8                   | 8                 | 8                   |                      |
/// | [`GL_R16F`](crate::enums::GL_R16F)                    | [`GL_RED`](crate::enums::GL_RED)                     | f16              |                     |                   |                     |                      |
/// | [`GL_RG16F`](crate::enums::GL_RG16F)                  | [`GL_RG`](crate::enums::GL_RG)                       | f16              | f16                 |                   |                     |                      |
/// | [`GL_RGB16F`](crate::enums::GL_RGB16F)                | [`GL_RGB`](crate::enums::GL_RGB)                     | f16              | f16                 | f16               |                     |                      |
/// | [`GL_RGBA16F`](crate::enums::GL_RGBA16F)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | f16              | f16                 | f16               | f16                 |                      |
/// | [`GL_R32F`](crate::enums::GL_R32F)                    | [`GL_RED`](crate::enums::GL_RED)                     | f32              |                     |                   |                     |                      |
/// | [`GL_RG32F`](crate::enums::GL_RG32F)                  | [`GL_RG`](crate::enums::GL_RG)                       | f32              | f32                 |                   |                     |                      |
/// | [`GL_RGB32F`](crate::enums::GL_RGB32F)                | [`GL_RGB`](crate::enums::GL_RGB)                     | f32              | f32                 | f32               |                     |                      |
/// | [`GL_RGBA32F`](crate::enums::GL_RGBA32F)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | f32              | f32                 | f32               | f32                 |                      |
/// | [`GL_R11F_G11F_B10F`](crate::enums::GL_R11F_G11F_B10F) | [`GL_RGB`](crate::enums::GL_RGB)                    | f11              | f11                 | f10               |                     |                      |
/// | [`GL_RGB9_E5`](crate::enums::GL_RGB9_E5)              | [`GL_RGB`](crate::enums::GL_RGB)                     | 9                | 9                   | 9                 |                     | 5                    |
/// | [`GL_R8I`](crate::enums::GL_R8I)                      | [`GL_RED`](crate::enums::GL_RED)                     | i8               |                     |                   |                     |                      |
/// | [`GL_R8UI`](crate::enums::GL_R8UI)                    | [`GL_RED`](crate::enums::GL_RED)                     | ui8              |                     |                   |                     |                      |
/// | [`GL_R16I`](crate::enums::GL_R16I)                    | [`GL_RED`](crate::enums::GL_RED)                     | i16              |                     |                   |                     |                      |
/// | [`GL_R16UI`](crate::enums::GL_R16UI)                  | [`GL_RED`](crate::enums::GL_RED)                     | ui16             |                     |                   |                     |                      |
/// | [`GL_R32I`](crate::enums::GL_R32I)                    | [`GL_RED`](crate::enums::GL_RED)                     | i32              |                     |                   |                     |                      |
/// | [`GL_R32UI`](crate::enums::GL_R32UI)                  | [`GL_RED`](crate::enums::GL_RED)                     | ui32             |                     |                   |                     |                      |
/// | [`GL_RG8I`](crate::enums::GL_RG8I)                    | [`GL_RG`](crate::enums::GL_RG)                       | i8               | i8                  |                   |                     |                      |
/// | [`GL_RG8UI`](crate::enums::GL_RG8UI)                  | [`GL_RG`](crate::enums::GL_RG)                       | ui8              | ui8                 |                   |                     |                      |
/// | [`GL_RG16I`](crate::enums::GL_RG16I)                  | [`GL_RG`](crate::enums::GL_RG)                       | i16              | i16                 |                   |                     |                      |
/// | [`GL_RG16UI`](crate::enums::GL_RG16UI)                | [`GL_RG`](crate::enums::GL_RG)                       | ui16             | ui16                |                   |                     |                      |
/// | [`GL_RG32I`](crate::enums::GL_RG32I)                  | [`GL_RG`](crate::enums::GL_RG)                       | i32              | i32                 |                   |                     |                      |
/// | [`GL_RG32UI`](crate::enums::GL_RG32UI)                | [`GL_RG`](crate::enums::GL_RG)                       | ui32             | ui32                |                   |                     |                      |
/// | [`GL_RGB8I`](crate::enums::GL_RGB8I)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | i8               | i8                  | i8                |                     |                      |
/// | [`GL_RGB8UI`](crate::enums::GL_RGB8UI)                | [`GL_RGB`](crate::enums::GL_RGB)                     | ui8              | ui8                 | ui8               |                     |                      |
/// | [`GL_RGB16I`](crate::enums::GL_RGB16I)                | [`GL_RGB`](crate::enums::GL_RGB)                     | i16              | i16                 | i16               |                     |                      |
/// | [`GL_RGB16UI`](crate::enums::GL_RGB16UI)              | [`GL_RGB`](crate::enums::GL_RGB)                     | ui16             | ui16                | ui16              |                     |                      |
/// | [`GL_RGB32I`](crate::enums::GL_RGB32I)                | [`GL_RGB`](crate::enums::GL_RGB)                     | i32              | i32                 | i32               |                     |                      |
/// | [`GL_RGB32UI`](crate::enums::GL_RGB32UI)              | [`GL_RGB`](crate::enums::GL_RGB)                     | ui32             | ui32                | ui32              |                     |                      |
/// | [`GL_RGBA8I`](crate::enums::GL_RGBA8I)                | [`GL_RGBA`](crate::enums::GL_RGBA)                   | i8               | i8                  | i8                | i8                  |                      |
/// | [`GL_RGBA8UI`](crate::enums::GL_RGBA8UI)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui8              | ui8                 | ui8               | ui8                 |                      |
/// | [`GL_RGBA16I`](crate::enums::GL_RGBA16I)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | i16              | i16                 | i16               | i16                 |                      |
/// | [`GL_RGBA16UI`](crate::enums::GL_RGBA16UI)            | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui16             | ui16                | ui16              | ui16                |                      |
/// | [`GL_RGBA32I`](crate::enums::GL_RGBA32I)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | i32              | i32                 | i32               | i32                 |                      |
/// | [`GL_RGBA32UI`](crate::enums::GL_RGBA32UI)            | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui32             | ui32                | ui32              | ui32                |                      |
///
impl Context {
    pub fn oxidegl_tex_storage2_d_multisample(
        &mut self,
        target: TextureTarget,
        samples: GLsizei,
        internalformat: SizedInternalFormat,
        width: GLsizei,
        height: GLsizei,
        fixedsamplelocations: GLboolean,
    ) {
        panic!("command oxidegl_tex_storage2_d_multisample not yet implemented");
    }
    pub fn oxidegl_texture_storage2_d_multisample(
        &mut self,
        texture: GLuint,
        samples: GLsizei,
        internalformat: SizedInternalFormat,
        width: GLsizei,
        height: GLsizei,
        fixedsamplelocations: GLboolean,
    ) {
        panic!("command oxidegl_texture_storage2_d_multisample not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the texture object is bound for [**glTexStorage3D**](crate::context::Context::oxidegl_tex_storage3_d).
/// > Must be one of [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D), [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY),
/// > [`GL_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_CUBE_MAP_ARRAY),
/// > [`GL_PROXY_TEXTURE_3D`](crate::enums::GL_PROXY_TEXTURE_3D), [`GL_PROXY_TEXTURE_2D_ARRAY`](crate::enums::GL_PROXY_TEXTURE_2D_ARRAY)
/// > or [`GL_PROXY_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_PROXY_TEXTURE_CUBE_MAP_ARRAY).
///
/// `texture`
///
/// > Specifies the texture object name for [**glTextureStorage3D**](crate::context::Context::oxidegl_texture_storage3_d).
/// > The effective target of `texture` must be one of the valid non-proxy `target`
/// > values above.
///
/// `levels`
///
/// > Specify the number of texture levels.
///
/// `internalformat`
///
/// > Specifies the sized internal format to be used to store texture image data.
///
/// `width`
///
/// > Specifies the width of the texture, in texels.
///
/// `height`
///
/// > Specifies the height of the texture, in texels.
///
/// `depth`
///
/// > Specifies the depth of the texture, in texels.
///
/// ### Description
/// [**glTexStorage3D**](crate::context::Context::oxidegl_tex_storage3_d) and
/// [**glTextureStorage3D**](crate::context::Context::oxidegl_texture_storage3_d)
/// specify the storage requirements for all levels of a three-dimensional,
/// two-dimensional array or cube-map array texture simultaneously. Once a
/// texture is specified with this command, the format and dimensions of all
/// levels become immutable unless it is a proxy texture. The contents of the
/// image may still be modified, however, its storage requirements may not
/// change. Such a texture is referred to as an *immutable-format* texture.
///
/// The behavior of [**glTexStorage3D**](crate::context::Context::oxidegl_tex_storage3_d)
/// depends on the `target` parameter. When `target` is [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D),
/// or [`GL_PROXY_TEXTURE_3D`](crate::enums::GL_PROXY_TEXTURE_3D), calling
/// [**glTexStorage3D**](crate::context::Context::oxidegl_tex_storage3_d) is
/// equivalent, assuming no errors are generated, to executing the following
/// pseudo-code:
///
/// When `target` is [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY),
/// [`GL_PROXY_TEXTURE_2D_ARRAY`](crate::enums::GL_PROXY_TEXTURE_2D_ARRAY),
/// [`GL_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_CUBE_MAP_ARRAY),
/// or [`GL_PROXY_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_PROXY_TEXTURE_CUBE_MAP_ARRAY),
/// [**glTexStorage3D**](crate::context::Context::oxidegl_tex_storage3_d) is
/// equivalent to:
///
/// Calling [**glTextureStorage3D**](crate::context::Context::oxidegl_texture_storage3_d)
/// is equivalent to the above pseudo-code, where `target` is the effective
/// target of `texture` and it is as if `texture` were bound to `target` for
/// the purposes of [**glTexImage3D**](crate::context::Context::oxidegl_tex_image3_d).
///
/// Since no texture data is actually provided, the values used in the pseudo-code
/// for `format` and `type` are irrelevant and may be considered to be any
/// values that are legal for the chosen `internalformat` enumerant. `internalformat`
/// must be one of the sized internal formats given in Table 1 below, one of
/// the sized depth-component formats [`GL_DEPTH_COMPONENT32F`](crate::enums::GL_DEPTH_COMPONENT32F),
/// [`GL_DEPTH_COMPONENT24`](crate::enums::GL_DEPTH_COMPONENT24), or [`GL_DEPTH_COMPONENT16`](crate::enums::GL_DEPTH_COMPONENT16),
/// one of the combined depth-stencil formats, [`GL_DEPTH32F_STENCIL8`](crate::enums::GL_DEPTH32F_STENCIL8),
/// or [`GL_DEPTH24_STENCIL8`](crate::enums::GL_DEPTH24_STENCIL8), or the
/// stencil-only format, [`GL_STENCIL_INDEX8`](crate::enums::GL_STENCIL_INDEX8).
/// Upon success, the value of [`GL_TEXTURE_IMMUTABLE_FORMAT`](crate::enums::GL_TEXTURE_IMMUTABLE_FORMAT)
/// becomes [`GL_TRUE`](crate::enums::GL_TRUE). The value of [`GL_TEXTURE_IMMUTABLE_FORMAT`](crate::enums::GL_TEXTURE_IMMUTABLE_FORMAT)
/// may be discovered by calling [**glGetTexParameter**](crate::context::Context::oxidegl_get_tex_parameter)
/// with `pname` set to [`GL_TEXTURE_IMMUTABLE_FORMAT`](crate::enums::GL_TEXTURE_IMMUTABLE_FORMAT).
/// No further changes to the dimensions or format of the texture object may
/// be made. Using any command that might alter the dimensions or format of
/// the texture object (such as [**glTexImage3D**](crate::context::Context::oxidegl_tex_image3_d)
/// or another call to [**glTexStorage3D**](crate::context::Context::oxidegl_tex_storage3_d))
/// will result in the generation of a [`GL_INVALID_OPERATION`](crate::enums::GL_INVALID_OPERATION)
/// error, even if it would not, in fact, alter the dimensions or format of
/// the object.
///
/// | *Sized Internal Format*                               | *Base Internal Format*                               | *Red Bits*       | *Green Bits*        | *Blue Bits*       | *Alpha Bits*        | *Shared Bits*        |
/// |-------------------------------------------------------|------------------------------------------------------|------------------|---------------------|-------------------|---------------------|----------------------|
/// | [`GL_R8`](crate::enums::GL_R8)                        | [`GL_RED`](crate::enums::GL_RED)                     | 8                |                     |                   |                     |                      |
/// | [`GL_R8_SNORM`](crate::enums::GL_R8_SNORM)            | [`GL_RED`](crate::enums::GL_RED)                     | s8               |                     |                   |                     |                      |
/// | [`GL_R16`](crate::enums::GL_R16)                      | [`GL_RED`](crate::enums::GL_RED)                     | 16               |                     |                   |                     |                      |
/// | [`GL_R16_SNORM`](crate::enums::GL_R16_SNORM)          | [`GL_RED`](crate::enums::GL_RED)                     | s16              |                     |                   |                     |                      |
/// | [`GL_RG8`](crate::enums::GL_RG8)                      | [`GL_RG`](crate::enums::GL_RG)                       | 8                | 8                   |                   |                     |                      |
/// | [`GL_RG8_SNORM`](crate::enums::GL_RG8_SNORM)          | [`GL_RG`](crate::enums::GL_RG)                       | s8               | s8                  |                   |                     |                      |
/// | [`GL_RG16`](crate::enums::GL_RG16)                    | [`GL_RG`](crate::enums::GL_RG)                       | 16               | 16                  |                   |                     |                      |
/// | [`GL_RG16_SNORM`](crate::enums::GL_RG16_SNORM)        | [`GL_RG`](crate::enums::GL_RG)                       | s16              | s16                 |                   |                     |                      |
/// | [`GL_R3_G3_B2`](crate::enums::GL_R3_G3_B2)            | [`GL_RGB`](crate::enums::GL_RGB)                     | 3                | 3                   | 2                 |                     |                      |
/// | [`GL_RGB4`](crate::enums::GL_RGB4)                    | [`GL_RGB`](crate::enums::GL_RGB)                     | 4                | 4                   | 4                 |                     |                      |
/// | [`GL_RGB5`](crate::enums::GL_RGB5)                    | [`GL_RGB`](crate::enums::GL_RGB)                     | 5                | 5                   | 5                 |                     |                      |
/// | [`GL_RGB8`](crate::enums::GL_RGB8)                    | [`GL_RGB`](crate::enums::GL_RGB)                     | 8                | 8                   | 8                 |                     |                      |
/// | [`GL_RGB8_SNORM`](crate::enums::GL_RGB8_SNORM)        | [`GL_RGB`](crate::enums::GL_RGB)                     | s8               | s8                  | s8                |                     |                      |
/// | [`GL_RGB10`](crate::enums::GL_RGB10)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 10               | 10                  | 10                |                     |                      |
/// | [`GL_RGB12`](crate::enums::GL_RGB12)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 12               | 12                  | 12                |                     |                      |
/// | [`GL_RGB16_SNORM`](crate::enums::GL_RGB16_SNORM)      | [`GL_RGB`](crate::enums::GL_RGB)                     | 16               | 16                  | 16                |                     |                      |
/// | [`GL_RGBA2`](crate::enums::GL_RGBA2)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 2                | 2                   | 2                 | 2                   |                      |
/// | [`GL_RGBA4`](crate::enums::GL_RGBA4)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 4                | 4                   | 4                 | 4                   |                      |
/// | [`GL_RGB5_A1`](crate::enums::GL_RGB5_A1)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 5                | 5                   | 5                 | 1                   |                      |
/// | [`GL_RGBA8`](crate::enums::GL_RGBA8)                  | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 8                | 8                   | 8                 | 8                   |                      |
/// | [`GL_RGBA8_SNORM`](crate::enums::GL_RGBA8_SNORM)      | [`GL_RGBA`](crate::enums::GL_RGBA)                   | s8               | s8                  | s8                | s8                  |                      |
/// | [`GL_RGB10_A2`](crate::enums::GL_RGB10_A2)            | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 10               | 10                  | 10                | 2                   |                      |
/// | [`GL_RGB10_A2UI`](crate::enums::GL_RGB10_A2UI)        | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui10             | ui10                | ui10              | ui2                 |                      |
/// | [`GL_RGBA12`](crate::enums::GL_RGBA12)                | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 12               | 12                  | 12                | 12                  |                      |
/// | [`GL_RGBA16`](crate::enums::GL_RGBA16)                | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 16               | 16                  | 16                | 16                  |                      |
/// | [`GL_SRGB8`](crate::enums::GL_SRGB8)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 8                | 8                   | 8                 |                     |                      |
/// | [`GL_SRGB8_ALPHA8`](crate::enums::GL_SRGB8_ALPHA8)    | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 8                | 8                   | 8                 | 8                   |                      |
/// | [`GL_R16F`](crate::enums::GL_R16F)                    | [`GL_RED`](crate::enums::GL_RED)                     | f16              |                     |                   |                     |                      |
/// | [`GL_RG16F`](crate::enums::GL_RG16F)                  | [`GL_RG`](crate::enums::GL_RG)                       | f16              | f16                 |                   |                     |                      |
/// | [`GL_RGB16F`](crate::enums::GL_RGB16F)                | [`GL_RGB`](crate::enums::GL_RGB)                     | f16              | f16                 | f16               |                     |                      |
/// | [`GL_RGBA16F`](crate::enums::GL_RGBA16F)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | f16              | f16                 | f16               | f16                 |                      |
/// | [`GL_R32F`](crate::enums::GL_R32F)                    | [`GL_RED`](crate::enums::GL_RED)                     | f32              |                     |                   |                     |                      |
/// | [`GL_RG32F`](crate::enums::GL_RG32F)                  | [`GL_RG`](crate::enums::GL_RG)                       | f32              | f32                 |                   |                     |                      |
/// | [`GL_RGB32F`](crate::enums::GL_RGB32F)                | [`GL_RGB`](crate::enums::GL_RGB)                     | f32              | f32                 | f32               |                     |                      |
/// | [`GL_RGBA32F`](crate::enums::GL_RGBA32F)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | f32              | f32                 | f32               | f32                 |                      |
/// | [`GL_R11F_G11F_B10F`](crate::enums::GL_R11F_G11F_B10F) | [`GL_RGB`](crate::enums::GL_RGB)                    | f11              | f11                 | f10               |                     |                      |
/// | [`GL_RGB9_E5`](crate::enums::GL_RGB9_E5)              | [`GL_RGB`](crate::enums::GL_RGB)                     | 9                | 9                   | 9                 |                     | 5                    |
/// | [`GL_R8I`](crate::enums::GL_R8I)                      | [`GL_RED`](crate::enums::GL_RED)                     | i8               |                     |                   |                     |                      |
/// | [`GL_R8UI`](crate::enums::GL_R8UI)                    | [`GL_RED`](crate::enums::GL_RED)                     | ui8              |                     |                   |                     |                      |
/// | [`GL_R16I`](crate::enums::GL_R16I)                    | [`GL_RED`](crate::enums::GL_RED)                     | i16              |                     |                   |                     |                      |
/// | [`GL_R16UI`](crate::enums::GL_R16UI)                  | [`GL_RED`](crate::enums::GL_RED)                     | ui16             |                     |                   |                     |                      |
/// | [`GL_R32I`](crate::enums::GL_R32I)                    | [`GL_RED`](crate::enums::GL_RED)                     | i32              |                     |                   |                     |                      |
/// | [`GL_R32UI`](crate::enums::GL_R32UI)                  | [`GL_RED`](crate::enums::GL_RED)                     | ui32             |                     |                   |                     |                      |
/// | [`GL_RG8I`](crate::enums::GL_RG8I)                    | [`GL_RG`](crate::enums::GL_RG)                       | i8               | i8                  |                   |                     |                      |
/// | [`GL_RG8UI`](crate::enums::GL_RG8UI)                  | [`GL_RG`](crate::enums::GL_RG)                       | ui8              | ui8                 |                   |                     |                      |
/// | [`GL_RG16I`](crate::enums::GL_RG16I)                  | [`GL_RG`](crate::enums::GL_RG)                       | i16              | i16                 |                   |                     |                      |
/// | [`GL_RG16UI`](crate::enums::GL_RG16UI)                | [`GL_RG`](crate::enums::GL_RG)                       | ui16             | ui16                |                   |                     |                      |
/// | [`GL_RG32I`](crate::enums::GL_RG32I)                  | [`GL_RG`](crate::enums::GL_RG)                       | i32              | i32                 |                   |                     |                      |
/// | [`GL_RG32UI`](crate::enums::GL_RG32UI)                | [`GL_RG`](crate::enums::GL_RG)                       | ui32             | ui32                |                   |                     |                      |
/// | [`GL_RGB8I`](crate::enums::GL_RGB8I)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | i8               | i8                  | i8                |                     |                      |
/// | [`GL_RGB8UI`](crate::enums::GL_RGB8UI)                | [`GL_RGB`](crate::enums::GL_RGB)                     | ui8              | ui8                 | ui8               |                     |                      |
/// | [`GL_RGB16I`](crate::enums::GL_RGB16I)                | [`GL_RGB`](crate::enums::GL_RGB)                     | i16              | i16                 | i16               |                     |                      |
/// | [`GL_RGB16UI`](crate::enums::GL_RGB16UI)              | [`GL_RGB`](crate::enums::GL_RGB)                     | ui16             | ui16                | ui16              |                     |                      |
/// | [`GL_RGB32I`](crate::enums::GL_RGB32I)                | [`GL_RGB`](crate::enums::GL_RGB)                     | i32              | i32                 | i32               |                     |                      |
/// | [`GL_RGB32UI`](crate::enums::GL_RGB32UI)              | [`GL_RGB`](crate::enums::GL_RGB)                     | ui32             | ui32                | ui32              |                     |                      |
/// | [`GL_RGBA8I`](crate::enums::GL_RGBA8I)                | [`GL_RGBA`](crate::enums::GL_RGBA)                   | i8               | i8                  | i8                | i8                  |                      |
/// | [`GL_RGBA8UI`](crate::enums::GL_RGBA8UI)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui8              | ui8                 | ui8               | ui8                 |                      |
/// | [`GL_RGBA16I`](crate::enums::GL_RGBA16I)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | i16              | i16                 | i16               | i16                 |                      |
/// | [`GL_RGBA16UI`](crate::enums::GL_RGBA16UI)            | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui16             | ui16                | ui16              | ui16                |                      |
/// | [`GL_RGBA32I`](crate::enums::GL_RGBA32I)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | i32              | i32                 | i32               | i32                 |                      |
/// | [`GL_RGBA32UI`](crate::enums::GL_RGBA32UI)            | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui32             | ui32                | ui32              | ui32                |                      |
///
///
/// ### Notes
/// [`GL_STENCIL_INDEX8`](crate::enums::GL_STENCIL_INDEX8) is accepted for
/// `internalformat` only if the GL version is 4.4 or higher.
impl Context {
    pub fn oxidegl_tex_storage3_d(
        &mut self,
        target: TextureTarget,
        levels: GLsizei,
        internalformat: SizedInternalFormat,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
    ) {
        panic!("command oxidegl_tex_storage3_d not yet implemented");
    }
    pub fn oxidegl_texture_storage3_d(
        &mut self,
        texture: GLuint,
        levels: GLsizei,
        internalformat: SizedInternalFormat,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
    ) {
        panic!("command oxidegl_texture_storage3_d not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the texture object is bound for [**glTexStorage3DMultisample**](crate::context::Context::oxidegl_tex_storage3_d_multisample).
/// > Must be one of [`GL_TEXTURE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE_ARRAY)
/// > or [`GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY).
///
/// `texture`
///
/// > Specifies the texture object name for [**glTextureStorage3DMultisample**](crate::context::Context::oxidegl_texture_storage3_d_multisample).
/// > The effective target of `texture` must be one of the valid non-proxy `target`
/// > values above.
///
/// `samples`
///
/// > Specify the number of samples in the texture.
///
/// `internalformat`
///
/// > Specifies the sized internal format to be used to store texture image data.
///
/// `width`
///
/// > Specifies the width of the texture, in texels.
///
/// `height`
///
/// > Specifies the height of the texture, in texels.
///
/// `depth`
///
/// > Specifies the depth of the texture, in layers.
///
/// `fixedsamplelocations`
///
/// > Specifies whether the image will use identical sample locations and the
/// > same number of samples for all texels in the image, and the sample locations
/// > will not depend on the internal format or size of the image.
///
/// ### Description
/// [**glTexStorage3DMultisample**](crate::context::Context::oxidegl_tex_storage3_d_multisample)
/// and [**glTextureStorage3DMultisample**](crate::context::Context::oxidegl_texture_storage3_d_multisample)
/// specify the storage requirements for a two-dimensional multisample array
/// texture. Once a texture is specified with this command, its format and
/// dimensions become immutable unless it is a proxy texture. The contents
/// of the image may still be modified, however, its storage requirements may
/// not change. Such a texture is referred to as an *immutable-format* texture.
///
/// `samples` specifies the number of samples to be used for the texture and
/// must be greater than zero and less than or equal to the value of [`GL_MAX_SAMPLES`](crate::enums::GL_MAX_SAMPLES).
/// `internalformat` must be a color-renderable, depth-renderable, or stencil-renderable
/// format. `width` and `height` specify the width and height, respectively,
/// of the texture and `depth` specifies the depth (or the number of layers)
/// of the texture. If `fixedsamplelocations` is [`GL_TRUE`](crate::enums::GL_TRUE),
/// the image will use identical sample locations and the same number of samples
/// for all texels in the image, and the sample locations will not depend on
/// the internal format or size of the image.
///
/// | *Sized Internal Format*                               | *Base Internal Format*                               | *Red Bits*       | *Green Bits*        | *Blue Bits*       | *Alpha Bits*        | *Shared Bits*        |
/// |-------------------------------------------------------|------------------------------------------------------|------------------|---------------------|-------------------|---------------------|----------------------|
/// | [`GL_R8`](crate::enums::GL_R8)                        | [`GL_RED`](crate::enums::GL_RED)                     | 8                |                     |                   |                     |                      |
/// | [`GL_R8_SNORM`](crate::enums::GL_R8_SNORM)            | [`GL_RED`](crate::enums::GL_RED)                     | s8               |                     |                   |                     |                      |
/// | [`GL_R16`](crate::enums::GL_R16)                      | [`GL_RED`](crate::enums::GL_RED)                     | 16               |                     |                   |                     |                      |
/// | [`GL_R16_SNORM`](crate::enums::GL_R16_SNORM)          | [`GL_RED`](crate::enums::GL_RED)                     | s16              |                     |                   |                     |                      |
/// | [`GL_RG8`](crate::enums::GL_RG8)                      | [`GL_RG`](crate::enums::GL_RG)                       | 8                | 8                   |                   |                     |                      |
/// | [`GL_RG8_SNORM`](crate::enums::GL_RG8_SNORM)          | [`GL_RG`](crate::enums::GL_RG)                       | s8               | s8                  |                   |                     |                      |
/// | [`GL_RG16`](crate::enums::GL_RG16)                    | [`GL_RG`](crate::enums::GL_RG)                       | 16               | 16                  |                   |                     |                      |
/// | [`GL_RG16_SNORM`](crate::enums::GL_RG16_SNORM)        | [`GL_RG`](crate::enums::GL_RG)                       | s16              | s16                 |                   |                     |                      |
/// | [`GL_R3_G3_B2`](crate::enums::GL_R3_G3_B2)            | [`GL_RGB`](crate::enums::GL_RGB)                     | 3                | 3                   | 2                 |                     |                      |
/// | [`GL_RGB4`](crate::enums::GL_RGB4)                    | [`GL_RGB`](crate::enums::GL_RGB)                     | 4                | 4                   | 4                 |                     |                      |
/// | [`GL_RGB5`](crate::enums::GL_RGB5)                    | [`GL_RGB`](crate::enums::GL_RGB)                     | 5                | 5                   | 5                 |                     |                      |
/// | [`GL_RGB8`](crate::enums::GL_RGB8)                    | [`GL_RGB`](crate::enums::GL_RGB)                     | 8                | 8                   | 8                 |                     |                      |
/// | [`GL_RGB8_SNORM`](crate::enums::GL_RGB8_SNORM)        | [`GL_RGB`](crate::enums::GL_RGB)                     | s8               | s8                  | s8                |                     |                      |
/// | [`GL_RGB10`](crate::enums::GL_RGB10)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 10               | 10                  | 10                |                     |                      |
/// | [`GL_RGB12`](crate::enums::GL_RGB12)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 12               | 12                  | 12                |                     |                      |
/// | [`GL_RGB16_SNORM`](crate::enums::GL_RGB16_SNORM)      | [`GL_RGB`](crate::enums::GL_RGB)                     | 16               | 16                  | 16                |                     |                      |
/// | [`GL_RGBA2`](crate::enums::GL_RGBA2)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 2                | 2                   | 2                 | 2                   |                      |
/// | [`GL_RGBA4`](crate::enums::GL_RGBA4)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 4                | 4                   | 4                 | 4                   |                      |
/// | [`GL_RGB5_A1`](crate::enums::GL_RGB5_A1)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 5                | 5                   | 5                 | 1                   |                      |
/// | [`GL_RGBA8`](crate::enums::GL_RGBA8)                  | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 8                | 8                   | 8                 | 8                   |                      |
/// | [`GL_RGBA8_SNORM`](crate::enums::GL_RGBA8_SNORM)      | [`GL_RGBA`](crate::enums::GL_RGBA)                   | s8               | s8                  | s8                | s8                  |                      |
/// | [`GL_RGB10_A2`](crate::enums::GL_RGB10_A2)            | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 10               | 10                  | 10                | 2                   |                      |
/// | [`GL_RGB10_A2UI`](crate::enums::GL_RGB10_A2UI)        | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui10             | ui10                | ui10              | ui2                 |                      |
/// | [`GL_RGBA12`](crate::enums::GL_RGBA12)                | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 12               | 12                  | 12                | 12                  |                      |
/// | [`GL_RGBA16`](crate::enums::GL_RGBA16)                | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 16               | 16                  | 16                | 16                  |                      |
/// | [`GL_SRGB8`](crate::enums::GL_SRGB8)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 8                | 8                   | 8                 |                     |                      |
/// | [`GL_SRGB8_ALPHA8`](crate::enums::GL_SRGB8_ALPHA8)    | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 8                | 8                   | 8                 | 8                   |                      |
/// | [`GL_R16F`](crate::enums::GL_R16F)                    | [`GL_RED`](crate::enums::GL_RED)                     | f16              |                     |                   |                     |                      |
/// | [`GL_RG16F`](crate::enums::GL_RG16F)                  | [`GL_RG`](crate::enums::GL_RG)                       | f16              | f16                 |                   |                     |                      |
/// | [`GL_RGB16F`](crate::enums::GL_RGB16F)                | [`GL_RGB`](crate::enums::GL_RGB)                     | f16              | f16                 | f16               |                     |                      |
/// | [`GL_RGBA16F`](crate::enums::GL_RGBA16F)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | f16              | f16                 | f16               | f16                 |                      |
/// | [`GL_R32F`](crate::enums::GL_R32F)                    | [`GL_RED`](crate::enums::GL_RED)                     | f32              |                     |                   |                     |                      |
/// | [`GL_RG32F`](crate::enums::GL_RG32F)                  | [`GL_RG`](crate::enums::GL_RG)                       | f32              | f32                 |                   |                     |                      |
/// | [`GL_RGB32F`](crate::enums::GL_RGB32F)                | [`GL_RGB`](crate::enums::GL_RGB)                     | f32              | f32                 | f32               |                     |                      |
/// | [`GL_RGBA32F`](crate::enums::GL_RGBA32F)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | f32              | f32                 | f32               | f32                 |                      |
/// | [`GL_R11F_G11F_B10F`](crate::enums::GL_R11F_G11F_B10F) | [`GL_RGB`](crate::enums::GL_RGB)                    | f11              | f11                 | f10               |                     |                      |
/// | [`GL_RGB9_E5`](crate::enums::GL_RGB9_E5)              | [`GL_RGB`](crate::enums::GL_RGB)                     | 9                | 9                   | 9                 |                     | 5                    |
/// | [`GL_R8I`](crate::enums::GL_R8I)                      | [`GL_RED`](crate::enums::GL_RED)                     | i8               |                     |                   |                     |                      |
/// | [`GL_R8UI`](crate::enums::GL_R8UI)                    | [`GL_RED`](crate::enums::GL_RED)                     | ui8              |                     |                   |                     |                      |
/// | [`GL_R16I`](crate::enums::GL_R16I)                    | [`GL_RED`](crate::enums::GL_RED)                     | i16              |                     |                   |                     |                      |
/// | [`GL_R16UI`](crate::enums::GL_R16UI)                  | [`GL_RED`](crate::enums::GL_RED)                     | ui16             |                     |                   |                     |                      |
/// | [`GL_R32I`](crate::enums::GL_R32I)                    | [`GL_RED`](crate::enums::GL_RED)                     | i32              |                     |                   |                     |                      |
/// | [`GL_R32UI`](crate::enums::GL_R32UI)                  | [`GL_RED`](crate::enums::GL_RED)                     | ui32             |                     |                   |                     |                      |
/// | [`GL_RG8I`](crate::enums::GL_RG8I)                    | [`GL_RG`](crate::enums::GL_RG)                       | i8               | i8                  |                   |                     |                      |
/// | [`GL_RG8UI`](crate::enums::GL_RG8UI)                  | [`GL_RG`](crate::enums::GL_RG)                       | ui8              | ui8                 |                   |                     |                      |
/// | [`GL_RG16I`](crate::enums::GL_RG16I)                  | [`GL_RG`](crate::enums::GL_RG)                       | i16              | i16                 |                   |                     |                      |
/// | [`GL_RG16UI`](crate::enums::GL_RG16UI)                | [`GL_RG`](crate::enums::GL_RG)                       | ui16             | ui16                |                   |                     |                      |
/// | [`GL_RG32I`](crate::enums::GL_RG32I)                  | [`GL_RG`](crate::enums::GL_RG)                       | i32              | i32                 |                   |                     |                      |
/// | [`GL_RG32UI`](crate::enums::GL_RG32UI)                | [`GL_RG`](crate::enums::GL_RG)                       | ui32             | ui32                |                   |                     |                      |
/// | [`GL_RGB8I`](crate::enums::GL_RGB8I)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | i8               | i8                  | i8                |                     |                      |
/// | [`GL_RGB8UI`](crate::enums::GL_RGB8UI)                | [`GL_RGB`](crate::enums::GL_RGB)                     | ui8              | ui8                 | ui8               |                     |                      |
/// | [`GL_RGB16I`](crate::enums::GL_RGB16I)                | [`GL_RGB`](crate::enums::GL_RGB)                     | i16              | i16                 | i16               |                     |                      |
/// | [`GL_RGB16UI`](crate::enums::GL_RGB16UI)              | [`GL_RGB`](crate::enums::GL_RGB)                     | ui16             | ui16                | ui16              |                     |                      |
/// | [`GL_RGB32I`](crate::enums::GL_RGB32I)                | [`GL_RGB`](crate::enums::GL_RGB)                     | i32              | i32                 | i32               |                     |                      |
/// | [`GL_RGB32UI`](crate::enums::GL_RGB32UI)              | [`GL_RGB`](crate::enums::GL_RGB)                     | ui32             | ui32                | ui32              |                     |                      |
/// | [`GL_RGBA8I`](crate::enums::GL_RGBA8I)                | [`GL_RGBA`](crate::enums::GL_RGBA)                   | i8               | i8                  | i8                | i8                  |                      |
/// | [`GL_RGBA8UI`](crate::enums::GL_RGBA8UI)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui8              | ui8                 | ui8               | ui8                 |                      |
/// | [`GL_RGBA16I`](crate::enums::GL_RGBA16I)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | i16              | i16                 | i16               | i16                 |                      |
/// | [`GL_RGBA16UI`](crate::enums::GL_RGBA16UI)            | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui16             | ui16                | ui16              | ui16                |                      |
/// | [`GL_RGBA32I`](crate::enums::GL_RGBA32I)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | i32              | i32                 | i32               | i32                 |                      |
/// | [`GL_RGBA32UI`](crate::enums::GL_RGBA32UI)            | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui32             | ui32                | ui32              | ui32                |                      |
///
///
/// ### Associated Gets
/// [**glGetInteger**](crate::context::Context::oxidegl_get_integer) with arguments
/// [`GL_MAX_TEXTURE_SIZE`](crate::enums::GL_MAX_TEXTURE_SIZE), [`GL_MAX_ARRAY_TEXTURE_LEVELS`](crate::enums::GL_MAX_ARRAY_TEXTURE_LEVELS),
/// [`GL_TEXTURE_VIEW_MIN_LAYER`](crate::enums::GL_TEXTURE_VIEW_MIN_LAYER),
/// [`GL_TEXTURE_VIEW_NUM_LAYERS`](crate::enums::GL_TEXTURE_VIEW_NUM_LAYERS),
/// or [`GL_TEXTURE_IMMUTABLE_LEVELS`](crate::enums::GL_TEXTURE_IMMUTABLE_LEVELS).
impl Context {
    pub fn oxidegl_tex_storage3_d_multisample(
        &mut self,
        target: TextureTarget,
        samples: GLsizei,
        internalformat: SizedInternalFormat,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        fixedsamplelocations: GLboolean,
    ) {
        panic!("command oxidegl_tex_storage3_d_multisample not yet implemented");
    }
    pub fn oxidegl_texture_storage3_d_multisample(
        &mut self,
        texture: GLuint,
        samples: GLsizei,
        internalformat: SizedInternalFormat,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        fixedsamplelocations: GLboolean,
    ) {
        panic!("command oxidegl_texture_storage3_d_multisample not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the texture is bound for [**glTexSubImage1D**](crate::context::Context::oxidegl_tex_sub_image1_d).
/// > Must be [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D).
///
/// `texture`
///
/// > Specifies the texture object name for [**glTextureSubImage1D**](crate::context::Context::oxidegl_texture_sub_image1_d).
/// > The effective target of `texture` must be one of the valid `target` values
/// > above.
///
/// `level`
///
/// > Specifies the level-of-detail number. Level 0 is the base image level.
/// > Level *n* is the *n* th mipmap reduction image.
///
/// `xoffset`
///
/// > Specifies a texel offset in the x direction within the texture array.
///
/// `width`
///
/// > Specifies the width of the texture subimage.
///
/// `format`
///
/// > Specifies the format of the pixel data. The following symbolic values are
/// > accepted: [`GL_RED`](crate::enums::GL_RED), [`GL_RG`](crate::enums::GL_RG),
/// > [`GL_RGB`](crate::enums::GL_RGB), [`GL_BGR`](crate::enums::GL_BGR), [`GL_RGBA`](crate::enums::GL_RGBA),
/// > [`GL_DEPTH_COMPONENT`](crate::enums::GL_DEPTH_COMPONENT), and [`GL_STENCIL_INDEX`](crate::enums::GL_STENCIL_INDEX).
///
/// `type`
///
/// > Specifies the data type of the pixel data. The following symbolic values
/// > are accepted: [`GL_UNSIGNED_BYTE`](crate::enums::GL_UNSIGNED_BYTE), [`GL_BYTE`](crate::enums::GL_BYTE),
/// > [`GL_UNSIGNED_SHORT`](crate::enums::GL_UNSIGNED_SHORT), [`GL_SHORT`](crate::enums::GL_SHORT),
/// > [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT), [`GL_INT`](crate::enums::GL_INT),
/// > [`GL_FLOAT`](crate::enums::GL_FLOAT), [`GL_UNSIGNED_BYTE_3_3_2`](crate::enums::GL_UNSIGNED_BYTE_3_3_2),
/// > [`GL_UNSIGNED_BYTE_2_3_3_REV`](crate::enums::GL_UNSIGNED_BYTE_2_3_3_REV),
/// > [`GL_UNSIGNED_SHORT_5_6_5`](crate::enums::GL_UNSIGNED_SHORT_5_6_5), [`GL_UNSIGNED_SHORT_5_6_5_REV`](crate::enums::GL_UNSIGNED_SHORT_5_6_5_REV),
/// > [`GL_UNSIGNED_SHORT_4_4_4_4`](crate::enums::GL_UNSIGNED_SHORT_4_4_4_4),
/// > [`GL_UNSIGNED_SHORT_4_4_4_4_REV`](crate::enums::GL_UNSIGNED_SHORT_4_4_4_4_REV),
/// > [`GL_UNSIGNED_SHORT_5_5_5_1`](crate::enums::GL_UNSIGNED_SHORT_5_5_5_1),
/// > [`GL_UNSIGNED_SHORT_1_5_5_5_REV`](crate::enums::GL_UNSIGNED_SHORT_1_5_5_5_REV),
/// > [`GL_UNSIGNED_INT_8_8_8_8`](crate::enums::GL_UNSIGNED_INT_8_8_8_8), [`GL_UNSIGNED_INT_8_8_8_8_REV`](crate::enums::GL_UNSIGNED_INT_8_8_8_8_REV),
/// > [`GL_UNSIGNED_INT_10_10_10_2`](crate::enums::GL_UNSIGNED_INT_10_10_10_2),
/// > and [`GL_UNSIGNED_INT_2_10_10_10_REV`](crate::enums::GL_UNSIGNED_INT_2_10_10_10_REV).
///
/// `pixels`
///
/// > Specifies a pointer to the image data in memory.
///
/// ### Description
/// Texturing maps a portion of a specified texture image onto each graphical
/// primitive for which texturing is enabled. To enable or disable one-dimensional
/// texturing, call [**glEnable**](crate::context::Context::oxidegl_enable)
/// and [**glDisable**](crate::context::Context::oxidegl_disable) with argument
/// [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D).
///
/// [**glTexSubImage1D**](crate::context::Context::oxidegl_tex_sub_image1_d)
/// and [**glTextureSubImage1D**](crate::context::Context::oxidegl_texture_sub_image1_d)
/// redefine a contiguous subregion of an existing one-dimensional texture
/// image. The texels referenced by `pixels` replace the portion of the existing
/// texture array with x indices `xoffset` and `[inlineq]`
///
/// If a non-zero named buffer object is bound to the [`GL_PIXEL_UNPACK_BUFFER`](crate::enums::GL_PIXEL_UNPACK_BUFFER)
/// target (see [**glBindBuffer**](crate::context::Context::oxidegl_bind_buffer))
/// while a texture image is specified, `pixels` is treated as a byte offset
/// into the buffer object's data store.
///
/// ### Notes
/// [**glPixelStore**](crate::context::Context::oxidegl_pixel_store) modes
/// affect texture images.
///
/// [**glTexSubImage1D**](crate::context::Context::oxidegl_tex_sub_image1_d)
/// and [**glTextureSubImage1D**](crate::context::Context::oxidegl_texture_sub_image1_d)
/// specify a one-dimensional subtexture for the current texture unit, specified
/// with [**glActiveTexture**](crate::context::Context::oxidegl_active_texture).
///
/// [`GL_STENCIL_INDEX`](crate::enums::GL_STENCIL_INDEX) is accepted for `format`
/// only if the GL version is 4.4 or higher.
///
/// ### Associated Gets
/// [**glGetTexImage**](crate::context::Context::oxidegl_get_tex_image)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_PIXEL_UNPACK_BUFFER_BINDING`](crate::enums::GL_PIXEL_UNPACK_BUFFER_BINDING)
impl Context {
    pub unsafe fn oxidegl_tex_sub_image1_d(
        &mut self,
        target: TextureTarget,
        level: GLint,
        xoffset: GLint,
        width: GLsizei,
        format: PixelFormat,
        r#type: PixelType,
        pixels: *const GLvoid,
    ) {
        panic!("command oxidegl_tex_sub_image1_d not yet implemented");
    }
    pub unsafe fn oxidegl_texture_sub_image1_d(
        &mut self,
        texture: GLuint,
        level: GLint,
        xoffset: GLint,
        width: GLsizei,
        format: PixelFormat,
        r#type: PixelType,
        pixels: *const GLvoid,
    ) {
        panic!("command oxidegl_texture_sub_image1_d not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the texture is bound for [**glTexSubImage2D**](crate::context::Context::oxidegl_tex_sub_image2_d).
/// > Must be [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D), [`GL_TEXTURE_CUBE_MAP_POSITIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_X),
/// > [`GL_TEXTURE_CUBE_MAP_NEGATIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_X),
/// > [`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Y),
/// > [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Y),
/// > [`GL_TEXTURE_CUBE_MAP_POSITIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Z),
/// > [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Z),
/// > or [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY).
///
/// `texture`
///
/// > Specifies the texture object name for [**glTextureSubImage2D**](crate::context::Context::oxidegl_texture_sub_image2_d).
/// > The effective target of `texture` must be one of the valid `target` values
/// > above.
///
/// `level`
///
/// > Specifies the level-of-detail number. Level 0 is the base image level.
/// > Level *n* is the *n* th mipmap reduction image.
///
/// `xoffset`
///
/// > Specifies a texel offset in the x direction within the texture array.
///
/// `yoffset`
///
/// > Specifies a texel offset in the y direction within the texture array.
///
/// `width`
///
/// > Specifies the width of the texture subimage.
///
/// `height`
///
/// > Specifies the height of the texture subimage.
///
/// `format`
///
/// > Specifies the format of the pixel data. The following symbolic values are
/// > accepted: [`GL_RED`](crate::enums::GL_RED), [`GL_RG`](crate::enums::GL_RG),
/// > [`GL_RGB`](crate::enums::GL_RGB), [`GL_BGR`](crate::enums::GL_BGR), [`GL_RGBA`](crate::enums::GL_RGBA),
/// > [`GL_BGRA`](crate::enums::GL_BGRA), [`GL_DEPTH_COMPONENT`](crate::enums::GL_DEPTH_COMPONENT),
/// > and [`GL_STENCIL_INDEX`](crate::enums::GL_STENCIL_INDEX).
///
/// `type`
///
/// > Specifies the data type of the pixel data. The following symbolic values
/// > are accepted: [`GL_UNSIGNED_BYTE`](crate::enums::GL_UNSIGNED_BYTE), [`GL_BYTE`](crate::enums::GL_BYTE),
/// > [`GL_UNSIGNED_SHORT`](crate::enums::GL_UNSIGNED_SHORT), [`GL_SHORT`](crate::enums::GL_SHORT),
/// > [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT), [`GL_INT`](crate::enums::GL_INT),
/// > [`GL_FLOAT`](crate::enums::GL_FLOAT), [`GL_UNSIGNED_BYTE_3_3_2`](crate::enums::GL_UNSIGNED_BYTE_3_3_2),
/// > [`GL_UNSIGNED_BYTE_2_3_3_REV`](crate::enums::GL_UNSIGNED_BYTE_2_3_3_REV),
/// > [`GL_UNSIGNED_SHORT_5_6_5`](crate::enums::GL_UNSIGNED_SHORT_5_6_5), [`GL_UNSIGNED_SHORT_5_6_5_REV`](crate::enums::GL_UNSIGNED_SHORT_5_6_5_REV),
/// > [`GL_UNSIGNED_SHORT_4_4_4_4`](crate::enums::GL_UNSIGNED_SHORT_4_4_4_4),
/// > [`GL_UNSIGNED_SHORT_4_4_4_4_REV`](crate::enums::GL_UNSIGNED_SHORT_4_4_4_4_REV),
/// > [`GL_UNSIGNED_SHORT_5_5_5_1`](crate::enums::GL_UNSIGNED_SHORT_5_5_5_1),
/// > [`GL_UNSIGNED_SHORT_1_5_5_5_REV`](crate::enums::GL_UNSIGNED_SHORT_1_5_5_5_REV),
/// > [`GL_UNSIGNED_INT_8_8_8_8`](crate::enums::GL_UNSIGNED_INT_8_8_8_8), [`GL_UNSIGNED_INT_8_8_8_8_REV`](crate::enums::GL_UNSIGNED_INT_8_8_8_8_REV),
/// > [`GL_UNSIGNED_INT_10_10_10_2`](crate::enums::GL_UNSIGNED_INT_10_10_10_2),
/// > and [`GL_UNSIGNED_INT_2_10_10_10_REV`](crate::enums::GL_UNSIGNED_INT_2_10_10_10_REV).
///
/// `pixels`
///
/// > Specifies a pointer to the image data in memory.
///
/// ### Description
/// Texturing maps a portion of a specified texture image onto each graphical
/// primitive for which texturing is enabled.
///
/// [**glTexSubImage2D**](crate::context::Context::oxidegl_tex_sub_image2_d)
/// and [**glTextureSubImage2D**](crate::context::Context::oxidegl_texture_sub_image2_d)
/// redefine a contiguous subregion of an existing two-dimensional or one-dimensional
/// array texture image. The texels referenced by `pixels` replace the portion
/// of the existing texture array with x indices `xoffset` and `[inlineq]`
/// `yoffset` and `[inlineq]`
///
/// If a non-zero named buffer object is bound to the [`GL_PIXEL_UNPACK_BUFFER`](crate::enums::GL_PIXEL_UNPACK_BUFFER)
/// target (see [**glBindBuffer**](crate::context::Context::oxidegl_bind_buffer))
/// while a texture image is specified, `pixels` is treated as a byte offset
/// into the buffer object's data store.
///
/// ### Notes
/// [**glPixelStore**](crate::context::Context::oxidegl_pixel_store) modes
/// affect texture images.
///
/// [**glTexSubImage2D**](crate::context::Context::oxidegl_tex_sub_image2_d)
/// and [**glTextureSubImage3D**](crate::context::Context::oxidegl_texture_sub_image3_d)
/// specify a two-dimensional subtexture for the current texture unit, specified
/// with [**glActiveTexture**](crate::context::Context::oxidegl_active_texture).
///
/// [`GL_STENCIL_INDEX`](crate::enums::GL_STENCIL_INDEX) is accepted for `format`
/// only if the GL version is 4.4 or higher.
///
/// ### Associated Gets
/// [**glGetTexImage**](crate::context::Context::oxidegl_get_tex_image)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_PIXEL_UNPACK_BUFFER_BINDING`](crate::enums::GL_PIXEL_UNPACK_BUFFER_BINDING)
impl Context {
    pub unsafe fn oxidegl_tex_sub_image2_d(
        &mut self,
        target: TextureTarget,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        width: GLsizei,
        height: GLsizei,
        format: PixelFormat,
        r#type: PixelType,
        pixels: *const GLvoid,
    ) {
        panic!("command oxidegl_tex_sub_image2_d not yet implemented");
    }
    pub unsafe fn oxidegl_texture_sub_image2_d(
        &mut self,
        texture: GLuint,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        width: GLsizei,
        height: GLsizei,
        format: PixelFormat,
        r#type: PixelType,
        pixels: *const GLvoid,
    ) {
        panic!("command oxidegl_texture_sub_image2_d not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the texture is bound for [**glTexSubImage3D**](crate::context::Context::oxidegl_tex_sub_image3_d).
/// > Must be [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D) or [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY).
///
/// `texture`
///
/// > Specifies the texture object name for [**glTextureSubImage3D**](crate::context::Context::oxidegl_texture_sub_image3_d).
/// > The effective target of `texture` must be one of the valid `target` values
/// > above.
///
/// `level`
///
/// > Specifies the level-of-detail number. Level 0 is the base image level.
/// > Level *n* is the *n* th mipmap reduction image.
///
/// `xoffset`
///
/// > Specifies a texel offset in the x direction within the texture array.
///
/// `yoffset`
///
/// > Specifies a texel offset in the y direction within the texture array.
///
/// `zoffset`
///
/// > Specifies a texel offset in the z direction within the texture array.
///
/// `width`
///
/// > Specifies the width of the texture subimage.
///
/// `height`
///
/// > Specifies the height of the texture subimage.
///
/// `depth`
///
/// > Specifies the depth of the texture subimage.
///
/// `format`
///
/// > Specifies the format of the pixel data. The following symbolic values are
/// > accepted: [`GL_RED`](crate::enums::GL_RED), [`GL_RG`](crate::enums::GL_RG),
/// > [`GL_RGB`](crate::enums::GL_RGB), [`GL_BGR`](crate::enums::GL_BGR), [`GL_RGBA`](crate::enums::GL_RGBA),
/// > [`GL_DEPTH_COMPONENT`](crate::enums::GL_DEPTH_COMPONENT), and [`GL_STENCIL_INDEX`](crate::enums::GL_STENCIL_INDEX).
///
/// `type`
///
/// > Specifies the data type of the pixel data. The following symbolic values
/// > are accepted: [`GL_UNSIGNED_BYTE`](crate::enums::GL_UNSIGNED_BYTE), [`GL_BYTE`](crate::enums::GL_BYTE),
/// > [`GL_UNSIGNED_SHORT`](crate::enums::GL_UNSIGNED_SHORT), [`GL_SHORT`](crate::enums::GL_SHORT),
/// > [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT), [`GL_INT`](crate::enums::GL_INT),
/// > [`GL_FLOAT`](crate::enums::GL_FLOAT), [`GL_UNSIGNED_BYTE_3_3_2`](crate::enums::GL_UNSIGNED_BYTE_3_3_2),
/// > [`GL_UNSIGNED_BYTE_2_3_3_REV`](crate::enums::GL_UNSIGNED_BYTE_2_3_3_REV),
/// > [`GL_UNSIGNED_SHORT_5_6_5`](crate::enums::GL_UNSIGNED_SHORT_5_6_5), [`GL_UNSIGNED_SHORT_5_6_5_REV`](crate::enums::GL_UNSIGNED_SHORT_5_6_5_REV),
/// > [`GL_UNSIGNED_SHORT_4_4_4_4`](crate::enums::GL_UNSIGNED_SHORT_4_4_4_4),
/// > [`GL_UNSIGNED_SHORT_4_4_4_4_REV`](crate::enums::GL_UNSIGNED_SHORT_4_4_4_4_REV),
/// > [`GL_UNSIGNED_SHORT_5_5_5_1`](crate::enums::GL_UNSIGNED_SHORT_5_5_5_1),
/// > [`GL_UNSIGNED_SHORT_1_5_5_5_REV`](crate::enums::GL_UNSIGNED_SHORT_1_5_5_5_REV),
/// > [`GL_UNSIGNED_INT_8_8_8_8`](crate::enums::GL_UNSIGNED_INT_8_8_8_8), [`GL_UNSIGNED_INT_8_8_8_8_REV`](crate::enums::GL_UNSIGNED_INT_8_8_8_8_REV),
/// > [`GL_UNSIGNED_INT_10_10_10_2`](crate::enums::GL_UNSIGNED_INT_10_10_10_2),
/// > and [`GL_UNSIGNED_INT_2_10_10_10_REV`](crate::enums::GL_UNSIGNED_INT_2_10_10_10_REV).
///
/// `pixels`
///
/// > Specifies a pointer to the image data in memory.
///
/// ### Description
/// Texturing maps a portion of a specified texture image onto each graphical
/// primitive for which texturing is enabled.
///
/// [**glTexSubImage3D**](crate::context::Context::oxidegl_tex_sub_image3_d)
/// and [**glTextureSubImage3D**](crate::context::Context::oxidegl_texture_sub_image3_d)
/// redefine a contiguous subregion of an existing three-dimensional or two-dimensioanl
/// array texture image. The texels referenced by `pixels` replace the portion
/// of the existing texture array with x indices `xoffset` and `[inlineq]`
/// `yoffset` and `[inlineq]` `zoffset` and `[inlineq]`
///
/// If a non-zero named buffer object is bound to the [`GL_PIXEL_UNPACK_BUFFER`](crate::enums::GL_PIXEL_UNPACK_BUFFER)
/// target (see [**glBindBuffer**](crate::context::Context::oxidegl_bind_buffer))
/// while a texture image is specified, `pixels` is treated as a byte offset
/// into the buffer object's data store.
///
/// ### Notes
/// The [**glPixelStore**](crate::context::Context::oxidegl_pixel_store) modes
/// affect texture images.
///
/// [**glTexSubImage3D**](crate::context::Context::oxidegl_tex_sub_image3_d)
/// and [**glTextureSubImage3D**](crate::context::Context::oxidegl_texture_sub_image3_d)
/// specify a three-dimensional or two-dimensional array subtexture for the
/// current texture unit, specified with [**glActiveTexture**](crate::context::Context::oxidegl_active_texture).
///
/// [`GL_STENCIL_INDEX`](crate::enums::GL_STENCIL_INDEX) is accepted for `format`
/// only if the GL version is 4.4 or higher.
///
/// ### Associated Gets
/// [**glGetTexImage**](crate::context::Context::oxidegl_get_tex_image)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_PIXEL_UNPACK_BUFFER_BINDING`](crate::enums::GL_PIXEL_UNPACK_BUFFER_BINDING)
impl Context {
    pub unsafe fn oxidegl_tex_sub_image3_d(
        &mut self,
        target: TextureTarget,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        zoffset: GLint,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        format: PixelFormat,
        r#type: PixelType,
        pixels: *const GLvoid,
    ) {
        panic!("command oxidegl_tex_sub_image3_d not yet implemented");
    }
    pub unsafe fn oxidegl_texture_sub_image3_d(
        &mut self,
        texture: GLuint,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        zoffset: GLint,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        format: PixelFormat,
        r#type: PixelType,
        pixels: *const GLvoid,
    ) {
        panic!("command oxidegl_texture_sub_image3_d not yet implemented");
    }
}
/// ### Parameters
/// `location`
///
/// > Specifies the location of the uniform variable to be modified.
///
/// `count`
///
/// > For the vector( [**glUniform*v**](crate::context::Context::oxidegl_uniform*v))
/// > commands, specifies the number of elements that are to be modified. This
/// > should be 1 if the targeted uniform variable is not an array, and 1 or
/// > more if it is an array.
///
/// > For the matrix( [**glUniformMatrix***](crate::context::Context::oxidegl_uniform_matrix*))
/// > commands, specifies the number of matrices that are to be modified. This
/// > should be 1 if the targeted uniform variable is not an array of matrices,
/// > and 1 or more if it is an array of matrices.
///
/// `transpose`
///
/// > For the matrix commands, specifies whether to transpose the matrix as the
/// > values are loaded into the uniform variable.
///
/// `v0`, `v1`, `v2`, `v3`
///
/// > For the scalar commands, specifies the new values to be used for the specified
/// > uniform variable.
///
/// `value`
///
/// > For the vector and matrix commands, specifies a pointer to an array of
/// > `count` values that will be used to update the specified uniform variable.
///
/// ### Description
/// [**glUniform**](crate::context::Context::oxidegl_uniform) modifies the
/// value of a uniform variable or a uniform variable array. The location of
/// the uniform variable to be modified is specified by `location`, which should
/// be a value returned by [**glGetUniformLocation**](crate::context::Context::oxidegl_get_uniform_location).
/// [**glUniform**](crate::context::Context::oxidegl_uniform) operates on the
/// program object that was made part of current state by calling [**glUseProgram**](crate::context::Context::oxidegl_use_program).
///
/// The commands [**glUniform{1|2|3|4}{f|i|ui}**](crate::context::Context::oxidegl_uniform{1|2|3|4}{f|i|ui})
/// are used to change the value of the uniform variable specified by `location`
/// using the values passed as arguments. The number specified in the command
/// should match the number of components in the data type of the specified
/// uniform variable (e.g., [**1**](crate::context::Context::oxide1) for [**2**](crate::context::Context::oxide2)
/// for [**f**](crate::context::Context::oxidef) indicates that floating-point
/// values are being passed; the suffix [**i**](crate::context::Context::oxidei)
/// indicates that integer values are being passed; the suffix [**ui**](crate::context::Context::oxideui)
/// indicates that unsigned integer values are being passed, and this type
/// should also match the data type of the specified uniform variable. The
/// [**i**](crate::context::Context::oxidei) variants of this function should
/// be used to provide values for uniform variables defined as [**ui**](crate::context::Context::oxideui)
/// variants of this function should be used to provide values for uniform
/// variables defined as [**f**](crate::context::Context::oxidef) variants
/// should be used to provide values for uniform variables of type [**i**](crate::context::Context::oxidei),
/// [**ui**](crate::context::Context::oxideui) or [**f**](crate::context::Context::oxidef)
/// variants may be used to provide values for uniform variables of type
///
/// All active uniform variables defined in a program object are initialized
/// to 0 when the program object is linked successfully. They retain the values
/// assigned to them by a call to [**glUniform **](crate::context::Context::oxidegl_uniform
///) until the next successful link operation occurs on the program object,
/// when they are once again initialized to 0.
///
/// The commands [**glUniform{1|2|3|4}{f|i|ui}v**](crate::context::Context::oxidegl_uniform{1|2|3|4}{f|i|ui}v)
/// can be used to modify a single uniform variable or a uniform variable array.
/// These commands pass a count and a pointer to the values to be loaded into
/// a uniform variable or a uniform variable array. A count of 1 should be
/// used if modifying the value of a single uniform variable, and a count of
/// 1 or greater can be used to modify an entire array or part of an array.
/// When loading *n* elements starting at an arbitrary position *m* in a uniform
/// variable array, elements *m*+ *n*- 1 in the array will be replaced with
/// the new values. If `m`+ `n`- 1 is larger than the size of the uniform variable
/// array, values for all array elements beyond the end of the array will be
/// ignored. The number specified in the name of the command indicates the
/// number of components for each element in `value`, and it should match the
/// number of components in the data type of the specified uniform variable
/// (e.g., [**1**](crate::context::Context::oxide1) for float, int, bool; [**2**](crate::context::Context::oxide2)
/// for vec2, ivec2, bvec2, etc.). The data type specified in the name of the
/// command must match the data type for the specified uniform variable as
/// described previously for [**glUniform{1|2|3|4}{f|i|ui}**](crate::context::Context::oxidegl_uniform{1|2|3|4}{f|i|ui}).
///
/// For uniform variable arrays, each element of the array is considered to
/// be of the type indicated in the name of the command (e.g., [**glUniform3f**](crate::context::Context::oxidegl_uniform3f)
/// or [**glUniform3fv**](crate::context::Context::oxidegl_uniform3fv) can
/// be used to load a uniform variable array of type vec3). The number of elements
/// of the uniform variable array to be modified is specified by `count`
///
/// The commands [**glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv**](crate::context::Context::oxidegl_uniform_matrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv)
/// are used to modify a matrix or an array of matrices. The numbers in the
/// command name are interpreted as the dimensionality of the matrix. The number
/// [**2**](crate::context::Context::oxide2) indicates a 2 × 2 matrix (i.e.,
/// 4 values), the number [**3**](crate::context::Context::oxide3) indicates
/// a 3 × 3 matrix (i.e., 9 values), and the number [**4**](crate::context::Context::oxide4)
/// indicates a 4 × 4 matrix (i.e., 16 values). Non-square matrix dimensionality
/// is explicit, with the first number representing the number of columns and
/// the second number representing the number of rows. For example, [**2x4**](crate::context::Context::oxide2x4)
/// indicates a 2 × 4 matrix with 2 columns and 4 rows (i.e., 8 values). If
/// `transpose` is [`GL_FALSE`](crate::enums::GL_FALSE), each matrix is assumed
/// to be supplied in column major order. If `transpose` is [`GL_TRUE`](crate::enums::GL_TRUE),
/// each matrix is assumed to be supplied in row major order. The `count`
/// argument indicates the number of matrices to be passed. A count of 1 should
/// be used if modifying the value of a single matrix, and a count greater
/// than 1 can be used to modify an array of matrices.
///
/// ### Notes
/// [**glUniform1i**](crate::context::Context::oxidegl_uniform1i) and [**glUniform1iv**](crate::context::Context::oxidegl_uniform1iv)
/// are the only two functions that may be used to load uniform variables defined
/// as sampler types. Loading samplers with any other function will result
/// in a [`GL_INVALID_OPERATION`](crate::enums::GL_INVALID_OPERATION) error.
///
/// If `count` is greater than 1 and the indicated uniform variable is not
/// an array, a [`GL_INVALID_OPERATION`](crate::enums::GL_INVALID_OPERATION)
/// error is generated and the specified uniform variable will remain unchanged.
///
/// Other than the preceding exceptions, if the type and size of the uniform
/// variable as defined in the shader do not match the type and size specified
/// in the name of the command used to load its value, a [`GL_INVALID_OPERATION`](crate::enums::GL_INVALID_OPERATION)
/// error will be generated and the specified uniform variable will remain
/// unchanged.
///
/// If `location` is a value other than -1 and it does not represent a valid
/// uniform variable location in the current program object, an error will
/// be generated, and no changes will be made to the uniform variable storage
/// of the current program object. If `location` is equal to -1, the data passed
/// in will be silently ignored and the specified uniform variable will not
/// be changed.
///
/// ### Associated Gets
/// [**glGet**](crate::context::Context::oxidegl_get) with the argument [`GL_CURRENT_PROGRAM`](crate::enums::GL_CURRENT_PROGRAM)
///
/// [**glGetActiveUniform**](crate::context::Context::oxidegl_get_active_uniform)
/// with the handle of a program object and the index of an active uniform
/// variable
///
/// [**glGetUniform**](crate::context::Context::oxidegl_get_uniform) with the
/// handle of a program object and the location of a uniform variable
///
/// [**glGetUniformLocation**](crate::context::Context::oxidegl_get_uniform_location)
/// with the handle of a program object and the name of a uniform variable
impl Context {
    pub fn oxidegl_uniform1f(&mut self, location: GLint, v0: GLfloat) {
        panic!("command oxidegl_uniform1f not yet implemented");
    }
    pub fn oxidegl_uniform2f(&mut self, location: GLint, v0: GLfloat, v1: GLfloat) {
        panic!("command oxidegl_uniform2f not yet implemented");
    }
    pub fn oxidegl_uniform3f(&mut self, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat) {
        panic!("command oxidegl_uniform3f not yet implemented");
    }
    pub fn oxidegl_uniform4f(
        &mut self,
        location: GLint,
        v0: GLfloat,
        v1: GLfloat,
        v2: GLfloat,
        v3: GLfloat,
    ) {
        panic!("command oxidegl_uniform4f not yet implemented");
    }
    pub fn oxidegl_uniform1i(&mut self, location: GLint, v0: GLint) {
        panic!("command oxidegl_uniform1i not yet implemented");
    }
    pub fn oxidegl_uniform2i(&mut self, location: GLint, v0: GLint, v1: GLint) {
        panic!("command oxidegl_uniform2i not yet implemented");
    }
    pub fn oxidegl_uniform3i(&mut self, location: GLint, v0: GLint, v1: GLint, v2: GLint) {
        panic!("command oxidegl_uniform3i not yet implemented");
    }
    pub fn oxidegl_uniform4i(
        &mut self,
        location: GLint,
        v0: GLint,
        v1: GLint,
        v2: GLint,
        v3: GLint,
    ) {
        panic!("command oxidegl_uniform4i not yet implemented");
    }
    pub unsafe fn oxidegl_uniform1fv(
        &mut self,
        location: GLint,
        count: GLsizei,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_uniform1fv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform2fv(
        &mut self,
        location: GLint,
        count: GLsizei,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_uniform2fv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform3fv(
        &mut self,
        location: GLint,
        count: GLsizei,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_uniform3fv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform4fv(
        &mut self,
        location: GLint,
        count: GLsizei,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_uniform4fv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform1iv(
        &mut self,
        location: GLint,
        count: GLsizei,
        value: *const GLint,
    ) {
        panic!("command oxidegl_uniform1iv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform2iv(
        &mut self,
        location: GLint,
        count: GLsizei,
        value: *const GLint,
    ) {
        panic!("command oxidegl_uniform2iv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform3iv(
        &mut self,
        location: GLint,
        count: GLsizei,
        value: *const GLint,
    ) {
        panic!("command oxidegl_uniform3iv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform4iv(
        &mut self,
        location: GLint,
        count: GLsizei,
        value: *const GLint,
    ) {
        panic!("command oxidegl_uniform4iv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform_matrix2fv(
        &mut self,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_uniform_matrix2fv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform_matrix3fv(
        &mut self,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_uniform_matrix3fv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform_matrix4fv(
        &mut self,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_uniform_matrix4fv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform_matrix2x3fv(
        &mut self,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_uniform_matrix2x3fv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform_matrix3x2fv(
        &mut self,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_uniform_matrix3x2fv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform_matrix2x4fv(
        &mut self,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_uniform_matrix2x4fv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform_matrix4x2fv(
        &mut self,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_uniform_matrix4x2fv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform_matrix3x4fv(
        &mut self,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_uniform_matrix3x4fv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform_matrix4x3fv(
        &mut self,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        panic!("command oxidegl_uniform_matrix4x3fv not yet implemented");
    }
    pub fn oxidegl_uniform1ui(&mut self, location: GLint, v0: GLuint) {
        panic!("command oxidegl_uniform1ui not yet implemented");
    }
    pub fn oxidegl_uniform2ui(&mut self, location: GLint, v0: GLuint, v1: GLuint) {
        panic!("command oxidegl_uniform2ui not yet implemented");
    }
    pub fn oxidegl_uniform3ui(&mut self, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint) {
        panic!("command oxidegl_uniform3ui not yet implemented");
    }
    pub fn oxidegl_uniform4ui(
        &mut self,
        location: GLint,
        v0: GLuint,
        v1: GLuint,
        v2: GLuint,
        v3: GLuint,
    ) {
        panic!("command oxidegl_uniform4ui not yet implemented");
    }
    pub unsafe fn oxidegl_uniform1uiv(
        &mut self,
        location: GLint,
        count: GLsizei,
        value: *const GLuint,
    ) {
        panic!("command oxidegl_uniform1uiv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform2uiv(
        &mut self,
        location: GLint,
        count: GLsizei,
        value: *const GLuint,
    ) {
        panic!("command oxidegl_uniform2uiv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform3uiv(
        &mut self,
        location: GLint,
        count: GLsizei,
        value: *const GLuint,
    ) {
        panic!("command oxidegl_uniform3uiv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform4uiv(
        &mut self,
        location: GLint,
        count: GLsizei,
        value: *const GLuint,
    ) {
        panic!("command oxidegl_uniform4uiv not yet implemented");
    }
}
/// ### Parameters
/// `target`
///
/// > Specifies the target to which the buffer object is bound for [**glUnmapBuffer**](crate::context::Context::oxidegl_unmap_buffer),
/// > which must be one of the buffer binding targets in the following table:
///
/// > | *Buffer Binding Target*                               | *Purpose*      |
/// > |-------------------------------------------------------|----------------|
/// > | [`GL_ARRAY_BUFFER`](crate::enums::GL_ARRAY_BUFFER)    | Vertex attributes |
/// > | [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER) | Atomic counter storage |
/// > | [`GL_COPY_READ_BUFFER`](crate::enums::GL_COPY_READ_BUFFER) | Buffer copy source |
/// > | [`GL_COPY_WRITE_BUFFER`](crate::enums::GL_COPY_WRITE_BUFFER) | Buffer copy destination |
/// > | [`GL_DISPATCH_INDIRECT_BUFFER`](crate::enums::GL_DISPATCH_INDIRECT_BUFFER) | Indirect compute dispatch commands |
/// > | [`GL_DRAW_INDIRECT_BUFFER`](crate::enums::GL_DRAW_INDIRECT_BUFFER) | Indirect command arguments |
/// > | [`GL_ELEMENT_ARRAY_BUFFER`](crate::enums::GL_ELEMENT_ARRAY_BUFFER) | Vertex array indices |
/// > | [`GL_PIXEL_PACK_BUFFER`](crate::enums::GL_PIXEL_PACK_BUFFER) | Pixel read target |
/// > | [`GL_PIXEL_UNPACK_BUFFER`](crate::enums::GL_PIXEL_UNPACK_BUFFER) | Texture data source |
/// > | [`GL_QUERY_BUFFER`](crate::enums::GL_QUERY_BUFFER)    | Query result buffer |
/// > | [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER) | Read-write storage for shaders |
/// > | [`GL_TEXTURE_BUFFER`](crate::enums::GL_TEXTURE_BUFFER) | Texture data buffer |
/// > | [`GL_TRANSFORM_FEEDBACK_BUFFER`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER) | Transform feedback buffer |
/// > | [`GL_UNIFORM_BUFFER`](crate::enums::GL_UNIFORM_BUFFER) | Uniform block storage |
///
/// `buffer`
///
/// > Specifies the name of the buffer object for [**glUnmapNamedBuffer**](crate::context::Context::oxidegl_unmap_named_buffer).
///
/// ### Description
/// [**glUnmapBuffer**](crate::context::Context::oxidegl_unmap_buffer) and
/// [**glUnmapNamedBuffer**](crate::context::Context::oxidegl_unmap_named_buffer)
/// unmap (release) any mapping of a specified buffer object into the client's
/// address space (see [**glMapBufferRange**](crate::context::Context::oxidegl_map_buffer_range)
/// and [**glMapBuffer**](crate::context::Context::oxidegl_map_buffer) ).
///
/// If a mapping is not unmapped before the corresponding buffer object's data
/// store is used by the GL, an error will be generated by any GL command that
/// attempts to dereference the buffer object's data store, unless the buffer
/// was successfully mapped with [`GL_MAP_PERSISTENT_BIT`](crate::enums::GL_MAP_PERSISTENT_BIT)
/// (see [**glMapBufferRange**](crate::context::Context::oxidegl_map_buffer_range)
/// ). When a data store is unmapped, the mapped pointer becomes invalid.
///
/// [**glUnmapBuffer**](crate::context::Context::oxidegl_unmap_buffer) returns
/// [`GL_TRUE`](crate::enums::GL_TRUE) unless the data store contents have
/// become corrupt during the time the data store was mapped. This can occur
/// for system-specific reasons that affect the availability of graphics memory,
/// such as screen mode changes. In such situations, [`GL_FALSE`](crate::enums::GL_FALSE)
/// is returned and the data store contents are undefined. An application must
/// detect this rare condition and reinitialize the data store.
///
/// A buffer object's mapped data store is automatically unmapped when the
/// buffer object is deleted or its data store is recreated with [**glBufferData**](crate::context::Context::oxidegl_buffer_data)
/// ).
///
/// ### Notes
/// If an error is generated, [**glUnmapBuffer**](crate::context::Context::oxidegl_unmap_buffer)
/// returns [`GL_FALSE`](crate::enums::GL_FALSE).
///
/// The [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER)
/// target is accepted only if the GL version is 4.2 or greater.
///
/// The [`GL_DISPATCH_INDIRECT_BUFFER`](crate::enums::GL_DISPATCH_INDIRECT_BUFFER)
/// and [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER)
/// targets are available only if the GL version is 4.3 or greater.
///
/// The [`GL_QUERY_BUFFER`](crate::enums::GL_QUERY_BUFFER) target is available
/// only if the GL version is 4.4 or greater.
///
/// ### Associated Gets
/// [**glGetBufferParameter**](crate::context::Context::oxidegl_get_buffer_parameter)
/// with argument [`GL_BUFFER_MAPPED`](crate::enums::GL_BUFFER_MAPPED).
impl Context {
    pub fn oxidegl_unmap_buffer(&mut self, target: BufferTarget) -> GLboolean {
        panic!("command oxidegl_unmap_buffer not yet implemented");
    }
    pub fn oxidegl_unmap_named_buffer(&mut self, buffer: GLuint) -> GLboolean {
        panic!("command oxidegl_unmap_named_buffer not yet implemented");
    }
}
/// ### Parameters
/// `index`
///
/// > Specifies the index of the generic vertex attribute to be modified.
///
/// `v0`, `v1`, `v2`, `v3`
///
/// > For the scalar commands, specifies the new values to be used for the specified
/// > vertex attribute.
///
/// `v`
///
/// > For the vector commands( [**glVertexAttrib*v**](crate::context::Context::oxidegl_vertex_attrib*v)
/// > ), specifies a pointer to an array of values to be used for the generic
/// > vertex attribute.
///
/// `type`
///
/// > For the packed commands( [**glVertexAttribP***](crate::context::Context::oxidegl_vertex_attrib_p*)
/// > ), specified the type of packing used on the data. This parameter must
/// > be [`GL_INT_2_10_10_10_REV`](crate::enums::GL_INT_2_10_10_10_REV) or [`GL_UNSIGNED_INT_2_10_10_10_REV`](crate::enums::GL_UNSIGNED_INT_2_10_10_10_REV),
/// > to specify signed or unsigned data, respectively, or [`GL_UNSIGNED_INT_10F_11F_11F_REV`](crate::enums::GL_UNSIGNED_INT_10F_11F_11F_REV)
/// > to specify floating point data.
///
/// `normalized`
///
/// > For the packed commands, if [`GL_TRUE`](crate::enums::GL_TRUE), then the
/// > values are to be converted to floating point values by normalizing. Otherwise,
/// > they are converted directly to floating-point values. If `type` indicates
/// > a floating-pont format, then `normalized` value must be [`GL_FALSE`](crate::enums::GL_FALSE).
///
/// `value`
///
/// > For the packed commands, specifies the new packed value to be used for
/// > the specified vertex attribute.
///
/// ### Description
/// The [**glVertexAttrib**](crate::context::Context::oxidegl_vertex_attrib)
/// family of entry points allows an application to pass generic vertex attributes
/// in numbered locations.
///
/// Generic attributes are defined as four-component values that are organized
/// into an array. The first entry of this array is numbered 0, and the size
/// of the array is specified by the implementation-dependent constant [`GL_MAX_VERTEX_ATTRIBS`](crate::enums::GL_MAX_VERTEX_ATTRIBS).
/// Individual elements of this array can be modified with a [**glVertexAttrib**](crate::context::Context::oxidegl_vertex_attrib)
/// call that specifies the index of the element to be modified and a value
/// for that element.
///
/// These commands can be used to specify one, two, three, or all four components
/// of the generic vertex attribute specified by `index`. A [**1**](crate::context::Context::oxide1)
/// in the name of the command indicates that only one value is passed, and
/// it will be used to modify the first component of the generic vertex attribute.
/// The second and third components will be set to 0, and the fourth component
/// will be set to 1. Similarly, a [**2**](crate::context::Context::oxide2)
/// in the name of the command indicates that values are provided for the first
/// two components, the third component will be set to 0, and the fourth component
/// will be set to 1. A [**3**](crate::context::Context::oxide3) in the name
/// of the command indicates that values are provided for the first three components
/// and the fourth component will be set to 1, whereas a [**4**](crate::context::Context::oxide4)
/// in the name indicates that values are provided for all four components.
///
/// The letters [**s**](crate::context::Context::oxides), [**f**](crate::context::Context::oxidef),
/// [**i**](crate::context::Context::oxidei), [**d**](crate::context::Context::oxided),
/// [**ub**](crate::context::Context::oxideub), [**us**](crate::context::Context::oxideus),
/// and [**ui**](crate::context::Context::oxideui) indicate whether the arguments
/// are of type short, float, int, double, unsigned byte, unsigned short, or
/// unsigned int. When [**v**](crate::context::Context::oxidev) is appended
/// to the name, the commands can take a pointer to an array of such values.
///
/// Additional capitalized letters can indicate further alterations to the
/// default behavior of the glVertexAttrib function:
///
/// The commands containing [**N**](crate::context::Context::oxide_n) indicate
/// that the arguments will be passed as fixed-point values that are scaled
/// to a normalized range according to the component conversion rules defined
/// by the OpenGL specification. Signed values are understood to represent
/// fixed-point values in the range \[-1,1\], and unsigned values are understood
/// to represent fixed-point values in the range \[0,1\].
///
/// The commands containing [**I**](crate::context::Context::oxide_i) indicate
/// that the arguments are extended to full signed or unsigned integers.
///
/// The commands containing [**P**](crate::context::Context::oxide_p) indicate
/// that the arguments are stored as packed components within a larger natural
/// type.
///
/// The commands containing [**L**](crate::context::Context::oxide_l) indicate
/// that the arguments are full 64-bit quantities and should be passed directly
/// to shader inputs declared as 64-bit double precision types.
///
/// OpenGL Shading Language attribute variables are allowed to be of type mat2,
/// mat3, or mat4. Attributes of these types may be loaded using the [**glVertexAttrib**](crate::context::Context::oxidegl_vertex_attrib)
/// entry points. Matrices must be loaded into successive generic attribute
/// slots in column major order, with one column of the matrix in each generic
/// attribute slot.
///
/// A user-defined attribute variable declared in a vertex shader can be bound
/// to a generic attribute index by calling [**glBindAttribLocation**](crate::context::Context::oxidegl_bind_attrib_location).
/// This allows an application to use more descriptive variable names in a
/// vertex shader. A subsequent change to the specified generic vertex attribute
/// will be immediately reflected as a change to the corresponding attribute
/// variable in the vertex shader.
///
/// The binding between a generic vertex attribute index and a user-defined
/// attribute variable in a vertex shader is part of the state of a program
/// object, but the current value of the generic vertex attribute is not. The
/// value of each generic vertex attribute is part of current state, just like
/// standard vertex attributes, and it is maintained even if a different program
/// object is used.
///
/// An application may freely modify generic vertex attributes that are not
/// bound to a named vertex shader attribute variable. These values are simply
/// maintained as part of current state and will not be accessed by the vertex
/// shader. If a generic vertex attribute bound to an attribute variable in
/// a vertex shader is not updated while the vertex shader is executing, the
/// vertex shader will repeatedly use the current value for the generic vertex
/// attribute.
///
/// ### Notes
/// Generic vertex attributes can be updated at any time.
///
/// It is possible for an application to bind more than one attribute name
/// to the same generic vertex attribute index. This is referred to as aliasing,
/// and it is allowed only if just one of the aliased attribute variables is
/// active in the vertex shader, or if no path through the vertex shader consumes
/// more than one of the attributes aliased to the same location. OpenGL implementations
/// are not required to do error checking to detect aliasing, they are allowed
/// to assume that aliasing will not occur, and they are allowed to employ
/// optimizations that work only in the absence of aliasing.
///
/// There is no provision for binding standard vertex attributes; therefore,
/// it is not possible to alias generic attributes with standard attributes.
///
/// [**glVertexAttribL**](crate::context::Context::oxidegl_vertex_attrib_l)
/// versions are available only if the GL version is 4.1 or higher.
///
/// [`GL_UNSIGNED_INT_10F_11F_11F_REV`](crate::enums::GL_UNSIGNED_INT_10F_11F_11F_REV)
/// is accepted for `type` by [**glVertexAttribP***](crate::context::Context::oxidegl_vertex_attrib_p*)
/// only if the GL version is 4.4 or higher.
///
/// ### Associated Gets
/// [**glGet**](crate::context::Context::oxidegl_get) with the argument [`GL_CURRENT_PROGRAM`](crate::enums::GL_CURRENT_PROGRAM)
///
/// [**glGetActiveAttrib**](crate::context::Context::oxidegl_get_active_attrib)
/// with argument `program` and the index of an active attribute variable
///
/// [**glGetAttribLocation**](crate::context::Context::oxidegl_get_attrib_location)
/// with argument `program` and an attribute variable name
///
/// [**glGetVertexAttrib**](crate::context::Context::oxidegl_get_vertex_attrib)
/// with arguments [`GL_CURRENT_VERTEX_ATTRIB`](crate::enums::GL_CURRENT_VERTEX_ATTRIB)
/// and `index`
impl Context {
    pub fn oxidegl_vertex_attrib1d(&mut self, index: GLuint, x: GLdouble) {
        panic!("command oxidegl_vertex_attrib1d not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib1dv(&mut self, index: GLuint, v: *const GLdouble) {
        panic!("command oxidegl_vertex_attrib1dv not yet implemented");
    }
    pub fn oxidegl_vertex_attrib1f(&mut self, index: GLuint, x: GLfloat) {
        panic!("command oxidegl_vertex_attrib1f not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib1fv(&mut self, index: GLuint, v: *const GLfloat) {
        panic!("command oxidegl_vertex_attrib1fv not yet implemented");
    }
    pub fn oxidegl_vertex_attrib1s(&mut self, index: GLuint, x: GLshort) {
        panic!("command oxidegl_vertex_attrib1s not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib1sv(&mut self, index: GLuint, v: *const GLshort) {
        panic!("command oxidegl_vertex_attrib1sv not yet implemented");
    }
    pub fn oxidegl_vertex_attrib2d(&mut self, index: GLuint, x: GLdouble, y: GLdouble) {
        panic!("command oxidegl_vertex_attrib2d not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib2dv(&mut self, index: GLuint, v: *const GLdouble) {
        panic!("command oxidegl_vertex_attrib2dv not yet implemented");
    }
    pub fn oxidegl_vertex_attrib2f(&mut self, index: GLuint, x: GLfloat, y: GLfloat) {
        panic!("command oxidegl_vertex_attrib2f not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib2fv(&mut self, index: GLuint, v: *const GLfloat) {
        panic!("command oxidegl_vertex_attrib2fv not yet implemented");
    }
    pub fn oxidegl_vertex_attrib2s(&mut self, index: GLuint, x: GLshort, y: GLshort) {
        panic!("command oxidegl_vertex_attrib2s not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib2sv(&mut self, index: GLuint, v: *const GLshort) {
        panic!("command oxidegl_vertex_attrib2sv not yet implemented");
    }
    pub fn oxidegl_vertex_attrib3d(
        &mut self,
        index: GLuint,
        x: GLdouble,
        y: GLdouble,
        z: GLdouble,
    ) {
        panic!("command oxidegl_vertex_attrib3d not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib3dv(&mut self, index: GLuint, v: *const GLdouble) {
        panic!("command oxidegl_vertex_attrib3dv not yet implemented");
    }
    pub fn oxidegl_vertex_attrib3f(&mut self, index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat) {
        panic!("command oxidegl_vertex_attrib3f not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib3fv(&mut self, index: GLuint, v: *const GLfloat) {
        panic!("command oxidegl_vertex_attrib3fv not yet implemented");
    }
    pub fn oxidegl_vertex_attrib3s(&mut self, index: GLuint, x: GLshort, y: GLshort, z: GLshort) {
        panic!("command oxidegl_vertex_attrib3s not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib3sv(&mut self, index: GLuint, v: *const GLshort) {
        panic!("command oxidegl_vertex_attrib3sv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib4_nbv(&mut self, index: GLuint, v: *const GLbyte) {
        panic!("command oxidegl_vertex_attrib4_nbv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib4_niv(&mut self, index: GLuint, v: *const GLint) {
        panic!("command oxidegl_vertex_attrib4_niv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib4_nsv(&mut self, index: GLuint, v: *const GLshort) {
        panic!("command oxidegl_vertex_attrib4_nsv not yet implemented");
    }
    pub fn oxidegl_vertex_attrib4_nub(
        &mut self,
        index: GLuint,
        x: GLubyte,
        y: GLubyte,
        z: GLubyte,
        w: GLubyte,
    ) {
        panic!("command oxidegl_vertex_attrib4_nub not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib4_nubv(&mut self, index: GLuint, v: *const GLubyte) {
        panic!("command oxidegl_vertex_attrib4_nubv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib4_nuiv(&mut self, index: GLuint, v: *const GLuint) {
        panic!("command oxidegl_vertex_attrib4_nuiv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib4_nusv(&mut self, index: GLuint, v: *const GLushort) {
        panic!("command oxidegl_vertex_attrib4_nusv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib4bv(&mut self, index: GLuint, v: *const GLbyte) {
        panic!("command oxidegl_vertex_attrib4bv not yet implemented");
    }
    pub fn oxidegl_vertex_attrib4d(
        &mut self,
        index: GLuint,
        x: GLdouble,
        y: GLdouble,
        z: GLdouble,
        w: GLdouble,
    ) {
        panic!("command oxidegl_vertex_attrib4d not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib4dv(&mut self, index: GLuint, v: *const GLdouble) {
        panic!("command oxidegl_vertex_attrib4dv not yet implemented");
    }
    pub fn oxidegl_vertex_attrib4f(
        &mut self,
        index: GLuint,
        x: GLfloat,
        y: GLfloat,
        z: GLfloat,
        w: GLfloat,
    ) {
        panic!("command oxidegl_vertex_attrib4f not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib4fv(&mut self, index: GLuint, v: *const GLfloat) {
        panic!("command oxidegl_vertex_attrib4fv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib4iv(&mut self, index: GLuint, v: *const GLint) {
        panic!("command oxidegl_vertex_attrib4iv not yet implemented");
    }
    pub fn oxidegl_vertex_attrib4s(
        &mut self,
        index: GLuint,
        x: GLshort,
        y: GLshort,
        z: GLshort,
        w: GLshort,
    ) {
        panic!("command oxidegl_vertex_attrib4s not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib4sv(&mut self, index: GLuint, v: *const GLshort) {
        panic!("command oxidegl_vertex_attrib4sv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib4ubv(&mut self, index: GLuint, v: *const GLubyte) {
        panic!("command oxidegl_vertex_attrib4ubv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib4uiv(&mut self, index: GLuint, v: *const GLuint) {
        panic!("command oxidegl_vertex_attrib4uiv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib4usv(&mut self, index: GLuint, v: *const GLushort) {
        panic!("command oxidegl_vertex_attrib4usv not yet implemented");
    }
    pub fn oxidegl_vertex_attrib_i1i(&mut self, index: GLuint, x: GLint) {
        panic!("command oxidegl_vertex_attrib_i1i not yet implemented");
    }
    pub fn oxidegl_vertex_attrib_i2i(&mut self, index: GLuint, x: GLint, y: GLint) {
        panic!("command oxidegl_vertex_attrib_i2i not yet implemented");
    }
    pub fn oxidegl_vertex_attrib_i3i(&mut self, index: GLuint, x: GLint, y: GLint, z: GLint) {
        panic!("command oxidegl_vertex_attrib_i3i not yet implemented");
    }
    pub fn oxidegl_vertex_attrib_i4i(
        &mut self,
        index: GLuint,
        x: GLint,
        y: GLint,
        z: GLint,
        w: GLint,
    ) {
        panic!("command oxidegl_vertex_attrib_i4i not yet implemented");
    }
    pub fn oxidegl_vertex_attrib_i1ui(&mut self, index: GLuint, x: GLuint) {
        panic!("command oxidegl_vertex_attrib_i1ui not yet implemented");
    }
    pub fn oxidegl_vertex_attrib_i2ui(&mut self, index: GLuint, x: GLuint, y: GLuint) {
        panic!("command oxidegl_vertex_attrib_i2ui not yet implemented");
    }
    pub fn oxidegl_vertex_attrib_i3ui(&mut self, index: GLuint, x: GLuint, y: GLuint, z: GLuint) {
        panic!("command oxidegl_vertex_attrib_i3ui not yet implemented");
    }
    pub fn oxidegl_vertex_attrib_i4ui(
        &mut self,
        index: GLuint,
        x: GLuint,
        y: GLuint,
        z: GLuint,
        w: GLuint,
    ) {
        panic!("command oxidegl_vertex_attrib_i4ui not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib_i1iv(&mut self, index: GLuint, v: *const GLint) {
        panic!("command oxidegl_vertex_attrib_i1iv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib_i2iv(&mut self, index: GLuint, v: *const GLint) {
        panic!("command oxidegl_vertex_attrib_i2iv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib_i3iv(&mut self, index: GLuint, v: *const GLint) {
        panic!("command oxidegl_vertex_attrib_i3iv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib_i4iv(&mut self, index: GLuint, v: *const GLint) {
        panic!("command oxidegl_vertex_attrib_i4iv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib_i1uiv(&mut self, index: GLuint, v: *const GLuint) {
        panic!("command oxidegl_vertex_attrib_i1uiv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib_i2uiv(&mut self, index: GLuint, v: *const GLuint) {
        panic!("command oxidegl_vertex_attrib_i2uiv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib_i3uiv(&mut self, index: GLuint, v: *const GLuint) {
        panic!("command oxidegl_vertex_attrib_i3uiv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib_i4uiv(&mut self, index: GLuint, v: *const GLuint) {
        panic!("command oxidegl_vertex_attrib_i4uiv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib_i4bv(&mut self, index: GLuint, v: *const GLbyte) {
        panic!("command oxidegl_vertex_attrib_i4bv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib_i4sv(&mut self, index: GLuint, v: *const GLshort) {
        panic!("command oxidegl_vertex_attrib_i4sv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib_i4ubv(&mut self, index: GLuint, v: *const GLubyte) {
        panic!("command oxidegl_vertex_attrib_i4ubv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib_i4usv(&mut self, index: GLuint, v: *const GLushort) {
        panic!("command oxidegl_vertex_attrib_i4usv not yet implemented");
    }
    pub fn oxidegl_vertex_attrib_p1ui(
        &mut self,
        index: GLuint,
        r#type: VertexAttribPointerType,
        normalized: GLboolean,
        value: GLuint,
    ) {
        panic!("command oxidegl_vertex_attrib_p1ui not yet implemented");
    }
    pub fn oxidegl_vertex_attrib_p2ui(
        &mut self,
        index: GLuint,
        r#type: VertexAttribPointerType,
        normalized: GLboolean,
        value: GLuint,
    ) {
        panic!("command oxidegl_vertex_attrib_p2ui not yet implemented");
    }
    pub fn oxidegl_vertex_attrib_p3ui(
        &mut self,
        index: GLuint,
        r#type: VertexAttribPointerType,
        normalized: GLboolean,
        value: GLuint,
    ) {
        panic!("command oxidegl_vertex_attrib_p3ui not yet implemented");
    }
    pub fn oxidegl_vertex_attrib_p4ui(
        &mut self,
        index: GLuint,
        r#type: VertexAttribPointerType,
        normalized: GLboolean,
        value: GLuint,
    ) {
        panic!("command oxidegl_vertex_attrib_p4ui not yet implemented");
    }
    pub fn oxidegl_vertex_attrib_l1d(&mut self, index: GLuint, x: GLdouble) {
        panic!("command oxidegl_vertex_attrib_l1d not yet implemented");
    }
    pub fn oxidegl_vertex_attrib_l2d(&mut self, index: GLuint, x: GLdouble, y: GLdouble) {
        panic!("command oxidegl_vertex_attrib_l2d not yet implemented");
    }
    pub fn oxidegl_vertex_attrib_l3d(
        &mut self,
        index: GLuint,
        x: GLdouble,
        y: GLdouble,
        z: GLdouble,
    ) {
        panic!("command oxidegl_vertex_attrib_l3d not yet implemented");
    }
    pub fn oxidegl_vertex_attrib_l4d(
        &mut self,
        index: GLuint,
        x: GLdouble,
        y: GLdouble,
        z: GLdouble,
        w: GLdouble,
    ) {
        panic!("command oxidegl_vertex_attrib_l4d not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib_l1dv(&mut self, index: GLuint, v: *const GLdouble) {
        panic!("command oxidegl_vertex_attrib_l1dv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib_l2dv(&mut self, index: GLuint, v: *const GLdouble) {
        panic!("command oxidegl_vertex_attrib_l2dv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib_l3dv(&mut self, index: GLuint, v: *const GLdouble) {
        panic!("command oxidegl_vertex_attrib_l3dv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib_l4dv(&mut self, index: GLuint, v: *const GLdouble) {
        panic!("command oxidegl_vertex_attrib_l4dv not yet implemented");
    }
}

/// ### Parameters
/// `index`
///
/// > Specify the first viewport to set.
///
/// `x`
///
/// `y`
///
/// > For [**glViewportIndexedf**](crate::context::Context::oxidegl_viewport_indexedf),
/// > specifies the lower left corner of the viewport rectangle, in pixels.
/// > The initial value is (0,0).
///
/// `w`
///
/// `h`
///
/// > For [**glViewportIndexedf**](crate::context::Context::oxidegl_viewport_indexedf),
/// > specifies the width and height of the viewport. When a GL context is first
/// > attached to a window, `w` and `h` are set to the dimensions of that window.
///
/// `v`
///
/// > For [**glViewportIndexedfv**](crate::context::Context::oxidegl_viewport_indexedfv),
/// > specifies the address of an array containing the viewport parameters.
///
/// ### Description
/// [**glViewportIndexedf**](crate::context::Context::oxidegl_viewport_indexedf)
/// and [**glViewportIndexedfv**](crate::context::Context::oxidegl_viewport_indexedfv)
/// specify the parameters for a single viewport. `index` specifies the index
/// of the viewport to modify. `index` must be less than the value of [`GL_MAX_VIEWPORTS`](crate::enums::GL_MAX_VIEWPORTS).
/// For [**glViewportIndexedf**](crate::context::Context::oxidegl_viewport_indexedf),
/// `x`, `y`, `w`, and `h` specify the left, bottom, width and height of the
/// viewport in pixels, respectively. For [**glViewportIndexedfv**](crate::context::Context::oxidegl_viewport_indexedfv),
/// `v` contains the address of an array of floating point values specifying
/// the left( `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]`
/// `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]`
///
///
///
/// The location of the viewport's bottom left corner, given by( `[inlineq]`
/// `[inlineq]` `[inlineq]` `[inlineq]` [**glGet**](crate::context::Context::oxidegl_get)
/// with argument [`GL_VIEWPORT_BOUNDS_RANGE`](crate::enums::GL_VIEWPORT_BOUNDS_RANGE).
/// Viewport width and height are silently clamped to a range that depends
/// on the implementation. To query this range, call [**glGet**](crate::context::Context::oxidegl_get)
/// with argument [`GL_MAX_VIEWPORT_DIMS`](crate::enums::GL_MAX_VIEWPORT_DIMS).
///
/// The precision with which the GL interprets the floating point viewport
/// bounds is implementation-dependent and may be determined by querying the
/// impementation-defined constant [`GL_VIEWPORT_SUBPIXEL_BITS`](crate::enums::GL_VIEWPORT_SUBPIXEL_BITS).
///
/// Calling [**glViewportIndexedfv**](crate::context::Context::oxidegl_viewport_indexedfv)
/// is equivalent to calling [**glViewportArray**](crate::context::Context::oxidegl_viewport_array)
/// with `first` set to `index`, `count` set to 1 and `v` passsed directly.
/// [**glViewportIndexedf**](crate::context::Context::oxidegl_viewport_indexedf)
/// is equivalent to:
///
/// ### Associated Gets
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_VIEWPORT`](crate::enums::GL_VIEWPORT)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_VIEWPORT_DIMS`](crate::enums::GL_MAX_VIEWPORT_DIMS)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_VIEWPORT_BOUNDS_RANGE`](crate::enums::GL_VIEWPORT_BOUNDS_RANGE)
///
/// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_VIEWPORT_SUBPIXEL_BITS`](crate::enums::GL_VIEWPORT_SUBPIXEL_BITS)
impl Context {
    pub fn oxidegl_viewport_indexedf(
        &mut self,
        index: GLuint,
        x: GLfloat,
        y: GLfloat,
        w: GLfloat,
        h: GLfloat,
    ) {
        panic!("command oxidegl_viewport_indexedf not yet implemented");
    }
    pub unsafe fn oxidegl_viewport_indexedfv(&mut self, index: GLuint, v: *const GLfloat) {
        panic!("command oxidegl_viewport_indexedfv not yet implemented");
    }
}
impl Context {
    /// ### Parameters
    /// `pipeline`
    ///
    /// > Specifies the program pipeline object to set the active program object
    /// > for.
    ///
    /// `program`
    ///
    /// > Specifies the program object to set as the active program pipeline object
    /// > `pipeline`.
    ///
    /// ### Description
    /// [**glActiveShaderProgram**](crate::context::Context::oxidegl_active_shader_program)
    /// sets the linked program named by `program` to be the active program for
    /// the program pipeline object `pipeline`. The active program in the active
    /// program pipeline object is the target of calls to [**glUniform**](crate::context::Context::oxidegl_uniform)
    /// when no program has been made current through a call to [**glUseProgram**](crate::context::Context::oxidegl_use_program).

    pub fn oxidegl_active_shader_program(&mut self, pipeline: GLuint, program: GLuint) {
        panic!("command oxidegl_active_shader_program not yet implemented");
    }
    /// ### Parameters
    /// `texture`
    ///
    /// > Specifies which texture unit to make active. The number of texture units
    /// > is implementation dependent, but must be at least 80. `texture` must be
    /// > one of [`GL_TEXTURE`](crate::enums::GL_TEXTURE) *i*, where *i* ranges from
    /// > zero to the value of [`GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS`](crate::enums::GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS)
    /// > minus one. The initial value is [`GL_TEXTURE0`](crate::enums::GL_TEXTURE0).
    ///
    /// ### Description
    /// [**glActiveTexture**](crate::context::Context::oxidegl_active_texture)
    /// selects which texture unit subsequent texture state calls will affect.
    /// The number of texture units an implementation supports is implementation
    /// dependent, but must be at least 80.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_ACTIVE_TEXTURE`](crate::enums::GL_ACTIVE_TEXTURE),
    /// or [`GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS`](crate::enums::GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS).

    pub fn oxidegl_active_texture(&mut self, texture: TextureUnit) {
        panic!("command oxidegl_active_texture not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the program object to which a shader object will be attached.
    ///
    /// `shader`
    ///
    /// > Specifies the shader object that is to be attached.
    ///
    /// ### Description
    /// In order to create a complete shader program, there must be a way to specify
    /// the list of things that will be linked together. Program objects provide
    /// this mechanism. Shaders that are to be linked together in a program object
    /// must first be attached to that program object. [**glAttachShader**](crate::context::Context::oxidegl_attach_shader)
    /// attaches the shader object specified by `shader` to the program object
    /// specified by `program`. This indicates that `shader` will be included in
    /// link operations that will be performed on `program`.
    ///
    /// All operations that can be performed on a shader object are valid whether
    /// or not the shader object is attached to a program object. It is permissible
    /// to attach a shader object to a program object before source code has been
    /// loaded into the shader object or before the shader object has been compiled.
    /// It is permissible to attach multiple shader objects of the same type because
    /// each may contain a portion of the complete shader. It is also permissible
    /// to attach a shader object to more than one program object. If a shader
    /// object is deleted while it is attached to a program object, it will be
    /// flagged for deletion, and deletion will not occur until [**glDetachShader**](crate::context::Context::oxidegl_detach_shader)
    /// is called to detach it from all program objects to which it is attached.
    ///
    /// ### Associated Gets
    /// [**glGetAttachedShaders**](crate::context::Context::oxidegl_get_attached_shaders)
    /// with the handle of a valid program object
    ///
    /// [**glGetShaderInfoLog**](crate::context::Context::oxidegl_get_shader_info_log)
    ///
    /// [**glGetShaderSource**](crate::context::Context::oxidegl_get_shader_source)
    ///
    /// [**glIsProgram**](crate::context::Context::oxidegl_is_program)
    ///
    /// [**glIsShader**](crate::context::Context::oxidegl_is_shader)

    pub fn oxidegl_attach_shader(&mut self, program: GLuint, shader: GLuint) {
        panic!("command oxidegl_attach_shader not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the handle of the program object in which the association is
    /// > to be made.
    ///
    /// `index`
    ///
    /// > Specifies the index of the generic vertex attribute to be bound.
    ///
    /// `name`
    ///
    /// > Specifies a null terminated string containing the name of the vertex shader
    /// > attribute variable to which `index` is to be bound.
    ///
    /// ### Description
    /// [**glBindAttribLocation**](crate::context::Context::oxidegl_bind_attrib_location)
    /// is used to associate a user-defined attribute variable in the program object
    /// specified by `program` with a generic vertex attribute index. The name
    /// of the user-defined attribute variable is passed as a null terminated string
    /// in `name`. The generic vertex attribute index to be bound to this variable
    /// is specified by `index`. When `program` is made part of current state,
    /// values provided via the generic vertex attribute `index` will modify the
    /// value of the user-defined attribute variable specified by `name`.
    ///
    /// If `name` refers to a matrix attribute variable, `index` refers to the
    /// first column of the matrix. Other matrix columns are then automatically
    /// bound to locations `index+1` for a matrix of type [**mat2**](crate::context::Context::oxidemat2);
    /// `index+1` and `index+2` for a matrix of type [**mat3**](crate::context::Context::oxidemat3);
    /// and `index+1`, `index+2`, and `index+3` for a matrix of type [**mat4**](crate::context::Context::oxidemat4).
    ///
    /// This command makes it possible for vertex shaders to use descriptive names
    /// for attribute variables rather than generic variables that are numbered
    /// from zero to the value of [`GL_MAX_VERTEX_ATTRIBS`](crate::enums::GL_MAX_VERTEX_ATTRIBS)
    /// minus one. The values sent to each generic attribute index are part of
    /// current state. If a different program object is made current by calling
    /// [**glUseProgram**](crate::context::Context::oxidegl_use_program), the generic
    /// vertex attributes are tracked in such a way that the same values will be
    /// observed by attributes in the new program object that are also bound to
    /// `index`.
    ///
    /// Attribute variable name-to-generic attribute index bindings for a program
    /// object can be explicitly assigned at any time by calling [**glBindAttribLocation**](crate::context::Context::oxidegl_bind_attrib_location).
    /// Attribute bindings do not go into effect until [**glLinkProgram**](crate::context::Context::oxidegl_link_program)
    /// is called. After a program object has been linked successfully, the index
    /// values for generic attributes remain fixed (and their values can be queried)
    /// until the next link command occurs.
    ///
    /// Any attribute binding that occurs after the program object has been linked
    /// will not take effect until the next time the program object is linked.
    ///
    /// ### Notes
    /// [**glBindAttribLocation**](crate::context::Context::oxidegl_bind_attrib_location)
    /// can be called before any vertex shader objects are bound to the specified
    /// program object. It is also permissible to bind a generic attribute index
    /// to an attribute variable name that is never used in a vertex shader.
    ///
    /// If `name` was bound previously, that information is lost. Thus you cannot
    /// bind one user-defined attribute variable to multiple indices, but you can
    /// bind multiple user-defined attribute variables to the same index.
    ///
    /// Applications are allowed to bind more than one user-defined attribute variable
    /// to the same generic vertex attribute index. This is called *aliasing*, and
    /// it is allowed only if just one of the aliased attributes is active in the
    /// executable program, or if no path through the shader consumes more than
    /// one attribute of a set of attributes aliased to the same location. The
    /// compiler and linker are allowed to assume that no aliasing is done and
    /// are free to employ optimizations that work only in the absence of aliasing.
    /// OpenGL implementations are not required to do error checking to detect
    /// aliasing.
    ///
    /// Active attributes that are not explicitly bound will be bound by the linker
    /// when [**glLinkProgram**](crate::context::Context::oxidegl_link_program)
    /// is called. The locations assigned can be queried by calling [**glGetAttribLocation**](crate::context::Context::oxidegl_get_attrib_location).
    ///
    /// OpenGL copies the `name` string when [**glBindAttribLocation**](crate::context::Context::oxidegl_bind_attrib_location)
    /// is called, so an application may free its copy of the `name` string immediately
    /// after the function returns.
    ///
    /// Generic attribute locations may be specified in the shader source text
    /// using a [**location**](crate::context::Context::oxidelocation) layout qualifier.
    /// In this case, the location of the attribute specified in the shader's source
    /// takes precedence and may be queried by calling [**glGetAttribLocation**](crate::context::Context::oxidegl_get_attrib_location).
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_VERTEX_ATTRIBS`](crate::enums::GL_MAX_VERTEX_ATTRIBS)
    ///
    /// [**glGetActiveAttrib**](crate::context::Context::oxidegl_get_active_attrib)
    /// with argument `program`
    ///
    /// [**glGetAttribLocation**](crate::context::Context::oxidegl_get_attrib_location)
    /// with arguments `program` and `name`
    ///
    /// [**glIsProgram**](crate::context::Context::oxidegl_is_program)

    pub unsafe fn oxidegl_bind_attrib_location(
        &mut self,
        program: GLuint,
        index: GLuint,
        name: *const GLchar,
    ) {
        panic!("command oxidegl_bind_attrib_location not yet implemented");
    }
    /// ### Parameters
    /// `target`
    ///
    /// > Specify the target of the bind operation. `target` must be one of [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER),
    /// > [`GL_TRANSFORM_FEEDBACK_BUFFER`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER),
    /// > [`GL_UNIFORM_BUFFER`](crate::enums::GL_UNIFORM_BUFFER) or [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER).
    ///
    /// `index`
    ///
    /// > Specify the index of the binding point within the array specified by `target`.
    ///
    /// `buffer`
    ///
    /// > The name of a buffer object to bind to the specified binding point.
    ///
    /// ### Description
    /// [**glBindBufferBase**](crate::context::Context::oxidegl_bind_buffer_base)
    /// binds the buffer object `buffer` to the binding point at index `index`
    /// of the array of targets specified by `target`. Each `target` represents
    /// an indexed array of buffer binding points, as well as a single general
    /// binding point that can be used by other buffer manipulation functions such
    /// as [**glBindBuffer**](crate::context::Context::oxidegl_bind_buffer) or
    /// [**glMapBuffer**](crate::context::Context::oxidegl_map_buffer). In addition
    /// to binding `buffer` to the indexed buffer binding target, [**glBindBufferBase**](crate::context::Context::oxidegl_bind_buffer_base)
    /// also binds `buffer` to the generic buffer binding point specified by `target`.
    ///
    /// ### Notes
    /// Calling [**glBindBufferBase**](crate::context::Context::oxidegl_bind_buffer_base)
    /// is equivalent to calling [**glBindBufferRange**](crate::context::Context::oxidegl_bind_buffer_range)
    /// with `offset` zero and `size` equal to the size of the buffer.
    ///
    /// The [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER)
    /// target is available only if the GL version is 4.2 or greater.
    ///
    /// The [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER)
    /// target is available only if the GL version is 4.3 or greater.

    pub fn oxidegl_bind_buffer_base(
        &mut self,
        target: BufferTarget,
        index: GLuint,
        buffer: GLuint,
    ) {
        panic!("command oxidegl_bind_buffer_base not yet implemented");
    }
    /// ### Parameters
    /// `target`
    ///
    /// > Specify the target of the bind operation. `target` must be one of [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER),
    /// > [`GL_TRANSFORM_FEEDBACK_BUFFER`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER),
    /// > [`GL_UNIFORM_BUFFER`](crate::enums::GL_UNIFORM_BUFFER), or [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER).
    ///
    /// `index`
    ///
    /// > Specify the index of the binding point within the array specified by `target`.
    ///
    /// `buffer`
    ///
    /// > The name of a buffer object to bind to the specified binding point.
    ///
    /// `offset`
    ///
    /// > The starting offset in basic machine units into the buffer object `buffer`.
    ///
    /// `size`
    ///
    /// > The amount of data in machine units that can be read from the buffer object
    /// > while used as an indexed target.
    ///
    /// ### Description
    /// [**glBindBufferRange**](crate::context::Context::oxidegl_bind_buffer_range)
    /// binds a range the buffer object `buffer` represented by `offset` and `size`
    /// to the binding point at index `index` of the array of targets specified
    /// by `target`. Each `target` represents an indexed array of buffer binding
    /// points, as well as a single general binding point that can be used by other
    /// buffer manipulation functions such as [**glBindBuffer**](crate::context::Context::oxidegl_bind_buffer)
    /// or [**glMapBuffer**](crate::context::Context::oxidegl_map_buffer). In addition
    /// to binding a range of `buffer` to the indexed buffer binding target, [**glBindBufferRange**](crate::context::Context::oxidegl_bind_buffer_range)
    /// also binds the range to the generic buffer binding point specified by `target`.
    ///
    /// `offset` specifies the offset in basic machine units into the buffer object
    /// `buffer` and `size` specifies the amount of data that can be read from
    /// the buffer object while used as an indexed target.
    ///
    /// ### Notes
    /// The [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER)
    /// target is available only if the GL version is 4.2 or greater.
    ///
    /// The [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER)
    /// target is available only if the GL version is 4.3 or greater.

    pub fn oxidegl_bind_buffer_range(
        &mut self,
        target: BufferTarget,
        index: GLuint,
        buffer: GLuint,
        offset: GLintptr,
        size: GLsizeiptr,
    ) {
        panic!("command oxidegl_bind_buffer_range not yet implemented");
    }
    /// ### Parameters
    /// `target`
    ///
    /// > Specify the target of the bind operation. `target` must be one of [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER),
    /// > [`GL_TRANSFORM_FEEDBACK_BUFFER`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER),
    /// > [`GL_UNIFORM_BUFFER`](crate::enums::GL_UNIFORM_BUFFER) or [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER).
    ///
    /// `first`
    ///
    /// > Specify the index of the first binding point within the array specified
    /// > by `target`.
    ///
    /// `count`
    ///
    /// > Specify the number of contiguous binding points to which to bind buffers.
    ///
    /// `buffers`
    ///
    /// > A pointer to an array of names of buffer objects to bind to the targets
    /// > on the specified binding point, or [`NULL`](crate::enums::NULL).
    ///
    /// ### Description
    /// [**glBindBuffersBase**](crate::context::Context::oxidegl_bind_buffers_base)
    /// binds a set of `count` buffer objects whose names are given in the array
    /// `buffers` to the `count` consecutive binding points starting from index
    /// `first` of the array of targets specified by `target`. If `buffers` is
    /// [`NULL`](crate::enums::NULL) then [**glBindBuffersBase**](crate::context::Context::oxidegl_bind_buffers_base)
    /// unbinds any buffers that are currently bound to the referenced binding
    /// points. Assuming no errors are generated, it is equivalent to the following
    /// pseudo-code, which calls [**glBindBufferBase**](crate::context::Context::oxidegl_bind_buffer_base),
    /// with the exception that the non-indexed `target` is not changed by [**glBindBuffersBase**](crate::context::Context::oxidegl_bind_buffers_base):
    ///
    /// Each entry in `buffers` will be checked individually and if found to be
    /// invalid, the state for that buffer binding index will not be changed and
    /// an error will be generated. However, the state for other buffer binding
    /// indices referenced by the command will still be updated.
    ///
    /// ### Notes
    /// [**glBindBuffersBase**](crate::context::Context::oxidegl_bind_buffers_base)
    /// is available only if the GL version is 4.4 or higher.

    pub unsafe fn oxidegl_bind_buffers_base(
        &mut self,
        target: BufferTarget,
        first: GLuint,
        count: GLsizei,
        buffers: *const GLuint,
    ) {
        panic!("command oxidegl_bind_buffers_base not yet implemented");
    }
    /// ### Parameters
    /// `target`
    ///
    /// > Specify the target of the bind operation. `target` must be one of [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER),
    /// > [`GL_TRANSFORM_FEEDBACK_BUFFER`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER),
    /// > [`GL_UNIFORM_BUFFER`](crate::enums::GL_UNIFORM_BUFFER) or [`GL_SHADER_STORAGE_BUFFER`](crate::enums::GL_SHADER_STORAGE_BUFFER).
    ///
    /// `first`
    ///
    /// > Specify the index of the first binding point within the array specified
    /// > by `target`.
    ///
    /// `count`
    ///
    /// > Specify the number of contiguous binding points to which to bind buffers.
    ///
    /// `buffers`
    ///
    /// > A pointer to an array of names of buffer objects to bind to the targets
    /// > on the specified binding point, or [`NULL`](crate::enums::NULL).
    ///
    /// `offsets`
    ///
    /// > A pointer to an array of offsets into the corresponding buffer in `buffers`
    /// > to bind, or [`NULL`](crate::enums::NULL) if `buffers` is [`NULL`](crate::enums::NULL).
    ///
    /// `sizes`
    ///
    /// > A pointer to an array of sizes of the corresponding buffer in `buffers`
    /// > to bind, or [`NULL`](crate::enums::NULL) if `buffers` is [`NULL`](crate::enums::NULL).
    ///
    /// ### Description
    /// [**glBindBuffersRange**](crate::context::Context::oxidegl_bind_buffers_range)
    /// binds a set of `count` ranges from buffer objects whose names are given
    /// in the array `buffers` to the `count` consecutive binding points starting
    /// from index `first` of the array of targets specified by `target`. `offsets`
    /// specifies the address of an array containing `count` starting offsets within
    /// the buffers, and `sizes` specifies the address of an array of `count` sizes
    /// of the ranges. If `buffers` is [`NULL`](crate::enums::NULL) then `offsets`
    /// and `sizes` are ignored and [**glBindBuffersRange**](crate::context::Context::oxidegl_bind_buffers_range)
    /// unbinds any buffers that are currently bound to the referenced binding
    /// points. Assuming no errors are generated, it is equivalent to the following
    /// pseudo-code, which calls [**glBindBufferRange**](crate::context::Context::oxidegl_bind_buffer_range),
    /// with the exception that the non-indexed `target` is not changed by [**glBindBuffersRange**](crate::context::Context::oxidegl_bind_buffers_range):
    ///
    /// Each entry in `buffers`, `offsets`, and `sizes` will be checked individually
    /// and if found to be invalid, the state for that buffer binding index will
    /// not be changed and an error will be generated. However, the state for other
    /// buffer binding indices referenced by the command will still be updated.
    ///
    /// ### Notes
    /// [**glBindBuffersBase**](crate::context::Context::oxidegl_bind_buffers_base)
    /// is available only if the GL version is 4.4 or higher.

    pub unsafe fn oxidegl_bind_buffers_range(
        &mut self,
        target: BufferTarget,
        first: GLuint,
        count: GLsizei,
        buffers: *const GLuint,
        offsets: *const GLintptr,
        sizes: *const GLsizeiptr,
    ) {
        panic!("command oxidegl_bind_buffers_range not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > The name of the program containing varying out variable whose binding to
    /// > modify
    ///
    /// `colorNumber`
    ///
    /// > The color number to bind the user-defined varying out variable to
    ///
    /// `name`
    ///
    /// > The name of the user-defined varying out variable whose binding to modify
    ///
    /// ### Description
    /// [**glBindFragDataLocation**](crate::context::Context::oxidegl_bind_frag_data_location)
    /// explicitly specifies the binding of the user-defined varying out variable
    /// `name` to fragment shader color number `colorNumber` for program `program`.
    /// If `name` was bound previously, its assigned binding is replaced with
    /// `colorNumber`. `name` must be a null-terminated string. `colorNumber` must
    /// be less than [`GL_MAX_DRAW_BUFFERS`](crate::enums::GL_MAX_DRAW_BUFFERS).
    ///
    /// The bindings specified by [**glBindFragDataLocation**](crate::context::Context::oxidegl_bind_frag_data_location)
    /// have no effect until `program` is next linked. Bindings may be specified
    /// at any time after `program` has been created. Specifically, they may be
    /// specified before shader objects are attached to the program. Therefore,
    /// any name may be specified in `name`, including a name that is never used
    /// as a varying out variable in any fragment shader object. Names beginning
    /// with [`gl_`](crate::enums::gl_) are reserved by the GL.
    ///
    /// In addition to the errors generated by [**glBindFragDataLocation**](crate::context::Context::oxidegl_bind_frag_data_location),
    /// the program `program` will fail to link if: The number of active outputs
    /// > is greater than the value [`GL_MAX_DRAW_BUFFERS`](crate::enums::GL_MAX_DRAW_BUFFERS).
    ///
    /// > More than one varying out variable is bound to the same color number.
    ///
    ///
    /// ### Notes
    /// Varying out varyings may have indexed locations assigned explicitly in
    /// the shader text using a [**glBindFragDataLocation**](crate::context::Context::oxidegl_bind_frag_data_location)
    /// is ignored.
    ///
    /// ### Associated Gets
    /// [**glGetFragDataLocation**](crate::context::Context::oxidegl_get_frag_data_location)
    /// with a valid program object and the name of a user-defined varying out
    /// variable

    pub unsafe fn oxidegl_bind_frag_data_location(
        &mut self,
        program: GLuint,
        color: GLuint,
        name: *const GLchar,
    ) {
        panic!("command oxidegl_bind_frag_data_location not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > The name of the program containing varying out variable whose binding to
    /// > modify
    ///
    /// `colorNumber`
    ///
    /// > The color number to bind the user-defined varying out variable to
    ///
    /// `index`
    ///
    /// > The index of the color input to bind the user-defined varying out variable
    /// > to
    ///
    /// `name`
    ///
    /// > The name of the user-defined varying out variable whose binding to modify
    ///
    /// ### Description
    /// [**glBindFragDataLocationIndexed**](crate::context::Context::oxidegl_bind_frag_data_location_indexed)
    /// specifies that the varying out variable `name` in `program` should be bound
    /// to fragment color `colorNumber` when the program is next linked. `index`
    /// may be zero or one to specify that the color be used as either the first
    /// or second color input to the blend equation, respectively.
    ///
    /// The bindings specified by [**glBindFragDataLocationIndexed**](crate::context::Context::oxidegl_bind_frag_data_location_indexed)
    /// have no effect until `program` is next linked. Bindings may be specified
    /// at any time after `program` has been created. Specifically, they may be
    /// specified before shader objects are attached to the program. Therefore,
    /// any name may be specified in `name`, including a name that is never used
    /// as a varying out variable in any fragment shader object. Names beginning
    /// with [`gl_`](crate::enums::gl_) are reserved by the GL.
    ///
    /// If `name` was bound previously, its assigned binding is replaced with `colorNumber`
    /// and `index`. `name` must be a null-terminated string. `index` must be less
    /// than or equal to one, and `colorNumber` must be less than the value of
    /// [`GL_MAX_DRAW_BUFFERS`](crate::enums::GL_MAX_DRAW_BUFFERS) if `index` is
    /// zero, and less than the value of [`GL_MAX_DUAL_SOURCE_DRAW_BUFFERS`](crate::enums::GL_MAX_DUAL_SOURCE_DRAW_BUFFERS)
    /// if index is greater than or equal to one.
    ///
    /// In addition to the errors generated by [**glBindFragDataLocationIndexed**](crate::context::Context::oxidegl_bind_frag_data_location_indexed),
    /// the program `program` will fail to link if: The number of active outputs
    /// > is greater than the value [`GL_MAX_DRAW_BUFFERS`](crate::enums::GL_MAX_DRAW_BUFFERS).
    ///
    /// > More than one varying out variable is bound to the same color number.
    ///
    ///
    /// ### Notes
    /// Varying out varyings may have locations assigned explicitly in the shader
    /// text using a [**glBindFragDataLocation**](crate::context::Context::oxidegl_bind_frag_data_location)
    /// is ignored.
    ///
    /// ### Associated Gets
    /// [**glGetFragDataLocation**](crate::context::Context::oxidegl_get_frag_data_location)
    /// with a valid program object and the name of a user-defined varying out
    /// variable
    ///
    /// [**glGetFragDataIndex**](crate::context::Context::oxidegl_get_frag_data_index)
    /// with a valid program object and the name of a user-defined varying out
    /// variable

    pub unsafe fn oxidegl_bind_frag_data_location_indexed(
        &mut self,
        program: GLuint,
        color_number: GLuint,
        index: GLuint,
        name: *const GLchar,
    ) {
        panic!("command oxidegl_bind_frag_data_location_indexed not yet implemented");
    }
    /// ### Parameters
    /// `target`
    ///
    /// > Specifies the framebuffer target of the binding operation.
    ///
    /// `framebuffer`
    ///
    /// > Specifies the name of the framebuffer object to bind.
    ///
    /// ### Description
    /// [**glBindFramebuffer**](crate::context::Context::oxidegl_bind_framebuffer)
    /// binds the framebuffer object with name `framebuffer` to the framebuffer
    /// target specified by `target`. `target` must be either [`GL_DRAW_FRAMEBUFFER`](crate::enums::GL_DRAW_FRAMEBUFFER),
    /// [`GL_READ_FRAMEBUFFER`](crate::enums::GL_READ_FRAMEBUFFER) or [`GL_FRAMEBUFFER`](crate::enums::GL_FRAMEBUFFER).
    /// If a framebuffer object is bound to [`GL_DRAW_FRAMEBUFFER`](crate::enums::GL_DRAW_FRAMEBUFFER)
    /// or [`GL_READ_FRAMEBUFFER`](crate::enums::GL_READ_FRAMEBUFFER), it becomes
    /// the target for rendering or readback operations, respectively, until it
    /// is deleted or another framebuffer is bound to the corresponding bind point.
    /// Calling [**glBindFramebuffer**](crate::context::Context::oxidegl_bind_framebuffer)
    /// with `target` set to [`GL_FRAMEBUFFER`](crate::enums::GL_FRAMEBUFFER) binds
    /// `framebuffer` to both the read and draw framebuffer targets. `framebuffer`
    /// is the name of a framebuffer object previously returned from a call to
    /// [**glGenFramebuffers**](crate::context::Context::oxidegl_gen_framebuffers),
    /// or zero to break the existing binding of a framebuffer object to `target`.

    pub fn oxidegl_bind_framebuffer(&mut self, target: FramebufferTarget, framebuffer: GLuint) {
        panic!("command oxidegl_bind_framebuffer not yet implemented");
    }
    /// ### Parameters
    /// `unit`
    ///
    /// > Specifies the index of the image unit to which to bind the texture
    ///
    /// `texture`
    ///
    /// > Specifies the name of the texture to bind to the image unit.
    ///
    /// `level`
    ///
    /// > Specifies the level of the texture that is to be bound.
    ///
    /// `layered`
    ///
    /// > Specifies whether a layered texture binding is to be established.
    ///
    /// `layer`
    ///
    /// > If `layered` is [`GL_FALSE`](crate::enums::GL_FALSE), specifies the layer
    /// > of `texture` to be bound to the image unit. Ignored otherwise.
    ///
    /// `access`
    ///
    /// > Specifies a token indicating the type of access that will be performed
    /// > on the image.
    ///
    /// `format`
    ///
    /// > Specifies the format that the elements of the image will be treated as
    /// > for the purposes of formatted stores.
    ///
    /// ### Description
    /// [**glBindImageTexture**](crate::context::Context::oxidegl_bind_image_texture)
    /// binds a single level of a texture to an image unit for the purpose of reading
    /// and writing it from shaders. `unit` specifies the zero-based index of the
    /// image unit to which to bind the texture level. `texture` specifies the
    /// name of an existing texture object to bind to the image unit. If `texture`
    /// is zero, then any existing binding to the image unit is broken. `level`
    /// specifies the level of the texture to bind to the image unit.
    ///
    /// If `texture` is the name of a one-, two-, or three-dimensional array texture,
    /// a cube map or cube map array texture, or a two-dimensional multisample
    /// array texture, then it is possible to bind either the entire array, or
    /// only a single layer of the array to the image unit. In such cases, if `layered`
    /// is [`GL_TRUE`](crate::enums::GL_TRUE), the entire array is attached to
    /// the image unit and `layer` is ignored. However, if `layered` is [`GL_FALSE`](crate::enums::GL_FALSE)
    /// then `layer` specifies the layer of the array to attach to the image unit.
    ///
    /// `access` specifies the access types to be performed by shaders and may
    /// be set to [`GL_READ_ONLY`](crate::enums::GL_READ_ONLY), [`GL_WRITE_ONLY`](crate::enums::GL_WRITE_ONLY),
    /// or [`GL_READ_WRITE`](crate::enums::GL_READ_WRITE) to indicate read-only,
    /// write-only or read-write access, respectively. Violation of the access
    /// type specified in `access` (for example, if a shader writes to an image
    /// bound with `access` set to [`GL_READ_ONLY`](crate::enums::GL_READ_ONLY))
    /// will lead to undefined results, possibly including program termination.
    ///
    /// `format` specifies the format that is to be used when performing formatted
    /// stores into the image from shaders. `format` must be compatible with the
    /// texture's internal format and must be one of the formats listed in the
    /// following table.
    ///
    /// |* Image Unit Format*                             |* Format Qualifier*                             |
    /// |-------------------------------------------------|------------------------------------------------|
    /// | [`GL_RGBA32F`](crate::enums::GL_RGBA32F)        |                                                |
    /// | [`GL_RGBA16F`](crate::enums::GL_RGBA16F)        |                                                |
    /// | [`GL_RG32F`](crate::enums::GL_RG32F)            |                                                |
    /// | [`GL_RG16F`](crate::enums::GL_RG16F)            |                                                |
    /// | [`GL_R11F_G11F_B10F`](crate::enums::GL_R11F_G11F_B10F) |                                         |
    /// | [`GL_R32F`](crate::enums::GL_R32F)              |                                                |
    /// | [`GL_R16F`](crate::enums::GL_R16F)              |                                                |
    /// | [`GL_RGBA32UI`](crate::enums::GL_RGBA32UI)      |                                                |
    /// | [`GL_RGBA16UI`](crate::enums::GL_RGBA16UI)      |                                                |
    /// | [`GL_RGB10_A2UI`](crate::enums::GL_RGB10_A2UI)  |                                                |
    /// | [`GL_RGBA8UI`](crate::enums::GL_RGBA8UI)        |                                                |
    /// | [`GL_RG32UI`](crate::enums::GL_RG32UI)          |                                                |
    /// | [`GL_RG16UI`](crate::enums::GL_RG16UI)          |                                                |
    /// | [`GL_RG8UI`](crate::enums::GL_RG8UI)            |                                                |
    /// | [`GL_R32UI`](crate::enums::GL_R32UI)            |                                                |
    /// | [`GL_R16UI`](crate::enums::GL_R16UI)            |                                                |
    /// | [`GL_R8UI`](crate::enums::GL_R8UI)              |                                                |
    /// | [`GL_RGBA32I`](crate::enums::GL_RGBA32I)        |                                                |
    /// | [`GL_RGBA16I`](crate::enums::GL_RGBA16I)        |                                                |
    /// | [`GL_RGBA8I`](crate::enums::GL_RGBA8I)          |                                                |
    /// | [`GL_RG32I`](crate::enums::GL_RG32I)            |                                                |
    /// | [`GL_RG16I`](crate::enums::GL_RG16I)            |                                                |
    /// | [`GL_RG8I`](crate::enums::GL_RG8I)              |                                                |
    /// | [`GL_R32I`](crate::enums::GL_R32I)              |                                                |
    /// | [`GL_R16I`](crate::enums::GL_R16I)              |                                                |
    /// | [`GL_R8I`](crate::enums::GL_R8I)                |                                                |
    /// | [`GL_RGBA16`](crate::enums::GL_RGBA16)          |                                                |
    /// | [`GL_RGB10_A2`](crate::enums::GL_RGB10_A2)      |                                                |
    /// | [`GL_RGBA8`](crate::enums::GL_RGBA8)            |                                                |
    /// | [`GL_RG16`](crate::enums::GL_RG16)              |                                                |
    /// | [`GL_RG8`](crate::enums::GL_RG8)                |                                                |
    /// | [`GL_R16`](crate::enums::GL_R16)                |                                                |
    /// | [`GL_R8`](crate::enums::GL_R8)                  |                                                |
    /// | [`GL_RGBA16_SNORM`](crate::enums::GL_RGBA16_SNORM) |                                             |
    /// | [`GL_RGBA8_SNORM`](crate::enums::GL_RGBA8_SNORM) |                                               |
    /// | [`GL_RG16_SNORM`](crate::enums::GL_RG16_SNORM)  |                                                |
    /// | [`GL_RG8_SNORM`](crate::enums::GL_RG8_SNORM)    |                                                |
    /// | [`GL_R16_SNORM`](crate::enums::GL_R16_SNORM)    |                                                |
    /// | [`GL_R8_SNORM`](crate::enums::GL_R8_SNORM)      |                                                |
    ///
    ///
    /// When a texture is bound to an image unit, the `format` parameter for the
    /// image unit need not exactly match the texture internal format as long as
    /// the formats are considered compatible as defined in the OpenGL Specification.
    /// The matching criterion used for a given texture may be determined by calling
    /// [**glGetTexParameter**](crate::context::Context::oxidegl_get_tex_parameter)
    /// with `value` set to [`GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`](crate::enums::GL_IMAGE_FORMAT_COMPATIBILITY_TYPE),
    /// with return values of [`GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE`](crate::enums::GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE)
    /// and [`GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS`](crate::enums::GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS),
    /// specifying matches by size and class, respectively.
    ///
    /// ### Notes
    /// The [**glBindImageTexture**](crate::context::Context::oxidegl_bind_image_texture)
    /// is available only if the GL version is 4.2 or greater.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_IMAGE_BINDING_NAME`](crate::enums::GL_IMAGE_BINDING_NAME).
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_IMAGE_BINDING_LEVEL`](crate::enums::GL_IMAGE_BINDING_LEVEL).
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_IMAGE_BINDING_LAYERED`](crate::enums::GL_IMAGE_BINDING_LAYERED).
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_IMAGE_BINDING_LAYER`](crate::enums::GL_IMAGE_BINDING_LAYER).
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_IMAGE_BINDING_ACCESS`](crate::enums::GL_IMAGE_BINDING_ACCESS).
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_IMAGE_BINDING_FORMAT`](crate::enums::GL_IMAGE_BINDING_FORMAT).

    pub fn oxidegl_bind_image_texture(
        &mut self,
        unit: GLuint,
        texture: GLuint,
        level: GLint,
        layered: GLboolean,
        layer: GLint,
        access: BufferAccess,
        format: InternalFormat,
    ) {
        panic!("command oxidegl_bind_image_texture not yet implemented");
    }
    /// ### Parameters
    /// `first`
    ///
    /// > Specifies the first image unit to which a texture is to be bound.
    ///
    /// `count`
    ///
    /// > Specifies the number of textures to bind.
    ///
    /// `textures`
    ///
    /// > Specifies the address of an array of names of existing texture objects.
    ///
    /// ### Description
    /// [**glBindImageTextures**](crate::context::Context::oxidegl_bind_image_textures)
    /// binds images from an array of existing texture objects to a specified number
    /// of consecutive image units. `count` specifies the number of texture objects
    /// whose names are stored in the array `textures`. That number of texture
    /// names are read from the array and bound to the `count` consecutive texture
    /// units starting from `first`. If the name zero appears in the `textures`
    /// array, any existing binding to the image unit is reset. Any non-zero entry
    /// in `textures` must be the name of an existing texture object. When a non-zero
    /// entry in `textures` is present, the image at level zero is bound, the binding
    /// is considered layered, with the first layer set to zero, and the image
    /// is bound for read-write access. The image unit format parameter is taken
    /// from the internal format of the image at level zero of the texture object.
    /// For cube map textures, the internal format of the positive X image of level
    /// zero is used. If `textures` is [`NULL`](crate::enums::NULL) then it is
    /// as if an appropriately sized array containing only zeros had been specified.
    ///
    /// [**glBindImageTextures**](crate::context::Context::oxidegl_bind_image_textures)
    /// is equivalent to the following pseudo code:
    ///
    /// Each entry in `textures` will be checked individually and if found to be
    /// invalid, the state for that image unit will not be changed and an error
    /// will be generated. However, the state for other texture image units referenced
    /// by the command will still be updated.
    ///
    /// ### Notes
    /// [**glBindImageTextures**](crate::context::Context::oxidegl_bind_image_textures)
    /// is available only if the GL version is 4.4 or higher.
    ///
    /// Note that because [**glBindImageTextures**](crate::context::Context::oxidegl_bind_image_textures)
    /// cannot create new textures (even if a name passed has been previously generated
    /// by call to [**glGenTextures**](crate::context::Context::oxidegl_gen_textures)
    /// ), names passed to [**glBindImageTextures**](crate::context::Context::oxidegl_bind_image_textures)
    /// must have been bound at least once previously via a call to [**glBindTexture**](crate::context::Context::oxidegl_bind_texture).
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_TEXTURE_BINDING_1D`](crate::enums::GL_TEXTURE_BINDING_1D),
    /// [`GL_TEXTURE_BINDING_2D`](crate::enums::GL_TEXTURE_BINDING_2D), [`GL_TEXTURE_BINDING_3D`](crate::enums::GL_TEXTURE_BINDING_3D),
    /// [`GL_TEXTURE_BINDING_1D_ARRAY`](crate::enums::GL_TEXTURE_BINDING_1D_ARRAY),
    /// [`GL_TEXTURE_BINDING_2D_ARRAY`](crate::enums::GL_TEXTURE_BINDING_2D_ARRAY),
    /// [`GL_TEXTURE_BINDING_RECTANGLE`](crate::enums::GL_TEXTURE_BINDING_RECTANGLE),
    /// [`GL_TEXTURE_BINDING_BUFFER`](crate::enums::GL_TEXTURE_BINDING_BUFFER),
    /// [`GL_TEXTURE_BINDING_CUBE_MAP`](crate::enums::GL_TEXTURE_BINDING_CUBE_MAP),
    /// [`GL_TEXTURE_BINDING_CUBE_MAP`](crate::enums::GL_TEXTURE_BINDING_CUBE_MAP),
    /// [`GL_TEXTURE_BINDING_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_BINDING_CUBE_MAP_ARRAY),
    /// [`GL_TEXTURE_BINDING_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_BINDING_2D_MULTISAMPLE),
    /// or [`GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY).

    pub unsafe fn oxidegl_bind_image_textures(
        &mut self,
        first: GLuint,
        count: GLsizei,
        textures: *const GLuint,
    ) {
        panic!("command oxidegl_bind_image_textures not yet implemented");
    }
    /// ### Parameters
    /// `pipeline`
    ///
    /// > Specifies the name of the pipeline object to bind to the context.
    ///
    /// ### Description
    /// [**glBindProgramPipeline**](crate::context::Context::oxidegl_bind_program_pipeline)
    /// binds a program pipeline object to the current context. `pipeline` must
    /// be a name previously returned from a call to [**glGenProgramPipelines**](crate::context::Context::oxidegl_gen_program_pipelines).
    /// If no program pipeline exists with name `pipeline` then a new pipeline
    /// object is created with that name and initialized to the default state vector.
    ///
    /// When a program pipeline object is bound using [**glBindProgramPipeline**](crate::context::Context::oxidegl_bind_program_pipeline),
    /// any previous binding is broken and is replaced with a binding to the specified
    /// pipeline object. If `pipeline` is zero, the previous binding is broken
    /// and is not replaced, leaving no pipeline object bound. If no current program
    /// object has been established by [**glUseProgram**](crate::context::Context::oxidegl_use_program),
    /// the program objects used for each stage and for uniform updates are taken
    /// from the bound program pipeline object, if any. If there is a current program
    /// object established by [**glUseProgram**](crate::context::Context::oxidegl_use_program),
    /// the bound program pipeline object has no effect on rendering or uniform
    /// updates. When a bound program pipeline object is used for rendering, individual
    /// shader executables are taken from its program objects.

    pub fn oxidegl_bind_program_pipeline(&mut self, pipeline: GLuint) {
        panic!("command oxidegl_bind_program_pipeline not yet implemented");
    }
    /// ### Parameters
    /// `target`
    ///
    /// > Specifies the renderbuffer target of the binding operation. `target` must
    /// > be [`GL_RENDERBUFFER`](crate::enums::GL_RENDERBUFFER).
    ///
    /// `renderbuffer`
    ///
    /// > Specifies the name of the renderbuffer object to bind.
    ///
    /// ### Description
    /// [**glBindRenderbuffer**](crate::context::Context::oxidegl_bind_renderbuffer)
    /// binds the renderbuffer object with name `renderbuffer` to the renderbuffer
    /// target specified by `target`. `target` must be [`GL_RENDERBUFFER`](crate::enums::GL_RENDERBUFFER).
    /// `renderbuffer` is the name of a renderbuffer object previously returned
    /// from a call to [**glGenRenderbuffers**](crate::context::Context::oxidegl_gen_renderbuffers),
    /// or zero to break the existing binding of a renderbuffer object to `target`.

    pub fn oxidegl_bind_renderbuffer(&mut self, target: GLenum, renderbuffer: GLuint) {
        panic!("command oxidegl_bind_renderbuffer not yet implemented");
    }
    /// ### Parameters
    /// `unit`
    ///
    /// > Specifies the index of the texture unit to which the sampler is bound.
    ///
    /// `sampler`
    ///
    /// > Specifies the name of a sampler.
    ///
    /// ### Description
    /// [**glBindSampler**](crate::context::Context::oxidegl_bind_sampler) binds
    /// `sampler` to the texture unit at index `unit`. `sampler` must be zero or
    /// the name of a sampler object previously returned from a call to [**glGenSamplers**](crate::context::Context::oxidegl_gen_samplers).
    /// `unit` must be less than the value of [`GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS`](crate::enums::GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS).
    ///
    /// When a sampler object is bound to a texture unit, its state supersedes
    /// that of the texture object bound to that texture unit. If the sampler name
    /// zero is bound to a texture unit, the currently bound texture's sampler
    /// state becomes active. A single sampler object may be bound to multiple
    /// texture units simultaneously.
    ///
    /// ### Notes
    /// [**glBindSampler**](crate::context::Context::oxidegl_bind_sampler) is available
    /// only if the GL version is 3.3 or higher.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_SAMPLER_BINDING`](crate::enums::GL_SAMPLER_BINDING)

    pub fn oxidegl_bind_sampler(&mut self, unit: GLuint, sampler: GLuint) {
        panic!("command oxidegl_bind_sampler not yet implemented");
    }
    /// ### Parameters
    /// `first`
    ///
    /// > Specifies the first sampler unit to which a sampler object is to be bound.
    ///
    /// `count`
    ///
    /// > Specifies the number of samplers to bind.
    ///
    /// `samplers`
    ///
    /// > Specifies the address of an array of names of existing sampler objects.
    ///
    /// ### Description
    /// [**glBindSamplers**](crate::context::Context::oxidegl_bind_samplers) binds
    /// samplers from an array of existing sampler objects to a specified number
    /// of consecutive sampler units. `count` specifies the number of sampler objects
    /// whose names are stored in the array `samplers`. That number of sampler
    /// names is read from the array and bound to the `count` consecutive sampler
    /// units starting from `first`.
    ///
    /// If the name zero appears in the `samplers` array, any existing binding
    /// to the sampler unit is reset. Any non-zero entry in `samplers` must be
    /// the name of an existing sampler object. When a non-zero entry in `samplers`
    /// is present, that sampler object is bound to the corresponding sampler unit.
    /// If `samplers` is [`NULL`](crate::enums::NULL) then it is as if an appropriately
    /// sized array containing only zeros had been specified.
    ///
    /// [**glBindSamplers**](crate::context::Context::oxidegl_bind_samplers) is
    /// equivalent to the following pseudo code:
    ///
    /// Each entry in `samplers` will be checked individually and if found to be
    /// invalid, the state for that sampler unit will not be changed and an error
    /// will be generated. However, the state for other sampler units referenced
    /// by the command will still be updated.
    ///
    /// ### Notes
    /// [**glBindSamplers**](crate::context::Context::oxidegl_bind_samplers) is
    /// available only if the GL version is 4.4 or higher.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_SAMPLER_BINDING`](crate::enums::GL_SAMPLER_BINDING)

    pub unsafe fn oxidegl_bind_samplers(
        &mut self,
        first: GLuint,
        count: GLsizei,
        samplers: *const GLuint,
    ) {
        panic!("command oxidegl_bind_samplers not yet implemented");
    }
    /// ### Parameters
    /// `target`
    ///
    /// > Specifies the target to which the texture is bound. Must be one of [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D),
    /// > [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D), [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D),
    /// > [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY), [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY),
    /// > [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE), [`GL_TEXTURE_CUBE_MAP`](crate::enums::GL_TEXTURE_CUBE_MAP),
    /// > [`GL_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_CUBE_MAP_ARRAY),
    /// > [`GL_TEXTURE_BUFFER`](crate::enums::GL_TEXTURE_BUFFER), [`GL_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE)
    /// > or [`GL_TEXTURE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE_ARRAY).
    ///
    /// `texture`
    ///
    /// > Specifies the name of a texture.
    ///
    /// ### Description
    /// [**glBindTexture**](crate::context::Context::oxidegl_bind_texture) lets
    /// you create or use a named texture. Calling [**glBindTexture**](crate::context::Context::oxidegl_bind_texture)
    /// with `target` set to [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D), [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D),
    /// [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D), [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY),
    /// [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY), [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE),
    /// [`GL_TEXTURE_CUBE_MAP`](crate::enums::GL_TEXTURE_CUBE_MAP), [`GL_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_CUBE_MAP_ARRAY),
    /// [`GL_TEXTURE_BUFFER`](crate::enums::GL_TEXTURE_BUFFER), [`GL_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE)
    /// or [`GL_TEXTURE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE_ARRAY)
    /// and `texture` set to the name of the new texture binds the texture name
    /// to the target. When a texture is bound to a target, the previous binding
    /// for that target is automatically broken.
    ///
    /// Texture names are unsigned integers. The value zero is reserved to represent
    /// the default texture for each texture target. Texture names and the corresponding
    /// texture contents are local to the shared object space of the current GL
    /// rendering context; two rendering contexts share texture names only if they
    /// explicitly enable sharing between contexts through the appropriate GL windows
    /// interfaces functions.
    ///
    /// You must use [**glGenTextures**](crate::context::Context::oxidegl_gen_textures)
    /// to generate a set of new texture names.
    ///
    /// When a texture is first bound, it assumes the specified target: A texture
    /// first bound to [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D) becomes one-dimensional
    /// texture, a texture first bound to [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D)
    /// becomes two-dimensional texture, a texture first bound to [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D)
    /// becomes three-dimensional texture, a texture first bound to [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY)
    /// becomes one-dimensional array texture, a texture first bound to [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY)
    /// becomes two-dimensional array texture, a texture first bound to [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE)
    /// becomes rectangle texture, a texture first bound to [`GL_TEXTURE_CUBE_MAP`](crate::enums::GL_TEXTURE_CUBE_MAP)
    /// becomes a cube-mapped texture, a texture first bound to [`GL_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_CUBE_MAP_ARRAY)
    /// becomes a cube-mapped array texture, a texture first bound to [`GL_TEXTURE_BUFFER`](crate::enums::GL_TEXTURE_BUFFER)
    /// becomes a buffer texture, a texture first bound to [`GL_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE)
    /// becomes a two-dimensional multisampled texture, and a texture first bound
    /// to [`GL_TEXTURE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE_ARRAY)
    /// becomes a two-dimensional multisampled array texture. The state of a one-dimensional
    /// texture immediately after it is first bound is equivalent to the state
    /// of the default [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D) at GL initialization,
    /// and similarly for the other texture types.
    ///
    /// While a texture is bound, GL operations on the target to which it is bound
    /// affect the bound texture, and queries of the target to which it is bound
    /// return state from the bound texture. In effect, the texture targets become
    /// aliases for the textures currently bound to them, and the texture name
    /// zero refers to the default textures that were bound to them at initialization.
    ///
    /// A texture binding created with [**glBindTexture**](crate::context::Context::oxidegl_bind_texture)
    /// remains active until a different texture is bound to the same target, or
    /// until the bound texture is deleted with [**glDeleteTextures**](crate::context::Context::oxidegl_delete_textures).
    ///
    /// Once created, a named texture may be re-bound to its same original target
    /// as often as needed. It is usually much faster to use [**glBindTexture**](crate::context::Context::oxidegl_bind_texture)
    /// to bind an existing named texture to one of the texture targets than it
    /// is to reload the texture image using [**glTexImage1D**](crate::context::Context::oxidegl_tex_image1_d),
    /// [**glTexImage2D**](crate::context::Context::oxidegl_tex_image2_d), [**glTexImage3D**](crate::context::Context::oxidegl_tex_image3_d)
    /// or another similar function.
    ///
    /// ### Notes
    /// The [`GL_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE)
    /// and [`GL_TEXTURE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE_ARRAY)
    /// targets are available only if the GL version is 3.2 or higher.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_TEXTURE_BINDING_1D`](crate::enums::GL_TEXTURE_BINDING_1D),
    /// [`GL_TEXTURE_BINDING_2D`](crate::enums::GL_TEXTURE_BINDING_2D), [`GL_TEXTURE_BINDING_3D`](crate::enums::GL_TEXTURE_BINDING_3D),
    /// [`GL_TEXTURE_BINDING_1D_ARRAY`](crate::enums::GL_TEXTURE_BINDING_1D_ARRAY),
    /// [`GL_TEXTURE_BINDING_2D_ARRAY`](crate::enums::GL_TEXTURE_BINDING_2D_ARRAY),
    /// [`GL_TEXTURE_BINDING_RECTANGLE`](crate::enums::GL_TEXTURE_BINDING_RECTANGLE),
    /// [`GL_TEXTURE_BINDING_BUFFER`](crate::enums::GL_TEXTURE_BINDING_BUFFER),
    /// [`GL_TEXTURE_BINDING_CUBE_MAP`](crate::enums::GL_TEXTURE_BINDING_CUBE_MAP),
    /// [`GL_TEXTURE_BINDING_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_BINDING_CUBE_MAP_ARRAY),
    /// [`GL_TEXTURE_BINDING_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_BINDING_2D_MULTISAMPLE),
    /// or [`GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY).

    pub fn oxidegl_bind_texture(&mut self, target: TextureTarget, texture: GLuint) {
        panic!("command oxidegl_bind_texture not yet implemented");
    }
    /// ### Parameters
    /// `first`
    ///
    /// > Specifies the first texture unit to which a texture is to be bound.
    ///
    /// `count`
    ///
    /// > Specifies the number of textures to bind.
    ///
    /// `textures`
    ///
    /// > Specifies the address of an array of names of existing texture objects.
    ///
    /// ### Description
    /// [**glBindTextures**](crate::context::Context::oxidegl_bind_textures) binds
    /// an array of existing texture objects to a specified number of consecutive
    /// texture units. `count` specifies the number of texture objects whose names
    /// are stored in the array `textures`. That number of texture names are read
    /// from the array and bound to the `count` consecutive texture units starting
    /// from `first`. The target, or type of texture is deduced from the texture
    /// object and each texture is bound to the corresponding target of the texture
    /// unit. If the name zero appears in the `textures` array, any existing binding
    /// to any target of the texture unit is reset and the default texture for
    /// that target is bound in its place. Any non-zero entry in `textures` must
    /// be the name of an existing texture object. If `textures` is [`NULL`](crate::enums::NULL)
    /// then it is as if an appropriately sized array containing only zeros had
    /// been specified.
    ///
    /// With the exception that the active texture selector maintains its current
    /// value, [**glBindTextures**](crate::context::Context::oxidegl_bind_textures)
    /// is equivalent to the following pseudo code:
    ///
    /// Each entry in `textures` will be checked individually and if found to be
    /// invalid, the state for that texture unit will not be changed and an error
    /// will be generated. However, the state for other texture units referenced
    /// by the command will still be updated.
    ///
    /// ### Notes
    /// [**glBindTextures**](crate::context::Context::oxidegl_bind_textures) is
    /// available only if the GL version is 4.4 or higher.
    ///
    /// Note that because [**glBindTextures**](crate::context::Context::oxidegl_bind_textures)
    /// cannot create new textures (even if a name passed has been previously generated
    /// by call to [**glGenTextures**](crate::context::Context::oxidegl_gen_textures)
    /// ), names passed to [**glBindTextures**](crate::context::Context::oxidegl_bind_textures)
    /// must have been bound at least once previously via a call to [**glBindTexture**](crate::context::Context::oxidegl_bind_texture).
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_TEXTURE_BINDING_1D`](crate::enums::GL_TEXTURE_BINDING_1D),
    /// [`GL_TEXTURE_BINDING_2D`](crate::enums::GL_TEXTURE_BINDING_2D), [`GL_TEXTURE_BINDING_3D`](crate::enums::GL_TEXTURE_BINDING_3D),
    /// [`GL_TEXTURE_BINDING_1D_ARRAY`](crate::enums::GL_TEXTURE_BINDING_1D_ARRAY),
    /// [`GL_TEXTURE_BINDING_2D_ARRAY`](crate::enums::GL_TEXTURE_BINDING_2D_ARRAY),
    /// [`GL_TEXTURE_BINDING_RECTANGLE`](crate::enums::GL_TEXTURE_BINDING_RECTANGLE),
    /// [`GL_TEXTURE_BINDING_BUFFER`](crate::enums::GL_TEXTURE_BINDING_BUFFER),
    /// [`GL_TEXTURE_BINDING_CUBE_MAP`](crate::enums::GL_TEXTURE_BINDING_CUBE_MAP),
    /// [`GL_TEXTURE_BINDING_CUBE_MAP`](crate::enums::GL_TEXTURE_BINDING_CUBE_MAP),
    /// [`GL_TEXTURE_BINDING_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_BINDING_CUBE_MAP_ARRAY),
    /// [`GL_TEXTURE_BINDING_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_BINDING_2D_MULTISAMPLE),
    /// or [`GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY).

    pub unsafe fn oxidegl_bind_textures(
        &mut self,
        first: GLuint,
        count: GLsizei,
        textures: *const GLuint,
    ) {
        panic!("command oxidegl_bind_textures not yet implemented");
    }
    /// ### Parameters
    /// `unit`
    ///
    /// > Specifies the texture unit, to which the texture object should be bound
    /// > to.
    ///
    /// `texture`
    ///
    /// > Specifies the name of a texture.
    ///
    /// ### Description
    /// [**glBindTextureUnit**](crate::context::Context::oxidegl_bind_texture_unit)
    /// binds an existing texture object to the texture unit numbered `unit`.
    ///
    /// `texture` must be zero or the name of an existing texture object. When
    /// `texture` is the name of an existing texture object, that object is bound
    /// to the target, in the corresponding texture unit, that was specified when
    /// the object was created. When `texture` is zero, each of the targets enumerated
    /// at the beginning of this section is reset to its default texture for the
    /// corresponding texture image unit.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_TEXTURE_BINDING_1D`](crate::enums::GL_TEXTURE_BINDING_1D),
    /// [`GL_TEXTURE_BINDING_2D`](crate::enums::GL_TEXTURE_BINDING_2D), [`GL_TEXTURE_BINDING_3D`](crate::enums::GL_TEXTURE_BINDING_3D),
    /// [`GL_TEXTURE_BINDING_1D_ARRAY`](crate::enums::GL_TEXTURE_BINDING_1D_ARRAY),
    /// [`GL_TEXTURE_BINDING_2D_ARRAY`](crate::enums::GL_TEXTURE_BINDING_2D_ARRAY),
    /// [`GL_TEXTURE_BINDING_RECTANGLE`](crate::enums::GL_TEXTURE_BINDING_RECTANGLE),
    /// [`GL_TEXTURE_BINDING_BUFFER`](crate::enums::GL_TEXTURE_BINDING_BUFFER),
    /// [`GL_TEXTURE_BINDING_CUBE_MAP`](crate::enums::GL_TEXTURE_BINDING_CUBE_MAP),
    /// [`GL_TEXTURE_BINDING_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_BINDING_CUBE_MAP_ARRAY),
    /// [`GL_TEXTURE_BINDING_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_BINDING_2D_MULTISAMPLE)
    /// or [`GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY).

    pub fn oxidegl_bind_texture_unit(&mut self, unit: GLuint, texture: GLuint) {
        panic!("command oxidegl_bind_texture_unit not yet implemented");
    }
    /// ### Parameters
    /// `target`
    ///
    /// > Specifies the target to which to bind the transform feedback object `id`.
    /// > `target` must be [`GL_TRANSFORM_FEEDBACK`](crate::enums::GL_TRANSFORM_FEEDBACK).
    ///
    /// `id`
    ///
    /// > Specifies the name of a transform feedback object reserved by [**glGenTransformFeedbacks**](crate::context::Context::oxidegl_gen_transform_feedbacks).
    ///
    /// ### Description
    /// [**glBindTransformFeedback**](crate::context::Context::oxidegl_bind_transform_feedback)
    /// binds the transform feedback object with name `id` to the current GL state.
    /// `id` must be a name previously returned from a call to [**glGenTransformFeedbacks**](crate::context::Context::oxidegl_gen_transform_feedbacks).
    /// If `id` has not previously been bound, a new transform feedback object
    /// with name `id` and initialized with the default transform state vector
    /// is created.
    ///
    /// In the initial state, a default transform feedback object is bound and
    /// treated as a transform feedback object with a name of zero. If the name
    /// zero is subsequently bound, the default transform feedback object is again
    /// bound to the GL state.
    ///
    /// While a transform feedback buffer object is bound, GL operations on the
    /// target to which it is bound affect the bound transform feedback object,
    /// and queries of the target to which a transform feedback object is bound
    /// return state from the bound object. When buffer objects are bound for transform
    /// feedback, they are attached to the currently bound transform feedback object.
    /// Buffer objects are used for trans- form feedback only if they are attached
    /// to the currently bound transform feedback object.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_TRANSFORM_FEEDBACK_BINDING`](crate::enums::GL_TRANSFORM_FEEDBACK_BINDING)

    pub fn oxidegl_bind_transform_feedback(&mut self, target: GLenum, id: GLuint) {
        panic!("command oxidegl_bind_transform_feedback not yet implemented");
    }

    /// ### Parameters
    /// `red`
    ///
    /// `green`
    ///
    /// `blue`
    ///
    /// `alpha`
    ///
    /// > specify the components of [`GL_BLEND_COLOR`](crate::enums::GL_BLEND_COLOR)
    ///
    /// ### Description
    /// The [`GL_BLEND_COLOR`](crate::enums::GL_BLEND_COLOR) may be used to calculate
    /// the source and destination blending factors. The color components are clamped
    /// to the range `[inlineq]` [**glBlendFunc**](crate::context::Context::oxidegl_blend_func)
    /// for a complete description of the blending operations. Initially the [`GL_BLEND_COLOR`](crate::enums::GL_BLEND_COLOR)
    /// is set to (0, 0, 0, 0).
    ///
    /// ### Notes
    /// The type of the `red`, `green`, `blue`, and `alpha` parameters was changed
    /// from `GLclampf` to `GLfloat`. This change is transparent to user code and is
    /// described in detail on the [**removedTypes**](crate::context::Context::oxideremoved_types)
    /// page.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with an argument of [`GL_BLEND_COLOR`](crate::enums::GL_BLEND_COLOR)

    pub fn oxidegl_blend_color(
        &mut self,
        red: GLfloat,
        green: GLfloat,
        blue: GLfloat,
        alpha: GLfloat,
    ) {
        panic!("command oxidegl_blend_color not yet implemented");
    }
    /// ### Parameters
    /// `target`
    ///
    /// > Target for color clamping. `target` must be [`GL_CLAMP_READ_COLOR`](crate::enums::GL_CLAMP_READ_COLOR).
    ///
    /// `clamp`
    ///
    /// > Specifies whether to apply color clamping. `clamp` must be [`GL_TRUE`](crate::enums::GL_TRUE)
    /// > or [`GL_FALSE`](crate::enums::GL_FALSE).
    ///
    /// ### Description
    /// [**glClampColor**](crate::context::Context::oxidegl_clamp_color) controls
    /// color clamping that is performed during [**glReadPixels**](crate::context::Context::oxidegl_read_pixels).
    /// `target` must be [`GL_CLAMP_READ_COLOR`](crate::enums::GL_CLAMP_READ_COLOR).
    /// If `clamp` is [`GL_TRUE`](crate::enums::GL_TRUE), read color clamping
    /// is enabled; if `clamp` is [`GL_FALSE`](crate::enums::GL_FALSE), read color
    /// clamping is disabled. If `clamp` is [`GL_FIXED_ONLY`](crate::enums::GL_FIXED_ONLY),
    /// read color clamping is enabled only if the selected read buffer has fixed
    /// point components and disabled otherwise.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_CLAMP_READ_COLOR`](crate::enums::GL_CLAMP_READ_COLOR).

    pub fn oxidegl_clamp_color(&mut self, target: GLenum, clamp: ClampColorMode) {
        panic!("command oxidegl_clamp_color not yet implemented");
    }
    /// ### Parameters
    /// `texture`
    ///
    /// > The name of an existing texture object containing the image to be cleared.
    ///
    /// `level`
    ///
    /// > The level of `texture` containing the region to be cleared.
    ///
    /// `format`
    ///
    /// > The format of the data whose address in memory is given by `data`.
    ///
    /// `type`
    ///
    /// > The type of the data whose address in memory is given by `data`.
    ///
    /// `data`
    ///
    /// > The address in memory of the data to be used to clear the specified region.
    ///
    /// ### Description
    /// [**glClearTexImage**](crate::context::Context::oxidegl_clear_tex_image)
    /// fills all an image contained in a texture with an application supplied
    /// value. `texture` must be the name of an existing texture. Further, `texture`
    /// may not be the name of a buffer texture, nor may its internal format be
    /// compressed.
    ///
    /// `format` and `type` specify the format and type of the source data and
    /// are interpreted as they are for [**glTexImage3D**](crate::context::Context::oxidegl_tex_image3_d).
    /// Textures with a base internal format of [`GL_DEPTH_COMPONENT`](crate::enums::GL_DEPTH_COMPONENT),
    /// [`GL_STENCIL_INDEX`](crate::enums::GL_STENCIL_INDEX), or [`GL_DEPTH_STENCIL`](crate::enums::GL_DEPTH_STENCIL)
    /// require depth component, stencil, or depth-stencil component data respectively.
    /// Textures with other base internal formats require RGBA formats. Textures
    /// with integer internal formats require integer data.
    ///
    /// `data` is a pointer to an array of between one and four components of texel
    /// data that will be used as the source for the constant fill value. The elements
    /// of data are converted by the GL into the internal format of the texture
    /// image (that was specified when the level was defined by any of the [**glTexImage***](crate::context::Context::oxidegl_tex_image*),
    /// [**glTexStorage***](crate::context::Context::oxidegl_tex_storage*) or [**glCopyTexImage***](crate::context::Context::oxidegl_copy_tex_image*)
    /// commands), and then used to fill the specified range of the destination
    /// texture level. If `data` is [`NULL`](crate::enums::NULL), then the pointer
    /// is ignored and the sub-range of the texture image is filled with zeros.
    /// If texture is a multisample texture, all the samples in a texel are cleared
    /// to the value specified by data.
    ///
    /// ### Notes
    /// [**glClearTexImage**](crate::context::Context::oxidegl_clear_tex_image)
    /// is available only if the GL version is 4.4 or greater.
    ///
    /// ### Associated Gets
    /// [**glGetTexImage**](crate::context::Context::oxidegl_get_tex_image), [**glGetInternalformat**](crate::context::Context::oxidegl_get_internalformat)

    pub unsafe fn oxidegl_clear_tex_image(
        &mut self,
        texture: GLuint,
        level: GLint,
        format: PixelFormat,
        r#type: PixelType,
        data: *const GLvoid,
    ) {
        panic!("command oxidegl_clear_tex_image not yet implemented");
    }
    /// ### Parameters
    /// `texture`
    ///
    /// > The name of an existing texture object containing the image to be cleared.
    ///
    /// `level`
    ///
    /// > The level of `texture` containing the region to be cleared.
    ///
    /// `xoffset`
    ///
    /// > The coordinate of the left edge of the region to be cleared.
    ///
    /// `yoffset`
    ///
    /// > The coordinate of the lower edge of the region to be cleared.
    ///
    /// `zoffset`
    ///
    /// > The coordinate of the front of the region to be cleared.
    ///
    /// `width`
    ///
    /// > The width of the region to be cleared.
    ///
    /// `height`
    ///
    /// > The height of the region to be cleared.
    ///
    /// `depth`
    ///
    /// > The depth of the region to be cleared.
    ///
    /// `format`
    ///
    /// > The format of the data whose address in memory is given by `data`.
    ///
    /// `type`
    ///
    /// > The type of the data whose address in memory is given by `data`.
    ///
    /// `data`
    ///
    /// > The address in memory of the data to be used to clear the specified region.
    ///
    /// ### Description
    /// [**glClearTexSubImage**](crate::context::Context::oxidegl_clear_tex_sub_image)
    /// fills all or part of an image contained in a texture with an application
    /// supplied value. `texture` must be the name of an existing texture. Further,
    /// `texture` may not be the name of a buffer texture, nor may its internal
    /// format be compressed.
    ///
    /// Arguments `xoffset`, `yoffset`, and `zoffset` specify the lower left texel
    /// coordinates of a width-wide by height-high by depth-deep rectangular subregion
    /// of the texel array.
    ///
    /// For one-dimensional array textures, `yoffset` is interpreted as the first
    /// layer to be cleared and `height` is the number of layers to clear. For
    /// two-dimensional array textures, `zoffset` is interpreted as the first layer
    /// to be cleared and `depth` is the number of layers to clear. Cube map textures
    /// are treated as an array of six slices in the z-dimension, where the value
    /// of `zoffset` is interpreted as specifying the cube map face for the corresponding
    /// layer and `depth` is the number of faces to clear. For cube map array textures,
    /// `zoffset` is the first layer-face to clear, and `depth` is the number of
    /// layer-faces to clear. Each layer-face is translated into an array layer
    /// and a cube map face as described in the OpenGL Specification.
    ///
    /// Negative values of `xoffset`, `yoffset`, and `zoffset` correspond to the
    /// coordinates of border texels. Taking `[inlineq]` `[inlineq]` `[inlineq]`
    /// `[inlineq]` `[inlineq]` `[inlineq]` `width`, `height`, `depth`, and the
    /// border width, border height, and border depth of the texel array and taking
    /// `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]`
    /// `xoffset`, `yoffset`, `zoffset`, `width`, `height`, and `depth` argument
    /// values, any of the following relationships generates a [`GL_INVALID_OPERATION`](crate::enums::GL_INVALID_OPERATION)
    /// error:
    ///
    /// For texture types that do not have certain dimensions, this command treats
    /// those dimensions as having a size of 1. For example, to clear a portion
    /// of a two-dimensional texture, use `zoffset` equal to zero and `depth` equal
    /// to one.
    ///
    /// `format` and `type` specify the format and type of the source data and
    /// are interpreted as they are for [**glTexImage3D**](crate::context::Context::oxidegl_tex_image3_d).
    /// Textures with a base internal format of [`GL_DEPTH_COMPONENT`](crate::enums::GL_DEPTH_COMPONENT),
    /// [`GL_STENCIL_INDEX`](crate::enums::GL_STENCIL_INDEX), or [`GL_DEPTH_STENCIL`](crate::enums::GL_DEPTH_STENCIL)
    /// require depth component, stencil, or depth-stencil component data respectively.
    /// Textures with other base internal formats require RGBA formats. Textures
    /// with integer internal formats require integer data.
    ///
    /// `data` is a pointer to an array of between one and four components of texel
    /// data that will be used as the source for the constant fill value. The elements
    /// of data are converted by the GL into the internal format of the texture
    /// image (that was specified when the level was defined by any of the [**glTexImage***](crate::context::Context::oxidegl_tex_image*),
    /// [**glTexStorage***](crate::context::Context::oxidegl_tex_storage*) or [**glCopyTexImage***](crate::context::Context::oxidegl_copy_tex_image*)
    /// commands), and then used to fill the specified range of the destination
    /// texture level. If `data` is [`NULL`](crate::enums::NULL), then the pointer
    /// is ignored and the sub-range of the texture image is filled with zeros.
    /// If texture is a multisample texture, all the samples in a texel are cleared
    /// to the value specified by data.
    ///
    /// ### Notes
    /// [**glClearTexSubImage**](crate::context::Context::oxidegl_clear_tex_sub_image)
    /// is available only if the GL version is 4.4 or greater.
    ///
    /// ### Associated Gets
    /// [**glGetTexImage**](crate::context::Context::oxidegl_get_tex_image), [**glGetInternalformat**](crate::context::Context::oxidegl_get_internalformat)

    pub unsafe fn oxidegl_clear_tex_sub_image(
        &mut self,
        texture: GLuint,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        zoffset: GLint,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        format: PixelFormat,
        r#type: PixelType,
        data: *const GLvoid,
    ) {
        panic!("command oxidegl_clear_tex_sub_image not yet implemented");
    }
    /// ### Parameters
    /// `sync`
    ///
    /// > The sync object whose status to wait on.
    ///
    /// `flags`
    ///
    /// > A bitfield controlling the command flushing behavior. `flags` may be [`GL_SYNC_FLUSH_COMMANDS_BIT`](crate::enums::GL_SYNC_FLUSH_COMMANDS_BIT).
    ///
    /// `timeout`
    ///
    /// > The timeout, specified in nanoseconds, for which the implementation should
    /// > wait for `sync` to become signaled.
    ///
    /// ### Description
    /// [**glClientWaitSync**](crate::context::Context::oxidegl_client_wait_sync)
    /// causes the client to block and wait for the sync object specified by `sync`
    /// to become signaled. If `sync` is signaled when [**glClientWaitSync**](crate::context::Context::oxidegl_client_wait_sync)
    /// is called, [**glClientWaitSync**](crate::context::Context::oxidegl_client_wait_sync)
    /// returns immediately, otherwise it will block and wait for up to `timeout`
    /// nanoseconds for `sync` to become signaled.
    ///
    /// The return value is one of four status values: [`GL_ALREADY_SIGNALED`](crate::enums::GL_ALREADY_SIGNALED)
    /// > indicates that `sync` was signaled at the time that [**glClientWaitSync**](crate::context::Context::oxidegl_client_wait_sync)
    /// > was called.
    ///
    /// > [`GL_TIMEOUT_EXPIRED`](crate::enums::GL_TIMEOUT_EXPIRED) indicates that
    /// > at least `timeout` nanoseconds passed and `sync` did not become signaled.
    ///
    /// > [`GL_CONDITION_SATISFIED`](crate::enums::GL_CONDITION_SATISFIED) indicates
    /// > that `sync` was signaled before the timeout expired.
    ///
    /// > [`GL_WAIT_FAILED`](crate::enums::GL_WAIT_FAILED) indicates that an error
    /// > occurred. Additionally, an OpenGL error will be generated.
    ///
    ///
    /// ### Notes
    /// [**glClientWaitSync**](crate::context::Context::oxidegl_client_wait_sync)
    /// is available only if the GL version is 3.2 or greater.

    pub fn oxidegl_client_wait_sync(
        &mut self,
        sync: GLsync,
        flags: GLbitfield,
        timeout: GLuint64,
    ) -> GLenum {
        panic!("command oxidegl_client_wait_sync not yet implemented");
    }
    /// ### Parameters
    /// `origin`
    ///
    /// > Specifies the clip control origin. Must be one of [`GL_LOWER_LEFT`](crate::enums::GL_LOWER_LEFT)
    /// > or [`GL_UPPER_LEFT`](crate::enums::GL_UPPER_LEFT).
    ///
    /// `depth`
    ///
    /// > Specifies the clip control depth mode. Must be one of [`GL_NEGATIVE_ONE_TO_ONE`](crate::enums::GL_NEGATIVE_ONE_TO_ONE)
    /// > or [`GL_ZERO_TO_ONE`](crate::enums::GL_ZERO_TO_ONE).
    ///
    /// ### Description
    /// [**glClipControl**](crate::context::Context::oxidegl_clip_control) controls
    /// the clipping volume behavior and the clip coordinate to window coordinate
    /// transformation behavior.
    ///
    /// The view volume is defined by $$z_{min} \leq `z_c` \leq `w_c`$$ where $z_{min}
    ///= -`w_c`$ when `depth` is [`GL_NEGATIVE_ONE_TO_ONE`](crate::enums::GL_NEGATIVE_ONE_TO_ONE),
    /// and $z_{min}= 0$ when `depth` is [`GL_ZERO_TO_ONE`](crate::enums::GL_ZERO_TO_ONE).
    ///
    /// The normalized device coordinate $`y_d`$ is given by $$`y_d`={{ f \times `y_c`
    ///} \over `w_c` }$$ where $f= 1$ when `origin` is [`GL_LOWER_LEFT`](crate::enums::GL_LOWER_LEFT),
    /// and $f= -1$ when `origin` is [`GL_UPPER_LEFT`](crate::enums::GL_UPPER_LEFT).
    ///
    /// The window coordinate $`z_w`$ is given by $$`z_w`= s \times `z_d`+ b$$ where
    /// $s={{ f- n} \over 2 }$ and $b={ {n+ f} \over 2 }$ when `depth` is [`GL_NEGATIVE_ONE_TO_ONE`](crate::enums::GL_NEGATIVE_ONE_TO_ONE),
    /// and $s= f- n$ and $b= n$ when `depth` is [`GL_ZERO_TO_ONE`](crate::enums::GL_ZERO_TO_ONE).
    /// $n$ and $f$ are the near and far depth range values set with [**glDepthRange**](crate::context::Context::oxidegl_depth_range).
    ///
    /// Finally, the polygon area computation defined by [**`gl_FrontFacing`**](crate::context::Context::oxidegl__front_facing)
    /// to determine if a polygon is front- or back-facing has its sign negated
    /// when `origin` is [`GL_UPPER_LEFT`](crate::enums::GL_UPPER_LEFT).
    ///
    /// ### Notes
    /// The default GL clip volume definition is for a `origin` of [`GL_LOWER_LEFT`](crate::enums::GL_LOWER_LEFT)
    /// and a `depth` of [`GL_NEGATIVE_ONE_TO_ONE`](crate::enums::GL_NEGATIVE_ONE_TO_ONE).
    ///
    /// An `origin` of [`GL_UPPER_LEFT`](crate::enums::GL_UPPER_LEFT) and a `depth`
    /// of [`GL_ZERO_TO_ONE`](crate::enums::GL_ZERO_TO_ONE) corresponds to `Direct3D`'s
    /// clip volume definition.
    ///
    /// An `origin` of [`GL_UPPER_LEFT`](crate::enums::GL_UPPER_LEFT) and a `depth`
    /// of [`GL_NEGATIVE_ONE_TO_ONE`](crate::enums::GL_NEGATIVE_ONE_TO_ONE) corresponds
    /// to the upper-left origin of the window coordinate system of Microsoft Windows
    /// and the X Window System.
    ///
    /// There is extensive discussion of the uses and further consequences of the
    /// different clip volume settings in the

    pub fn oxidegl_clip_control(&mut self, origin: ClipControlOrigin, depth: ClipControlDepth) {
        panic!("command oxidegl_clip_control not yet implemented");
    }
    /// ### Parameters
    /// `shader`
    ///
    /// > Specifies the shader object to be compiled.
    ///
    /// ### Description
    /// [**glCompileShader**](crate::context::Context::oxidegl_compile_shader)
    /// compiles the source code strings that have been stored in the shader object
    /// specified by `shader`.
    ///
    /// The compilation status will be stored as part of the shader object's state.
    /// This value will be set to [`GL_TRUE`](crate::enums::GL_TRUE) if the shader
    /// was compiled without errors and is ready for use, and [`GL_FALSE`](crate::enums::GL_FALSE)
    /// otherwise. It can be queried by calling [**glGetShader**](crate::context::Context::oxidegl_get_shader)
    /// with arguments `shader` and [`GL_COMPILE_STATUS`](crate::enums::GL_COMPILE_STATUS).
    ///
    /// Compilation of a shader can fail for a number of reasons as specified by
    /// the OpenGL Shading Language Specification. Whether or not the compilation
    /// was successful, information about the compilation can be obtained from
    /// the shader object's information log by calling [**glGetShaderInfoLog**](crate::context::Context::oxidegl_get_shader_info_log).
    ///
    /// ### Associated Gets
    /// [**glGetShaderInfoLog**](crate::context::Context::oxidegl_get_shader_info_log)
    /// with argument `shader`
    ///
    /// [**glGetShader**](crate::context::Context::oxidegl_get_shader) with arguments
    /// `shader` and [`GL_COMPILE_STATUS`](crate::enums::GL_COMPILE_STATUS)
    ///
    /// [**glIsShader**](crate::context::Context::oxidegl_is_shader)

    pub fn oxidegl_compile_shader(&mut self, shader: GLuint) {
        panic!("command oxidegl_compile_shader not yet implemented");
    }
    /// ### Parameters
    /// `target`
    ///
    /// > Specifies the target texture. Must be [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D)
    /// > or [`GL_PROXY_TEXTURE_1D`](crate::enums::GL_PROXY_TEXTURE_1D).
    ///
    /// `level`
    ///
    /// > Specifies the level-of-detail number. Level 0 is the base image level.
    /// > Level *n* is the *n* th mipmap reduction image.
    ///
    /// `internalformat`
    ///
    /// > Specifies the format of the compressed image data stored at address `data`.
    ///
    /// `width`
    ///
    /// > Specifies the width of the texture image. All implementations support texture
    /// > images that are at least 64 texels wide. The height of the 1D texture image
    /// > is 1.
    ///
    /// `border`
    ///
    /// > This value must be 0.
    ///
    /// `imageSize`
    ///
    /// > Specifies the number of unsigned bytes of image data starting at the address
    /// > specified by `data`.
    ///
    /// `data`
    ///
    /// > Specifies a pointer to the compressed image data in memory.
    ///
    /// ### Description
    /// Texturing allows elements of an image array to be read by shaders.
    ///
    /// [**glCompressedTexImage1D**](crate::context::Context::oxidegl_compressed_tex_image1_d)
    /// loads a previously defined, and retrieved, compressed one-dimensional texture
    /// image if `target` is [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D) (see
    /// [**glTexImage1D**](crate::context::Context::oxidegl_tex_image1_d) ).
    ///
    /// If `target` is [`GL_PROXY_TEXTURE_1D`](crate::enums::GL_PROXY_TEXTURE_1D),
    /// no data is read from `data`, but all of the texture image state is recalculated,
    /// checked for consistency, and checked against the implementation's capabilities.
    /// If the implementation cannot handle a texture of the requested texture
    /// size, it sets all of the image state to 0, but does not generate an error
    /// (see [**glGetError**](crate::context::Context::oxidegl_get_error) ). To
    /// query for an entire mipmap array, use an image array level greater than
    /// or equal to 1.
    ///
    /// `internalformat` must be an extension-specified compressed-texture format.
    /// When a texture is loaded with [**glTexImage1D**](crate::context::Context::oxidegl_tex_image1_d)
    /// using a generic compressed texture format (e.g., [`GL_COMPRESSED_RGB`](crate::enums::GL_COMPRESSED_RGB))
    /// the GL selects from one of its extensions supporting compressed textures.
    /// In order to load the compressed texture image using [**glCompressedTexImage1D**](crate::context::Context::oxidegl_compressed_tex_image1_d),
    /// query the compressed texture image's size and format using [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter).
    ///
    /// If a non-zero named buffer object is bound to the [`GL_PIXEL_UNPACK_BUFFER`](crate::enums::GL_PIXEL_UNPACK_BUFFER)
    /// target (see [**glBindBuffer**](crate::context::Context::oxidegl_bind_buffer))
    /// while a texture image is specified, `data` is treated as a byte offset
    /// into the buffer object's data store.
    ///
    /// If the compressed data are arranged into fixed-size blocks of texels, the
    /// pixel storage modes can be used to select a sub-rectangle from a larger
    /// containing rectangle. These pixel storage modes operate in the same way
    /// as they do for [**glTexImage1D**](crate::context::Context::oxidegl_tex_image1_d).
    /// In the following description, denote by `[inlineq]` `[inlineq]` `[inlineq]`
    /// `[inlineq]` [`GL_UNPACK_COMPRESSED_BLOCK_SIZE`](crate::enums::GL_UNPACK_COMPRESSED_BLOCK_SIZE),
    /// [`GL_UNPACK_COMPRESSED_BLOCK_WIDTH`](crate::enums::GL_UNPACK_COMPRESSED_BLOCK_WIDTH),
    /// [`GL_UNPACK_COMPRESSED_BLOCK_HEIGHT`](crate::enums::GL_UNPACK_COMPRESSED_BLOCK_HEIGHT),
    /// and [`GL_UNPACK_COMPRESSED_BLOCK_DEPTH`](crate::enums::GL_UNPACK_COMPRESSED_BLOCK_DEPTH),
    /// respectively. `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]`
    ///
    /// By default the pixel storage modes [`GL_UNPACK_ROW_LENGTH`](crate::enums::GL_UNPACK_ROW_LENGTH),
    /// [`GL_UNPACK_SKIP_ROWS`](crate::enums::GL_UNPACK_SKIP_ROWS), [`GL_UNPACK_SKIP_PIXELS`](crate::enums::GL_UNPACK_SKIP_PIXELS),
    /// [`GL_UNPACK_IMAGE_HEIGHT`](crate::enums::GL_UNPACK_IMAGE_HEIGHT) and [`GL_UNPACK_SKIP_IMAGES`](crate::enums::GL_UNPACK_SKIP_IMAGES)
    /// are ignored for compressed images. To enable [`GL_UNPACK_SKIP_PIXELS`](crate::enums::GL_UNPACK_SKIP_PIXELS)
    /// and [`GL_UNPACK_ROW_LENGTH`](crate::enums::GL_UNPACK_ROW_LENGTH), `[inlineq]`
    /// `[inlineq]` [`GL_UNPACK_SKIP_ROWS`](crate::enums::GL_UNPACK_SKIP_ROWS)
    /// and [`GL_UNPACK_IMAGE_HEIGHT`](crate::enums::GL_UNPACK_IMAGE_HEIGHT), `[inlineq]`
    /// [`GL_UNPACK_SKIP_IMAGES`](crate::enums::GL_UNPACK_SKIP_IMAGES), `[inlineq]`
    ///
    /// When selecting a sub-rectangle from a compressed image, the value of [`GL_UNPACK_SKIP_PIXELS`](crate::enums::GL_UNPACK_SKIP_PIXELS)
    /// > must be a multiple of `[inlineq]`
    ///
    ///
    /// `imageSize` must be equal to:
    ///
    /// `[inlineq]`
    ///
    /// ### Associated Gets
    /// [**glGetCompressedTexImage**](crate::context::Context::oxidegl_get_compressed_tex_image)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_TEXTURE_COMPRESSED`](crate::enums::GL_TEXTURE_COMPRESSED)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_NUM_COMPRESSED_TEXTURE_FORMATS`](crate::enums::GL_NUM_COMPRESSED_TEXTURE_FORMATS)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_COMPRESSED_TEXTURE_FORMATS`](crate::enums::GL_COMPRESSED_TEXTURE_FORMATS)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_PIXEL_UNPACK_BUFFER_BINDING`](crate::enums::GL_PIXEL_UNPACK_BUFFER_BINDING)
    ///
    /// [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter)
    /// with arguments [`GL_TEXTURE_INTERNAL_FORMAT`](crate::enums::GL_TEXTURE_INTERNAL_FORMAT)
    /// and [`GL_TEXTURE_COMPRESSED_IMAGE_SIZE`](crate::enums::GL_TEXTURE_COMPRESSED_IMAGE_SIZE)

    pub unsafe fn oxidegl_compressed_tex_image1_d(
        &mut self,
        target: TextureTarget,
        level: GLint,
        internalformat: InternalFormat,
        width: GLsizei,
        border: GLint,
        image_size: GLsizei,
        data: *const GLvoid,
    ) {
        panic!("command oxidegl_compressed_tex_image1_d not yet implemented");
    }
    /// ### Parameters
    /// `target`
    ///
    /// > Specifies the target texture. Must be [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D),
    /// > [`GL_PROXY_TEXTURE_2D`](crate::enums::GL_PROXY_TEXTURE_2D), [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY),
    /// > [`GL_PROXY_TEXTURE_1D_ARRAY`](crate::enums::GL_PROXY_TEXTURE_1D_ARRAY),
    /// > [`GL_TEXTURE_CUBE_MAP_POSITIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_X),
    /// > [`GL_TEXTURE_CUBE_MAP_NEGATIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_X),
    /// > [`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Y),
    /// > [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Y),
    /// > [`GL_TEXTURE_CUBE_MAP_POSITIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Z),
    /// > [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Z),
    /// > or [`GL_PROXY_TEXTURE_CUBE_MAP`](crate::enums::GL_PROXY_TEXTURE_CUBE_MAP).
    ///
    /// `level`
    ///
    /// > Specifies the level-of-detail number. Level 0 is the base image level.
    /// > Level *n* is the *n* th mipmap reduction image.
    ///
    /// `internalformat`
    ///
    /// > Specifies the format of the compressed image data stored at address `data`.
    ///
    /// `width`
    ///
    /// > Specifies the width of the texture image. All implementations support 2D
    /// > texture and cube map texture images that are at least 16384 texels wide.
    ///
    /// `height`
    ///
    /// > Specifies the height of the texture image. All implementations support
    /// > 2D texture and cube map texture images that are at least 16384 texels high.
    ///
    /// `border`
    ///
    /// > This value must be 0.
    ///
    /// `imageSize`
    ///
    /// > Specifies the number of unsigned bytes of image data starting at the address
    /// > specified by `data`.
    ///
    /// `data`
    ///
    /// > Specifies a pointer to the compressed image data in memory.
    ///
    /// ### Description
    /// Texturing allows elements of an image array to be read by shaders.
    ///
    /// [**glCompressedTexImage2D**](crate::context::Context::oxidegl_compressed_tex_image2_d)
    /// loads a previously defined, and retrieved, compressed two-dimensional texture
    /// image if `target` is [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D), or
    /// one of the cube map faces such as [`GL_TEXTURE_CUBE_MAP_POSITIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_X).
    /// (see [**glTexImage2D**](crate::context::Context::oxidegl_tex_image2_d)
    /// ).
    ///
    /// If `target` is [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY),
    /// `data` is treated as an array of compressed 1D textures.
    ///
    /// If `target` is [`GL_PROXY_TEXTURE_2D`](crate::enums::GL_PROXY_TEXTURE_2D),
    /// [`GL_PROXY_TEXTURE_1D_ARRAY`](crate::enums::GL_PROXY_TEXTURE_1D_ARRAY)
    /// or [`GL_PROXY_TEXTURE_CUBE_MAP`](crate::enums::GL_PROXY_TEXTURE_CUBE_MAP),
    /// no data is read from `data`, but all of the texture image state is recalculated,
    /// checked for consistency, and checked against the implementation's capabilities.
    /// If the implementation cannot handle a texture of the requested texture
    /// size, it sets all of the image state to 0, but does not generate an error
    /// (see [**glGetError**](crate::context::Context::oxidegl_get_error) ). To
    /// query for an entire mipmap array, use an image array level greater than
    /// or equal to 1.
    ///
    /// `internalformat` must be a known compressed image format (such as [`GL_RGTC`](crate::enums::GL_RGTC))
    /// or an extension-specified compressed-texture format. When a texture is
    /// loaded with [**glTexImage2D**](crate::context::Context::oxidegl_tex_image2_d)
    /// using a generic compressed texture format (e.g., [`GL_COMPRESSED_RGB`](crate::enums::GL_COMPRESSED_RGB)
    /// ), the GL selects from one of its extensions supporting compressed textures.
    /// In order to load the compressed texture image using [**glCompressedTexImage2D**](crate::context::Context::oxidegl_compressed_tex_image2_d),
    /// query the compressed texture image's size and format using [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter).
    ///
    /// If a non-zero named buffer object is bound to the [`GL_PIXEL_UNPACK_BUFFER`](crate::enums::GL_PIXEL_UNPACK_BUFFER)
    /// target (see [**glBindBuffer**](crate::context::Context::oxidegl_bind_buffer))
    /// while a texture image is specified, `data` is treated as a byte offset
    /// into the buffer object's data store.
    ///
    /// If the compressed data are arranged into fixed-size blocks of texels, the
    /// pixel storage modes can be used to select a sub-rectangle from a larger
    /// containing rectangle. These pixel storage modes operate in the same way
    /// as they do for [**glTexImage2D**](crate::context::Context::oxidegl_tex_image2_d).
    /// In the following description, denote by `[inlineq]` `[inlineq]` `[inlineq]`
    /// `[inlineq]` [`GL_UNPACK_COMPRESSED_BLOCK_SIZE`](crate::enums::GL_UNPACK_COMPRESSED_BLOCK_SIZE),
    /// [`GL_UNPACK_COMPRESSED_BLOCK_WIDTH`](crate::enums::GL_UNPACK_COMPRESSED_BLOCK_WIDTH),
    /// [`GL_UNPACK_COMPRESSED_BLOCK_HEIGHT`](crate::enums::GL_UNPACK_COMPRESSED_BLOCK_HEIGHT),
    /// and [`GL_UNPACK_COMPRESSED_BLOCK_DEPTH`](crate::enums::GL_UNPACK_COMPRESSED_BLOCK_DEPTH),
    /// respectively. `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]`
    ///
    /// By default the pixel storage modes [`GL_UNPACK_ROW_LENGTH`](crate::enums::GL_UNPACK_ROW_LENGTH),
    /// [`GL_UNPACK_SKIP_ROWS`](crate::enums::GL_UNPACK_SKIP_ROWS), [`GL_UNPACK_SKIP_PIXELS`](crate::enums::GL_UNPACK_SKIP_PIXELS),
    /// [`GL_UNPACK_IMAGE_HEIGHT`](crate::enums::GL_UNPACK_IMAGE_HEIGHT) and [`GL_UNPACK_SKIP_IMAGES`](crate::enums::GL_UNPACK_SKIP_IMAGES)
    /// are ignored for compressed images. To enable [`GL_UNPACK_SKIP_PIXELS`](crate::enums::GL_UNPACK_SKIP_PIXELS)
    /// and [`GL_UNPACK_ROW_LENGTH`](crate::enums::GL_UNPACK_ROW_LENGTH), `[inlineq]`
    /// `[inlineq]` [`GL_UNPACK_SKIP_ROWS`](crate::enums::GL_UNPACK_SKIP_ROWS)
    /// and [`GL_UNPACK_IMAGE_HEIGHT`](crate::enums::GL_UNPACK_IMAGE_HEIGHT), `[inlineq]`
    /// [`GL_UNPACK_SKIP_IMAGES`](crate::enums::GL_UNPACK_SKIP_IMAGES), `[inlineq]`
    ///
    /// When selecting a sub-rectangle from a compressed image: The value of [`GL_UNPACK_SKIP_PIXELS`](crate::enums::GL_UNPACK_SKIP_PIXELS)
    /// > must be a multiple of `[inlineq]`
    ///
    /// > the value of [`GL_UNPACK_SKIP_ROWS`](crate::enums::GL_UNPACK_SKIP_ROWS)
    /// > must be a multiple of `[inlineq]`
    ///
    ///
    /// `imageSize` must be equal to:
    ///
    /// `[inlineq]`
    ///
    /// ### Notes
    /// The specific compressed internal formats [`GL_COMPRESSED_RGB8_ETC2`](crate::enums::GL_COMPRESSED_RGB8_ETC2),
    /// [`GL_COMPRESSED_SRGB8_ETC2`](crate::enums::GL_COMPRESSED_SRGB8_ETC2), [`GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2`](crate::enums::GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2),
    /// [`GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2`](crate::enums::GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2),
    /// [`GL_COMPRESSED_RGBA8_ETC2_EAC`](crate::enums::GL_COMPRESSED_RGBA8_ETC2_EAC),
    /// [`GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC`](crate::enums::GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC),
    /// [`GL_COMPRESSED_R11_EAC`](crate::enums::GL_COMPRESSED_R11_EAC), [`GL_COMPRESSED_SIGNED_R11_EAC`](crate::enums::GL_COMPRESSED_SIGNED_R11_EAC),
    /// [`GL_COMPRESSED_RG11_EAC`](crate::enums::GL_COMPRESSED_RG11_EAC), and [`GL_COMPRESSED_SIGNED_RG11_EAC`](crate::enums::GL_COMPRESSED_SIGNED_RG11_EAC)
    /// are available only if the GL version is 4.3 or higher.
    ///
    /// ### Associated Gets
    /// [**glGetCompressedTexImage**](crate::context::Context::oxidegl_get_compressed_tex_image)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_TEXTURE_COMPRESSED`](crate::enums::GL_TEXTURE_COMPRESSED)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_PIXEL_UNPACK_BUFFER_BINDING`](crate::enums::GL_PIXEL_UNPACK_BUFFER_BINDING)
    ///
    /// [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter)
    /// with arguments [`GL_TEXTURE_INTERNAL_FORMAT`](crate::enums::GL_TEXTURE_INTERNAL_FORMAT)
    /// and [`GL_TEXTURE_COMPRESSED_IMAGE_SIZE`](crate::enums::GL_TEXTURE_COMPRESSED_IMAGE_SIZE)

    pub unsafe fn oxidegl_compressed_tex_image2_d(
        &mut self,
        target: TextureTarget,
        level: GLint,
        internalformat: InternalFormat,
        width: GLsizei,
        height: GLsizei,
        border: GLint,
        image_size: GLsizei,
        data: *const GLvoid,
    ) {
        panic!("command oxidegl_compressed_tex_image2_d not yet implemented");
    }
    /// ### Parameters
    /// `target`
    ///
    /// > Specifies the target texture. Must be [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D),
    /// > [`GL_PROXY_TEXTURE_3D`](crate::enums::GL_PROXY_TEXTURE_3D), [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY)
    /// > or [`GL_PROXY_TEXTURE_2D_ARRAY`](crate::enums::GL_PROXY_TEXTURE_2D_ARRAY).
    ///
    /// `level`
    ///
    /// > Specifies the level-of-detail number. Level 0 is the base image level.
    /// > Level *n* is the *n* th mipmap reduction image.
    ///
    /// `internalformat`
    ///
    /// > Specifies the format of the compressed image data stored at address `data`.
    ///
    /// `width`
    ///
    /// > Specifies the width of the texture image. All implementations support 3D
    /// > texture images that are at least 16 texels wide.
    ///
    /// `height`
    ///
    /// > Specifies the height of the texture image. All implementations support
    /// > 3D texture images that are at least 16 texels high.
    ///
    /// `depth`
    ///
    /// > Specifies the depth of the texture image. All implementations support 3D
    /// > texture images that are at least 16 texels deep.
    ///
    /// `border`
    ///
    /// > This value must be 0.
    ///
    /// `imageSize`
    ///
    /// > Specifies the number of unsigned bytes of image data starting at the address
    /// > specified by `data`.
    ///
    /// `data`
    ///
    /// > Specifies a pointer to the compressed image data in memory.
    ///
    /// ### Description
    /// Texturing allows elements of an image array to be read by shaders.
    ///
    /// [**glCompressedTexImage3D**](crate::context::Context::oxidegl_compressed_tex_image3_d)
    /// loads a previously defined, and retrieved, compressed three-dimensional
    /// texture image if `target` is [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D)
    /// (see [**glTexImage3D**](crate::context::Context::oxidegl_tex_image3_d)
    /// ).
    ///
    /// If `target` is [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY),
    /// `data` is treated as an array of compressed 2D textures.
    ///
    /// If `target` is [`GL_PROXY_TEXTURE_3D`](crate::enums::GL_PROXY_TEXTURE_3D)
    /// or [`GL_PROXY_TEXTURE_2D_ARRAY`](crate::enums::GL_PROXY_TEXTURE_2D_ARRAY),
    /// no data is read from `data`, but all of the texture image state is recalculated,
    /// checked for consistency, and checked against the implementation's capabilities.
    /// If the implementation cannot handle a texture of the requested texture
    /// size, it sets all of the image state to 0, but does not generate an error
    /// (see [**glGetError**](crate::context::Context::oxidegl_get_error) ). To
    /// query for an entire mipmap array, use an image array level greater than
    /// or equal to 1.
    ///
    /// `internalformat` must be a known compressed image format (such as [`GL_RGTC`](crate::enums::GL_RGTC))
    /// or an extension-specified compressed-texture format. When a texture is
    /// loaded with [**glTexImage2D**](crate::context::Context::oxidegl_tex_image2_d)
    /// using a generic compressed texture format (e.g., [`GL_COMPRESSED_RGB`](crate::enums::GL_COMPRESSED_RGB)
    /// ), the GL selects from one of its extensions supporting compressed textures.
    /// In order to load the compressed texture image using [**glCompressedTexImage3D**](crate::context::Context::oxidegl_compressed_tex_image3_d),
    /// query the compressed texture image's size and format using [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter).
    ///
    /// If a non-zero named buffer object is bound to the [`GL_PIXEL_UNPACK_BUFFER`](crate::enums::GL_PIXEL_UNPACK_BUFFER)
    /// target (see [**glBindBuffer**](crate::context::Context::oxidegl_bind_buffer))
    /// while a texture image is specified, `data` is treated as a byte offset
    /// into the buffer object's data store.
    ///
    /// If the compressed data are arranged into fixed-size blocks of texels, the
    /// pixel storage modes can be used to select a sub-rectangle from a larger
    /// containing rectangle. These pixel storage modes operate in the same way
    /// as they do for [**glTexImage1D**](crate::context::Context::oxidegl_tex_image1_d).
    /// In the following description, denote by `[inlineq]` `[inlineq]` `[inlineq]`
    /// `[inlineq]` [`GL_UNPACK_COMPRESSED_BLOCK_SIZE`](crate::enums::GL_UNPACK_COMPRESSED_BLOCK_SIZE),
    /// [`GL_UNPACK_COMPRESSED_BLOCK_WIDTH`](crate::enums::GL_UNPACK_COMPRESSED_BLOCK_WIDTH),
    /// [`GL_UNPACK_COMPRESSED_BLOCK_HEIGHT`](crate::enums::GL_UNPACK_COMPRESSED_BLOCK_HEIGHT),
    /// and [`GL_UNPACK_COMPRESSED_BLOCK_DEPTH`](crate::enums::GL_UNPACK_COMPRESSED_BLOCK_DEPTH),
    /// respectively. `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]`
    ///
    /// By default the pixel storage modes [`GL_UNPACK_ROW_LENGTH`](crate::enums::GL_UNPACK_ROW_LENGTH),
    /// [`GL_UNPACK_SKIP_ROWS`](crate::enums::GL_UNPACK_SKIP_ROWS), [`GL_UNPACK_SKIP_PIXELS`](crate::enums::GL_UNPACK_SKIP_PIXELS),
    /// [`GL_UNPACK_IMAGE_HEIGHT`](crate::enums::GL_UNPACK_IMAGE_HEIGHT) and [`GL_UNPACK_SKIP_IMAGES`](crate::enums::GL_UNPACK_SKIP_IMAGES)
    /// are ignored for compressed images. To enable [`GL_UNPACK_SKIP_PIXELS`](crate::enums::GL_UNPACK_SKIP_PIXELS)
    /// and [`GL_UNPACK_ROW_LENGTH`](crate::enums::GL_UNPACK_ROW_LENGTH), `[inlineq]`
    /// `[inlineq]` [`GL_UNPACK_SKIP_ROWS`](crate::enums::GL_UNPACK_SKIP_ROWS)
    /// and [`GL_UNPACK_IMAGE_HEIGHT`](crate::enums::GL_UNPACK_IMAGE_HEIGHT), `[inlineq]`
    /// [`GL_UNPACK_SKIP_IMAGES`](crate::enums::GL_UNPACK_SKIP_IMAGES), `[inlineq]`
    ///
    /// When selecting a sub-rectangle from a compressed image: the value of [`GL_UNPACK_SKIP_PIXELS`](crate::enums::GL_UNPACK_SKIP_PIXELS)
    /// > must be a multiple of `[inlineq]`
    ///
    /// > the value of [`GL_UNPACK_SKIP_ROWS`](crate::enums::GL_UNPACK_SKIP_ROWS)
    /// > must be a multiple of `[inlineq]`
    ///
    /// > the value of [`GL_UNPACK_SKIP_IMAGES`](crate::enums::GL_UNPACK_SKIP_IMAGES)
    /// > must be a multiple of `[inlineq]`
    ///
    ///
    /// `imageSize` must be equal to:
    ///
    /// `[inlineq]`
    ///
    /// ### Associated Gets
    /// [**glGetCompressedTexImage**](crate::context::Context::oxidegl_get_compressed_tex_image)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_TEXTURE_COMPRESSED`](crate::enums::GL_TEXTURE_COMPRESSED)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_PIXEL_UNPACK_BUFFER_BINDING`](crate::enums::GL_PIXEL_UNPACK_BUFFER_BINDING)
    ///
    /// [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter)
    /// with arguments [`GL_TEXTURE_INTERNAL_FORMAT`](crate::enums::GL_TEXTURE_INTERNAL_FORMAT)
    /// and [`GL_TEXTURE_COMPRESSED_IMAGE_SIZE`](crate::enums::GL_TEXTURE_COMPRESSED_IMAGE_SIZE)

    pub unsafe fn oxidegl_compressed_tex_image3_d(
        &mut self,
        target: TextureTarget,
        level: GLint,
        internalformat: InternalFormat,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        border: GLint,
        image_size: GLsizei,
        data: *const GLvoid,
    ) {
        panic!("command oxidegl_compressed_tex_image3_d not yet implemented");
    }
    /// ### Parameters
    /// `srcName`
    ///
    /// > The name of a texture or renderbuffer object from which to copy.
    ///
    /// `srcTarget`
    ///
    /// > The target representing the namespace of the source name `srcName`.
    ///
    /// `srcLevel`
    ///
    /// > The mipmap level to read from the source.
    ///
    /// `srcX`
    ///
    /// > The X coordinate of the left edge of the souce region to copy.
    ///
    /// `srcY`
    ///
    /// > The Y coordinate of the top edge of the souce region to copy.
    ///
    /// `srcZ`
    ///
    /// > The Z coordinate of the near edge of the souce region to copy.
    ///
    /// `dstName`
    ///
    /// > The name of a texture or renderbuffer object to which to copy.
    ///
    /// `dstTarget`
    ///
    /// > The target representing the namespace of the destination name `dstName`.
    ///
    /// `dstX`
    ///
    /// > The X coordinate of the left edge of the destination region.
    ///
    /// `dstY`
    ///
    /// > The Y coordinate of the top edge of the destination region.
    ///
    /// `dstZ`
    ///
    /// > The Z coordinate of the near edge of the destination region.
    ///
    /// `srcWidth`
    ///
    /// > The width of the region to be copied.
    ///
    /// `srcHeight`
    ///
    /// > The height of the region to be copied.
    ///
    /// `srcDepth`
    ///
    /// > The depth of the region to be copied.
    ///
    /// ### Description
    /// [**glCopyImageSubData**](crate::context::Context::oxidegl_copy_image_sub_data)
    /// may be used to copy data from one image (i.e. texture or renderbuffer)
    /// to another. [**glCopyImageSubData**](crate::context::Context::oxidegl_copy_image_sub_data)
    /// does not perform general-purpose conversions such as scaling, resizing,
    /// blending, color-space, or format conversions. It should be considered to
    /// operate in a manner similar to a CPU memcpy. `CopyImageSubData` can copy
    /// between images with different internal formats, provided the formats are
    /// compatible.
    ///
    /// [**glCopyImageSubData**](crate::context::Context::oxidegl_copy_image_sub_data)
    /// also allows copying between certain types of compressed and uncompressed
    /// internal formats. This copy does not perform on-the-fly compression or
    /// decompression. When copying from an uncompressed internal format to a compressed
    /// internal format, each texel of uncompressed data becomes a single block
    /// of compressed data. When copying from a compressed internal format to an
    /// uncompressed internal format, a block of compressed data becomes a single
    /// texel of uncompressed data. The texel size of the uncompressed format must
    /// be the same size the block size of the compressed formats. Thus it is permitted
    /// to copy between a 128-bit uncompressed format and a compressed format which
    /// uses 8-bit 4x4 blocks, or between a 64-bit uncompressed format and a compressed
    /// format which uses 4-bit 4x4 blocks.
    ///
    /// The source object is identified by `srcName` and `srcTarget` and the destination
    /// object is identified by `dstName` and `dstTarget`. The interpretation of
    /// the name depends on the value of the corresponding `target` parameter.
    /// If `target` is [`GL_RENDERBUFFER`](crate::enums::GL_RENDERBUFFER), the
    /// name is interpreted as the name of a renderbuffer object. If the target
    /// parameter is a texture target, the name is interpreted as a texture object.
    /// All non-proxy texture targets are accepted, with the exception of [`GL_TEXTURE_BUFFER`](crate::enums::GL_TEXTURE_BUFFER)
    /// and the cubemap face selectors.
    ///
    /// `srcLevel` and `dstLevel` identify the source and destination level of
    /// detail. For textures, this must be a valid level of detail in the texture
    /// object. For renderbuffers, this value must be zero.
    ///
    /// `srcX`, `srcY`, and `srcZ` specify the lower left texel coordinates of
    /// a `srcWidth` -wide by `srcHeight` -high by `srcDepth` -deep rectangular
    /// subregion of the source texel array. Similarly, `dstX`, `dstY` and `dstZ`
    /// specify the coordinates of a subregion of the destination texel array.
    /// The source and destination subregions must be contained entirely within
    /// the specified level of the corresponding image objects.
    ///
    /// The dimensions are always specified in texels, even for compressed texture
    /// formats. However, it should be noted that if only one of the source and
    /// destination textures is compressed then the number of texels touched in
    /// the compressed image will be a factor of the block size larger than in
    /// the uncompressed image.
    ///
    /// Slices of a [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY),
    /// [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY), [`GL_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_CUBE_MAP_ARRAY)
    /// [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D) and faces of [`GL_TEXTURE_CUBE_MAP`](crate::enums::GL_TEXTURE_CUBE_MAP)
    /// are all compatible provided they share a compatible internal format, and
    /// multiple slices or faces may be copied between these objects with a single
    /// call by specifying the starting slice with `srcZ` and `dstZ`, and the number
    /// of slices to be copied with `srcDepth`. Cubemap textures always have six
    /// faces which are selected by a zero-based face index.
    ///
    /// For the purposes of `CopyImageSubData`, two internal formats are considered
    /// compatible if any of the following conditions are met: the formats are
    /// > the same,
    ///
    /// > the formats are considered compatible according to the compatibility rules
    /// > used for texture views as defined in section 3.9.X. In particular, if both
    /// > internal formats are listed in the same entry of Table 3.X.2, they are
    /// > considered compatible, or
    ///
    /// > one format is compressed and the other is uncompressed and Table 4.X.1
    /// > lists the two formats in the same row.
    ///
    ///
    /// |* Texel/ Block Size*                             |* Uncompressed Internal Format*                                   |* Compressed Internal Format(s)*                                   |
    /// |-------------------------------------------------|------------------------------------------------------------------|-------------------------------------------------------------------|
    /// | 64-bit                                          | [`GL_RGBA32UI`](crate::enums::GL_RGBA32UI), [`GL_RGBA32I`](crate::enums::GL_RGBA32I), [`GL_RGBA32F`](crate::enums::GL_RGBA32F) | [`GL_COMPRESSED_RGBA_S3TC_DXT3_EXT`](crate::enums::GL_COMPRESSED_RGBA_S3TC_DXT3_EXT), [`GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT`](crate::enums::GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT), [`GL_COMPRESSED_RGBA_S3TC_DXT5_EXT`](crate::enums::GL_COMPRESSED_RGBA_S3TC_DXT5_EXT), [`GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT`](crate::enums::GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT), [`GL_COMPRESSED_RG_RGTC2`](crate::enums::GL_COMPRESSED_RG_RGTC2), [`GL_COMPRESSED_SIGNED_RG_RGTC2`](crate::enums::GL_COMPRESSED_SIGNED_RG_RGTC2), [`GL_COMPRESSED_RGBA_BPTC_UNORM`](crate::enums::GL_COMPRESSED_RGBA_BPTC_UNORM), [`GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM`](crate::enums::GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM), [`GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT`](crate::enums::GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT), [`GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT`](crate::enums::GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT) |
    /// | 128-bit                                         | [`GL_RGBA16UI`](crate::enums::GL_RGBA16UI), [`GL_RGBA16I`](crate::enums::GL_RGBA16I), [`GL_RGBA16F`](crate::enums::GL_RGBA16F), [`GL_RG32F`](crate::enums::GL_RG32F), [`GL_RG32UI`](crate::enums::GL_RG32UI), [`GL_RG32I`](crate::enums::GL_RG32I), [`GL_RGBA16`](crate::enums::GL_RGBA16), [`GL_RGBA16_SNORM`](crate::enums::GL_RGBA16_SNORM) | [`GL_COMPRESSED_RGB_S3TC_DXT1_EXT`](crate::enums::GL_COMPRESSED_RGB_S3TC_DXT1_EXT), [`GL_COMPRESSED_SRGB_S3TC_DXT1_EXT`](crate::enums::GL_COMPRESSED_SRGB_S3TC_DXT1_EXT), [`GL_COMPRESSED_RGBA_S3TC_DXT1_EXT`](crate::enums::GL_COMPRESSED_RGBA_S3TC_DXT1_EXT), [`GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT`](crate::enums::GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT), [`GL_COMPRESSED_RED_RGTC1`](crate::enums::GL_COMPRESSED_RED_RGTC1), [`GL_COMPRESSED_SIGNED_RED_RGTC1`](crate::enums::GL_COMPRESSED_SIGNED_RED_RGTC1) |
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_COMPUTE_WORK_GROUP_COUNT`](crate::enums::GL_MAX_COMPUTE_WORK_GROUP_COUNT)

    pub fn oxidegl_copy_image_sub_data(
        &mut self,
        src_name: GLuint,
        src_target: CopyImageSubDataTarget,
        src_level: GLint,
        src_x: GLint,
        src_y: GLint,
        src_z: GLint,
        dst_name: GLuint,
        dst_target: CopyImageSubDataTarget,
        dst_level: GLint,
        dst_x: GLint,
        dst_y: GLint,
        dst_z: GLint,
        src_width: GLsizei,
        src_height: GLsizei,
        src_depth: GLsizei,
    ) {
        panic!("command oxidegl_copy_image_sub_data not yet implemented");
    }
    /// ### Parameters
    /// `target`
    ///
    /// > Specifies the target texture. Must be [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D).
    ///
    /// `level`
    ///
    /// > Specifies the level-of-detail number. Level 0 is the base image level.
    /// > Level *n* is the *n* th mipmap reduction image.
    ///
    /// `internalformat`
    ///
    /// > Specifies the internal format of the texture. Must be one of the following
    /// > symbolic constants: [`GL_COMPRESSED_RED`](crate::enums::GL_COMPRESSED_RED),
    /// > [`GL_COMPRESSED_RG`](crate::enums::GL_COMPRESSED_RG), [`GL_COMPRESSED_RGB`](crate::enums::GL_COMPRESSED_RGB),
    /// > [`GL_COMPRESSED_RGBA`](crate::enums::GL_COMPRESSED_RGBA). [`GL_COMPRESSED_SRGB`](crate::enums::GL_COMPRESSED_SRGB),
    /// > [`GL_COMPRESSED_SRGB_ALPHA`](crate::enums::GL_COMPRESSED_SRGB_ALPHA). [`GL_DEPTH_COMPONENT`](crate::enums::GL_DEPTH_COMPONENT),
    /// > [`GL_DEPTH_COMPONENT16`](crate::enums::GL_DEPTH_COMPONENT16), [`GL_DEPTH_COMPONENT24`](crate::enums::GL_DEPTH_COMPONENT24),
    /// > [`GL_DEPTH_COMPONENT32`](crate::enums::GL_DEPTH_COMPONENT32), [`GL_STENCIL_INDEX8`](crate::enums::GL_STENCIL_INDEX8),
    /// > [`GL_RED`](crate::enums::GL_RED), [`GL_RG`](crate::enums::GL_RG), [`GL_RGB`](crate::enums::GL_RGB),
    /// > [`GL_R3_G3_B2`](crate::enums::GL_R3_G3_B2), [`GL_RGB4`](crate::enums::GL_RGB4),
    /// > [`GL_RGB5`](crate::enums::GL_RGB5), [`GL_RGB8`](crate::enums::GL_RGB8),
    /// > [`GL_RGB10`](crate::enums::GL_RGB10), [`GL_RGB12`](crate::enums::GL_RGB12),
    /// > [`GL_RGB16`](crate::enums::GL_RGB16), [`GL_RGBA`](crate::enums::GL_RGBA),
    /// > [`GL_RGBA2`](crate::enums::GL_RGBA2), [`GL_RGBA4`](crate::enums::GL_RGBA4),
    /// > [`GL_RGB5_A1`](crate::enums::GL_RGB5_A1), [`GL_RGBA8`](crate::enums::GL_RGBA8),
    /// > [`GL_RGB10_A2`](crate::enums::GL_RGB10_A2), [`GL_RGBA12`](crate::enums::GL_RGBA12),
    /// > [`GL_RGBA16`](crate::enums::GL_RGBA16), [`GL_SRGB`](crate::enums::GL_SRGB),
    /// > [`GL_SRGB8`](crate::enums::GL_SRGB8), [`GL_SRGB_ALPHA`](crate::enums::GL_SRGB_ALPHA),
    /// > or [`GL_SRGB8_ALPHA8`](crate::enums::GL_SRGB8_ALPHA8).
    ///
    /// `x`
    ///
    /// `y`
    ///
    /// > Specify the window coordinates of the left corner of the row of pixels
    /// > to be copied.
    ///
    /// `width`
    ///
    /// > Specifies the width of the texture image. The height of the texture image
    /// > is 1.
    ///
    /// `border`
    ///
    /// > Must be 0.
    ///
    /// ### Description
    /// [**glCopyTexImage1D**](crate::context::Context::oxidegl_copy_tex_image1_d)
    /// defines a one-dimensional texture image with pixels from the current [`GL_READ_BUFFER`](crate::enums::GL_READ_BUFFER).
    ///
    /// The screen-aligned pixel row with left corner at `[inlineq]` `[inlineq]`
    /// `level`. `internalformat` specifies the internal format of the texture
    /// array.
    ///
    /// The pixels in the row are processed exactly as if [**glReadPixels**](crate::context::Context::oxidegl_read_pixels)
    /// had been called, but the process stops just before final conversion. At
    /// this point all pixel component values are clamped to the range `[inlineq]`
    ///
    /// Pixel ordering is such that lower `[inlineq]`
    ///
    /// If any of the pixels within the specified row of the current [`GL_READ_BUFFER`](crate::enums::GL_READ_BUFFER)
    /// are outside the window associated with the current rendering context, then
    /// the values obtained for those pixels are undefined.
    ///
    /// [**glCopyTexImage1D**](crate::context::Context::oxidegl_copy_tex_image1_d)
    /// defines a one-dimensional texture image with pixels from the current [`GL_READ_BUFFER`](crate::enums::GL_READ_BUFFER).
    ///
    /// When `internalformat` is one of the sRGB types, the GL does not automatically
    /// convert the source pixels to the sRGB color space. In this case, the [**glPixelMap**](crate::context::Context::oxidegl_pixel_map)
    /// function can be used to accomplish the conversion.
    ///
    /// ### Notes
    /// 1, 2, 3, and 4 are not accepted values for `internalformat`.
    ///
    /// An image with 0 width indicates a NULL texture.
    ///
    /// [`GL_STENCIL_INDEX8`](crate::enums::GL_STENCIL_INDEX8) is accepted for
    /// `internalformat` only if the GL version is 4.4 or higher.
    ///
    /// ### Associated Gets
    /// [**glGetTexImage**](crate::context::Context::oxidegl_get_tex_image)

    pub fn oxidegl_copy_tex_image1_d(
        &mut self,
        target: TextureTarget,
        level: GLint,
        internalformat: InternalFormat,
        x: GLint,
        y: GLint,
        width: GLsizei,
        border: GLint,
    ) {
        panic!("command oxidegl_copy_tex_image1_d not yet implemented");
    }
    /// ### Parameters
    /// `target`
    ///
    /// > Specifies the target texture. Must be [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D),
    /// > [`GL_TEXTURE_CUBE_MAP_POSITIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_X),
    /// > [`GL_TEXTURE_CUBE_MAP_NEGATIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_X),
    /// > [`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Y),
    /// > [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Y),
    /// > [`GL_TEXTURE_CUBE_MAP_POSITIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Z),
    /// > or [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Z).
    ///
    /// `level`
    ///
    /// > Specifies the level-of-detail number. Level 0 is the base image level.
    /// > Level *n* is the *n* th mipmap reduction image.
    ///
    /// `internalformat`
    ///
    /// > Specifies the internal format of the texture. Must be one of the following
    /// > symbolic constants: [`GL_COMPRESSED_RED`](crate::enums::GL_COMPRESSED_RED),
    /// > [`GL_COMPRESSED_RG`](crate::enums::GL_COMPRESSED_RG), [`GL_COMPRESSED_RGB`](crate::enums::GL_COMPRESSED_RGB),
    /// > [`GL_COMPRESSED_RGBA`](crate::enums::GL_COMPRESSED_RGBA). [`GL_COMPRESSED_SRGB`](crate::enums::GL_COMPRESSED_SRGB),
    /// > [`GL_COMPRESSED_SRGB_ALPHA`](crate::enums::GL_COMPRESSED_SRGB_ALPHA). [`GL_DEPTH_COMPONENT`](crate::enums::GL_DEPTH_COMPONENT),
    /// > [`GL_DEPTH_COMPONENT16`](crate::enums::GL_DEPTH_COMPONENT16), [`GL_DEPTH_COMPONENT24`](crate::enums::GL_DEPTH_COMPONENT24),
    /// > [`GL_DEPTH_COMPONENT32`](crate::enums::GL_DEPTH_COMPONENT32), [`GL_STENCIL_INDEX8`](crate::enums::GL_STENCIL_INDEX8),
    /// > [`GL_RED`](crate::enums::GL_RED), [`GL_RG`](crate::enums::GL_RG), [`GL_RGB`](crate::enums::GL_RGB),
    /// > [`GL_R3_G3_B2`](crate::enums::GL_R3_G3_B2), [`GL_RGB4`](crate::enums::GL_RGB4),
    /// > [`GL_RGB5`](crate::enums::GL_RGB5), [`GL_RGB8`](crate::enums::GL_RGB8),
    /// > [`GL_RGB10`](crate::enums::GL_RGB10), [`GL_RGB12`](crate::enums::GL_RGB12),
    /// > [`GL_RGB16`](crate::enums::GL_RGB16), [`GL_RGBA`](crate::enums::GL_RGBA),
    /// > [`GL_RGBA2`](crate::enums::GL_RGBA2), [`GL_RGBA4`](crate::enums::GL_RGBA4),
    /// > [`GL_RGB5_A1`](crate::enums::GL_RGB5_A1), [`GL_RGBA8`](crate::enums::GL_RGBA8),
    /// > [`GL_RGB10_A2`](crate::enums::GL_RGB10_A2), [`GL_RGBA12`](crate::enums::GL_RGBA12),
    /// > [`GL_RGBA16`](crate::enums::GL_RGBA16), [`GL_SRGB`](crate::enums::GL_SRGB),
    /// > [`GL_SRGB8`](crate::enums::GL_SRGB8), [`GL_SRGB_ALPHA`](crate::enums::GL_SRGB_ALPHA),
    /// > or [`GL_SRGB8_ALPHA8`](crate::enums::GL_SRGB8_ALPHA8).
    ///
    /// `x`
    ///
    /// `y`
    ///
    /// > Specify the window coordinates of the lower left corner of the rectangular
    /// > region of pixels to be copied.
    ///
    /// `width`
    ///
    /// > Specifies the width of the texture image.
    ///
    /// `height`
    ///
    /// > Specifies the height of the texture image.
    ///
    /// `border`
    ///
    /// > Must be 0.
    ///
    /// ### Description
    /// [**glCopyTexImage2D**](crate::context::Context::oxidegl_copy_tex_image2_d)
    /// defines a two-dimensional texture image, or cube-map texture image with
    /// pixels from the current [`GL_READ_BUFFER`](crate::enums::GL_READ_BUFFER).
    ///
    /// The screen-aligned pixel rectangle with lower left corner at( `x`, `y`)
    /// and with a width of `[inlineq]` `[inlineq]` `level`. `internalformat`
    /// specifies the internal format of the texture array.
    ///
    /// The pixels in the rectangle are processed exactly as if [**glReadPixels**](crate::context::Context::oxidegl_read_pixels)
    /// had been called, but the process stops just before final conversion. At
    /// this point all pixel component values are clamped to the range `[inlineq]`
    ///
    /// Pixel ordering is such that lower `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]`
    ///
    /// If any of the pixels within the specified rectangle of the current [`GL_READ_BUFFER`](crate::enums::GL_READ_BUFFER)
    /// are outside the window associated with the current rendering context, then
    /// the values obtained for those pixels are undefined.
    ///
    /// When `internalformat` is one of the sRGB types, the GL does not automatically
    /// convert the source pixels to the sRGB color space. In this case, the [**glPixelMap**](crate::context::Context::oxidegl_pixel_map)
    /// function can be used to accomplish the conversion.
    ///
    /// ### Notes
    /// 1, 2, 3, and 4 are not accepted values for `internalformat`.
    ///
    /// An image with height or width of 0 indicates a NULL texture.
    ///
    /// [`GL_STENCIL_INDEX8`](crate::enums::GL_STENCIL_INDEX8) is accepted for
    /// `internalformat` only if the GL version is 4.4 or higher.
    ///
    /// ### Associated Gets
    /// [**glGetTexImage**](crate::context::Context::oxidegl_get_tex_image)

    pub fn oxidegl_copy_tex_image2_d(
        &mut self,
        target: TextureTarget,
        level: GLint,
        internalformat: InternalFormat,
        x: GLint,
        y: GLint,
        width: GLsizei,
        height: GLsizei,
        border: GLint,
    ) {
        panic!("command oxidegl_copy_tex_image2_d not yet implemented");
    }
    /// ### Parameters
    /// `n`
    ///
    /// > Number of framebuffer objects to create.
    ///
    /// `framebuffers`
    ///
    /// > Specifies an array in which names of the new framebuffer objects are stored.
    ///
    /// ### Description
    /// [**glCreateFramebuffers**](crate::context::Context::oxidegl_create_framebuffers)
    /// returns `n` previously unused framebuffer names in `framebuffers`, each
    /// representing a new framebuffer object initialized to the default state.

    pub unsafe fn oxidegl_create_framebuffers(&mut self, n: GLsizei, framebuffers: *mut GLuint) {
        panic!("command oxidegl_create_framebuffers not yet implemented");
    }
    /// ### Description
    /// [**glCreateProgram**](crate::context::Context::oxidegl_create_program)
    /// creates an empty program object and returns a non-zero value by which it
    /// can be referenced. A program object is an object to which shader objects
    /// can be attached. This provides a mechanism to specify the shader objects
    /// that will be linked to create a program. It also provides a means for checking
    /// the compatibility of the shaders that will be used to create a program
    /// (for instance, checking the compatibility between a vertex shader and a
    /// fragment shader). When no longer needed as part of a program object, shader
    /// objects can be detached.
    ///
    /// One or more executables are created in a program object by successfully
    /// attaching shader objects to it with [**glAttachShader**](crate::context::Context::oxidegl_attach_shader),
    /// successfully compiling the shader objects with [**glCompileShader**](crate::context::Context::oxidegl_compile_shader),
    /// and successfully linking the program object with [**glLinkProgram**](crate::context::Context::oxidegl_link_program).
    /// These executables are made part of current state when [**glUseProgram**](crate::context::Context::oxidegl_use_program)
    /// is called. Program objects can be deleted by calling [**glDeleteProgram**](crate::context::Context::oxidegl_delete_program).
    /// The memory associated with the program object will be deleted when it
    /// is no longer part of current rendering state for any context.
    ///
    /// ### Notes
    /// Like buffer and texture objects, the name space for program objects may
    /// be shared across a set of contexts, as long as the server sides of the
    /// contexts share the same address space. If the name space is shared across
    /// contexts, any attached objects and the data associated with those attached
    /// objects are shared as well.
    ///
    /// Applications are responsible for providing the synchronization across API
    /// calls when objects are accessed from different execution threads.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with the argument [`GL_CURRENT_PROGRAM`](crate::enums::GL_CURRENT_PROGRAM)
    ///
    /// [**glGetActiveAttrib**](crate::context::Context::oxidegl_get_active_attrib)
    /// with a valid program object and the index of an active attribute variable
    ///
    /// [**glGetActiveUniform**](crate::context::Context::oxidegl_get_active_uniform)
    /// with a valid program object and the index of an active uniform variable
    ///
    /// [**glGetAttachedShaders**](crate::context::Context::oxidegl_get_attached_shaders)
    /// with a valid program object
    ///
    /// [**glGetAttribLocation**](crate::context::Context::oxidegl_get_attrib_location)
    /// with a valid program object and the name of an attribute variable
    ///
    /// [**glGetProgram**](crate::context::Context::oxidegl_get_program) with a
    /// valid program object and the parameter to be queried
    ///
    /// [**glGetProgramInfoLog**](crate::context::Context::oxidegl_get_program_info_log)
    /// with a valid program object
    ///
    /// [**glGetUniform**](crate::context::Context::oxidegl_get_uniform) with a
    /// valid program object and the location of a uniform variable
    ///
    /// [**glGetUniformLocation**](crate::context::Context::oxidegl_get_uniform_location)
    /// with a valid program object and the name of a uniform variable
    ///
    /// [**glIsProgram**](crate::context::Context::oxidegl_is_program)

    pub fn oxidegl_create_program(&mut self) -> GLuint {
        panic!("command oxidegl_create_program not yet implemented");
    }
    /// ### Parameters
    /// `n`
    ///
    /// > Number of program pipeline objects to create.
    ///
    /// `pipelines`
    ///
    /// > Specifies an array in which names of the new program pipeline objects are
    /// > stored.
    ///
    /// ### Description
    /// [**glCreateProgramPipelines**](crate::context::Context::oxidegl_create_program_pipelines)
    /// returns `n` previously unused program pipeline names in `pipelines`, each
    /// representing a new program pipeline object initialized to the default state.

    pub unsafe fn oxidegl_create_program_pipelines(&mut self, n: GLsizei, pipelines: *mut GLuint) {
        panic!("command oxidegl_create_program_pipelines not yet implemented");
    }
    /// ### Parameters
    /// `target`
    ///
    /// > Specifies the target of each created query object.
    ///
    /// `n`
    ///
    /// > Number of query objects to create.
    ///
    /// `ids`
    ///
    /// > Specifies an array in which names of the new query objects are stored.
    ///
    /// ### Description
    /// [**glCreateQueries**](crate::context::Context::oxidegl_create_queries)
    /// returns `n` previously unused query object names in `ids`, each representing
    /// a new query object with the specified `target`.
    ///
    /// `target` may be one of [`GL_SAMPLES_PASSED`](crate::enums::GL_SAMPLES_PASSED),
    /// [`GL_ANY_SAMPLES_PASSED`](crate::enums::GL_ANY_SAMPLES_PASSED), [`GL_ANY_SAMPLES_PASSED_CONSERVATIVE`](crate::enums::GL_ANY_SAMPLES_PASSED_CONSERVATIVE),
    /// [`GL_TIME_ELAPSED`](crate::enums::GL_TIME_ELAPSED), [`GL_TIMESTAMP`](crate::enums::GL_TIMESTAMP),
    /// [`GL_PRIMITIVES_GENERATED`](crate::enums::GL_PRIMITIVES_GENERATED) or [`GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`](crate::enums::GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN).

    pub unsafe fn oxidegl_create_queries(
        &mut self,
        target: QueryTarget,
        n: GLsizei,
        ids: *mut GLuint,
    ) {
        panic!("command oxidegl_create_queries not yet implemented");
    }
    /// ### Parameters
    /// `n`
    ///
    /// > Number of renderbuffer objects to create.
    ///
    /// `renderbuffers`
    ///
    /// > Specifies an array in which names of the new renderbuffer objects are stored.
    ///
    /// ### Description
    /// [**glCreateRenderbuffers**](crate::context::Context::oxidegl_create_renderbuffers)
    /// returns `n` previously unused renderbuffer object names in `renderbuffers`,
    /// each representing a new renderbuffer object initialized to the default
    /// state.

    pub unsafe fn oxidegl_create_renderbuffers(&mut self, n: GLsizei, renderbuffers: *mut GLuint) {
        panic!("command oxidegl_create_renderbuffers not yet implemented");
    }
    /// ### Parameters
    /// `n`
    ///
    /// > Number of sampler objects to create.
    ///
    /// `samplers`
    ///
    /// > Specifies an array in which names of the new sampler objects are stored.
    ///
    /// ### Description
    /// [**glCreateSamplers**](crate::context::Context::oxidegl_create_samplers)
    /// returns `n` previously unused sampler names in `samplers`, each representing
    /// a new sampler object initialized to the default state.

    pub unsafe fn oxidegl_create_samplers(&mut self, n: GLsizei, samplers: *mut GLuint) {
        panic!("command oxidegl_create_samplers not yet implemented");
    }
    /// ### Parameters
    /// `shaderType`
    ///
    /// > Specifies the type of shader to be created. Must be one of [`GL_COMPUTE_SHADER`](crate::enums::GL_COMPUTE_SHADER),
    /// > [`GL_VERTEX_SHADER`](crate::enums::GL_VERTEX_SHADER), [`GL_TESS_CONTROL_SHADER`](crate::enums::GL_TESS_CONTROL_SHADER),
    /// > [`GL_TESS_EVALUATION_SHADER`](crate::enums::GL_TESS_EVALUATION_SHADER),
    /// > [`GL_GEOMETRY_SHADER`](crate::enums::GL_GEOMETRY_SHADER), or [`GL_FRAGMENT_SHADER`](crate::enums::GL_FRAGMENT_SHADER).
    ///
    /// ### Description
    /// [**glCreateShader**](crate::context::Context::oxidegl_create_shader) creates
    /// an empty shader object and returns a non-zero value by which it can be
    /// referenced. A shader object is used to maintain the source code strings
    /// that define a shader. `shaderType` indicates the type of shader to be created.
    /// Five types of shader are supported. A shader of type [`GL_COMPUTE_SHADER`](crate::enums::GL_COMPUTE_SHADER)
    /// is a shader that is intended to run on the programmable compute processor.
    /// A shader of type [`GL_VERTEX_SHADER`](crate::enums::GL_VERTEX_SHADER) is
    /// a shader that is intended to run on the programmable vertex processor.
    /// A shader of type [`GL_TESS_CONTROL_SHADER`](crate::enums::GL_TESS_CONTROL_SHADER)
    /// is a shader that is intended to run on the programmable tessellation processor
    /// in the control stage. A shader of type [`GL_TESS_EVALUATION_SHADER`](crate::enums::GL_TESS_EVALUATION_SHADER)
    /// is a shader that is intended to run on the programmable tessellation processor
    /// in the evaluation stage. A shader of type [`GL_GEOMETRY_SHADER`](crate::enums::GL_GEOMETRY_SHADER)
    /// is a shader that is intended to run on the programmable geometry processor.
    /// A shader of type [`GL_FRAGMENT_SHADER`](crate::enums::GL_FRAGMENT_SHADER)
    /// is a shader that is intended to run on the programmable fragment processor.
    ///
    /// When created, a shader object's [`GL_SHADER_TYPE`](crate::enums::GL_SHADER_TYPE)
    /// parameter is set to either [`GL_COMPUTE_SHADER`](crate::enums::GL_COMPUTE_SHADER),
    /// [`GL_VERTEX_SHADER`](crate::enums::GL_VERTEX_SHADER), [`GL_TESS_CONTROL_SHADER`](crate::enums::GL_TESS_CONTROL_SHADER),
    /// [`GL_TESS_EVALUATION_SHADER`](crate::enums::GL_TESS_EVALUATION_SHADER),
    /// [`GL_GEOMETRY_SHADER`](crate::enums::GL_GEOMETRY_SHADER) or [`GL_FRAGMENT_SHADER`](crate::enums::GL_FRAGMENT_SHADER),
    /// depending on the value of `shaderType`.
    ///
    /// ### Notes
    /// Like buffer and texture objects, the name space for shader objects may
    /// be shared across a set of contexts, as long as the server sides of the
    /// contexts share the same address space. If the name space is shared across
    /// contexts, any attached objects and the data associated with those attached
    /// objects are shared as well.
    ///
    /// Applications are responsible for providing the synchronization across API
    /// calls when objects are accessed from different execution threads.
    ///
    /// [`GL_COMPUTE_SHADER`](crate::enums::GL_COMPUTE_SHADER) is available only
    /// if the GL version is 4.3 or higher.
    ///
    /// ### Associated Gets
    /// [**glGetShader**](crate::context::Context::oxidegl_get_shader) with a valid
    /// shader object and the parameter to be queried
    ///
    /// [**glGetShaderInfoLog**](crate::context::Context::oxidegl_get_shader_info_log)
    /// with a valid shader object
    ///
    /// [**glGetShaderSource**](crate::context::Context::oxidegl_get_shader_source)
    /// with a valid shader object
    ///
    /// [**glIsShader**](crate::context::Context::oxidegl_is_shader)

    pub fn oxidegl_create_shader(&mut self, r#type: ShaderType) -> GLuint {
        panic!("command oxidegl_create_shader not yet implemented");
    }
    /// ### Parameters
    /// `type`
    ///
    /// > Specifies the type of shader to create.
    ///
    /// `count`
    ///
    /// > Specifies the number of source code strings in the array `strings`.
    ///
    /// `strings`
    ///
    /// > Specifies the address of an array of pointers to source code strings from
    /// > which to create the program object.
    ///
    /// ### Description
    /// [**glCreateShaderProgram**](crate::context::Context::oxidegl_create_shader_program)
    /// creates a program object containing compiled and linked shaders for a single
    /// stage specified by `type`. `strings` refers to an array of `count` strings
    /// from which to create the shader executables.
    ///
    /// [**glCreateShaderProgram**](crate::context::Context::oxidegl_create_shader_program)
    /// is equivalent (assuming no errors are generated) to:
    ///
    /// The program object created by [**glCreateShaderProgram**](crate::context::Context::oxidegl_create_shader_program)
    /// has its [`GL_PROGRAM_SEPARABLE`](crate::enums::GL_PROGRAM_SEPARABLE) status
    /// set to [`GL_TRUE`](crate::enums::GL_TRUE).

    pub fn oxidegl_create_shader_programv(
        &mut self,
        r#type: ShaderType,
        count: GLsizei,
        strings: GLchar,
    ) -> GLuint {
        panic!("command oxidegl_create_shader_programv not yet implemented");
    }
    /// ### Parameters
    /// `target`
    ///
    /// > Specifies the effective texture target of each created texture.
    ///
    /// `n`
    ///
    /// > Number of texture objects to create.
    ///
    /// `textures`
    ///
    /// > Specifies an array in which names of the new texture objects are stored.
    ///
    /// ### Description
    /// [**glCreateTextures**](crate::context::Context::oxidegl_create_textures)
    /// returns `n` previously unused texture names in `textures`, each representing
    /// a new texture object of the dimensionality and type specified by `target`
    /// and initialized to the default values for that texture type.
    ///
    /// `target` must be one of [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D),
    /// [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D), [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D),
    /// [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY), [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY),
    /// [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE), [`GL_TEXTURE_CUBE_MAP`](crate::enums::GL_TEXTURE_CUBE_MAP),
    /// [`GL_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_CUBE_MAP_ARRAY),
    /// [`GL_TEXTURE_BUFFER`](crate::enums::GL_TEXTURE_BUFFER), [`GL_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE)
    /// or [`GL_TEXTURE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE_ARRAY).

    pub unsafe fn oxidegl_create_textures(
        &mut self,
        target: TextureTarget,
        n: GLsizei,
        textures: *mut GLuint,
    ) {
        panic!("command oxidegl_create_textures not yet implemented");
    }
    /// ### Parameters
    /// `n`
    ///
    /// > Number of transform feedback objects to create.
    ///
    /// `ids`
    ///
    /// > Specifies an array in which names of the new transform feedback objects
    /// > are stored.
    ///
    /// ### Description
    /// [**glCreateTransformFeedbacks**](crate::context::Context::oxidegl_create_transform_feedbacks)
    /// returns `n` previously unused transform feedback object names in `ids`,
    /// each representing a new transform feedback object initialized to the default
    /// state.

    pub unsafe fn oxidegl_create_transform_feedbacks(&mut self, n: GLsizei, ids: *mut GLuint) {
        panic!("command oxidegl_create_transform_feedbacks not yet implemented");
    }
    /// ### Parameters
    /// `mode`
    ///
    /// > Specifies whether front- or back-facing facets are candidates for culling.
    /// > Symbolic constants [`GL_FRONT`](crate::enums::GL_FRONT), [`GL_BACK`](crate::enums::GL_BACK),
    /// > and [`GL_FRONT_AND_BACK`](crate::enums::GL_FRONT_AND_BACK) are accepted.
    /// > The initial value is [`GL_BACK`](crate::enums::GL_BACK).
    ///
    /// ### Description
    /// [**glCullFace**](crate::context::Context::oxidegl_cull_face) specifies
    /// whether front- or back-facing facets are culled (as specified by *mode*)
    /// when facet culling is enabled. Facet culling is initially disabled. To
    /// enable and disable facet culling, call the [**glEnable**](crate::context::Context::oxidegl_enable)
    /// and [**glDisable**](crate::context::Context::oxidegl_disable) commands
    /// with the argument [`GL_CULL_FACE`](crate::enums::GL_CULL_FACE). Facets
    /// include triangles, quadrilaterals, polygons, and rectangles.
    ///
    /// [**glFrontFace**](crate::context::Context::oxidegl_front_face) specifies
    /// which of the clockwise and counterclockwise facets are front-facing and
    /// back-facing. See [**glFrontFace**](crate::context::Context::oxidegl_front_face).
    ///
    /// ### Notes
    /// If `mode` is [`GL_FRONT_AND_BACK`](crate::enums::GL_FRONT_AND_BACK), no
    /// facets are drawn, but other primitives such as points and lines are drawn.
    ///
    /// ### Associated Gets
    /// [**glIsEnabled**](crate::context::Context::oxidegl_is_enabled) with argument
    /// [`GL_CULL_FACE`](crate::enums::GL_CULL_FACE)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_CULL_FACE_MODE`](crate::enums::GL_CULL_FACE_MODE)

    pub fn oxidegl_cull_face(&mut self, mode: TriangleFace) {
        panic!("command oxidegl_cull_face not yet implemented");
    }
    /// ### Parameters
    /// `callback`
    ///
    /// > The address of a callback function that will be called when a debug message
    /// > is generated.
    ///
    /// `userParam`
    ///
    /// > A user supplied pointer that will be passed on each invocation of `callback`.
    ///
    /// ### Description
    /// [**glDebugMessageCallback**](crate::context::Context::oxidegl_debug_message_callback)
    /// sets the current debug output callback function to the function whose address
    /// is given in `callback`. The callback function should have the following
    /// prototype (in C), or be otherwise compatible with such a prototype:
    ///
    /// This function is defined to have the same calling convention as the GL
    /// API functions. In most cases this is defined as
    ///
    /// Each time a debug message is generated the debug callback function will
    /// be invoked with `source`, `type`, `id`, and `severity` associated with
    /// the message, and `length` set to the length of debug message whose character
    /// string is in the array pointed to by `message`. `userParam` will be set
    /// to the value passed in the `userParam` parameter to the most recent call
    /// to [**glDebugMessageCallback**](crate::context::Context::oxidegl_debug_message_callback).
    ///
    /// ### Notes
    /// When the GL is in use remotely, the server may not be able to call functions
    /// in the client's address space. In such cases, the callback function may
    /// not be invoked and the user should retrieve debug messages from the context's
    /// debug message log by calling [**glGetDebugMessageLog**](crate::context::Context::oxidegl_get_debug_message_log).

    pub unsafe fn oxidegl_debug_message_callback(
        &mut self,
        callback: GLDEBUGPROC,
        user_param: *const GLvoid,
    ) {
        panic!("command oxidegl_debug_message_callback not yet implemented");
    }
    /// ### Parameters
    /// `source`
    ///
    /// > The source of debug messages to enable or disable.
    ///
    /// `type`
    ///
    /// > The type of debug messages to enable or disable.
    ///
    /// `severity`
    ///
    /// > The severity of debug messages to enable or disable.
    ///
    /// `count`
    ///
    /// > The length of the array `ids`.
    ///
    /// `ids`
    ///
    /// > The address of an array of unsigned integers contianing the ids of the
    /// > messages to enable or disable.
    ///
    /// `enabled`
    ///
    /// > A Boolean flag determining whether the selected messages should be enabled
    /// > or disabled.
    ///
    /// ### Description
    /// [**glDebugMessageControl**](crate::context::Context::oxidegl_debug_message_control)
    /// controls the reporting of debug messages generated by a debug context.
    /// The parameters `source`, `type` and `severity` form a filter to select
    /// messages from the pool of potential messages generated by the GL.
    ///
    /// `source` may be [`GL_DEBUG_SOURCE_API`](crate::enums::GL_DEBUG_SOURCE_API),
    /// [`GL_DEBUG_SOURCE_WINDOW_SYSTEM_`](crate::enums::GL_DEBUG_SOURCE_WINDOW_SYSTEM_),
    /// [`GL_DEBUG_SOURCE_SHADER_COMPILER`](crate::enums::GL_DEBUG_SOURCE_SHADER_COMPILER),
    /// [`GL_DEBUG_SOURCE_THIRD_PARTY`](crate::enums::GL_DEBUG_SOURCE_THIRD_PARTY),
    /// [`GL_DEBUG_SOURCE_APPLICATION`](crate::enums::GL_DEBUG_SOURCE_APPLICATION),
    /// [`GL_DEBUG_SOURCE_OTHER`](crate::enums::GL_DEBUG_SOURCE_OTHER) to select
    /// messages generated by usage of the GL API, the window system, the shader
    /// compiler, third party tools or libraries, explicitly by the application
    /// or by some other source, respectively. It may also take the value [`GL_DONT_CARE`](crate::enums::GL_DONT_CARE).
    /// If `source` is not [`GL_DONT_CARE`](crate::enums::GL_DONT_CARE) then only
    /// messages whose source matches `source` will be referenced.
    ///
    /// `type` may be one of [`GL_DEBUG_TYPE_ERROR`](crate::enums::GL_DEBUG_TYPE_ERROR),
    /// [`GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR`](crate::enums::GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR),
    /// [`GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR`](crate::enums::GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR),
    /// [`GL_DEBUG_TYPE_PORTABILITY`](crate::enums::GL_DEBUG_TYPE_PORTABILITY),
    /// [`GL_DEBUG_TYPE_PERFORMANCE`](crate::enums::GL_DEBUG_TYPE_PERFORMANCE),
    /// [`GL_DEBUG_TYPE_MARKER`](crate::enums::GL_DEBUG_TYPE_MARKER), [`GL_DEBUG_TYPE_PUSH_GROUP`](crate::enums::GL_DEBUG_TYPE_PUSH_GROUP),
    /// [`GL_DEBUG_TYPE_POP_GROUP`](crate::enums::GL_DEBUG_TYPE_POP_GROUP), or
    /// [`GL_DEBUG_TYPE_OTHER`](crate::enums::GL_DEBUG_TYPE_OTHER) to indicate
    /// the type of messages describing GL errors, attempted use of deprecated
    /// features, triggering of undefined behavior, portability issues, performance
    /// notifications, markers, group push and pop events, and other types of messages,
    /// respectively. It may also take the value [`GL_DONT_CARE`](crate::enums::GL_DONT_CARE).
    /// If `type` is not [`GL_DONT_CARE`](crate::enums::GL_DONT_CARE) then only
    /// messages whose type matches `type` will be referenced.
    ///
    /// `severity` may be one of [`GL_DEBUG_SEVERITY_LOW`](crate::enums::GL_DEBUG_SEVERITY_LOW),
    /// [`GL_DEBUG_SEVERITY_MEDIUM`](crate::enums::GL_DEBUG_SEVERITY_MEDIUM), or
    /// [`GL_DEBUG_SEVERITY_HIGH`](crate::enums::GL_DEBUG_SEVERITY_HIGH) to select
    /// messages of low, medium or high severity messages or to [`GL_DEBUG_SEVERITY_NOTIFICATION`](crate::enums::GL_DEBUG_SEVERITY_NOTIFICATION)
    /// for notifications. It may also take the value [`GL_DONT_CARE`](crate::enums::GL_DONT_CARE).
    /// If `severity` is not [`GL_DONT_CARE`](crate::enums::GL_DONT_CARE) then
    /// only messages whose severity matches `severity` will be referenced.
    ///
    /// `ids` contains a list of `count` message identifiers to select specific
    /// messages from the pool of available messages. If `count` is zero then the
    /// value of `ids` is ignored. Otherwise, only messages appearing in this list
    /// are selected. In this case, `source` and `type` may not be [`GL_DONT_CARE`](crate::enums::GL_DONT_CARE)
    /// and `severity` must be [`GL_DONT_CARE`](crate::enums::GL_DONT_CARE).
    ///
    /// If `enabled` is [`GL_TRUE`](crate::enums::GL_TRUE) then messages that match
    /// the filter formed by `source`, `type`, `severity` and `ids` are enabled.
    /// Otherwise, those messages are disabled.
    ///
    /// ### Notes
    /// Although debug messages may be enabled in a non-debug context, the quantity
    /// and detail of such messages may be substantially inferior to those in a
    /// debug context. In particular, a valid implementation of the debug message
    /// queue in a non-debug context may produce no messages at all.
    ///
    /// [`GL_DEBUG_TYPE_MARKER`](crate::enums::GL_DEBUG_TYPE_MARKER), [`GL_DEBUG_TYPE_PUSH_GROUP`](crate::enums::GL_DEBUG_TYPE_PUSH_GROUP),
    /// [`GL_DEBUG_TYPE_POP_GROUP`](crate::enums::GL_DEBUG_TYPE_POP_GROUP), and
    /// [`GL_DEBUG_SEVERITY_NOTIFICATION`](crate::enums::GL_DEBUG_SEVERITY_NOTIFICATION)
    /// are available only if the GL version is 4.3 or higher.

    pub unsafe fn oxidegl_debug_message_control(
        &mut self,
        source: DebugSource,
        r#type: DebugType,
        severity: DebugSeverity,
        count: GLsizei,
        ids: *const GLuint,
        enabled: GLboolean,
    ) {
        panic!("command oxidegl_debug_message_control not yet implemented");
    }
    /// ### Parameters
    /// `source`
    ///
    /// > The source of the debug message to insert.
    ///
    /// `type`
    ///
    /// > The type of the debug message insert.
    ///
    /// `id`
    ///
    /// > The user-supplied identifier of the message to insert.
    ///
    /// `severity`
    ///
    /// > The severity of the debug messages to insert.
    ///
    /// `length`
    ///
    /// > The length string contained in the character array whose address is given
    /// > by `message`.
    ///
    /// `message`
    ///
    /// > The address of a character array containing the message to insert.
    ///
    /// ### Description
    /// [**glDebugMessageInsert**](crate::context::Context::oxidegl_debug_message_insert)
    /// inserts a user-supplied message into the debug output queue. `source` specifies
    /// the source that will be used to classify the message and must be [`GL_DEBUG_SOURCE_APPLICATION`](crate::enums::GL_DEBUG_SOURCE_APPLICATION)
    /// or [`GL_DEBUG_SOURCE_THIRD_PARTY`](crate::enums::GL_DEBUG_SOURCE_THIRD_PARTY).
    /// All other sources are reserved for use by the GL implementation. `type`
    /// indicates the type of the message to be inserted and may be one of [`GL_DEBUG_TYPE_ERROR`](crate::enums::GL_DEBUG_TYPE_ERROR),
    /// [`GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR`](crate::enums::GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR),
    /// [`GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR`](crate::enums::GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR),
    /// [`GL_DEBUG_TYPE_PORTABILITY`](crate::enums::GL_DEBUG_TYPE_PORTABILITY),
    /// [`GL_DEBUG_TYPE_PERFORMANCE`](crate::enums::GL_DEBUG_TYPE_PERFORMANCE),
    /// [`GL_DEBUG_TYPE_MARKER`](crate::enums::GL_DEBUG_TYPE_MARKER), [`GL_DEBUG_TYPE_PUSH_GROUP`](crate::enums::GL_DEBUG_TYPE_PUSH_GROUP),
    /// [`GL_DEBUG_TYPE_POP_GROUP`](crate::enums::GL_DEBUG_TYPE_POP_GROUP), or
    /// [`GL_DEBUG_TYPE_OTHER`](crate::enums::GL_DEBUG_TYPE_OTHER). `severity`
    /// indicates the severity of the message and may be [`GL_DEBUG_SEVERITY_LOW`](crate::enums::GL_DEBUG_SEVERITY_LOW),
    /// [`GL_DEBUG_SEVERITY_MEDIUM`](crate::enums::GL_DEBUG_SEVERITY_MEDIUM), [`GL_DEBUG_SEVERITY_HIGH`](crate::enums::GL_DEBUG_SEVERITY_HIGH)
    /// or [`GL_DEBUG_SEVERITY_NOTIFICATION`](crate::enums::GL_DEBUG_SEVERITY_NOTIFICATION).
    /// `id` is available for application defined use and may be any value. This
    /// value will be recorded and used to identify the message.
    ///
    /// `length` contains a count of the characters in the character array whose
    /// address is given in `message`. If `length` is negative then `message` is
    /// treated as a null-terminated string. The length of the message, whether
    /// specified explicitly or implicitly, must be less than or equal to the implementation
    /// defined constant [`GL_MAX_DEBUG_MESSAGE_LENGTH`](crate::enums::GL_MAX_DEBUG_MESSAGE_LENGTH).
    ///
    /// ### Notes
    /// [`GL_DEBUG_TYPE_MARKER`](crate::enums::GL_DEBUG_TYPE_MARKER), [`GL_DEBUG_TYPE_PUSH_GROUP`](crate::enums::GL_DEBUG_TYPE_PUSH_GROUP),
    /// [`GL_DEBUG_TYPE_POP_GROUP`](crate::enums::GL_DEBUG_TYPE_POP_GROUP), and
    /// [`GL_DEBUG_SEVERITY_NOTIFICATION`](crate::enums::GL_DEBUG_SEVERITY_NOTIFICATION)
    /// are available only if the GL version is 4.3 or higher.

    pub unsafe fn oxidegl_debug_message_insert(
        &mut self,
        source: DebugSource,
        r#type: DebugType,
        id: GLuint,
        severity: DebugSeverity,
        length: GLsizei,
        buf: *const GLchar,
    ) {
        panic!("command oxidegl_debug_message_insert not yet implemented");
    }
    /// ### Parameters
    /// `n`
    ///
    /// > Specifies the number of framebuffer objects to be deleted.
    ///
    /// `framebuffers`
    ///
    /// > A pointer to an array containing `n` framebuffer objects to be deleted.
    ///
    /// ### Description
    /// [**glDeleteFramebuffers**](crate::context::Context::oxidegl_delete_framebuffers)
    /// deletes the `n` framebuffer objects whose names are stored in the array
    /// addressed by `framebuffers`. The name zero is reserved by the GL and is
    /// silently ignored, should it occur in `framebuffers`, as are other unused
    /// names. Once a framebuffer object is deleted, its name is again unused and
    /// it has no attachments. If a framebuffer that is currently bound to one
    /// or more of the targets [`GL_DRAW_FRAMEBUFFER`](crate::enums::GL_DRAW_FRAMEBUFFER)
    /// or [`GL_READ_FRAMEBUFFER`](crate::enums::GL_READ_FRAMEBUFFER) is deleted,
    /// it is as though [**glBindFramebuffer**](crate::context::Context::oxidegl_bind_framebuffer)
    /// had been executed with the corresponding `target` and `framebuffer` zero.

    pub unsafe fn oxidegl_delete_framebuffers(&mut self, n: GLsizei, framebuffers: *const GLuint) {
        panic!("command oxidegl_delete_framebuffers not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the program object to be deleted.
    ///
    /// ### Description
    /// [**glDeleteProgram**](crate::context::Context::oxidegl_delete_program)
    /// frees the memory and invalidates the name associated with the program object
    /// specified by `program.` This command effectively undoes the effects of
    /// a call to [**glCreateProgram**](crate::context::Context::oxidegl_create_program).
    ///
    /// If a program object is in use as part of current rendering state, it will
    /// be flagged for deletion, but it will not be deleted until it is no longer
    /// part of current state for any rendering context. If a program object to
    /// be deleted has shader objects attached to it, those shader objects will
    /// be automatically detached but not deleted unless they have already been
    /// flagged for deletion by a previous call to [**glDeleteShader**](crate::context::Context::oxidegl_delete_shader).
    /// A value of 0 for `program` will be silently ignored.
    ///
    /// To determine whether a program object has been flagged for deletion, call
    /// [**glGetProgram**](crate::context::Context::oxidegl_get_program) with arguments
    /// `program` and [`GL_DELETE_STATUS`](crate::enums::GL_DELETE_STATUS).
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_CURRENT_PROGRAM`](crate::enums::GL_CURRENT_PROGRAM)
    ///
    /// [**glGetProgram**](crate::context::Context::oxidegl_get_program) with arguments
    /// `program` and [`GL_DELETE_STATUS`](crate::enums::GL_DELETE_STATUS)
    ///
    /// [**glIsProgram**](crate::context::Context::oxidegl_is_program)

    pub fn oxidegl_delete_program(&mut self, program: GLuint) {
        panic!("command oxidegl_delete_program not yet implemented");
    }
    /// ### Parameters
    /// `n`
    ///
    /// > Specifies the number of program pipeline objects to delete.
    ///
    /// `pipelines`
    ///
    /// > Specifies an array of names of program pipeline objects to delete.
    ///
    /// ### Description
    /// [**glDeleteProgramPipelines**](crate::context::Context::oxidegl_delete_program_pipelines)
    /// deletes the `n` program pipeline objects whose names are stored in the
    /// array `pipelines`. Unused names in `pipelines` are ignored, as is the name
    /// zero. After a program pipeline object is deleted, its name is again unused
    /// and it has no contents. If program pipeline object that is currently bound
    /// is deleted, the binding for that object reverts to zero and no program
    /// pipeline object becomes current.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_PROGRAM_PIPELINE_BINDING`](crate::enums::GL_PROGRAM_PIPELINE_BINDING)

    pub unsafe fn oxidegl_delete_program_pipelines(
        &mut self,
        n: GLsizei,
        pipelines: *const GLuint,
    ) {
        panic!("command oxidegl_delete_program_pipelines not yet implemented");
    }
    /// ### Parameters
    /// `n`
    ///
    /// > Specifies the number of query objects to be deleted.
    ///
    /// `ids`
    ///
    /// > Specifies an array of query objects to be deleted.
    ///
    /// ### Description
    /// [**glDeleteQueries**](crate::context::Context::oxidegl_delete_queries)
    /// deletes `n` query objects named by the elements of the array `ids`. After
    /// a query object is deleted, it has no contents, and its name is free for
    /// reuse (for example by [**glGenQueries**](crate::context::Context::oxidegl_gen_queries)
    /// ).
    ///
    /// [**glDeleteQueries**](crate::context::Context::oxidegl_delete_queries)
    /// silently ignores 0's and names that do not correspond to existing query
    /// objects.
    ///
    /// ### Associated Gets
    /// [**glIsQuery**](crate::context::Context::oxidegl_is_query)

    pub unsafe fn oxidegl_delete_queries(&mut self, n: GLsizei, ids: *const GLuint) {
        panic!("command oxidegl_delete_queries not yet implemented");
    }
    /// ### Parameters
    /// `n`
    ///
    /// > Specifies the number of renderbuffer objects to be deleted.
    ///
    /// `renderbuffers`
    ///
    /// > A pointer to an array containing `n` renderbuffer objects to be deleted.
    ///
    /// ### Description
    /// [**glDeleteRenderbuffers**](crate::context::Context::oxidegl_delete_renderbuffers)
    /// deletes the `n` renderbuffer objects whose names are stored in the array
    /// addressed by `renderbuffers`. The name zero is reserved by the GL and is
    /// silently ignored, should it occur in `renderbuffers`, as are other unused
    /// names. Once a renderbuffer object is deleted, its name is again unused
    /// and it has no contents. If a renderbuffer that is currently bound to the
    /// target [`GL_RENDERBUFFER`](crate::enums::GL_RENDERBUFFER) is deleted, it
    /// is as though [**glBindRenderbuffer**](crate::context::Context::oxidegl_bind_renderbuffer)
    /// had been executed with a `target` of [`GL_RENDERBUFFER`](crate::enums::GL_RENDERBUFFER)
    /// and a `name` of zero.
    ///
    /// If a renderbuffer object is attached to one or more attachment points in
    /// the currently bound framebuffer, then it as if [**glFramebufferRenderbuffer**](crate::context::Context::oxidegl_framebuffer_renderbuffer)
    /// had been called, with a `renderbuffer` of zero for each attachment point
    /// to which this image was attached in the currently bound framebuffer. In
    /// other words, this renderbuffer object is first detached from all attachment
    /// ponits in the currently bound framebuffer. Note that the renderbuffer image
    /// is specifically *not* detached from any non-bound framebuffers.

    pub unsafe fn oxidegl_delete_renderbuffers(
        &mut self,
        n: GLsizei,
        renderbuffers: *const GLuint,
    ) {
        panic!("command oxidegl_delete_renderbuffers not yet implemented");
    }
    /// ### Parameters
    /// `n`
    ///
    /// > Specifies the number of sampler objects to be deleted.
    ///
    /// `samplers`
    ///
    /// > Specifies an array of sampler objects to be deleted.
    ///
    /// ### Description
    /// [**glDeleteSamplers**](crate::context::Context::oxidegl_delete_samplers)
    /// deletes `n` sampler objects named by the elements of the array `samplers`.
    /// After a sampler object is deleted, its name is again unused. If a sampler
    /// object that is currently bound to a sampler unit is deleted, it is as though
    /// [**glBindSampler**](crate::context::Context::oxidegl_bind_sampler) is called
    /// with unit set to the unit the sampler is bound to and sampler zero. Unused
    /// names in samplers are silently ignored, as is the reserved name zero.
    ///
    /// ### Notes
    /// [**glDeleteSamplers**](crate::context::Context::oxidegl_delete_samplers)
    /// is available only if the GL version is 3.3 or higher.
    ///
    /// ### Associated Gets
    /// [**glIsSampler**](crate::context::Context::oxidegl_is_sampler)

    pub unsafe fn oxidegl_delete_samplers(&mut self, count: GLsizei, samplers: *const GLuint) {
        panic!("command oxidegl_delete_samplers not yet implemented");
    }
    /// ### Parameters
    /// `shader`
    ///
    /// > Specifies the shader object to be deleted.
    ///
    /// ### Description
    /// [**glDeleteShader**](crate::context::Context::oxidegl_delete_shader) frees
    /// the memory and invalidates the name associated with the shader object specified
    /// by `shader`. This command effectively undoes the effects of a call to [**glCreateShader**](crate::context::Context::oxidegl_create_shader).
    ///
    /// If a shader object to be deleted is attached to a program object, it will
    /// be flagged for deletion, but it will not be deleted until it is no longer
    /// attached to any program object, for any rendering context (i.e., it must
    /// be detached from wherever it was attached before it will be deleted). A
    /// value of 0 for `shader` will be silently ignored.
    ///
    /// To determine whether an object has been flagged for deletion, call [**glGetShader**](crate::context::Context::oxidegl_get_shader)
    /// with arguments `shader` and [`GL_DELETE_STATUS`](crate::enums::GL_DELETE_STATUS).
    ///
    /// ### Associated Gets
    /// [**glGetAttachedShaders**](crate::context::Context::oxidegl_get_attached_shaders)
    /// with the program object to be queried
    ///
    /// [**glGetShader**](crate::context::Context::oxidegl_get_shader) with arguments
    /// `shader` and [`GL_DELETE_STATUS`](crate::enums::GL_DELETE_STATUS)
    ///
    /// [**glIsShader**](crate::context::Context::oxidegl_is_shader)

    pub fn oxidegl_delete_shader(&mut self, shader: GLuint) {
        panic!("command oxidegl_delete_shader not yet implemented");
    }
    /// ### Parameters
    /// `sync`
    ///
    /// > The sync object to be deleted.
    ///
    /// ### Description
    /// [**glDeleteSync**](crate::context::Context::oxidegl_delete_sync) deletes
    /// the sync object specified by `sync`. If the fence command corresponding
    /// to the specified sync object has completed, or if no [**glWaitSync**](crate::context::Context::oxidegl_wait_sync)
    /// or [**glClientWaitSync**](crate::context::Context::oxidegl_client_wait_sync)
    /// commands are blocking on `sync`, the object is deleted immediately. Otherwise,
    /// `sync` is flagged for deletion and will be deleted when it is no longer
    /// associated with any fence command and is no longer blocking any [**glWaitSync**](crate::context::Context::oxidegl_wait_sync)
    /// or [**glClientWaitSync**](crate::context::Context::oxidegl_client_wait_sync)
    /// command. In either case, after [**glDeleteSync**](crate::context::Context::oxidegl_delete_sync)
    /// returns, the name `sync` is invalid and can no longer be used to refer
    /// to the sync object.
    ///
    /// [**glDeleteSync**](crate::context::Context::oxidegl_delete_sync) will silently
    /// ignore a `sync` value of zero.
    ///
    /// ### Notes
    /// [**glSync**](crate::context::Context::oxidegl_sync) is only supported if
    /// the GL version is 3.2 or greater, or if the

    pub fn oxidegl_delete_sync(&mut self, sync: GLsync) {
        panic!("command oxidegl_delete_sync not yet implemented");
    }
    /// ### Parameters
    /// `n`
    ///
    /// > Specifies the number of textures to be deleted.
    ///
    /// `textures`
    ///
    /// > Specifies an array of textures to be deleted.
    ///
    /// ### Description
    /// [**glDeleteTextures**](crate::context::Context::oxidegl_delete_textures)
    /// deletes `n` textures named by the elements of the array `textures`. After
    /// a texture is deleted, it has no contents or dimensionality, and its name
    /// is free for reuse (for example by [**glGenTextures**](crate::context::Context::oxidegl_gen_textures)
    /// ). If a texture that is currently bound is deleted, the binding reverts
    /// to 0 (the default texture).
    ///
    /// [**glDeleteTextures**](crate::context::Context::oxidegl_delete_textures)
    /// silently ignores 0's and names that do not correspond to existing textures.
    ///
    /// ### Associated Gets
    /// [**glIsTexture**](crate::context::Context::oxidegl_is_texture)

    pub unsafe fn oxidegl_delete_textures(&mut self, n: GLsizei, textures: *const GLuint) {
        panic!("command oxidegl_delete_textures not yet implemented");
    }
    /// ### Parameters
    /// `n`
    ///
    /// > Specifies the number of transform feedback objects to delete.
    ///
    /// `ids`
    ///
    /// > Specifies an array of names of transform feedback objects to delete.
    ///
    /// ### Description
    /// [**glDeleteTransformFeedbacks**](crate::context::Context::oxidegl_delete_transform_feedbacks)
    /// deletes the `n` transform feedback objects whose names are stored in the
    /// array `ids`. Unused names in `ids` are ignored, as is the name zero. After
    /// a transform feedback object is deleted, its name is again unused and it
    /// has no contents. If an active transform feedback object is deleted, its
    /// name immediately becomes unused, but the underlying object is not deleted
    /// until it is no longer active.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_TRANSFORM_FEEDBACK_BINDING`](crate::enums::GL_TRANSFORM_FEEDBACK_BINDING)
    pub unsafe fn oxidegl_delete_transform_feedbacks(&mut self, n: GLsizei, ids: *const GLuint) {
        panic!("command oxidegl_delete_transform_feedbacks not yet implemented");
    }

    /// ### Parameters
    /// `func`
    ///
    /// > Specifies the depth comparison function. Symbolic constants [`GL_NEVER`](crate::enums::GL_NEVER),
    /// > [`GL_LESS`](crate::enums::GL_LESS), [`GL_EQUAL`](crate::enums::GL_EQUAL),
    /// > [`GL_LEQUAL`](crate::enums::GL_LEQUAL), [`GL_GREATER`](crate::enums::GL_GREATER),
    /// > [`GL_NOTEQUAL`](crate::enums::GL_NOTEQUAL), [`GL_GEQUAL`](crate::enums::GL_GEQUAL),
    /// > and [`GL_ALWAYS`](crate::enums::GL_ALWAYS) are accepted. The initial value
    /// > is [`GL_LESS`](crate::enums::GL_LESS).
    ///
    /// ### Description
    /// [**glDepthFunc**](crate::context::Context::oxidegl_depth_func) specifies
    /// the function used to compare each incoming pixel depth value with the depth
    /// value present in the depth buffer. The comparison is performed only if
    /// depth testing is enabled. (See [**glEnable**](crate::context::Context::oxidegl_enable)
    /// and [**glDisable**](crate::context::Context::oxidegl_disable) of [`GL_DEPTH_TEST`](crate::enums::GL_DEPTH_TEST)
    /// .)
    ///
    /// `func` specifies the conditions under which the pixel will be drawn. The
    /// comparison functions are as follows:
    ///
    /// [`GL_NEVER`](crate::enums::GL_NEVER)
    ///
    /// > Never passes.
    ///
    /// [`GL_LESS`](crate::enums::GL_LESS)
    ///
    /// > Passes if the incoming depth value is less than the stored depth value.
    ///
    /// [`GL_EQUAL`](crate::enums::GL_EQUAL)
    ///
    /// > Passes if the incoming depth value is equal to the stored depth value.
    ///
    /// [`GL_LEQUAL`](crate::enums::GL_LEQUAL)
    ///
    /// > Passes if the incoming depth value is less than or equal to the stored
    /// > depth value.
    ///
    /// [`GL_GREATER`](crate::enums::GL_GREATER)
    ///
    /// > Passes if the incoming depth value is greater than the stored depth value.
    ///
    /// [`GL_NOTEQUAL`](crate::enums::GL_NOTEQUAL)
    ///
    /// > Passes if the incoming depth value is not equal to the stored depth value.
    ///
    /// [`GL_GEQUAL`](crate::enums::GL_GEQUAL)
    ///
    /// > Passes if the incoming depth value is greater than or equal to the stored
    /// > depth value.
    ///
    /// [`GL_ALWAYS`](crate::enums::GL_ALWAYS)
    ///
    /// > Always passes.
    ///
    /// The initial value of `func` is [`GL_LESS`](crate::enums::GL_LESS). Initially,
    /// depth testing is disabled. If depth testing is disabled or if no depth
    /// buffer exists, it is as if the depth test always passes.
    ///
    /// ### Notes
    /// Even if the depth buffer exists and the depth mask is non-zero, the depth
    /// buffer is not updated if the depth test is disabled. In order to unconditionally
    /// write to the depth buffer, the depth test should be enabled and set to
    /// [`GL_ALWAYS`](crate::enums::GL_ALWAYS).
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_DEPTH_FUNC`](crate::enums::GL_DEPTH_FUNC)
    ///
    /// [**glIsEnabled**](crate::context::Context::oxidegl_is_enabled) with argument
    /// [`GL_DEPTH_TEST`](crate::enums::GL_DEPTH_TEST)

    pub fn oxidegl_depth_func(&mut self, func: DepthFunction) {
        panic!("command oxidegl_depth_func not yet implemented");
    }
    /// ### Parameters
    /// `flag`
    ///
    /// > Specifies whether the depth buffer is enabled for writing. If `flag` is
    /// > [`GL_FALSE`](crate::enums::GL_FALSE), depth buffer writing is disabled.
    /// > Otherwise, it is enabled. Initially, depth buffer writing is enabled.
    ///
    /// ### Description
    /// [**glDepthMask**](crate::context::Context::oxidegl_depth_mask) specifies
    /// whether the depth buffer is enabled for writing. If `flag` is [`GL_FALSE`](crate::enums::GL_FALSE),
    /// depth buffer writing is disabled. Otherwise, it is enabled. Initially,
    /// depth buffer writing is enabled.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_DEPTH_WRITEMASK`](crate::enums::GL_DEPTH_WRITEMASK)
    ///
    /// ### Notes
    /// Even if the depth buffer exists and the depth mask is non-zero, the depth
    /// buffer is not updated if the depth test is disabled. In order to unconditionally
    /// write to the depth buffer, the depth test should be enabled and set to
    /// [`GL_ALWAYS`](crate::enums::GL_ALWAYS) (see [**glDepthFunc**](crate::context::Context::oxidegl_depth_func)
    /// ).

    pub fn oxidegl_depth_mask(&mut self, flag: GLboolean) {
        panic!("command oxidegl_depth_mask not yet implemented");
    }
    /// ### Parameters
    /// `first`
    ///
    /// > Specifies the index of the first viewport whose depth range to update.
    ///
    /// `count`
    ///
    /// > Specifies the number of viewports whose depth range to update.
    ///
    /// `v`
    ///
    /// > Specifies the address of an array containing the near and far values for
    /// > the depth range of each modified viewport.
    ///
    /// ### Description
    /// After clipping and division by *w*, depth coordinates range from `[inlineq]`
    /// [**glDepthRangeArray**](crate::context::Context::oxidegl_depth_range_array)
    /// specifies a linear mapping of the normalized depth coordinates in this
    /// range to window depth coordinates for each viewport in the range \[ `first`,
    /// `first`+ `count` ). Thus, the values accepted by [**glDepthRangeArray**](crate::context::Context::oxidegl_depth_range_array)
    /// are both clamped to this range before they are accepted.
    ///
    /// The `first` parameter specifies the index of the first viewport whose depth
    /// range to modify and must be less than the value of [`GL_MAX_VIEWPORTS`](crate::enums::GL_MAX_VIEWPORTS).
    /// `count` specifies the number of viewports whose depth range to modify.
    /// `first`+ `count` must be less than or equal to the value of [`GL_MAX_VIEWPORTS`](crate::enums::GL_MAX_VIEWPORTS).
    /// `v` specifies the address of an array of pairs of double precision floating
    /// point values representing the near and far values of the depth range for
    /// each viewport, in that order.
    ///
    /// The setting of (0,1) maps the near plane to 0 and the far plane to 1. With
    /// this mapping, the depth buffer range is fully utilized.
    ///
    /// ### Notes
    /// It is not necessary that the near plane distance be less than the far plane
    /// distance. Reverse mappings such as `[inlineq]` `[inlineq]`
    ///
    /// The type of the `v` parameter was changed from `GLclampd` to `GLdouble`. This
    /// change is transparent to user code and is described in detail on the [**removedTypes**](crate::context::Context::oxideremoved_types)
    /// page.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_DEPTH_RANGE`](crate::enums::GL_DEPTH_RANGE)

    pub unsafe fn oxidegl_depth_range_arrayv(
        &mut self,
        first: GLuint,
        count: GLsizei,
        v: *const GLdouble,
    ) {
        panic!("command oxidegl_depth_range_arrayv not yet implemented");
    }
    /// ### Parameters
    /// `index`
    ///
    /// > Specifies the index of the viewport whose depth range to update.
    ///
    /// `nearVal`
    ///
    /// > Specifies the mapping of the near clipping plane to window coordinates.
    /// > The initial value is 0.
    ///
    /// `farVal`
    ///
    /// > Specifies the mapping of the far clipping plane to window coordinates.
    /// > The initial value is 1.
    ///
    /// ### Description
    /// After clipping and division by *w*, depth coordinates range from `[inlineq]`
    /// [**glDepthRangeIndexed**](crate::context::Context::oxidegl_depth_range_indexed)
    /// specifies a linear mapping of the normalized depth coordinates in this
    /// range to window depth coordinates for a specified viewport. Thus, the values
    /// accepted by [**glDepthRangeIndexed**](crate::context::Context::oxidegl_depth_range_indexed)
    /// are both clamped to this range before they are accepted.
    ///
    /// The `index` parameter specifies the index of first viewport whose depth
    /// range to modify and must be less than the value of [`GL_MAX_VIEWPORTS`](crate::enums::GL_MAX_VIEWPORTS).
    /// `nearVal` and `farVal` specify near and far values of the depth range for
    /// the specified viewport, respectively.
    ///
    /// The setting of (0,1) maps the near plane to 0 and the far plane to 1. With
    /// this mapping, the depth buffer range is fully utilized.
    ///
    /// ### Notes
    /// It is not necessary that the near plane distance be less than the far plane
    /// distance. Reverse mappings such as `[inlineq]` `[inlineq]`
    ///
    /// The type of the `nearVal` and `farVal` parameters was changed from `GLclampd`
    /// to `GLdouble`. This change is transparent to user code and is described in
    /// detail on the [**removedTypes**](crate::context::Context::oxideremoved_types)
    /// page.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_DEPTH_RANGE`](crate::enums::GL_DEPTH_RANGE)

    pub fn oxidegl_depth_range_indexed(&mut self, index: GLuint, n: GLdouble, f: GLdouble) {
        panic!("command oxidegl_depth_range_indexed not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the program object from which to detach the shader object.
    ///
    /// `shader`
    ///
    /// > Specifies the shader object to be detached.
    ///
    /// ### Description
    /// [**glDetachShader**](crate::context::Context::oxidegl_detach_shader) detaches
    /// the shader object specified by `shader` from the program object specified
    /// by `program`. This command can be used to undo the effect of the command
    /// [**glAttachShader**](crate::context::Context::oxidegl_attach_shader).
    ///
    /// If `shader` has already been flagged for deletion by a call to [**glDeleteShader**](crate::context::Context::oxidegl_delete_shader)
    /// and it is not attached to any other program object, it will be deleted
    /// after it has been detached.
    ///
    /// ### Associated Gets
    /// [**glGetAttachedShaders**](crate::context::Context::oxidegl_get_attached_shaders)
    /// with the handle of a valid program object
    ///
    /// [**glGetShader**](crate::context::Context::oxidegl_get_shader) with arguments
    /// `shader` and [`GL_DELETE_STATUS`](crate::enums::GL_DELETE_STATUS)
    ///
    /// [**glIsProgram**](crate::context::Context::oxidegl_is_program)
    ///
    /// [**glIsShader**](crate::context::Context::oxidegl_is_shader)

    pub fn oxidegl_detach_shader(&mut self, program: GLuint, shader: GLuint) {
        panic!("command oxidegl_detach_shader not yet implemented");
    }
    /// ### Parameters
    /// `num_groups_x`
    ///
    /// > The number of work groups to be launched in the X dimension.
    ///
    /// `num_groups_y`
    ///
    /// > The number of work groups to be launched in the Y dimension.
    ///
    /// `num_groups_z`
    ///
    /// > The number of work groups to be launched in the Z dimension.
    ///
    /// ### Description
    /// [**glDispatchCompute**](crate::context::Context::oxidegl_dispatch_compute)
    /// launches one or more compute work groups. Each work group is processed
    /// by the active program object for the compute shader stage. While the individual
    /// shader invocations within a work group are executed as a unit, work groups
    /// are executed completely independently and in unspecified order. `num_groups_x`,
    /// `num_groups_y` and `num_groups_z` specify the number of local work groups
    /// that will be dispatched in the X, Y and Z dimensions, respectively.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_COMPUTE_WORK_GROUP_COUNT`](crate::enums::GL_MAX_COMPUTE_WORK_GROUP_COUNT)

    pub fn oxidegl_dispatch_compute(
        &mut self,
        num_groups_x: GLuint,
        num_groups_y: GLuint,
        num_groups_z: GLuint,
    ) {
        panic!("command oxidegl_dispatch_compute not yet implemented");
    }
    /// ### Parameters
    /// `indirect`
    ///
    /// > The offset into the buffer object currently bound to the [`GL_DISPATCH_INDIRECT_BUFFER`](crate::enums::GL_DISPATCH_INDIRECT_BUFFER)
    /// > buffer target at which the dispatch parameters are stored.
    ///
    /// ### Description
    /// [**glDispatchComputeIndirect**](crate::context::Context::oxidegl_dispatch_compute_indirect)
    /// launches one or more compute work groups using parameters stored in the
    /// buffer object currently bound to the [`GL_DISPATCH_INDIRECT_BUFFER`](crate::enums::GL_DISPATCH_INDIRECT_BUFFER)
    /// target. Each work group is processed by the active program object for the
    /// compute shader stage. While the individual shader invocations within a
    /// work group are executed as a unit, work groups are executed completely
    /// independently and in unspecified order. `indirect` contains the offset
    /// into the data store of the buffer object bound to the [`GL_DISPATCH_INDIRECT_BUFFER`](crate::enums::GL_DISPATCH_INDIRECT_BUFFER)
    /// target at which the parameters are stored.
    ///
    /// The parameters addressed by `indirect` are packed a structure, which takes
    /// the form (in C):
    ///
    /// A call to [**glDispatchComputeIndirect**](crate::context::Context::oxidegl_dispatch_compute_indirect)
    /// is equivalent, assuming no errors are generated, to:
    ///
    /// Unlike [**glDispatchCompute**](crate::context::Context::oxidegl_dispatch_compute),
    /// no error is generated if any of the [`GL_MAX_COMPUTE_WORK_GROUP_COUNT`](crate::enums::GL_MAX_COMPUTE_WORK_GROUP_COUNT)
    /// for the corresponding dimension. In such circumstances, behavior is undefined
    /// and may lead to application termination.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_COMPUTE_WORK_GROUP_COUNT`](crate::enums::GL_MAX_COMPUTE_WORK_GROUP_COUNT)

    pub fn oxidegl_dispatch_compute_indirect(&mut self, indirect: GLintptr) {
        panic!("command oxidegl_dispatch_compute_indirect not yet implemented");
    }
    /// ### Parameters
    /// `mode`
    ///
    /// > Specifies what kind of primitives to render. Symbolic constants [`GL_POINTS`](crate::enums::GL_POINTS),
    /// > [`GL_LINE_STRIP`](crate::enums::GL_LINE_STRIP), [`GL_LINE_LOOP`](crate::enums::GL_LINE_LOOP),
    /// > [`GL_LINES`](crate::enums::GL_LINES), [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY),
    /// > [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY), [`GL_TRIANGLE_STRIP`](crate::enums::GL_TRIANGLE_STRIP),
    /// > [`GL_TRIANGLE_FAN`](crate::enums::GL_TRIANGLE_FAN), [`GL_TRIANGLES`](crate::enums::GL_TRIANGLES),
    /// > [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY),
    /// > [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY) and [`GL_PATCHES`](crate::enums::GL_PATCHES)
    /// > are accepted.
    ///
    /// `first`
    ///
    /// > Specifies the starting index in the enabled arrays.
    ///
    /// `count`
    ///
    /// > Specifies the number of indices to be rendered.
    ///
    /// ### Description
    /// [**glDrawArrays**](crate::context::Context::oxidegl_draw_arrays) specifies
    /// multiple geometric primitives with very few subroutine calls. Instead of
    /// calling a GL procedure to pass each individual vertex, normal, texture
    /// coordinate, edge flag, or color, you can prespecify separate arrays of
    /// vertices, normals, and colors and use them to construct a sequence of primitives
    /// with a single call to [**glDrawArrays**](crate::context::Context::oxidegl_draw_arrays).
    ///
    /// When [**glDrawArrays**](crate::context::Context::oxidegl_draw_arrays) is
    /// called, it uses `count` sequential elements from each enabled array to
    /// construct a sequence of geometric primitives, beginning with element `first`.
    /// `mode` specifies what kind of primitives are constructed and how the array
    /// elements construct those primitives.
    ///
    /// Vertex attributes that are modified by [**glDrawArrays**](crate::context::Context::oxidegl_draw_arrays)
    /// have an unspecified value after [**glDrawArrays**](crate::context::Context::oxidegl_draw_arrays)
    /// returns. Attributes that aren't modified remain well defined.
    ///
    /// ### Notes
    /// [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY), [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY),
    /// [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY)
    /// and [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY) are
    /// available only if the GL version is 3.2 or greater.

    pub fn oxidegl_draw_arrays(&mut self, mode: PrimitiveType, first: GLint, count: GLsizei) {
        panic!("command oxidegl_draw_arrays not yet implemented");
    }
    /// ### Parameters
    /// `mode`
    ///
    /// > Specifies what kind of primitives to render. Symbolic constants [`GL_POINTS`](crate::enums::GL_POINTS),
    /// > [`GL_LINE_STRIP`](crate::enums::GL_LINE_STRIP), [`GL_LINE_LOOP`](crate::enums::GL_LINE_LOOP),
    /// > [`GL_LINES`](crate::enums::GL_LINES), [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY),
    /// > [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY), [`GL_TRIANGLE_STRIP`](crate::enums::GL_TRIANGLE_STRIP),
    /// > [`GL_TRIANGLE_FAN`](crate::enums::GL_TRIANGLE_FAN), [`GL_TRIANGLES`](crate::enums::GL_TRIANGLES),
    /// > [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY),
    /// > [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY), and [`GL_PATCHES`](crate::enums::GL_PATCHES)
    /// > are accepted.
    ///
    /// `indirect`
    ///
    /// > Specifies the address of a structure containing the draw parameters.
    ///
    /// ### Description
    /// [**glDrawArraysIndirect**](crate::context::Context::oxidegl_draw_arrays_indirect)
    /// specifies multiple geometric primitives with very few subroutine calls.
    /// [**glDrawArraysIndirect**](crate::context::Context::oxidegl_draw_arrays_indirect)
    /// behaves similarly to [**glDrawArraysInstancedBaseInstance**](crate::context::Context::oxidegl_draw_arrays_instanced_base_instance),
    /// execept that the parameters to [**glDrawArraysInstancedBaseInstance**](crate::context::Context::oxidegl_draw_arrays_instanced_base_instance)
    /// are stored in memory at the address given by `indirect`.
    ///
    /// The parameters addressed by `indirect` are packed into a structure that
    /// takes the form (in C):
    ///
    /// If a buffer is bound to the [`GL_DRAW_INDIRECT_BUFFER`](crate::enums::GL_DRAW_INDIRECT_BUFFER)
    /// binding at the time of a call to [**glDrawArraysIndirect**](crate::context::Context::oxidegl_draw_arrays_indirect),
    /// `indirect` is interpreted as an offset, in basic machine units, into that
    /// buffer and the parameter data is read from the buffer rather than from
    /// client memory.
    ///
    /// In contrast to [**glDrawArraysInstancedBaseInstance**](crate::context::Context::oxidegl_draw_arrays_instanced_base_instance),
    /// the
    ///
    /// Vertex attributes that are modified by [**glDrawArraysIndirect**](crate::context::Context::oxidegl_draw_arrays_indirect)
    /// have an unspecified value after [**glDrawArraysIndirect**](crate::context::Context::oxidegl_draw_arrays_indirect)
    /// returns. Attributes that aren't modified remain well defined.
    ///
    /// ### Notes
    /// The `baseInstance` member of the `DrawArraysIndirectCommand` structure
    /// is defined only if the GL version is 4.2 or greater. For versions of the
    /// GL less than 4.2, this parameter is present but is reserved and should
    /// be set to zero. On earlier versions of the GL, behavior is undefined if
    /// it is non-zero.

    pub unsafe fn oxidegl_draw_arrays_indirect(
        &mut self,
        mode: PrimitiveType,
        indirect: *const GLvoid,
    ) {
        panic!("command oxidegl_draw_arrays_indirect not yet implemented");
    }
    /// ### Parameters
    /// `mode`
    ///
    /// > Specifies what kind of primitives to render. Symbolic constants [`GL_POINTS`](crate::enums::GL_POINTS),
    /// > [`GL_LINE_STRIP`](crate::enums::GL_LINE_STRIP), [`GL_LINE_LOOP`](crate::enums::GL_LINE_LOOP),
    /// > [`GL_LINES`](crate::enums::GL_LINES), [`GL_TRIANGLE_STRIP`](crate::enums::GL_TRIANGLE_STRIP),
    /// > [`GL_TRIANGLE_FAN`](crate::enums::GL_TRIANGLE_FAN), [`GL_TRIANGLES`](crate::enums::GL_TRIANGLES)
    /// > [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY), [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY),
    /// > [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY), [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY)
    /// > and [`GL_PATCHES`](crate::enums::GL_PATCHES) are accepted.
    ///
    /// `first`
    ///
    /// > Specifies the starting index in the enabled arrays.
    ///
    /// `count`
    ///
    /// > Specifies the number of indices to be rendered.
    ///
    /// `instancecount`
    ///
    /// > Specifies the number of instances of the specified range of indices to
    /// > be rendered.
    ///
    /// ### Description
    /// [**glDrawArraysInstanced**](crate::context::Context::oxidegl_draw_arrays_instanced)
    /// behaves identically to [**glDrawArrays**](crate::context::Context::oxidegl_draw_arrays)
    /// except that `instancecount` instances of the range of elements are executed
    /// and the value of the internal counter `instanceID` advances for each iteration.
    /// `instanceID` is an internal 32-bit integer counter that may be read by
    /// a vertex shader as [`gl_InstanceID`](crate::enums::gl_InstanceID).
    ///
    /// [**glDrawArraysInstanced**](crate::context::Context::oxidegl_draw_arrays_instanced)
    /// has the same effect as:

    pub fn oxidegl_draw_arrays_instanced(
        &mut self,
        mode: PrimitiveType,
        first: GLint,
        count: GLsizei,
        instancecount: GLsizei,
    ) {
        panic!("command oxidegl_draw_arrays_instanced not yet implemented");
    }
    /// ### Parameters
    /// `mode`
    ///
    /// > Specifies what kind of primitives to render. Symbolic constants [`GL_POINTS`](crate::enums::GL_POINTS),
    /// > [`GL_LINE_STRIP`](crate::enums::GL_LINE_STRIP), [`GL_LINE_LOOP`](crate::enums::GL_LINE_LOOP),
    /// > [`GL_LINES`](crate::enums::GL_LINES), [`GL_TRIANGLE_STRIP`](crate::enums::GL_TRIANGLE_STRIP),
    /// > [`GL_TRIANGLE_FAN`](crate::enums::GL_TRIANGLE_FAN), [`GL_TRIANGLES`](crate::enums::GL_TRIANGLES)
    /// > [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY), [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY),
    /// > [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY), [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY)
    /// > and [`GL_PATCHES`](crate::enums::GL_PATCHES) are accepted.
    ///
    /// `first`
    ///
    /// > Specifies the starting index in the enabled arrays.
    ///
    /// `count`
    ///
    /// > Specifies the number of indices to be rendered.
    ///
    /// `instancecount`
    ///
    /// > Specifies the number of instances of the specified range of indices to
    /// > be rendered.
    ///
    /// `baseinstance`
    ///
    /// > Specifies the base instance for use in fetching instanced vertex attributes.
    ///
    /// ### Description
    /// [**glDrawArraysInstancedBaseInstance**](crate::context::Context::oxidegl_draw_arrays_instanced_base_instance)
    /// behaves identically to [**glDrawArrays**](crate::context::Context::oxidegl_draw_arrays)
    /// except that `instancecount` instances of the range of elements are executed
    /// and the value of the internal counter `instanceID` advances for each iteration.
    /// `instanceID` is an internal 32-bit integer counter that may be read by
    /// a vertex shader as [`gl_InstanceID`](crate::enums::gl_InstanceID).
    ///
    /// [**glDrawArraysInstancedBaseInstance**](crate::context::Context::oxidegl_draw_arrays_instanced_base_instance)
    /// has the same effect as:
    ///
    /// Specific vertex attributes may be classified as *instanced* through the
    /// use of [**glVertexAttribDivisor**](crate::context::Context::oxidegl_vertex_attrib_divisor).
    /// Instanced vertex attributes supply per-instance vertex data to the vertex
    /// shader. The index of the vertex fetched from the enabled instanced vertex
    /// attribute arrays is calculated as: `[inlineq]` `baseinstance` does not
    /// affect the shader-visible value of [`gl_InstanceID`](crate::enums::gl_InstanceID).

    pub fn oxidegl_draw_arrays_instanced_base_instance(
        &mut self,
        mode: PrimitiveType,
        first: GLint,
        count: GLsizei,
        instancecount: GLsizei,
        baseinstance: GLuint,
    ) {
        panic!("command oxidegl_draw_arrays_instanced_base_instance not yet implemented");
    }
    /// ### Parameters
    /// `mode`
    ///
    /// > Specifies what kind of primitives to render. Symbolic constants [`GL_POINTS`](crate::enums::GL_POINTS),
    /// > [`GL_LINE_STRIP`](crate::enums::GL_LINE_STRIP), [`GL_LINE_LOOP`](crate::enums::GL_LINE_LOOP),
    /// > [`GL_LINES`](crate::enums::GL_LINES), [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY),
    /// > [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY), [`GL_TRIANGLE_STRIP`](crate::enums::GL_TRIANGLE_STRIP),
    /// > [`GL_TRIANGLE_FAN`](crate::enums::GL_TRIANGLE_FAN), [`GL_TRIANGLES`](crate::enums::GL_TRIANGLES),
    /// > [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY),
    /// > [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY) and [`GL_PATCHES`](crate::enums::GL_PATCHES)
    /// > are accepted.
    ///
    /// `count`
    ///
    /// > Specifies the number of elements to be rendered.
    ///
    /// `type`
    ///
    /// > Specifies the type of the values in `indices`. Must be one of [`GL_UNSIGNED_BYTE`](crate::enums::GL_UNSIGNED_BYTE),
    /// > [`GL_UNSIGNED_SHORT`](crate::enums::GL_UNSIGNED_SHORT), or [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT).
    ///
    /// `indices`
    ///
    /// > Specifies a pointer to the location where the indices are stored.
    ///
    /// ### Description
    /// [**glDrawElements**](crate::context::Context::oxidegl_draw_elements) specifies
    /// multiple geometric primitives with very few subroutine calls. Instead of
    /// calling a GL function to pass each individual vertex, normal, texture coordinate,
    /// edge flag, or color, you can prespecify separate arrays of vertices, normals,
    /// and so on, and use them to construct a sequence of primitives with a single
    /// call to [**glDrawElements**](crate::context::Context::oxidegl_draw_elements).
    ///
    /// When [**glDrawElements**](crate::context::Context::oxidegl_draw_elements)
    /// is called, it uses `count` sequential elements from an enabled array, starting
    /// at `indices` to construct a sequence of geometric primitives. `mode` specifies
    /// what kind of primitives are constructed and how the array elements construct
    /// these primitives. If more than one array is enabled, each is used.
    ///
    /// Vertex attributes that are modified by [**glDrawElements**](crate::context::Context::oxidegl_draw_elements)
    /// have an unspecified value after [**glDrawElements**](crate::context::Context::oxidegl_draw_elements)
    /// returns. Attributes that aren't modified maintain their previous values.
    ///
    /// ### Notes
    /// [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY), [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY),
    /// [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY)
    /// and [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY) are
    /// available only if the GL version is 3.2 or greater.

    pub unsafe fn oxidegl_draw_elements(
        &mut self,
        mode: PrimitiveType,
        count: GLsizei,
        r#type: DrawElementsType,
        indices: *const GLvoid,
    ) {
        panic!("command oxidegl_draw_elements not yet implemented");
    }
    /// ### Parameters
    /// `mode`
    ///
    /// > Specifies what kind of primitives to render. Symbolic constants [`GL_POINTS`](crate::enums::GL_POINTS),
    /// > [`GL_LINE_STRIP`](crate::enums::GL_LINE_STRIP), [`GL_LINE_LOOP`](crate::enums::GL_LINE_LOOP),
    /// > [`GL_LINES`](crate::enums::GL_LINES), [`GL_TRIANGLE_STRIP`](crate::enums::GL_TRIANGLE_STRIP),
    /// > [`GL_TRIANGLE_FAN`](crate::enums::GL_TRIANGLE_FAN), [`GL_TRIANGLES`](crate::enums::GL_TRIANGLES),
    /// > [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY), [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY),
    /// > [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY), [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY)
    /// > and [`GL_PATCHES`](crate::enums::GL_PATCHES) are accepted.
    ///
    /// `count`
    ///
    /// > Specifies the number of elements to be rendered.
    ///
    /// `type`
    ///
    /// > Specifies the type of the values in indices. Must be one of [`GL_UNSIGNED_BYTE`](crate::enums::GL_UNSIGNED_BYTE),
    /// > [`GL_UNSIGNED_SHORT`](crate::enums::GL_UNSIGNED_SHORT), or [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT).
    ///
    /// `indices`
    ///
    /// > Specifies a pointer to the location where the indices are stored.
    ///
    /// `basevertex`
    ///
    /// > Specifies a constant that should be added to each element of `indices`
    /// > when chosing elements from the enabled vertex arrays.
    ///
    /// ### Description
    /// [**glDrawElementsBaseVertex**](crate::context::Context::oxidegl_draw_elements_base_vertex)
    /// behaves identically to [**glDrawElements**](crate::context::Context::oxidegl_draw_elements)
    /// except that the *i* th element transferred by the corresponding draw call
    /// will be taken from element `indices` \[i\]+ `basevertex` of each enabled
    /// array. If the resulting value is larger than the maximum value representable
    /// by `type`, it is as if the calculation were upconverted to 32-bit unsigned
    /// integers (with wrapping on overflow conditions). The operation is undefined
    /// if the sum would be negative.
    ///
    /// ### Notes
    /// [**glDrawElementsBaseVertex**](crate::context::Context::oxidegl_draw_elements_base_vertex)
    /// is only supported if the GL version is 3.2 or greater, or if the

    pub unsafe fn oxidegl_draw_elements_base_vertex(
        &mut self,
        mode: PrimitiveType,
        count: GLsizei,
        r#type: DrawElementsType,
        indices: *const GLvoid,
        basevertex: GLint,
    ) {
        panic!("command oxidegl_draw_elements_base_vertex not yet implemented");
    }
    /// ### Parameters
    /// `mode`
    ///
    /// > Specifies what kind of primitives to render. Symbolic constants [`GL_POINTS`](crate::enums::GL_POINTS),
    /// > [`GL_LINE_STRIP`](crate::enums::GL_LINE_STRIP), [`GL_LINE_LOOP`](crate::enums::GL_LINE_LOOP),
    /// > [`GL_LINES`](crate::enums::GL_LINES), [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY),
    /// > [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY), [`GL_TRIANGLE_STRIP`](crate::enums::GL_TRIANGLE_STRIP),
    /// > [`GL_TRIANGLE_FAN`](crate::enums::GL_TRIANGLE_FAN), [`GL_TRIANGLES`](crate::enums::GL_TRIANGLES),
    /// > [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY),
    /// > [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY), and [`GL_PATCHES`](crate::enums::GL_PATCHES)
    /// > are accepted.
    ///
    /// `type`
    ///
    /// > Specifies the type of data in the buffer bound to the [`GL_ELEMENT_ARRAY_BUFFER`](crate::enums::GL_ELEMENT_ARRAY_BUFFER)
    /// > binding.
    ///
    /// `indirect`
    ///
    /// > Specifies the address of a structure containing the draw parameters.
    ///
    /// ### Description
    /// [**glDrawElementsIndirect**](crate::context::Context::oxidegl_draw_elements_indirect)
    /// specifies multiple indexed geometric primitives with very few subroutine
    /// calls. [**glDrawElementsIndirect**](crate::context::Context::oxidegl_draw_elements_indirect)
    /// behaves similarly to [**glDrawElementsInstancedBaseVertexBaseInstance**](crate::context::Context::oxidegl_draw_elements_instanced_base_vertex_base_instance),
    /// execpt that the parameters to [**glDrawElementsInstancedBaseVertexBaseInstance**](crate::context::Context::oxidegl_draw_elements_instanced_base_vertex_base_instance)
    /// are stored in memory at the address given by `indirect`.
    ///
    /// The parameters addressed by `indirect` are packed into a structure that
    /// takes the form (in C):
    ///
    /// [**glDrawElementsIndirect**](crate::context::Context::oxidegl_draw_elements_indirect)
    /// is equivalent to:
    ///
    ///
    /// If a buffer is bound to the [`GL_DRAW_INDIRECT_BUFFER`](crate::enums::GL_DRAW_INDIRECT_BUFFER)
    /// binding at the time of a call to [**glDrawElementsIndirect**](crate::context::Context::oxidegl_draw_elements_indirect),
    /// `indirect` is interpreted as an offset, in basic machine units, into that
    /// buffer and the parameter data is read from the buffer rather than from
    /// client memory.
    ///
    /// Note that indices stored in client memory are not supported. If no buffer
    /// is bound to the [`GL_ELEMENT_ARRAY_BUFFER`](crate::enums::GL_ELEMENT_ARRAY_BUFFER)
    /// binding, an error will be generated.
    ///
    /// The results of the operation are undefined if the
    ///
    /// Vertex attributes that are modified by [**glDrawElementsIndirect**](crate::context::Context::oxidegl_draw_elements_indirect)
    /// have an unspecified value after [**glDrawElementsIndirect**](crate::context::Context::oxidegl_draw_elements_indirect)
    /// returns. Attributes that aren't modified remain well defined.
    ///
    /// ### Notes
    /// The `baseInstance` member of the `DrawElementsIndirectCommand` structure
    /// is defined only if the GL version is 4.2 or greater. For versions of the
    /// GL less than 4.2, this parameter is present but is reserved and should
    /// be set to zero. On earlier versions of the GL, behavior is undefined if
    /// it is non-zero.

    pub unsafe fn oxidegl_draw_elements_indirect(
        &mut self,
        mode: PrimitiveType,
        r#type: DrawElementsType,
        indirect: *const GLvoid,
    ) {
        panic!("command oxidegl_draw_elements_indirect not yet implemented");
    }
    /// ### Parameters
    /// `mode`
    ///
    /// > Specifies what kind of primitives to render. Symbolic constants [`GL_POINTS`](crate::enums::GL_POINTS),
    /// > [`GL_LINE_STRIP`](crate::enums::GL_LINE_STRIP), [`GL_LINE_LOOP`](crate::enums::GL_LINE_LOOP),
    /// > [`GL_LINES`](crate::enums::GL_LINES), [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY),
    /// > [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY), [`GL_TRIANGLE_STRIP`](crate::enums::GL_TRIANGLE_STRIP),
    /// > [`GL_TRIANGLE_FAN`](crate::enums::GL_TRIANGLE_FAN), [`GL_TRIANGLES`](crate::enums::GL_TRIANGLES),
    /// > [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY),
    /// > [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY) and [`GL_PATCHES`](crate::enums::GL_PATCHES)
    /// > are accepted.
    ///
    /// `count`
    ///
    /// > Specifies the number of elements to be rendered.
    ///
    /// `type`
    ///
    /// > Specifies the type of the values in `indices`. Must be one of [`GL_UNSIGNED_BYTE`](crate::enums::GL_UNSIGNED_BYTE),
    /// > [`GL_UNSIGNED_SHORT`](crate::enums::GL_UNSIGNED_SHORT), or [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT).
    ///
    /// `indices`
    ///
    /// > Specifies a pointer to the location where the indices are stored.
    ///
    /// `instancecount`
    ///
    /// > Specifies the number of instances of the specified range of indices to
    /// > be rendered.
    ///
    /// ### Description
    /// [**glDrawElementsInstanced**](crate::context::Context::oxidegl_draw_elements_instanced)
    /// behaves identically to [**glDrawElements**](crate::context::Context::oxidegl_draw_elements)
    /// except that `instancecount` instances of the set of elements are executed
    /// and the value of the internal counter `instanceID` advances for each iteration.
    /// `instanceID` is an internal 32-bit integer counter that may be read by
    /// a vertex shader as [`gl_InstanceID`](crate::enums::gl_InstanceID).
    ///
    /// [**glDrawElementsInstanced**](crate::context::Context::oxidegl_draw_elements_instanced)
    /// has the same effect as:
    ///
    /// ### Notes
    /// [**glDrawElementsInstanced**](crate::context::Context::oxidegl_draw_elements_instanced)
    /// is available only if the GL version is 3.1 or greater.
    ///
    /// [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY), [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY),
    /// [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY)
    /// and [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY) are
    /// available only if the GL version is 3.2 or greater.

    pub unsafe fn oxidegl_draw_elements_instanced(
        &mut self,
        mode: PrimitiveType,
        count: GLsizei,
        r#type: DrawElementsType,
        indices: *const GLvoid,
        instancecount: GLsizei,
    ) {
        panic!("command oxidegl_draw_elements_instanced not yet implemented");
    }
    /// ### Parameters
    /// `mode`
    ///
    /// > Specifies what kind of primitives to render. Symbolic constants [`GL_POINTS`](crate::enums::GL_POINTS),
    /// > [`GL_LINE_STRIP`](crate::enums::GL_LINE_STRIP), [`GL_LINE_LOOP`](crate::enums::GL_LINE_LOOP),
    /// > [`GL_LINES`](crate::enums::GL_LINES), [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY),
    /// > [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY), [`GL_TRIANGLE_STRIP`](crate::enums::GL_TRIANGLE_STRIP),
    /// > [`GL_TRIANGLE_FAN`](crate::enums::GL_TRIANGLE_FAN), [`GL_TRIANGLES`](crate::enums::GL_TRIANGLES),
    /// > [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY),
    /// > [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY) and [`GL_PATCHES`](crate::enums::GL_PATCHES)
    /// > are accepted.
    ///
    /// `count`
    ///
    /// > Specifies the number of elements to be rendered.
    ///
    /// `type`
    ///
    /// > Specifies the type of the values in `indices`. Must be one of [`GL_UNSIGNED_BYTE`](crate::enums::GL_UNSIGNED_BYTE),
    /// > [`GL_UNSIGNED_SHORT`](crate::enums::GL_UNSIGNED_SHORT), or [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT).
    ///
    /// `indices`
    ///
    /// > Specifies a pointer to the location where the indices are stored.
    ///
    /// `instancecount`
    ///
    /// > Specifies the number of instances of the specified range of indices to
    /// > be rendered.
    ///
    /// `baseinstance`
    ///
    /// > Specifies the base instance for use in fetching instanced vertex attributes.
    ///
    /// ### Description
    /// [**glDrawElementsInstancedBaseInstance**](crate::context::Context::oxidegl_draw_elements_instanced_base_instance)
    /// behaves identically to [**glDrawElements**](crate::context::Context::oxidegl_draw_elements)
    /// except that `instancecount` instances of the set of elements are executed
    /// and the value of the internal counter `instanceID` advances for each iteration.
    /// `instanceID` is an internal 32-bit integer counter that may be read by
    /// a vertex shader as [`gl_InstanceID`](crate::enums::gl_InstanceID).
    ///
    /// [**glDrawElementsInstancedBaseInstance**](crate::context::Context::oxidegl_draw_elements_instanced_base_instance)
    /// has the same effect as:
    ///
    /// Specific vertex attributes may be classified as *instanced* through the
    /// use of [**glVertexAttribDivisor**](crate::context::Context::oxidegl_vertex_attrib_divisor).
    /// Instanced vertex attributes supply per-instance vertex data to the vertex
    /// shader. The index of the vertex fetched from the enabled instanced vertex
    /// attribute arrays is calculated as `[inlineq]` `baseinstance` does not affect
    /// the shader-visible value of [`gl_InstanceID`](crate::enums::gl_InstanceID).
    ///
    /// ### Notes
    /// [**glDrawElementsInstancedBaseInstance**](crate::context::Context::oxidegl_draw_elements_instanced_base_instance)
    /// is available only if the GL version is 4.2 or greater.
    ///
    /// [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY), [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY),
    /// [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY)
    /// and [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY) are
    /// available only if the GL version is 3.2 or greater.

    pub unsafe fn oxidegl_draw_elements_instanced_base_instance(
        &mut self,
        mode: PrimitiveType,
        count: GLsizei,
        r#type: DrawElementsType,
        indices: *const GLvoid,
        instancecount: GLsizei,
        baseinstance: GLuint,
    ) {
        panic!("command oxidegl_draw_elements_instanced_base_instance not yet implemented");
    }
    /// ### Parameters
    /// `mode`
    ///
    /// > Specifies what kind of primitives to render. Symbolic constants [`GL_POINTS`](crate::enums::GL_POINTS),
    /// > [`GL_LINE_STRIP`](crate::enums::GL_LINE_STRIP), [`GL_LINE_LOOP`](crate::enums::GL_LINE_LOOP),
    /// > [`GL_LINES`](crate::enums::GL_LINES), [`GL_TRIANGLE_STRIP`](crate::enums::GL_TRIANGLE_STRIP),
    /// > [`GL_TRIANGLE_FAN`](crate::enums::GL_TRIANGLE_FAN), [`GL_TRIANGLES`](crate::enums::GL_TRIANGLES),
    /// > [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY), [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY),
    /// > [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY), [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY)
    /// > and [`GL_PATCHES`](crate::enums::GL_PATCHES) are accepted.
    ///
    /// `count`
    ///
    /// > Specifies the number of elements to be rendered.
    ///
    /// `type`
    ///
    /// > Specifies the type of the values in indices. Must be one of [`GL_UNSIGNED_BYTE`](crate::enums::GL_UNSIGNED_BYTE),
    /// > [`GL_UNSIGNED_SHORT`](crate::enums::GL_UNSIGNED_SHORT), or [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT).
    ///
    /// `indices`
    ///
    /// > Specifies a pointer to the location where the indices are stored.
    ///
    /// `instancecount`
    ///
    /// > Specifies the number of instances of the indexed geometry that should be
    /// > drawn.
    ///
    /// `basevertex`
    ///
    /// > Specifies a constant that should be added to each element of `indices`
    /// > when chosing elements from the enabled vertex arrays.
    ///
    /// ### Description
    /// [**glDrawElementsInstancedBaseVertex**](crate::context::Context::oxidegl_draw_elements_instanced_base_vertex)
    /// behaves identically to [**glDrawElementsInstanced**](crate::context::Context::oxidegl_draw_elements_instanced)
    /// except that the *i* th element transferred by the corresponding draw call
    /// will be taken from element `indices` \[i\]+ `basevertex` of each enabled
    /// array. If the resulting value is larger than the maximum value representable
    /// by `type`, it is as if the calculation were upconverted to 32-bit unsigned
    /// integers (with wrapping on overflow conditions). The operation is undefined
    /// if the sum would be negative.
    ///
    /// ### Notes
    /// [**glDrawElementsInstancedBaseVertex**](crate::context::Context::oxidegl_draw_elements_instanced_base_vertex)
    /// is only supported if the GL version is 3.2 or greater.

    pub unsafe fn oxidegl_draw_elements_instanced_base_vertex(
        &mut self,
        mode: PrimitiveType,
        count: GLsizei,
        r#type: DrawElementsType,
        indices: *const GLvoid,
        instancecount: GLsizei,
        basevertex: GLint,
    ) {
        panic!("command oxidegl_draw_elements_instanced_base_vertex not yet implemented");
    }
    /// ### Parameters
    /// `mode`
    ///
    /// > Specifies what kind of primitives to render. Symbolic constants [`GL_POINTS`](crate::enums::GL_POINTS),
    /// > [`GL_LINE_STRIP`](crate::enums::GL_LINE_STRIP), [`GL_LINE_LOOP`](crate::enums::GL_LINE_LOOP),
    /// > [`GL_LINES`](crate::enums::GL_LINES), [`GL_TRIANGLE_STRIP`](crate::enums::GL_TRIANGLE_STRIP),
    /// > [`GL_TRIANGLE_FAN`](crate::enums::GL_TRIANGLE_FAN), [`GL_TRIANGLES`](crate::enums::GL_TRIANGLES),
    /// > [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY), [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY),
    /// > [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY), [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY)
    /// > and [`GL_PATCHES`](crate::enums::GL_PATCHES) are accepted.
    ///
    /// `count`
    ///
    /// > Specifies the number of elements to be rendered.
    ///
    /// `type`
    ///
    /// > Specifies the type of the values in indices. Must be one of [`GL_UNSIGNED_BYTE`](crate::enums::GL_UNSIGNED_BYTE),
    /// > [`GL_UNSIGNED_SHORT`](crate::enums::GL_UNSIGNED_SHORT), or [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT).
    ///
    /// `indices`
    ///
    /// > Specifies a pointer to the location where the indices are stored.
    ///
    /// `instancecount`
    ///
    /// > Specifies the number of instances of the indexed geometry that should be
    /// > drawn.
    ///
    /// `basevertex`
    ///
    /// > Specifies a constant that should be added to each element of `indices`
    /// > when chosing elements from the enabled vertex arrays.
    ///
    /// `baseinstance`
    ///
    /// > Specifies the base instance for use in fetching instanced vertex attributes.
    ///
    /// ### Description
    /// [**glDrawElementsInstancedBaseVertexBaseInstance**](crate::context::Context::oxidegl_draw_elements_instanced_base_vertex_base_instance)
    /// behaves identically to [**glDrawElementsInstanced**](crate::context::Context::oxidegl_draw_elements_instanced)
    /// except that the *i* th element transferred by the corresponding draw call
    /// will be taken from element `indices` \[i\]+ `basevertex` of each enabled
    /// array. If the resulting value is larger than the maximum value representable
    /// by `type`, it is as if the calculation were upconverted to 32-bit unsigned
    /// integers (with wrapping on overflow conditions). The operation is undefined
    /// if the sum would be negative.
    ///
    /// Specific vertex attributes may be classified as *instanced* through the
    /// use of [**glVertexAttribDivisor**](crate::context::Context::oxidegl_vertex_attrib_divisor).
    /// Instanced vertex attributes supply per-instance vertex data to the vertex
    /// shader. The index of the vertex fetched from the enabled instanced vertex
    /// attribute arrays is calculated as `[inlineq]` `baseinstance` does not affect
    /// the shader-visible value of [`gl_InstanceID`](crate::enums::gl_InstanceID).
    ///
    /// ### Notes
    /// [**glDrawElementsInstancedBaseVertex**](crate::context::Context::oxidegl_draw_elements_instanced_base_vertex)
    /// is only supported if the GL version is 3.2 or greater.

    pub unsafe fn oxidegl_draw_elements_instanced_base_vertex_base_instance(
        &mut self,
        mode: PrimitiveType,
        count: GLsizei,
        r#type: DrawElementsType,
        indices: *const GLvoid,
        instancecount: GLsizei,
        basevertex: GLint,
        baseinstance: GLuint,
    ) {
        panic!(
            "command oxidegl_draw_elements_instanced_base_vertex_base_instance not yet implemented"
        );
    }
    /// ### Parameters
    /// `mode`
    ///
    /// > Specifies what kind of primitives to render. Symbolic constants [`GL_POINTS`](crate::enums::GL_POINTS),
    /// > [`GL_LINE_STRIP`](crate::enums::GL_LINE_STRIP), [`GL_LINE_LOOP`](crate::enums::GL_LINE_LOOP),
    /// > [`GL_LINES`](crate::enums::GL_LINES), [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY),
    /// > [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY), [`GL_TRIANGLE_STRIP`](crate::enums::GL_TRIANGLE_STRIP),
    /// > [`GL_TRIANGLE_FAN`](crate::enums::GL_TRIANGLE_FAN), [`GL_TRIANGLES`](crate::enums::GL_TRIANGLES),
    /// > [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY),
    /// > [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY) and [`GL_PATCHES`](crate::enums::GL_PATCHES)
    /// > are accepted.
    ///
    /// `start`
    ///
    /// > Specifies the minimum array index contained in `indices`.
    ///
    /// `end`
    ///
    /// > Specifies the maximum array index contained in `indices`.
    ///
    /// `count`
    ///
    /// > Specifies the number of elements to be rendered.
    ///
    /// `type`
    ///
    /// > Specifies the type of the values in `indices`. Must be one of [`GL_UNSIGNED_BYTE`](crate::enums::GL_UNSIGNED_BYTE),
    /// > [`GL_UNSIGNED_SHORT`](crate::enums::GL_UNSIGNED_SHORT), or [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT).
    ///
    /// `indices`
    ///
    /// > Specifies a pointer to the location where the indices are stored.
    ///
    /// ### Description
    /// [**glDrawRangeElements**](crate::context::Context::oxidegl_draw_range_elements)
    /// is a restricted form of [**glDrawElements**](crate::context::Context::oxidegl_draw_elements).
    /// `mode`, and `count` match the corresponding arguments to [**glDrawElements**](crate::context::Context::oxidegl_draw_elements),
    /// with the additional constraint that all values in the arrays `count` must
    /// lie between `start` and `end`, inclusive.
    ///
    /// Implementations denote recommended maximum amounts of vertex and index
    /// data, which may be queried by calling [**glGet**](crate::context::Context::oxidegl_get)
    /// with argument [`GL_MAX_ELEMENTS_VERTICES`](crate::enums::GL_MAX_ELEMENTS_VERTICES)
    /// and [`GL_MAX_ELEMENTS_INDICES`](crate::enums::GL_MAX_ELEMENTS_INDICES).
    /// If `[inlineq]` [`GL_MAX_ELEMENTS_VERTICES`](crate::enums::GL_MAX_ELEMENTS_VERTICES),
    /// or if `count` is greater than the value of [`GL_MAX_ELEMENTS_INDICES`](crate::enums::GL_MAX_ELEMENTS_INDICES),
    /// then the call may operate at reduced performance. There is no requirement
    /// that all vertices in the range `[inlineq]`
    ///
    /// When [**glDrawRangeElements**](crate::context::Context::oxidegl_draw_range_elements)
    /// is called, it uses `count` sequential elements from an enabled array, starting
    /// at `start` to construct a sequence of geometric primitives. `mode` specifies
    /// what kind of primitives are constructed, and how the array elements construct
    /// these primitives. If more than one array is enabled, each is used.
    ///
    /// Vertex attributes that are modified by [**glDrawRangeElements**](crate::context::Context::oxidegl_draw_range_elements)
    /// have an unspecified value after [**glDrawRangeElements**](crate::context::Context::oxidegl_draw_range_elements)
    /// returns. Attributes that aren't modified maintain their previous values.
    ///
    /// ### Notes
    /// [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY), [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY),
    /// [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY)
    /// and [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY) are
    /// available only if the GL version is 3.2 or greater.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_ELEMENTS_VERTICES`](crate::enums::GL_MAX_ELEMENTS_VERTICES)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_ELEMENTS_INDICES`](crate::enums::GL_MAX_ELEMENTS_INDICES)

    pub unsafe fn oxidegl_draw_range_elements(
        &mut self,
        mode: PrimitiveType,
        start: GLuint,
        end: GLuint,
        count: GLsizei,
        r#type: DrawElementsType,
        indices: *const GLvoid,
    ) {
        panic!("command oxidegl_draw_range_elements not yet implemented");
    }
    /// ### Parameters
    /// `mode`
    ///
    /// > Specifies what kind of primitives to render. Symbolic constants [`GL_POINTS`](crate::enums::GL_POINTS),
    /// > [`GL_LINE_STRIP`](crate::enums::GL_LINE_STRIP), [`GL_LINE_LOOP`](crate::enums::GL_LINE_LOOP),
    /// > [`GL_LINES`](crate::enums::GL_LINES), [`GL_TRIANGLE_STRIP`](crate::enums::GL_TRIANGLE_STRIP),
    /// > [`GL_TRIANGLE_FAN`](crate::enums::GL_TRIANGLE_FAN), [`GL_TRIANGLES`](crate::enums::GL_TRIANGLES),
    /// > [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY), [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY),
    /// > [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY), [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY)
    /// > and [`GL_PATCHES`](crate::enums::GL_PATCHES) are accepted.
    ///
    /// `start`
    ///
    /// > Specifies the minimum array index contained in `indices`.
    ///
    /// `end`
    ///
    /// > Specifies the maximum array index contained in `indices`.
    ///
    /// `count`
    ///
    /// > Specifies the number of elements to be rendered.
    ///
    /// `type`
    ///
    /// > Specifies the type of the values in indices. Must be one of [`GL_UNSIGNED_BYTE`](crate::enums::GL_UNSIGNED_BYTE),
    /// > [`GL_UNSIGNED_SHORT`](crate::enums::GL_UNSIGNED_SHORT), or [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT).
    ///
    /// `indices`
    ///
    /// > Specifies a pointer to the location where the indices are stored.
    ///
    /// `basevertex`
    ///
    /// > Specifies a constant that should be added to each element of `indices`
    /// > when chosing elements from the enabled vertex arrays.
    ///
    /// ### Description
    /// [**glDrawRangeElementsBaseVertex**](crate::context::Context::oxidegl_draw_range_elements_base_vertex)
    /// is a restricted form of [**glDrawElementsBaseVertex**](crate::context::Context::oxidegl_draw_elements_base_vertex).
    /// `mode`, `count` and `basevertex` match the corresponding arguments to [**glDrawElementsBaseVertex**](crate::context::Context::oxidegl_draw_elements_base_vertex),
    /// with the additional constraint that all values in the array `indices`
    /// must lie between `start` and `end`, inclusive, prior to adding `basevertex`.
    /// Index values lying outside the range \[ `start`, `end` \] are treated
    /// in the same way as [**glDrawElementsBaseVertex**](crate::context::Context::oxidegl_draw_elements_base_vertex).
    /// The *i* th element transferred by the corresponding draw call will be
    /// taken from element `indices` \[i\]+ `basevertex` of each enabled array.
    /// If the resulting value is larger than the maximum value representable by
    /// `type`, it is as if the calculation were upconverted to 32-bit unsigned
    /// integers (with wrapping on overflow conditions). The operation is undefined
    /// if the sum would be negative.

    pub unsafe fn oxidegl_draw_range_elements_base_vertex(
        &mut self,
        mode: PrimitiveType,
        start: GLuint,
        end: GLuint,
        count: GLsizei,
        r#type: DrawElementsType,
        indices: *const GLvoid,
        basevertex: GLint,
    ) {
        panic!("command oxidegl_draw_range_elements_base_vertex not yet implemented");
    }
    /// ### Parameters
    /// `mode`
    ///
    /// > Specifies what kind of primitives to render. Symbolic constants [`GL_POINTS`](crate::enums::GL_POINTS),
    /// > [`GL_LINE_STRIP`](crate::enums::GL_LINE_STRIP), [`GL_LINE_LOOP`](crate::enums::GL_LINE_LOOP),
    /// > [`GL_LINES`](crate::enums::GL_LINES), [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY),
    /// > [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY), [`GL_TRIANGLE_STRIP`](crate::enums::GL_TRIANGLE_STRIP),
    /// > [`GL_TRIANGLE_FAN`](crate::enums::GL_TRIANGLE_FAN), [`GL_TRIANGLES`](crate::enums::GL_TRIANGLES),
    /// > [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY),
    /// > [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY), and [`GL_PATCHES`](crate::enums::GL_PATCHES)
    /// > are accepted.
    ///
    /// `id`
    ///
    /// > Specifies the name of a transform feedback object from which to retrieve
    /// > a primitive count.
    ///
    /// ### Description
    /// [**glDrawTransformFeedback**](crate::context::Context::oxidegl_draw_transform_feedback)
    /// draws primitives of a type specified by `mode` using a count retrieved
    /// from the transform feedback specified by `id`. Calling [**glDrawTransformFeedback**](crate::context::Context::oxidegl_draw_transform_feedback)
    /// is equivalent to calling [**glDrawArrays**](crate::context::Context::oxidegl_draw_arrays)
    /// with `mode` as specified, `first` set to zero, and `count` set to the number
    /// of vertices captured on vertex stream zero the last time transform feedback
    /// was active on the transform feedback object named by `id`.

    pub fn oxidegl_draw_transform_feedback(&mut self, mode: PrimitiveType, id: GLuint) {
        panic!("command oxidegl_draw_transform_feedback not yet implemented");
    }
    /// ### Parameters
    /// `mode`
    ///
    /// > Specifies what kind of primitives to render. Symbolic constants [`GL_POINTS`](crate::enums::GL_POINTS),
    /// > [`GL_LINE_STRIP`](crate::enums::GL_LINE_STRIP), [`GL_LINE_LOOP`](crate::enums::GL_LINE_LOOP),
    /// > [`GL_LINES`](crate::enums::GL_LINES), [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY),
    /// > [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY), [`GL_TRIANGLE_STRIP`](crate::enums::GL_TRIANGLE_STRIP),
    /// > [`GL_TRIANGLE_FAN`](crate::enums::GL_TRIANGLE_FAN), [`GL_TRIANGLES`](crate::enums::GL_TRIANGLES),
    /// > [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY),
    /// > [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY), and [`GL_PATCHES`](crate::enums::GL_PATCHES)
    /// > are accepted.
    ///
    /// `id`
    ///
    /// > Specifies the name of a transform feedback object from which to retrieve
    /// > a primitive count.
    ///
    /// `instancecount`
    ///
    /// > Specifies the number of instances of the geometry to render.
    ///
    /// ### Description
    /// [**glDrawTransformFeedbackInstanced**](crate::context::Context::oxidegl_draw_transform_feedback_instanced)
    /// draws multiple copies of a range of primitives of a type specified by `mode`
    /// using a count retrieved from the transform feedback stream specified by
    /// `stream` of the transform feedback object specified by `id`. Calling [**glDrawTransformFeedbackInstanced**](crate::context::Context::oxidegl_draw_transform_feedback_instanced)
    /// is equivalent to calling [**glDrawArraysInstanced**](crate::context::Context::oxidegl_draw_arrays_instanced)
    /// with `mode` and `instancecount` as specified, `first` set to zero, and
    /// `count` set to the number of vertices captured on vertex stream zero the
    /// last time transform feedback was active on the transform feedback object
    /// named by `id`.
    ///
    /// Calling [**glDrawTransformFeedbackInstanced**](crate::context::Context::oxidegl_draw_transform_feedback_instanced)
    /// is equivalent to calling [**glDrawTransformFeedbackStreamInstanced**](crate::context::Context::oxidegl_draw_transform_feedback_stream_instanced)
    /// with `stream` set to zero.

    pub fn oxidegl_draw_transform_feedback_instanced(
        &mut self,
        mode: PrimitiveType,
        id: GLuint,
        instancecount: GLsizei,
    ) {
        panic!("command oxidegl_draw_transform_feedback_instanced not yet implemented");
    }
    /// ### Parameters
    /// `mode`
    ///
    /// > Specifies what kind of primitives to render. Symbolic constants [`GL_POINTS`](crate::enums::GL_POINTS),
    /// > [`GL_LINE_STRIP`](crate::enums::GL_LINE_STRIP), [`GL_LINE_LOOP`](crate::enums::GL_LINE_LOOP),
    /// > [`GL_LINES`](crate::enums::GL_LINES), [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY),
    /// > [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY), [`GL_TRIANGLE_STRIP`](crate::enums::GL_TRIANGLE_STRIP),
    /// > [`GL_TRIANGLE_FAN`](crate::enums::GL_TRIANGLE_FAN), [`GL_TRIANGLES`](crate::enums::GL_TRIANGLES),
    /// > [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY),
    /// > [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY), and [`GL_PATCHES`](crate::enums::GL_PATCHES)
    /// > are accepted.
    ///
    /// `id`
    ///
    /// > Specifies the name of a transform feedback object from which to retrieve
    /// > a primitive count.
    ///
    /// `stream`
    ///
    /// > Specifies the index of the transform feedback stream from which to retrieve
    /// > a primitive count.
    ///
    /// ### Description
    /// [**glDrawTransformFeedbackStream**](crate::context::Context::oxidegl_draw_transform_feedback_stream)
    /// draws primitives of a type specified by `mode` using a count retrieved
    /// from the transform feedback stream specified by `stream` of the transform
    /// feedback object specified by `id`. Calling [**glDrawTransformFeedbackStream**](crate::context::Context::oxidegl_draw_transform_feedback_stream)
    /// is equivalent to calling [**glDrawArrays**](crate::context::Context::oxidegl_draw_arrays)
    /// with `mode` as specified, `first` set to zero, and `count` set to the number
    /// of vertices captured on vertex stream `stream` the last time transform
    /// feedback was active on the transform feedback object named by `id`.
    ///
    /// Calling [**glDrawTransformFeedback**](crate::context::Context::oxidegl_draw_transform_feedback)
    /// is equivalent to calling [**glDrawTransformFeedbackStream**](crate::context::Context::oxidegl_draw_transform_feedback_stream)
    /// with `stream` set to zero.

    pub fn oxidegl_draw_transform_feedback_stream(
        &mut self,
        mode: PrimitiveType,
        id: GLuint,
        stream: GLuint,
    ) {
        panic!("command oxidegl_draw_transform_feedback_stream not yet implemented");
    }
    /// ### Parameters
    /// `mode`
    ///
    /// > Specifies what kind of primitives to render. Symbolic constants [`GL_POINTS`](crate::enums::GL_POINTS),
    /// > [`GL_LINE_STRIP`](crate::enums::GL_LINE_STRIP), [`GL_LINE_LOOP`](crate::enums::GL_LINE_LOOP),
    /// > [`GL_LINES`](crate::enums::GL_LINES), [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY),
    /// > [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY), [`GL_TRIANGLE_STRIP`](crate::enums::GL_TRIANGLE_STRIP),
    /// > [`GL_TRIANGLE_FAN`](crate::enums::GL_TRIANGLE_FAN), [`GL_TRIANGLES`](crate::enums::GL_TRIANGLES),
    /// > [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY),
    /// > [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY), and [`GL_PATCHES`](crate::enums::GL_PATCHES)
    /// > are accepted.
    ///
    /// `id`
    ///
    /// > Specifies the name of a transform feedback object from which to retrieve
    /// > a primitive count.
    ///
    /// `stream`
    ///
    /// > Specifies the index of the transform feedback stream from which to retrieve
    /// > a primitive count.
    ///
    /// `instancecount`
    ///
    /// > Specifies the number of instances of the geometry to render.
    ///
    /// ### Description
    /// [**glDrawTransformFeedbackStreamInstanced**](crate::context::Context::oxidegl_draw_transform_feedback_stream_instanced)
    /// draws multiple copies of a range of primitives of a type specified by `mode`
    /// using a count retrieved from the transform feedback stream specified by
    /// `stream` of the transform feedback object specified by `id`. Calling [**glDrawTransformFeedbackStreamInstanced**](crate::context::Context::oxidegl_draw_transform_feedback_stream_instanced)
    /// is equivalent to calling [**glDrawArraysInstanced**](crate::context::Context::oxidegl_draw_arrays_instanced)
    /// with `mode` and `instancecount` as specified, `first` set to zero, and
    /// `count` set to the number of vertices captured on vertex stream `stream`
    /// the last time transform feedback was active on the transform feedback object
    /// named by `id`.
    ///
    /// Calling [**glDrawTransformFeedbackInstanced**](crate::context::Context::oxidegl_draw_transform_feedback_instanced)
    /// is equivalent to calling [**glDrawTransformFeedbackStreamInstanced**](crate::context::Context::oxidegl_draw_transform_feedback_stream_instanced)
    /// with `stream` set to zero.

    pub fn oxidegl_draw_transform_feedback_stream_instanced(
        &mut self,
        mode: PrimitiveType,
        id: GLuint,
        stream: GLuint,
        instancecount: GLsizei,
    ) {
        panic!("command oxidegl_draw_transform_feedback_stream_instanced not yet implemented");
    }
    /// ### Parameters
    /// `condition`
    ///
    /// > Specifies the condition that must be met to set the sync object's state
    /// > to signaled. `condition` must be [`GL_SYNC_GPU_COMMANDS_COMPLETE`](crate::enums::GL_SYNC_GPU_COMMANDS_COMPLETE).
    ///
    /// `flags`
    ///
    /// > Specifies a bitwise combination of flags controlling the behavior of the
    /// > sync object. No flags are presently defined for this operation and `flags`
    /// > must be zero. `flags` is a placeholder for anticipated future extensions
    /// > of fence sync object capabilities.
    ///
    ///
    /// ### Description
    /// [**glFenceSync**](crate::context::Context::oxidegl_fence_sync) creates
    /// a new fence sync object, inserts a fence command into the GL command stream
    /// and associates it with that sync object, and returns a non-zero name corresponding
    /// to the sync object.
    ///
    /// When the specified `condition` of the sync object is satisfied by the fence
    /// command, the sync object is signaled by the GL, causing any [**glWaitSync**](crate::context::Context::oxidegl_wait_sync),
    /// [**glClientWaitSync**](crate::context::Context::oxidegl_client_wait_sync)
    /// commands blocking in `sync` to *unblock*. No other state is affected by
    /// [**glFenceSync**](crate::context::Context::oxidegl_fence_sync) or by the
    /// execution of the associated fence command.
    ///
    /// `condition` must be [`GL_SYNC_GPU_COMMANDS_COMPLETE`](crate::enums::GL_SYNC_GPU_COMMANDS_COMPLETE).
    /// This condition is satisfied by completion of the fence command corresponding
    /// to the sync object and all preceding commands in the same command stream.
    /// The sync object will not be signaled until all effects from these commands
    /// on GL client and server state and the framebuffer are fully realized. Note
    /// that completion of the fence command occurs once the state of the corresponding
    /// sync object has been changed, but commands waiting on that sync object
    /// may not be unblocked until after the fence command completes.
    ///
    /// ### Notes
    /// [**glFenceSync**](crate::context::Context::oxidegl_fence_sync) is only
    /// supported if the GL version is 3.2 or greater, or if the

    pub fn oxidegl_fence_sync(&mut self, condition: GLenum, flags: GLbitfield) -> GLsync {
        panic!("command oxidegl_fence_sync not yet implemented");
    }
    /// ### Description
    /// [**glFinish**](crate::context::Context::oxidegl_finish) does not return
    /// until the effects of all previously called GL commands are complete. Such
    /// effects include all changes to GL state, all changes to connection state,
    /// and all changes to the frame buffer contents.
    ///
    /// ### Notes
    /// [**glFinish**](crate::context::Context::oxidegl_finish) requires a round
    /// trip to the server.

    pub fn oxidegl_finish(&mut self) {
        panic!("command oxidegl_finish not yet implemented");
    }
    /// ### Description
    /// Different GL implementations buffer commands in several different locations,
    /// including network buffers and the graphics accelerator itself. [**glFlush**](crate::context::Context::oxidegl_flush)
    /// empties all of these buffers, causing all issued commands to be executed
    /// as quickly as they are accepted by the actual rendering engine. Though
    /// this execution may not be completed in any particular time period, it does
    /// complete in finite time.
    ///
    /// Because any GL program might be executed over a network, or on an accelerator
    /// that buffers commands, all programs should call [**glFlush**](crate::context::Context::oxidegl_flush)
    /// whenever they count on having all of their previously issued commands completed.
    /// For example, call [**glFlush**](crate::context::Context::oxidegl_flush)
    /// before waiting for user input that depends on the generated image.
    ///
    /// ### Notes
    /// [**glFlush**](crate::context::Context::oxidegl_flush) can return at any
    /// time. It does not wait until the execution of all previously issued GL
    /// commands is complete.

    pub fn oxidegl_flush(&mut self) {
        panic!("command oxidegl_flush not yet implemented");
    }
    /// ### Parameters
    /// `mode`
    ///
    /// > Specifies the orientation of front-facing polygons. [`GL_CW`](crate::enums::GL_CW)
    /// > and [`GL_CCW`](crate::enums::GL_CCW) are accepted. The initial value is
    /// > [`GL_CCW`](crate::enums::GL_CCW).
    ///
    /// ### Description
    /// In a scene composed entirely of opaque closed surfaces, back-facing polygons
    /// are never visible. Eliminating these invisible polygons has the obvious
    /// benefit of speeding up the rendering of the image. To enable and disable
    /// elimination of back-facing polygons, call [**glEnable**](crate::context::Context::oxidegl_enable)
    /// and [**glDisable**](crate::context::Context::oxidegl_disable) with argument
    /// [`GL_CULL_FACE`](crate::enums::GL_CULL_FACE).
    ///
    /// The projection of a polygon to window coordinates is said to have clockwise
    /// winding if an imaginary object following the path from its first vertex,
    /// its second vertex, and so on, to its last vertex, and finally back to its
    /// first vertex, moves in a clockwise direction about the interior of the
    /// polygon. The polygon's winding is said to be counterclockwise if the imaginary
    /// object following the same path moves in a counterclockwise direction about
    /// the interior of the polygon. [**glFrontFace**](crate::context::Context::oxidegl_front_face)
    /// specifies whether polygons with clockwise winding in window coordinates,
    /// or counterclockwise winding in window coordinates, are taken to be front-facing.
    /// Passing [`GL_CCW`](crate::enums::GL_CCW) to `mode` selects counterclockwise
    /// polygons as front-facing; [`GL_CW`](crate::enums::GL_CW) selects clockwise
    /// polygons as front-facing. By default, counterclockwise polygons are taken
    /// to be front-facing.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_FRONT_FACE`](crate::enums::GL_FRONT_FACE)

    pub fn oxidegl_front_face(&mut self, mode: FrontFaceDirection) {
        panic!("command oxidegl_front_face not yet implemented");
    }
    /// ### Parameters
    /// `n`
    ///
    /// > Specifies the number of framebuffer object names to generate.
    ///
    /// `ids`
    ///
    /// > Specifies an array in which the generated framebuffer object names are
    /// > stored.
    ///
    /// ### Description
    /// [**glGenFramebuffers**](crate::context::Context::oxidegl_gen_framebuffers)
    /// returns `n` framebuffer object names in `ids`. There is no guarantee that
    /// the names form a contiguous set of integers; however, it is guaranteed
    /// that none of the returned names was in use immediately before the call
    /// to [**glGenFramebuffers**](crate::context::Context::oxidegl_gen_framebuffers).
    ///
    /// Framebuffer object names returned by a call to [**glGenFramebuffers**](crate::context::Context::oxidegl_gen_framebuffers)
    /// are not returned by subsequent calls, unless they are first deleted with
    /// [**glDeleteFramebuffers**](crate::context::Context::oxidegl_delete_framebuffers).
    ///
    /// The names returned in `ids` are marked as used, for the purposes of [**glGenFramebuffers**](crate::context::Context::oxidegl_gen_framebuffers)
    /// only, but they acquire state and type only when they are first bound.

    pub unsafe fn oxidegl_gen_framebuffers(&mut self, n: GLsizei, framebuffers: *mut GLuint) {
        panic!("command oxidegl_gen_framebuffers not yet implemented");
    }
    /// ### Parameters
    /// `n`
    ///
    /// > Specifies the number of program pipeline object names to reserve.
    ///
    /// `pipelines`
    ///
    /// > Specifies an array of into which the reserved names will be written.
    ///
    /// ### Description
    /// [**glGenProgramPipelines**](crate::context::Context::oxidegl_gen_program_pipelines)
    /// returns `n` previously unused program pipeline object names in `pipelines`.
    /// These names are marked as used, for the purposes of [**glGenProgramPipelines**](crate::context::Context::oxidegl_gen_program_pipelines)
    /// only, but they acquire program pipeline state only when they are first
    /// bound.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_PROGRAM_PIPELINE_BINDING`](crate::enums::GL_PROGRAM_PIPELINE_BINDING)
    ///
    /// [**glIsProgramPipeline**](crate::context::Context::oxidegl_is_program_pipeline)

    pub unsafe fn oxidegl_gen_program_pipelines(&mut self, n: GLsizei, pipelines: *mut GLuint) {
        panic!("command oxidegl_gen_program_pipelines not yet implemented");
    }
    /// ### Parameters
    /// `n`
    ///
    /// > Specifies the number of query object names to be generated.
    ///
    /// `ids`
    ///
    /// > Specifies an array in which the generated query object names are stored.
    ///
    /// ### Description
    /// [**glGenQueries**](crate::context::Context::oxidegl_gen_queries) returns
    /// `n` query object names in `ids`. There is no guarantee that the names form
    /// a contiguous set of integers; however, it is guaranteed that none of the
    /// returned names was in use immediately before the call to [**glGenQueries**](crate::context::Context::oxidegl_gen_queries).
    ///
    /// Query object names returned by a call to [**glGenQueries**](crate::context::Context::oxidegl_gen_queries)
    /// are not returned by subsequent calls, unless they are first deleted with
    /// [**glDeleteQueries**](crate::context::Context::oxidegl_delete_queries).
    ///
    /// No query objects are associated with the returned query object names until
    /// they are first used by calling [**glBeginQuery**](crate::context::Context::oxidegl_begin_query).
    ///
    /// ### Associated Gets
    /// [**glIsQuery**](crate::context::Context::oxidegl_is_query)

    pub unsafe fn oxidegl_gen_queries(&mut self, n: GLsizei, ids: *mut GLuint) {
        panic!("command oxidegl_gen_queries not yet implemented");
    }
    /// ### Parameters
    /// `n`
    ///
    /// > Specifies the number of renderbuffer object names to generate.
    ///
    /// `renderbuffers`
    ///
    /// > Specifies an array in which the generated renderbuffer object names are
    /// > stored.
    ///
    /// ### Description
    /// [**glGenRenderbuffers**](crate::context::Context::oxidegl_gen_renderbuffers)
    /// returns `n` renderbuffer object names in `renderbuffers`. There is no guarantee
    /// that the names form a contiguous set of integers; however, it is guaranteed
    /// that none of the returned names was in use immediately before the call
    /// to [**glGenRenderbuffers**](crate::context::Context::oxidegl_gen_renderbuffers).
    ///
    /// Renderbuffer object names returned by a call to [**glGenRenderbuffers**](crate::context::Context::oxidegl_gen_renderbuffers)
    /// are not returned by subsequent calls, unless they are first deleted with
    /// [**glDeleteRenderbuffers**](crate::context::Context::oxidegl_delete_renderbuffers).
    ///
    /// The names returned in `renderbuffers` are marked as used, for the purposes
    /// of [**glGenRenderbuffers**](crate::context::Context::oxidegl_gen_renderbuffers)
    /// only, but they acquire state and type only when they are first bound.

    pub unsafe fn oxidegl_gen_renderbuffers(&mut self, n: GLsizei, renderbuffers: *mut GLuint) {
        panic!("command oxidegl_gen_renderbuffers not yet implemented");
    }
    /// ### Parameters
    /// `n`
    ///
    /// > Specifies the number of sampler object names to generate.
    ///
    /// `samplers`
    ///
    /// > Specifies an array in which the generated sampler object names are stored.
    ///
    /// ### Description
    /// [**glGenSamplers**](crate::context::Context::oxidegl_gen_samplers) returns
    /// `n` sampler object names in `samplers`. There is no guarantee that the
    /// names form a contiguous set of integers; however, it is guaranteed that
    /// none of the returned names was in use immediately before the call to [**glGenSamplers**](crate::context::Context::oxidegl_gen_samplers).
    ///
    /// Sampler object names returned by a call to [**glGenSamplers**](crate::context::Context::oxidegl_gen_samplers)
    /// are not returned by subsequent calls, unless they are first deleted with
    /// [**glDeleteSamplers**](crate::context::Context::oxidegl_delete_samplers).
    ///
    /// The names returned in `samplers` are marked as used, for the purposes of
    /// [**glGenSamplers**](crate::context::Context::oxidegl_gen_samplers) only,
    /// but they acquire state and type only when they are first bound.
    ///
    /// ### Notes
    /// [**glGenSamplers**](crate::context::Context::oxidegl_gen_samplers) is available
    /// only if the GL version is 3.3 or higher.

    pub unsafe fn oxidegl_gen_samplers(&mut self, count: GLsizei, samplers: *mut GLuint) {
        panic!("command oxidegl_gen_samplers not yet implemented");
    }
    /// ### Parameters
    /// `n`
    ///
    /// > Specifies the number of texture names to be generated.
    ///
    /// `textures`
    ///
    /// > Specifies an array in which the generated texture names are stored.
    ///
    /// ### Description
    /// [**glGenTextures**](crate::context::Context::oxidegl_gen_textures) returns
    /// `n` texture names in `textures`. There is no guarantee that the names form
    /// a contiguous set of integers; however, it is guaranteed that none of the
    /// returned names was in use immediately before the call to [**glGenTextures**](crate::context::Context::oxidegl_gen_textures).
    ///
    /// The generated textures have no dimensionality; they assume the dimensionality
    /// of the texture target to which they are first bound (see [**glBindTexture**](crate::context::Context::oxidegl_bind_texture)
    /// ).
    ///
    /// Texture names returned by a call to [**glGenTextures**](crate::context::Context::oxidegl_gen_textures)
    /// are not returned by subsequent calls, unless they are first deleted with
    /// [**glDeleteTextures**](crate::context::Context::oxidegl_delete_textures).
    ///
    /// ### Associated Gets
    /// [**glIsTexture**](crate::context::Context::oxidegl_is_texture)

    pub unsafe fn oxidegl_gen_textures(&mut self, n: GLsizei, textures: *mut GLuint) {
        panic!("command oxidegl_gen_textures not yet implemented");
    }
    /// ### Parameters
    /// `n`
    ///
    /// > Specifies the number of transform feedback object names to reserve.
    ///
    /// `ids`
    ///
    /// > Specifies an array of into which the reserved names will be written.
    ///
    /// ### Description
    /// [**glGenTransformFeedbacks**](crate::context::Context::oxidegl_gen_transform_feedbacks)
    /// returns `n` previously unused transform feedback object names in `ids`.
    /// These names are marked as used, for the purposes of [**glGenTransformFeedbacks**](crate::context::Context::oxidegl_gen_transform_feedbacks)
    /// only, but they acquire transform feedback state only when they are first
    /// bound.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_TRANSFORM_FEEDBACK_BINDING`](crate::enums::GL_TRANSFORM_FEEDBACK_BINDING)
    ///
    /// [**glIsTransformFeedback**](crate::context::Context::oxidegl_is_transform_feedback)

    pub unsafe fn oxidegl_gen_transform_feedbacks(&mut self, n: GLsizei, ids: *mut GLuint) {
        panic!("command oxidegl_gen_transform_feedbacks not yet implemented");
    }

    /// ### Parameters
    /// `program`
    ///
    /// > The name of a program object from which to retrieve information.
    ///
    /// `bufferIndex`
    ///
    /// > Specifies index of an active atomic counter buffer.
    ///
    /// `pname`
    ///
    /// > Specifies which parameter of the atomic counter buffer to retrieve.
    ///
    /// `params`
    ///
    /// > Specifies the address of a variable into which to write the retrieved information.
    ///
    /// ### Description
    /// [**glGetActiveAtomicCounterBufferiv**](crate::context::Context::oxidegl_get_active_atomic_counter_bufferiv)
    /// retrieves information about the set of active atomic counter buffers for
    /// a program object. `program` is the name of a program object for which the
    /// command [**glLinkProgram**](crate::context::Context::oxidegl_link_program)
    /// has been issued in the past. It is not necessary for `program` to have
    /// been linked successfully. The link may have failed because the number of
    /// active atomic counters exceeded the limits.
    ///
    /// `bufferIndex` specifies the index of an active atomic counter buffer and
    /// must be in the range zero to the value of [`GL_ACTIVE_ATOMIC_COUNTER_BUFFERS`](crate::enums::GL_ACTIVE_ATOMIC_COUNTER_BUFFERS)
    /// minus one. The value of [`GL_ACTIVE_ATOMIC_COUNTER_BUFFERS`](crate::enums::GL_ACTIVE_ATOMIC_COUNTER_BUFFERS)
    /// for `program` indicates the number of active atomic counter buffer and
    /// can be queried with [**glGetProgram**](crate::context::Context::oxidegl_get_program).
    ///
    /// If no error occurs, the parameter(s) specified by `pname` are returned
    /// in `params`. If an error is generated, the contents of `params` are not
    /// modified.
    ///
    /// If `pname` is [`GL_ATOMIC_COUNTER_BUFFER_BINDING`](crate::enums::GL_ATOMIC_COUNTER_BUFFER_BINDING),
    /// then the index of the counter buffer binding point associated with the
    /// active atomic counter buffer `bufferIndex` for `program` is returned.
    ///
    /// If `pname` is [`GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE`](crate::enums::GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE),
    /// then the implementation-dependent minimum total buffer object size, in
    /// baseic machine units, required to hold all active atomic counters in the
    /// atomic counter binding point identified by `bufferIndex` is returned.
    ///
    /// If `pname` is [`GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS`](crate::enums::GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS),
    /// then the number of active atomic counters for the atomic counter buffer
    /// identified by `bufferIndex` is returned.
    ///
    /// If `pname` is [`GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES`](crate::enums::GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES),
    /// then a list of the active atomic counter indices for the atomic counter
    /// buffer identified by `bufferIndex` is returned. The number of elements
    /// that will be written into `params` is the value of [`GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS`](crate::enums::GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS)
    /// for `bufferIndex`.
    ///
    /// If `pname` is [`GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER),
    /// [`GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER),
    /// [`GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER),
    /// [`GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER),
    /// [`GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER),
    /// [`GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER)
    /// then a boolean value indicating whether the atomic counter buffer identified
    /// by `bufferIndex` is referenced by the vertex, tessellation control, tessellation
    /// evaluation, geometry, fragment or compute processing stages of `program`,
    /// respectively, is returned.
    ///
    /// ### Notes
    /// [**glGetActiveAtomicCounterBufferiv**](crate::context::Context::oxidegl_get_active_atomic_counter_bufferiv)
    /// is available only if the GL version is 4.2 or higher.
    ///
    /// [`GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER)
    /// is available only of the GL version is 4.3 or higher.

    pub unsafe fn oxidegl_get_active_atomic_counter_bufferiv(
        &mut self,
        program: GLuint,
        buffer_index: GLuint,
        pname: AtomicCounterBufferPName,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_active_atomic_counter_bufferiv not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the program object to be queried.
    ///
    /// `index`
    ///
    /// > Specifies the index of the attribute variable to be queried.
    ///
    /// `bufSize`
    ///
    /// > Specifies the maximum number of characters OpenGL is allowed to write in
    /// > the character buffer indicated by `name`.
    ///
    /// `length`
    ///
    /// > Returns the number of characters actually written by OpenGL in the string
    /// > indicated by `name` (excluding the null terminator) if a value other than
    /// > [`NULL`](crate::enums::NULL) is passed.
    ///
    /// `size`
    ///
    /// > Returns the size of the attribute variable.
    ///
    /// `type`
    ///
    /// > Returns the data type of the attribute variable.
    ///
    /// `name`
    ///
    /// > Returns a null terminated string containing the name of the attribute variable.
    ///
    /// ### Description
    /// [**glGetActiveAttrib**](crate::context::Context::oxidegl_get_active_attrib)
    /// returns information about an active attribute variable in the program object
    /// specified by `program`. The number of active attributes can be obtained
    /// by calling [**glGetProgram**](crate::context::Context::oxidegl_get_program)
    /// with the value [`GL_ACTIVE_ATTRIBUTES`](crate::enums::GL_ACTIVE_ATTRIBUTES).
    /// A value of 0 for `index` selects the first active attribute variable.
    /// Permissible values for `index` range from zero to the number of active
    /// attribute variables minus one.
    ///
    /// A vertex shader may use either built-in attribute variables, user-defined
    /// attribute variables, or both. Built-in attribute variables have a prefix
    /// of "gl_" and reference conventional OpenGL vertex attribtes (e.g., `gl_Vertex`,
    /// `gl_Normal`, etc., see the OpenGL Shading Language specification for a
    /// complete list.) User-defined attribute variables have arbitrary names and
    /// obtain their values through numbered generic vertex attributes. An attribute
    /// variable (either built-in or user-defined) is considered active if it is
    /// determined during the link operation that it may be accessed during program
    /// execution. Therefore, `program` should have previously been the target
    /// of a call to [**glLinkProgram**](crate::context::Context::oxidegl_link_program),
    /// but it is not necessary for it to have been linked successfully.
    ///
    /// The size of the character buffer required to store the longest attribute
    /// variable name in `program` can be obtained by calling [**glGetProgram**](crate::context::Context::oxidegl_get_program)
    /// with the value [`GL_ACTIVE_ATTRIBUTE_MAX_LENGTH`](crate::enums::GL_ACTIVE_ATTRIBUTE_MAX_LENGTH).
    /// This value should be used to allocate a buffer of sufficient size to store
    /// the returned attribute name. The size of this character buffer is passed
    /// in `bufSize`, and a pointer to this character buffer is passed in `name`.
    ///
    /// [**glGetActiveAttrib**](crate::context::Context::oxidegl_get_active_attrib)
    /// returns the name of the attribute variable indicated by `index`, storing
    /// it in the character buffer specified by `name`. The string returned will
    /// be null terminated. The actual number of characters written into this buffer
    /// is returned in `length`, and this count does not include the null termination
    /// character. If the length of the returned string is not required, a value
    /// of [`NULL`](crate::enums::NULL) can be passed in the `length` argument.
    ///
    /// The `type` argument specifies a pointer to a variable into which the attribute
    /// variable's data type will be written. The symbolic constants [`GL_FLOAT`](crate::enums::GL_FLOAT),
    /// [`GL_FLOAT_VEC2`](crate::enums::GL_FLOAT_VEC2), [`GL_FLOAT_VEC3`](crate::enums::GL_FLOAT_VEC3),
    /// [`GL_FLOAT_VEC4`](crate::enums::GL_FLOAT_VEC4), [`GL_FLOAT_MAT2`](crate::enums::GL_FLOAT_MAT2),
    /// [`GL_FLOAT_MAT3`](crate::enums::GL_FLOAT_MAT3), [`GL_FLOAT_MAT4`](crate::enums::GL_FLOAT_MAT4),
    /// [`GL_FLOAT_MAT2x3`](crate::enums::GL_FLOAT_MAT2x3), [`GL_FLOAT_MAT2x4`](crate::enums::GL_FLOAT_MAT2x4),
    /// [`GL_FLOAT_MAT3x2`](crate::enums::GL_FLOAT_MAT3x2), [`GL_FLOAT_MAT3x4`](crate::enums::GL_FLOAT_MAT3x4),
    /// [`GL_FLOAT_MAT4x2`](crate::enums::GL_FLOAT_MAT4x2), [`GL_FLOAT_MAT4x3`](crate::enums::GL_FLOAT_MAT4x3),
    /// [`GL_INT`](crate::enums::GL_INT), [`GL_INT_VEC2`](crate::enums::GL_INT_VEC2),
    /// [`GL_INT_VEC3`](crate::enums::GL_INT_VEC3), [`GL_INT_VEC4`](crate::enums::GL_INT_VEC4),
    /// [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT), [`GL_UNSIGNED_INT_VEC2`](crate::enums::GL_UNSIGNED_INT_VEC2),
    /// [`GL_UNSIGNED_INT_VEC3`](crate::enums::GL_UNSIGNED_INT_VEC3), [`GL_UNSIGNED_INT_VEC4`](crate::enums::GL_UNSIGNED_INT_VEC4),
    /// [`GL_DOUBLE`](crate::enums::GL_DOUBLE), [`GL_DOUBLE_VEC2`](crate::enums::GL_DOUBLE_VEC2),
    /// [`GL_DOUBLE_VEC3`](crate::enums::GL_DOUBLE_VEC3), [`GL_DOUBLE_VEC4`](crate::enums::GL_DOUBLE_VEC4),
    /// [`GL_DOUBLE_MAT2`](crate::enums::GL_DOUBLE_MAT2), [`GL_DOUBLE_MAT3`](crate::enums::GL_DOUBLE_MAT3),
    /// [`GL_DOUBLE_MAT4`](crate::enums::GL_DOUBLE_MAT4), [`GL_DOUBLE_MAT2x3`](crate::enums::GL_DOUBLE_MAT2x3),
    /// [`GL_DOUBLE_MAT2x4`](crate::enums::GL_DOUBLE_MAT2x4), [`GL_DOUBLE_MAT3x2`](crate::enums::GL_DOUBLE_MAT3x2),
    /// [`GL_DOUBLE_MAT3x4`](crate::enums::GL_DOUBLE_MAT3x4), [`GL_DOUBLE_MAT4x2`](crate::enums::GL_DOUBLE_MAT4x2),
    /// or [`GL_DOUBLE_MAT4x3`](crate::enums::GL_DOUBLE_MAT4x3) may be returned.
    /// The `size` argument will return the size of the attribute, in units of
    /// the type returned in `type`.
    ///
    /// The list of active attribute variables may include both built-in attribute
    /// variables (which begin with the prefix "gl_") as well as user-defined attribute
    /// variable names.
    ///
    /// This function will return as much information as it can about the specified
    /// active attribute variable. If no information is available, `length` will
    /// be 0, and `name` will be an empty string. This situation could occur if
    /// this function is called after a link operation that failed. If an error
    /// occurs, the return values `length`, `size`, `type`, and `name` will be
    /// unmodified.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_VERTEX_ATTRIBS`](crate::enums::GL_MAX_VERTEX_ATTRIBS).
    ///
    /// [**glGetProgram**](crate::context::Context::oxidegl_get_program) with argument
    /// [`GL_ACTIVE_ATTRIBUTES`](crate::enums::GL_ACTIVE_ATTRIBUTES) or [`GL_ACTIVE_ATTRIBUTE_MAX_LENGTH`](crate::enums::GL_ACTIVE_ATTRIBUTE_MAX_LENGTH).
    ///
    /// [**glIsProgram**](crate::context::Context::oxidegl_is_program)

    pub unsafe fn oxidegl_get_active_attrib(
        &mut self,
        program: GLuint,
        index: GLuint,
        buf_size: GLsizei,
        length: *mut GLsizei,
        size: *mut GLint,
        r#type: AttributeType,
        name: *mut GLchar,
    ) {
        panic!("command oxidegl_get_active_attrib not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the name of the program containing the subroutine.
    ///
    /// `shadertype`
    ///
    /// > Specifies the shader stage from which to query the subroutine name.
    ///
    /// `index`
    ///
    /// > Specifies the index of the shader subroutine uniform.
    ///
    /// `bufSize`
    ///
    /// > Specifies the size of the buffer whose address is given in `name`.
    ///
    /// `length`
    ///
    /// > Specifies the address of a variable which is to receive the length of the
    /// > shader subroutine uniform name.
    ///
    /// `name`
    ///
    /// > Specifies the address of an array into which the name of the shader subroutine
    /// > uniform will be written.
    ///
    /// ### Description
    /// [**glGetActiveSubroutineName**](crate::context::Context::oxidegl_get_active_subroutine_name)
    /// queries the name of an active shader subroutine uniform from the program
    /// object given in `program`. `index` specifies the index of the shader subroutine
    /// uniform within the shader stage given by `stage`, and must between zero
    /// and the value of [`GL_ACTIVE_SUBROUTINES`](crate::enums::GL_ACTIVE_SUBROUTINES)
    /// minus one for the shader stage.
    ///
    /// The name of the selected subroutine is returned as a null-terminated string
    /// in `name`. The actual number of characters written into `name`, not including
    /// the null-terminator, is returned in `length`. If `length` is [`NULL`](crate::enums::NULL),
    /// no length is returned. The maximum number of characters that may be written
    /// into `name`, including the null-terminator, is given in `bufSize`.
    ///
    /// ### Associated Gets
    /// [**glGetProgramStage**](crate::context::Context::oxidegl_get_program_stage)
    /// with argument [`GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH`](crate::enums::GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH)

    pub unsafe fn oxidegl_get_active_subroutine_name(
        &mut self,
        program: GLuint,
        shadertype: ShaderType,
        index: GLuint,
        buf_size: GLsizei,
        length: *mut GLsizei,
        name: *mut GLchar,
    ) {
        panic!("command oxidegl_get_active_subroutine_name not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the name of the program containing the subroutine.
    ///
    /// `shadertype`
    ///
    /// > Specifies the shader stage from which to query for the subroutine parameter.
    /// > `shadertype` must be one of [`GL_VERTEX_SHADER`](crate::enums::GL_VERTEX_SHADER),
    /// > [`GL_TESS_CONTROL_SHADER`](crate::enums::GL_TESS_CONTROL_SHADER), [`GL_TESS_EVALUATION_SHADER`](crate::enums::GL_TESS_EVALUATION_SHADER),
    /// > [`GL_GEOMETRY_SHADER`](crate::enums::GL_GEOMETRY_SHADER) or [`GL_FRAGMENT_SHADER`](crate::enums::GL_FRAGMENT_SHADER).
    ///
    /// `index`
    ///
    /// > Specifies the index of the shader subroutine uniform.
    ///
    /// `pname`
    ///
    /// > Specifies the parameter of the shader subroutine uniform to query. `pname`
    /// > must be [`GL_NUM_COMPATIBLE_SUBROUTINES`](crate::enums::GL_NUM_COMPATIBLE_SUBROUTINES),
    /// > [`GL_COMPATIBLE_SUBROUTINES`](crate::enums::GL_COMPATIBLE_SUBROUTINES),
    /// > [`GL_UNIFORM_SIZE`](crate::enums::GL_UNIFORM_SIZE) or [`GL_UNIFORM_NAME_LENGTH`](crate::enums::GL_UNIFORM_NAME_LENGTH).
    ///
    /// `values`
    ///
    /// > Specifies the address of a into which the queried value or values will
    /// > be placed.
    ///
    /// ### Description
    /// [**glGetActiveSubroutineUniform**](crate::context::Context::oxidegl_get_active_subroutine_uniform)
    /// queries a parameter of an active shader subroutine uniform. `program` contains
    /// the name of the program containing the uniform. `shadertype` specifies
    /// the stage which the uniform location, given by `index`, is valid. `index`
    /// must be between zero and the value of [`GL_ACTIVE_SUBROUTINE_UNIFORMS`](crate::enums::GL_ACTIVE_SUBROUTINE_UNIFORMS)
    /// minus one for the shader stage.
    ///
    /// If `pname` is [`GL_NUM_COMPATIBLE_SUBROUTINES`](crate::enums::GL_NUM_COMPATIBLE_SUBROUTINES),
    /// a single integer indicating the number of subroutines that can be assigned
    /// to the uniform is returned in `values`.
    ///
    /// If `pname` is [`GL_COMPATIBLE_SUBROUTINES`](crate::enums::GL_COMPATIBLE_SUBROUTINES),
    /// an array of integers is returned in `values`, with each integer specifying
    /// the index of an active subroutine that can be assigned to the selected
    /// subroutine uniform. The number of integers returned is the same as the
    /// value returned for [`GL_NUM_COMPATIBLE_SUBROUTINES`](crate::enums::GL_NUM_COMPATIBLE_SUBROUTINES).
    ///
    /// If `pname` is [`GL_UNIFORM_SIZE`](crate::enums::GL_UNIFORM_SIZE), a single
    /// integer is returned in `values`. If the selected subroutine uniform is
    /// an array, the declared size of the array is returned; otherwise, one is
    /// returned.
    ///
    /// If `pname` is [`GL_UNIFORM_NAME_LENGTH`](crate::enums::GL_UNIFORM_NAME_LENGTH),
    /// a single integer specifying the length of the subroutine uniform name
    /// (including the terminating null character) is returned in `values`.
    ///
    /// ### Associated Gets
    /// [**glGetProgramStage**](crate::context::Context::oxidegl_get_program_stage)
    /// with argument [`GL_ACTIVE_SUBROUTINE_UNIFORMS`](crate::enums::GL_ACTIVE_SUBROUTINE_UNIFORMS)

    pub unsafe fn oxidegl_get_active_subroutine_uniformiv(
        &mut self,
        program: GLuint,
        shadertype: ShaderType,
        index: GLuint,
        pname: SubroutineParameterName,
        values: *mut GLint,
    ) {
        panic!("command oxidegl_get_active_subroutine_uniformiv not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the name of the program containing the subroutine.
    ///
    /// `shadertype`
    ///
    /// > Specifies the shader stage from which to query for the subroutine parameter.
    /// > `shadertype` must be one of [`GL_VERTEX_SHADER`](crate::enums::GL_VERTEX_SHADER),
    /// > [`GL_TESS_CONTROL_SHADER`](crate::enums::GL_TESS_CONTROL_SHADER), [`GL_TESS_EVALUATION_SHADER`](crate::enums::GL_TESS_EVALUATION_SHADER),
    /// > [`GL_GEOMETRY_SHADER`](crate::enums::GL_GEOMETRY_SHADER) or [`GL_FRAGMENT_SHADER`](crate::enums::GL_FRAGMENT_SHADER).
    ///
    /// `index`
    ///
    /// > Specifies the index of the shader subroutine uniform.
    ///
    /// `bufSize`
    ///
    /// > Specifies the size of the buffer whose address is given in `name`.
    ///
    /// `length`
    ///
    /// > Specifies the address of a variable into which is written the number of
    /// > characters copied into `name`.
    ///
    /// `name`
    ///
    /// > Specifies the address of a buffer that will receive the name of the specified
    /// > shader subroutine uniform.
    ///
    /// ### Description
    /// [**glGetActiveSubroutineUniformName**](crate::context::Context::oxidegl_get_active_subroutine_uniform_name)
    /// retrieves the name of an active shader subroutine uniform. `program` contains
    /// the name of the program containing the uniform. `shadertype` specifies
    /// the stage for which the uniform location, given by `index`, is valid. `index`
    /// must be between zero and the value of [`GL_ACTIVE_SUBROUTINE_UNIFORMS`](crate::enums::GL_ACTIVE_SUBROUTINE_UNIFORMS)
    /// minus one for the shader stage.
    ///
    /// The uniform name is returned as a null-terminated string in `name`. The
    /// actual number of characters written into `name`, excluding the null terminator
    /// is returned in `length`. If `length` is [`NULL`](crate::enums::NULL), no
    /// length is returned. The maximum number of characters that may be written
    /// into `name`, including the null terminator, is specified by `bufSize`. The
    /// length of the longest subroutine uniform name in `program` and `shadertype`
    /// is given by the value of [`GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH`](crate::enums::GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH),
    /// which can be queried with [**glGetProgramStage**](crate::context::Context::oxidegl_get_program_stage).
    ///
    /// ### Associated Gets
    /// [**glGetProgramStage**](crate::context::Context::oxidegl_get_program_stage)
    /// with argument [`GL_ACTIVE_SUBROUTINE_UNIFORMS`](crate::enums::GL_ACTIVE_SUBROUTINE_UNIFORMS)

    pub unsafe fn oxidegl_get_active_subroutine_uniform_name(
        &mut self,
        program: GLuint,
        shadertype: ShaderType,
        index: GLuint,
        buf_size: GLsizei,
        length: *mut GLsizei,
        name: *mut GLchar,
    ) {
        panic!("command oxidegl_get_active_subroutine_uniform_name not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the program object to be queried.
    ///
    /// `index`
    ///
    /// > Specifies the index of the uniform variable to be queried.
    ///
    /// `bufSize`
    ///
    /// > Specifies the maximum number of characters OpenGL is allowed to write in
    /// > the character buffer indicated by `name`.
    ///
    /// `length`
    ///
    /// > Returns the number of characters actually written by OpenGL in the string
    /// > indicated by `name` (excluding the null terminator) if a value other than
    /// > [`NULL`](crate::enums::NULL) is passed.
    ///
    /// `size`
    ///
    /// > Returns the size of the uniform variable.
    ///
    /// `type`
    ///
    /// > Returns the data type of the uniform variable.
    ///
    /// `name`
    ///
    /// > Returns a null terminated string containing the name of the uniform variable.
    ///
    /// ### Description
    /// [**glGetActiveUniform**](crate::context::Context::oxidegl_get_active_uniform)
    /// returns information about an active uniform variable in the program object
    /// specified by `program`. The number of active uniform variables can be obtained
    /// by calling [**glGetProgram**](crate::context::Context::oxidegl_get_program)
    /// with the value [`GL_ACTIVE_UNIFORMS`](crate::enums::GL_ACTIVE_UNIFORMS).
    /// A value of 0 for `index` selects the first active uniform variable. Permissible
    /// values for `index` range from zero to the number of active uniform variables
    /// minus one.
    ///
    /// Shaders may use either built-in uniform variables, user-defined uniform
    /// variables, or both. Built-in uniform variables have a prefix of "gl_" and
    /// reference existing OpenGL state or values derived from such state (e.g.,
    /// `gl_DepthRangeParameters`, see the OpenGL Shading Language specification
    /// for a complete list.) User-defined uniform variables have arbitrary names
    /// and obtain their values from the application through calls to [**glUniform**](crate::context::Context::oxidegl_uniform).
    /// A uniform variable (either built-in or user-defined) is considered active
    /// if it is determined during the link operation that it may be accessed during
    /// program execution. Therefore, `program` should have previously been the
    /// target of a call to [**glLinkProgram**](crate::context::Context::oxidegl_link_program),
    /// but it is not necessary for it to have been linked successfully.
    ///
    /// The size of the character buffer required to store the longest uniform
    /// variable name in `program` can be obtained by calling [**glGetProgram**](crate::context::Context::oxidegl_get_program)
    /// with the value [`GL_ACTIVE_UNIFORM_MAX_LENGTH`](crate::enums::GL_ACTIVE_UNIFORM_MAX_LENGTH).
    /// This value should be used to allocate a buffer of sufficient size to store
    /// the returned uniform variable name. The size of this character buffer is
    /// passed in `bufSize`, and a pointer to this character buffer is passed in
    /// `name.`
    ///
    /// [**glGetActiveUniform**](crate::context::Context::oxidegl_get_active_uniform)
    /// returns the name of the uniform variable indicated by `index`, storing
    /// it in the character buffer specified by `name`. The string returned will
    /// be null terminated. The actual number of characters written into this buffer
    /// is returned in `length`, and this count does not include the null termination
    /// character. If the length of the returned string is not required, a value
    /// of [`NULL`](crate::enums::NULL) can be passed in the `length` argument.
    ///
    /// The `type` argument will return a pointer to the uniform variable's data
    /// type. The symbolic constants returned for uniform types are shown in the
    /// table below.
    /// |* Returned Symbolic Contant*                                 |* Shader Uniform Type*                              |
    /// |-------------------------------------------------------------|----------------------------------------------------|
    /// | [`GL_FLOAT`](crate::enums::GL_FLOAT)                        | [`float`](crate::enums::float)                     |
    /// | [`GL_FLOAT_VEC2`](crate::enums::GL_FLOAT_VEC2)              | [`vec2`](crate::enums::vec2)                       |
    /// | [`GL_FLOAT_VEC3`](crate::enums::GL_FLOAT_VEC3)              | [`vec3`](crate::enums::vec3)                       |
    /// | [`GL_FLOAT_VEC4`](crate::enums::GL_FLOAT_VEC4)              | [`vec4`](crate::enums::vec4)                       |
    /// | [`GL_DOUBLE`](crate::enums::GL_DOUBLE)                      | [`double`](crate::enums::double)                   |
    /// | [`GL_DOUBLE_VEC2`](crate::enums::GL_DOUBLE_VEC2)            | [`dvec2`](crate::enums::dvec2)                     |
    /// | [`GL_DOUBLE_VEC3`](crate::enums::GL_DOUBLE_VEC3)            | [`dvec3`](crate::enums::dvec3)                     |
    /// | [`GL_DOUBLE_VEC4`](crate::enums::GL_DOUBLE_VEC4)            | [`dvec4`](crate::enums::dvec4)                     |
    /// | [`GL_INT`](crate::enums::GL_INT)                            | [`int`](crate::enums::int)                         |
    /// | [`GL_INT_VEC2`](crate::enums::GL_INT_VEC2)                  | [`ivec2`](crate::enums::ivec2)                     |
    /// | [`GL_INT_VEC3`](crate::enums::GL_INT_VEC3)                  | [`ivec3`](crate::enums::ivec3)                     |
    /// | [`GL_INT_VEC4`](crate::enums::GL_INT_VEC4)                  | [`ivec4`](crate::enums::ivec4)                     |
    /// | [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT)          | [`unsigned int`](`crate::enums::unsigned` int)       |
    /// | [`GL_UNSIGNED_INT_VEC2`](crate::enums::GL_UNSIGNED_INT_VEC2) | [`uvec2`](crate::enums::uvec2)                    |
    /// | [`GL_UNSIGNED_INT_VEC3`](crate::enums::GL_UNSIGNED_INT_VEC3) | [`uvec3`](crate::enums::uvec3)                    |
    /// | [`GL_UNSIGNED_INT_VEC4`](crate::enums::GL_UNSIGNED_INT_VEC4) | [`uvec4`](crate::enums::uvec4)                    |
    /// | [`GL_BOOL`](crate::enums::GL_BOOL)                          | [`bool`](crate::enums::bool)                       |
    /// | [`GL_BOOL_VEC2`](crate::enums::GL_BOOL_VEC2)                | [`bvec2`](crate::enums::bvec2)                     |
    /// | [`GL_BOOL_VEC3`](crate::enums::GL_BOOL_VEC3)                | [`bvec3`](crate::enums::bvec3)                     |
    /// | [`GL_BOOL_VEC4`](crate::enums::GL_BOOL_VEC4)                | [`bvec4`](crate::enums::bvec4)                     |
    /// | [`GL_FLOAT_MAT2`](crate::enums::GL_FLOAT_MAT2)              | [`mat2`](crate::enums::mat2)                       |
    /// | [`GL_FLOAT_MAT3`](crate::enums::GL_FLOAT_MAT3)              | [`mat3`](crate::enums::mat3)                       |
    /// | [`GL_FLOAT_MAT4`](crate::enums::GL_FLOAT_MAT4)              | [`mat4`](crate::enums::mat4)                       |
    /// | [`GL_FLOAT_MAT2x3`](crate::enums::GL_FLOAT_MAT2x3)          | [`mat2x3`](crate::enums::mat2x3)                   |
    /// | [`GL_FLOAT_MAT2x4`](crate::enums::GL_FLOAT_MAT2x4)          | [`mat2x4`](crate::enums::mat2x4)                   |
    /// | [`GL_FLOAT_MAT3x2`](crate::enums::GL_FLOAT_MAT3x2)          | [`mat3x2`](crate::enums::mat3x2)                   |
    /// | [`GL_FLOAT_MAT3x4`](crate::enums::GL_FLOAT_MAT3x4)          | [`mat3x4`](crate::enums::mat3x4)                   |
    /// | [`GL_FLOAT_MAT4x2`](crate::enums::GL_FLOAT_MAT4x2)          | [`mat4x2`](crate::enums::mat4x2)                   |
    /// | [`GL_FLOAT_MAT4x3`](crate::enums::GL_FLOAT_MAT4x3)          | [`mat4x3`](crate::enums::mat4x3)                   |
    /// | [`GL_DOUBLE_MAT2`](crate::enums::GL_DOUBLE_MAT2)            | [`dmat2`](crate::enums::dmat2)                     |
    /// | [`GL_DOUBLE_MAT3`](crate::enums::GL_DOUBLE_MAT3)            | [`dmat3`](crate::enums::dmat3)                     |
    /// | [`GL_DOUBLE_MAT4`](crate::enums::GL_DOUBLE_MAT4)            | [`dmat4`](crate::enums::dmat4)                     |
    /// | [`GL_DOUBLE_MAT2x3`](crate::enums::GL_DOUBLE_MAT2x3)        | [`dmat2x3`](crate::enums::dmat2x3)                 |
    /// | [`GL_DOUBLE_MAT2x4`](crate::enums::GL_DOUBLE_MAT2x4)        | [`dmat2x4`](crate::enums::dmat2x4)                 |
    /// | [`GL_DOUBLE_MAT3x2`](crate::enums::GL_DOUBLE_MAT3x2)        | [`dmat3x2`](crate::enums::dmat3x2)                 |
    /// | [`GL_DOUBLE_MAT3x4`](crate::enums::GL_DOUBLE_MAT3x4)        | [`dmat3x4`](crate::enums::dmat3x4)                 |
    /// | [`GL_DOUBLE_MAT4x2`](crate::enums::GL_DOUBLE_MAT4x2)        | [`dmat4x2`](crate::enums::dmat4x2)                 |
    /// | [`GL_DOUBLE_MAT4x3`](crate::enums::GL_DOUBLE_MAT4x3)        | [`dmat4x3`](crate::enums::dmat4x3)                 |
    /// | [`GL_SAMPLER_1D`](crate::enums::GL_SAMPLER_1D)              | [`sampler1D`](crate::enums::sampler1D)             |
    /// | [`GL_SAMPLER_2D`](crate::enums::GL_SAMPLER_2D)              | [`sampler2D`](crate::enums::sampler2D)             |
    /// | [`GL_SAMPLER_3D`](crate::enums::GL_SAMPLER_3D)              | [`sampler3D`](crate::enums::sampler3D)             |
    /// | [`GL_SAMPLER_CUBE`](crate::enums::GL_SAMPLER_CUBE)          | [`samplerCube`](crate::enums::samplerCube)         |
    /// | [`GL_SAMPLER_1D_SHADOW`](crate::enums::GL_SAMPLER_1D_SHADOW) | [`sampler1DShadow`](crate::enums::sampler1DShadow) |
    /// | [`GL_SAMPLER_2D_SHADOW`](crate::enums::GL_SAMPLER_2D_SHADOW) | [`sampler2DShadow`](crate::enums::sampler2DShadow) |
    /// | [`GL_SAMPLER_1D_ARRAY`](crate::enums::GL_SAMPLER_1D_ARRAY)  | [`sampler1DArray`](crate::enums::sampler1DArray)   |
    /// | [`GL_SAMPLER_2D_ARRAY`](crate::enums::GL_SAMPLER_2D_ARRAY)  | [`sampler2DArray`](crate::enums::sampler2DArray)   |
    /// | [`GL_SAMPLER_1D_ARRAY_SHADOW`](crate::enums::GL_SAMPLER_1D_ARRAY_SHADOW) | [`sampler1DArrayShadow`](crate::enums::sampler1DArrayShadow) |
    /// | [`GL_SAMPLER_2D_ARRAY_SHADOW`](crate::enums::GL_SAMPLER_2D_ARRAY_SHADOW) | [`sampler2DArrayShadow`](crate::enums::sampler2DArrayShadow) |
    /// | [`GL_SAMPLER_2D_MULTISAMPLE`](crate::enums::GL_SAMPLER_2D_MULTISAMPLE) | [`sampler2DMS`](crate::enums::sampler2DMS) |
    /// | [`GL_SAMPLER_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_SAMPLER_2D_MULTISAMPLE_ARRAY) | [`sampler2DMSArray`](crate::enums::sampler2DMSArray) |
    /// | [`GL_SAMPLER_CUBE_SHADOW`](crate::enums::GL_SAMPLER_CUBE_SHADOW) | [`samplerCubeShadow`](crate::enums::samplerCubeShadow) |
    /// | [`GL_SAMPLER_BUFFER`](crate::enums::GL_SAMPLER_BUFFER)      | [`samplerBuffer`](crate::enums::samplerBuffer)     |
    /// | [`GL_SAMPLER_2D_RECT`](crate::enums::GL_SAMPLER_2D_RECT)    | [`sampler2DRect`](crate::enums::sampler2DRect)     |
    /// | [`GL_SAMPLER_2D_RECT_SHADOW`](crate::enums::GL_SAMPLER_2D_RECT_SHADOW) | [`sampler2DRectShadow`](crate::enums::sampler2DRectShadow) |
    /// | [`GL_INT_SAMPLER_1D`](crate::enums::GL_INT_SAMPLER_1D)      | [`isampler1D`](crate::enums::isampler1D)           |
    /// | [`GL_INT_SAMPLER_2D`](crate::enums::GL_INT_SAMPLER_2D)      | [`isampler2D`](crate::enums::isampler2D)           |
    /// | [`GL_INT_SAMPLER_3D`](crate::enums::GL_INT_SAMPLER_3D)      | [`isampler3D`](crate::enums::isampler3D)           |
    /// | [`GL_INT_SAMPLER_CUBE`](crate::enums::GL_INT_SAMPLER_CUBE)  | [`isamplerCube`](crate::enums::isamplerCube)       |
    /// | [`GL_INT_SAMPLER_1D_ARRAY`](crate::enums::GL_INT_SAMPLER_1D_ARRAY) | [`isampler1DArray`](crate::enums::isampler1DArray) |
    /// | [`GL_INT_SAMPLER_2D_ARRAY`](crate::enums::GL_INT_SAMPLER_2D_ARRAY) | [`isampler2DArray`](crate::enums::isampler2DArray) |
    /// | [`GL_INT_SAMPLER_2D_MULTISAMPLE`](crate::enums::GL_INT_SAMPLER_2D_MULTISAMPLE) | [`isampler2DMS`](crate::enums::isampler2DMS) |
    /// | [`GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY) | [`isampler2DMSArray`](crate::enums::isampler2DMSArray) |
    /// | [`GL_INT_SAMPLER_BUFFER`](crate::enums::GL_INT_SAMPLER_BUFFER) | [`isamplerBuffer`](crate::enums::isamplerBuffer) |
    /// | [`GL_INT_SAMPLER_2D_RECT`](crate::enums::GL_INT_SAMPLER_2D_RECT) | [`isampler2DRect`](crate::enums::isampler2DRect) |
    /// | [`GL_UNSIGNED_INT_SAMPLER_1D`](crate::enums::GL_UNSIGNED_INT_SAMPLER_1D) | [`usampler1D`](crate::enums::usampler1D) |
    /// | [`GL_UNSIGNED_INT_SAMPLER_2D`](crate::enums::GL_UNSIGNED_INT_SAMPLER_2D) | [`usampler2D`](crate::enums::usampler2D) |
    /// | [`GL_UNSIGNED_INT_SAMPLER_3D`](crate::enums::GL_UNSIGNED_INT_SAMPLER_3D) | [`usampler3D`](crate::enums::usampler3D) |
    /// | [`GL_UNSIGNED_INT_SAMPLER_CUBE`](crate::enums::GL_UNSIGNED_INT_SAMPLER_CUBE) | [`usamplerCube`](crate::enums::usamplerCube) |
    /// | [`GL_UNSIGNED_INT_SAMPLER_1D_ARRAY`](crate::enums::GL_UNSIGNED_INT_SAMPLER_1D_ARRAY) | [`usampler2DArray`](crate::enums::usampler2DArray) |
    /// | [`GL_UNSIGNED_INT_SAMPLER_2D_ARRAY`](crate::enums::GL_UNSIGNED_INT_SAMPLER_2D_ARRAY) | [`usampler2DArray`](crate::enums::usampler2DArray) |
    /// | [`GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE`](crate::enums::GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE) | [`usampler2DMS`](crate::enums::usampler2DMS) |
    /// | [`GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY) | [`usampler2DMSArray`](crate::enums::usampler2DMSArray) |
    /// | [`GL_UNSIGNED_INT_SAMPLER_BUFFER`](crate::enums::GL_UNSIGNED_INT_SAMPLER_BUFFER) | [`usamplerBuffer`](crate::enums::usamplerBuffer) |
    /// | [`GL_UNSIGNED_INT_SAMPLER_2D_RECT`](crate::enums::GL_UNSIGNED_INT_SAMPLER_2D_RECT) | [`usampler2DRect`](crate::enums::usampler2DRect) |
    /// | [`GL_IMAGE_1D`](crate::enums::GL_IMAGE_1D)                  | [`image1D`](crate::enums::image1D)                 |
    /// | [`GL_IMAGE_2D`](crate::enums::GL_IMAGE_2D)                  | [`image2D`](crate::enums::image2D)                 |
    /// | [`GL_IMAGE_3D`](crate::enums::GL_IMAGE_3D)                  | [`image3D`](crate::enums::image3D)                 |
    /// | [`GL_IMAGE_2D_RECT`](crate::enums::GL_IMAGE_2D_RECT)        | [`image2DRect`](crate::enums::image2DRect)         |
    /// | [`GL_IMAGE_CUBE`](crate::enums::GL_IMAGE_CUBE)              | [`imageCube`](crate::enums::imageCube)             |
    /// | [`GL_IMAGE_BUFFER`](crate::enums::GL_IMAGE_BUFFER)          | [`imageBuffer`](crate::enums::imageBuffer)         |
    /// | [`GL_IMAGE_1D_ARRAY`](crate::enums::GL_IMAGE_1D_ARRAY)      | [`image1DArray`](crate::enums::image1DArray)       |
    /// | [`GL_IMAGE_2D_ARRAY`](crate::enums::GL_IMAGE_2D_ARRAY)      | [`image2DArray`](crate::enums::image2DArray)       |
    /// | [`GL_IMAGE_2D_MULTISAMPLE`](crate::enums::GL_IMAGE_2D_MULTISAMPLE) | [`image2DMS`](crate::enums::image2DMS)      |
    /// | [`GL_IMAGE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_IMAGE_2D_MULTISAMPLE_ARRAY) | [`image2DMSArray`](crate::enums::image2DMSArray) |
    /// | [`GL_INT_IMAGE_1D`](crate::enums::GL_INT_IMAGE_1D)          | [`iimage1D`](crate::enums::iimage1D)               |
    /// | [`GL_INT_IMAGE_2D`](crate::enums::GL_INT_IMAGE_2D)          | [`iimage2D`](crate::enums::iimage2D)               |
    /// | [`GL_INT_IMAGE_3D`](crate::enums::GL_INT_IMAGE_3D)          | [`iimage3D`](crate::enums::iimage3D)               |
    /// | [`GL_INT_IMAGE_2D_RECT`](crate::enums::GL_INT_IMAGE_2D_RECT) | [`iimage2DRect`](crate::enums::iimage2DRect)      |
    /// | [`GL_INT_IMAGE_CUBE`](crate::enums::GL_INT_IMAGE_CUBE)      | [`iimageCube`](crate::enums::iimageCube)           |
    /// | [`GL_INT_IMAGE_BUFFER`](crate::enums::GL_INT_IMAGE_BUFFER)  | [`iimageBuffer`](crate::enums::iimageBuffer)       |
    /// | [`GL_INT_IMAGE_1D_ARRAY`](crate::enums::GL_INT_IMAGE_1D_ARRAY) | [`iimage1DArray`](crate::enums::iimage1DArray)  |
    /// | [`GL_INT_IMAGE_2D_ARRAY`](crate::enums::GL_INT_IMAGE_2D_ARRAY) | [`iimage2DArray`](crate::enums::iimage2DArray)  |
    /// | [`GL_INT_IMAGE_2D_MULTISAMPLE`](crate::enums::GL_INT_IMAGE_2D_MULTISAMPLE) | [`iimage2DMS`](crate::enums::iimage2DMS) |
    /// | [`GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY) | [`iimage2DMSArray`](crate::enums::iimage2DMSArray) |
    /// | [`GL_UNSIGNED_INT_IMAGE_1D`](crate::enums::GL_UNSIGNED_INT_IMAGE_1D) | [`uimage1D`](crate::enums::uimage1D)      |
    /// | [`GL_UNSIGNED_INT_IMAGE_2D`](crate::enums::GL_UNSIGNED_INT_IMAGE_2D) | [`uimage2D`](crate::enums::uimage2D)      |
    /// | [`GL_UNSIGNED_INT_IMAGE_3D`](crate::enums::GL_UNSIGNED_INT_IMAGE_3D) | [`uimage3D`](crate::enums::uimage3D)      |
    /// | [`GL_UNSIGNED_INT_IMAGE_2D_RECT`](crate::enums::GL_UNSIGNED_INT_IMAGE_2D_RECT) | [`uimage2DRect`](crate::enums::uimage2DRect) |
    /// | [`GL_UNSIGNED_INT_IMAGE_CUBE`](crate::enums::GL_UNSIGNED_INT_IMAGE_CUBE) | [`uimageCube`](crate::enums::uimageCube) |
    /// | [`GL_UNSIGNED_INT_IMAGE_BUFFER`](crate::enums::GL_UNSIGNED_INT_IMAGE_BUFFER) | [`uimageBuffer`](crate::enums::uimageBuffer) |
    /// | [`GL_UNSIGNED_INT_IMAGE_1D_ARRAY`](crate::enums::GL_UNSIGNED_INT_IMAGE_1D_ARRAY) | [`uimage1DArray`](crate::enums::uimage1DArray) |
    /// | [`GL_UNSIGNED_INT_IMAGE_2D_ARRAY`](crate::enums::GL_UNSIGNED_INT_IMAGE_2D_ARRAY) | [`uimage2DArray`](crate::enums::uimage2DArray) |
    /// | [`GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE`](crate::enums::GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE) | [`uimage2DMS`](crate::enums::uimage2DMS) |
    /// | [`GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY) | [`uimage2DMSArray`](crate::enums::uimage2DMSArray) |
    /// | [`GL_UNSIGNED_INT_ATOMIC_COUNTER`](crate::enums::GL_UNSIGNED_INT_ATOMIC_COUNTER) | [`atomic_uint`](crate::enums::atomic_uint) |
    ///
    ///
    /// If one or more elements of an array are active, the name of the array is
    /// returned in `name`, the type is returned in `type`, and the `size` parameter
    /// returns the highest array element index used, plus one, as determined by
    /// the compiler and/or linker. Only one active uniform variable will be reported
    /// for a uniform array.
    ///
    /// Uniform variables that are declared as structures or arrays of structures
    /// will not be returned directly by this function. Instead, each of these
    /// uniform variables will be reduced to its fundamental components containing
    /// the "." and "\[\]" operators such that each of the names is valid as an
    /// argument to [**glGetUniformLocation**](crate::context::Context::oxidegl_get_uniform_location).
    /// Each of these reduced uniform variables is counted as one active uniform
    /// variable and is assigned an index. A valid name cannot be a structure,
    /// an array of structures, or a subcomponent of a vector or matrix.
    ///
    /// The size of the uniform variable will be returned in `size`. Uniform variables
    /// other than arrays will have a size of 1. Structures and arrays of structures
    /// will be reduced as described earlier, such that each of the names returned
    /// will be a data type in the earlier list. If this reduction results in an
    /// array, the size returned will be as described for uniform arrays; otherwise,
    /// the size returned will be 1.
    ///
    /// The list of active uniform variables may include both built-in uniform
    /// variables (which begin with the prefix "gl_") as well as user-defined uniform
    /// variable names.
    ///
    /// This function will return as much information as it can about the specified
    /// active uniform variable. If no information is available, `length` will
    /// be 0, and `name` will be an empty string. This situation could occur if
    /// this function is called after a link operation that failed. If an error
    /// occurs, the return values `length`, `size`, `type`, and `name` will be
    /// unmodified.
    ///
    /// ### Notes
    /// The double types, [`GL_DOUBLE`](crate::enums::GL_DOUBLE), [`GL_DOUBLE_VEC2`](crate::enums::GL_DOUBLE_VEC2),
    /// [`GL_DOUBLE_VEC3`](crate::enums::GL_DOUBLE_VEC3), [`GL_DOUBLE_VEC4`](crate::enums::GL_DOUBLE_VEC4),
    /// [`GL_DOUBLE_MAT2`](crate::enums::GL_DOUBLE_MAT2), [`GL_DOUBLE_MAT3`](crate::enums::GL_DOUBLE_MAT3),
    /// [`GL_DOUBLE_MAT4`](crate::enums::GL_DOUBLE_MAT4), [`GL_DOUBLE_MAT2x3`](crate::enums::GL_DOUBLE_MAT2x3),
    /// [`GL_DOUBLE_MAT2x4`](crate::enums::GL_DOUBLE_MAT2x4), [`GL_DOUBLE_MAT3x2`](crate::enums::GL_DOUBLE_MAT3x2),
    /// [`GL_DOUBLE_MAT3x4`](crate::enums::GL_DOUBLE_MAT3x4), [`GL_DOUBLE_MAT4x2`](crate::enums::GL_DOUBLE_MAT4x2),
    /// and [`GL_DOUBLE_MAT4x3`](crate::enums::GL_DOUBLE_MAT4x3) are only available
    /// if the GL version is 4.1 or higher.
    ///
    /// The image types, [`GL_IMAGE_1D`](crate::enums::GL_IMAGE_1D), [`GL_IMAGE_2D`](crate::enums::GL_IMAGE_2D),
    /// [`GL_IMAGE_3D`](crate::enums::GL_IMAGE_3D), [`GL_IMAGE_2D_RECT`](crate::enums::GL_IMAGE_2D_RECT),
    /// [`GL_IMAGE_CUBE`](crate::enums::GL_IMAGE_CUBE), [`GL_IMAGE_BUFFER`](crate::enums::GL_IMAGE_BUFFER),
    /// [`GL_IMAGE_1D_ARRAY`](crate::enums::GL_IMAGE_1D_ARRAY), [`GL_IMAGE_2D_ARRAY`](crate::enums::GL_IMAGE_2D_ARRAY),
    /// [`GL_IMAGE_2D_MULTISAMPLE`](crate::enums::GL_IMAGE_2D_MULTISAMPLE), [`GL_IMAGE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_IMAGE_2D_MULTISAMPLE_ARRAY),
    /// [`GL_INT_IMAGE_1D`](crate::enums::GL_INT_IMAGE_1D), [`GL_INT_IMAGE_2D`](crate::enums::GL_INT_IMAGE_2D),
    /// [`GL_INT_IMAGE_3D`](crate::enums::GL_INT_IMAGE_3D), [`GL_INT_IMAGE_2D_RECT`](crate::enums::GL_INT_IMAGE_2D_RECT),
    /// [`GL_INT_IMAGE_CUBE`](crate::enums::GL_INT_IMAGE_CUBE), [`GL_INT_IMAGE_BUFFER`](crate::enums::GL_INT_IMAGE_BUFFER),
    /// [`GL_INT_IMAGE_1D_ARRAY`](crate::enums::GL_INT_IMAGE_1D_ARRAY), [`GL_INT_IMAGE_2D_ARRAY`](crate::enums::GL_INT_IMAGE_2D_ARRAY),
    /// [`GL_INT_IMAGE_2D_MULTISAMPLE`](crate::enums::GL_INT_IMAGE_2D_MULTISAMPLE),
    /// [`GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY),
    /// [`GL_UNSIGNED_INT_IMAGE_1D`](crate::enums::GL_UNSIGNED_INT_IMAGE_1D), [`GL_UNSIGNED_INT_IMAGE_2D`](crate::enums::GL_UNSIGNED_INT_IMAGE_2D),
    /// [`GL_UNSIGNED_INT_IMAGE_3D`](crate::enums::GL_UNSIGNED_INT_IMAGE_3D), [`GL_UNSIGNED_INT_IMAGE_2D_RECT`](crate::enums::GL_UNSIGNED_INT_IMAGE_2D_RECT),
    /// [`GL_UNSIGNED_INT_IMAGE_CUBE`](crate::enums::GL_UNSIGNED_INT_IMAGE_CUBE),
    /// [`GL_UNSIGNED_INT_IMAGE_BUFFER`](crate::enums::GL_UNSIGNED_INT_IMAGE_BUFFER),
    /// [`GL_UNSIGNED_INT_IMAGE_1D_ARRAY`](crate::enums::GL_UNSIGNED_INT_IMAGE_1D_ARRAY),
    /// [`GL_UNSIGNED_INT_IMAGE_2D_ARRAY`](crate::enums::GL_UNSIGNED_INT_IMAGE_2D_ARRAY),
    /// [`GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE`](crate::enums::GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE),
    /// [`GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY),
    /// and the atomic counter type, [`GL_UNSIGNED_INT_ATOMIC_COUNTER`](crate::enums::GL_UNSIGNED_INT_ATOMIC_COUNTER)
    /// are only available if the GL version is 4.2 or higher.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_VERTEX_UNIFORM_COMPONENTS`](crate::enums::GL_MAX_VERTEX_UNIFORM_COMPONENTS),
    /// [`GL_MAX_GEOMETRY_UNIFORM_COMPONENTS`](crate::enums::GL_MAX_GEOMETRY_UNIFORM_COMPONENTS),
    /// [`GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS`](crate::enums::GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS),
    /// [`GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS`](crate::enums::GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS),
    /// [`GL_MAX_FRAGMENT_UNIFORM_COMPONENTS`](crate::enums::GL_MAX_FRAGMENT_UNIFORM_COMPONENTS).
    ///
    /// [**glGetProgram**](crate::context::Context::oxidegl_get_program) with argument
    /// [`GL_ACTIVE_UNIFORMS`](crate::enums::GL_ACTIVE_UNIFORMS) or [`GL_ACTIVE_UNIFORM_MAX_LENGTH`](crate::enums::GL_ACTIVE_UNIFORM_MAX_LENGTH).
    ///
    /// [**glIsProgram**](crate::context::Context::oxidegl_is_program)

    pub unsafe fn oxidegl_get_active_uniform(
        &mut self,
        program: GLuint,
        index: GLuint,
        buf_size: GLsizei,
        length: *mut GLsizei,
        size: *mut GLint,
        r#type: UniformType,
        name: *mut GLchar,
    ) {
        panic!("command oxidegl_get_active_uniform not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the name of a program containing the uniform block.
    ///
    /// `uniformBlockIndex`
    ///
    /// > Specifies the index of the uniform block within `program`.
    ///
    /// `pname`
    ///
    /// > Specifies the name of the parameter to query.
    ///
    /// `params`
    ///
    /// > Specifies the address of a variable to receive the result of the query.
    ///
    /// ### Description
    /// [**glGetActiveUniformBlockiv**](crate::context::Context::oxidegl_get_active_uniform_blockiv)
    /// retrieves information about an active uniform block within `program`.
    ///
    /// `program` must be the name of a program object for which the command [**glLinkProgram**](crate::context::Context::oxidegl_link_program)
    /// must have been called in the past, although it is not required that [**glLinkProgram**](crate::context::Context::oxidegl_link_program)
    /// must have succeeded. The link could have failed because the number of active
    /// uniforms exceeded the limit.
    ///
    /// `uniformBlockIndex` is an active uniform block index of `program`, and
    /// must be less than the value of [`GL_ACTIVE_UNIFORM_BLOCKS`](crate::enums::GL_ACTIVE_UNIFORM_BLOCKS).
    ///
    /// Upon success, the uniform block parameter(s) specified by `pname` are returned
    /// in `params`. If an error occurs, nothing will be written to `params`.
    ///
    /// If `pname` is [`GL_UNIFORM_BLOCK_BINDING`](crate::enums::GL_UNIFORM_BLOCK_BINDING),
    /// then the index of the uniform buffer binding point last selected by the
    /// uniform block specified by `uniformBlockIndex` for `program` is returned.
    /// If no uniform block has been previously specified, zero is returned.
    ///
    /// If `pname` is [`GL_UNIFORM_BLOCK_DATA_SIZE`](crate::enums::GL_UNIFORM_BLOCK_DATA_SIZE),
    /// then the implementation-dependent minimum total buffer object size, in
    /// basic machine units, required to hold all active uniforms in the uniform
    /// block identified by `uniformBlockIndex` is returned. It is neither guaranteed
    /// nor expected that a given implementation will arrange uniform values as
    /// tightly packed in a buffer object. The exception to this is the *std140
    /// uniform block layout*, which guarantees specific packing behavior and does
    /// not require the application to query for offsets and strides. In this case
    /// the minimum size may still be queried, even though it is determined in
    /// advance based only on the uniform block declaration.
    ///
    /// If `pname` is [`GL_UNIFORM_BLOCK_NAME_LENGTH`](crate::enums::GL_UNIFORM_BLOCK_NAME_LENGTH),
    /// then the total length (including the nul terminator) of the name of the
    /// uniform block identified by `uniformBlockIndex` is returned.
    ///
    /// If `pname` is [`GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS`](crate::enums::GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS),
    /// then the number of active uniforms in the uniform block identified by
    /// `uniformBlockIndex` is returned.
    ///
    /// If `pname` is [`GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES`](crate::enums::GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES),
    /// then a list of the active uniform indices for the uniform block identified
    /// by `uniformBlockIndex` is returned. The number of elements that will be
    /// written to `params` is the value of [`GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS`](crate::enums::GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS)
    /// for `uniformBlockIndex`.
    ///
    /// If `pname` is [`GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER`](crate::enums::GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER),
    /// [`GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER`](crate::enums::GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER),
    /// [`GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER`](crate::enums::GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER),
    /// [`GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER`](crate::enums::GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER),
    /// [`GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER`](crate::enums::GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER),
    /// or [`GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER`](crate::enums::GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER)
    /// then a boolean value indicating whether the uniform block identified by
    /// `uniformBlockIndex` is referenced by the vertex, tessellation control,
    /// tessellation evaluation, geometry, fragment or compute programming stages
    /// of program, respectively, is returned.
    ///
    /// ### Notes
    /// [**glGetActiveUniformBlockiv**](crate::context::Context::oxidegl_get_active_uniform_blockiv)
    /// is available only if the GL version is 3.1 or greater.
    ///
    /// [`GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER`](crate::enums::GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER)
    /// is accepted only if the GL version is 4.3 or greater.

    pub unsafe fn oxidegl_get_active_uniform_blockiv(
        &mut self,
        program: GLuint,
        uniform_block_index: GLuint,
        pname: UniformBlockPName,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_active_uniform_blockiv not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the name of a program containing the uniform block.
    ///
    /// `uniformBlockIndex`
    ///
    /// > Specifies the index of the uniform block within `program`.
    ///
    /// `bufSize`
    ///
    /// > Specifies the size of the buffer addressed by `uniformBlockName`.
    ///
    /// `length`
    ///
    /// > Specifies the address of a variable to receive the number of characters
    /// > that were written to `uniformBlockName`.
    ///
    /// `uniformBlockName`
    ///
    /// > Specifies the address an array of characters to receive the name of the
    /// > uniform block at `uniformBlockIndex`.
    ///
    /// ### Description
    /// [**glGetActiveUniformBlockName**](crate::context::Context::oxidegl_get_active_uniform_block_name)
    /// retrieves the name of the active uniform block at `uniformBlockIndex` within
    /// `program`.
    ///
    /// `program` must be the name of a program object for which the command [**glLinkProgram**](crate::context::Context::oxidegl_link_program)
    /// must have been called in the past, although it is not required that [**glLinkProgram**](crate::context::Context::oxidegl_link_program)
    /// must have succeeded. The link could have failed because the number of active
    /// uniforms exceeded the limit.
    ///
    /// `uniformBlockIndex` is an active uniform block index of `program`, and
    /// must be less than the value of [`GL_ACTIVE_UNIFORM_BLOCKS`](crate::enums::GL_ACTIVE_UNIFORM_BLOCKS).
    ///
    /// Upon success, the name of the uniform block identified by `unifomBlockIndex`
    /// is returned into `uniformBlockName`. The name is nul-terminated. The actual
    /// number of characters written into `uniformBlockName`, excluding the nul
    /// terminator, is returned in `length`. If `length` is
    ///
    /// `bufSize` contains the maximum number of characters (including the nul
    /// terminator) that will be written into `uniformBlockName`.
    ///
    /// If an error occurs, nothing will be written to `uniformBlockName` or `length`.
    ///
    /// ### Notes
    /// [**glGetActiveUniformBlockName**](crate::context::Context::oxidegl_get_active_uniform_block_name)
    /// is available only if the GL version is 3.1 or greater.

    pub unsafe fn oxidegl_get_active_uniform_block_name(
        &mut self,
        program: GLuint,
        uniform_block_index: GLuint,
        buf_size: GLsizei,
        length: *mut GLsizei,
        uniform_block_name: *mut GLchar,
    ) {
        panic!("command oxidegl_get_active_uniform_block_name not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the program containing the active uniform index `uniformIndex`.
    ///
    /// `uniformIndex`
    ///
    /// > Specifies the index of the active uniform whose name to query.
    ///
    /// `bufSize`
    ///
    /// > Specifies the size of the buffer, in units of `uniformName`.
    ///
    /// `length`
    ///
    /// > Specifies the address of a variable that will receive the number of characters
    /// > that were or would have been written to the buffer addressed by `uniformName`.
    ///
    /// `uniformName`
    ///
    /// > Specifies the address of a buffer into which the GL will place the name
    /// > of the active uniform at `uniformIndex` within `program`.
    ///
    /// ### Description
    /// [**glGetActiveUniformName**](crate::context::Context::oxidegl_get_active_uniform_name)
    /// returns the name of the active uniform at `uniformIndex` within `program`.
    /// If `uniformName` is not `bufSize` characters (including a nul-terminator)
    /// will be written into the array whose address is specified by `uniformName`.
    /// If `length` is not `uniformName` (not including the nul-terminator) will
    /// be placed in the variable whose address is specified in `length`. If `length`
    /// is `program` is given by the value of [`GL_ACTIVE_UNIFORM_MAX_LENGTH`](crate::enums::GL_ACTIVE_UNIFORM_MAX_LENGTH),
    /// which can be queried with [**glGetProgram**](crate::context::Context::oxidegl_get_program).
    ///
    /// If [**glGetActiveUniformName**](crate::context::Context::oxidegl_get_active_uniform_name)
    /// is not successful, nothing is written to `length` or `uniformName`.
    ///
    /// `program` must be the name of a program for which the command [**glLinkProgram**](crate::context::Context::oxidegl_link_program)
    /// has been issued in the past. It is not necessary for `program` to have
    /// been linked successfully. The link could have failed because the number
    /// of active uniforms exceeded the limit.
    ///
    /// `uniformIndex` must be an active uniform index of the program `program`,
    /// in the range zero to the value of [`GL_ACTIVE_UNIFORMS`](crate::enums::GL_ACTIVE_UNIFORMS)
    /// minus one. The value of [`GL_ACTIVE_UNIFORMS`](crate::enums::GL_ACTIVE_UNIFORMS)
    /// can be queried with [**glGetProgram**](crate::context::Context::oxidegl_get_program).

    pub unsafe fn oxidegl_get_active_uniform_name(
        &mut self,
        program: GLuint,
        uniform_index: GLuint,
        buf_size: GLsizei,
        length: *mut GLsizei,
        uniform_name: *mut GLchar,
    ) {
        panic!("command oxidegl_get_active_uniform_name not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the program object to be queried.
    ///
    /// `uniformCount`
    ///
    /// > Specifies both the number of elements in the array of indices `uniformIndices`
    /// > and the number of parameters written to `params` upon successful return.
    ///
    /// `uniformIndices`
    ///
    /// > Specifies the address of an array of `uniformCount` integers containing
    /// > the indices of uniforms within `program` whose parameter `pname` should
    /// > be queried.
    ///
    /// `pname`
    ///
    /// > Specifies the property of each uniform in `uniformIndices` that should
    /// > be written into the corresponding element of `params`.
    ///
    /// `params`
    ///
    /// > Specifies the address of an array of `uniformCount` integers which are
    /// > to receive the value of `pname` for each uniform in `uniformIndices`.
    ///
    /// ### Description
    /// [**glGetActiveUniformsiv**](crate::context::Context::oxidegl_get_active_uniformsiv)
    /// queries the value of the parameter named `pname` for each of the uniforms
    /// within `program` whose indices are specified in the array of `uniformCount`
    /// unsigned integers `uniformIndices`. Upon success, the value of the parameter
    /// for each uniform is written into the corresponding entry in the array whose
    /// address is given in `params`. If an error is generated, nothing is written
    /// into `params`.
    ///
    /// If `pname` is [`GL_UNIFORM_TYPE`](crate::enums::GL_UNIFORM_TYPE), then
    /// an array identifying the types of uniforms specified by the corresponding
    /// array of `uniformIndices` is returned. The returned types can be any of
    /// the values from the following table:
    /// |* Returned Symbolic Contant*                                 |* Shader Uniform Type*                              |
    /// |-------------------------------------------------------------|----------------------------------------------------|
    /// | [`GL_FLOAT`](crate::enums::GL_FLOAT)                        | [`float`](crate::enums::float)                     |
    /// | [`GL_FLOAT_VEC2`](crate::enums::GL_FLOAT_VEC2)              | [`vec2`](crate::enums::vec2)                       |
    /// | [`GL_FLOAT_VEC3`](crate::enums::GL_FLOAT_VEC3)              | [`vec3`](crate::enums::vec3)                       |
    /// | [`GL_FLOAT_VEC4`](crate::enums::GL_FLOAT_VEC4)              | [`vec4`](crate::enums::vec4)                       |
    /// | [`GL_DOUBLE`](crate::enums::GL_DOUBLE)                      | [`double`](crate::enums::double)                   |
    /// | [`GL_DOUBLE_VEC2`](crate::enums::GL_DOUBLE_VEC2)            | [`dvec2`](crate::enums::dvec2)                     |
    /// | [`GL_DOUBLE_VEC3`](crate::enums::GL_DOUBLE_VEC3)            | [`dvec3`](crate::enums::dvec3)                     |
    /// | [`GL_DOUBLE_VEC4`](crate::enums::GL_DOUBLE_VEC4)            | [`dvec4`](crate::enums::dvec4)                     |
    /// | [`GL_INT`](crate::enums::GL_INT)                            | [`int`](crate::enums::int)                         |
    /// | [`GL_INT_VEC2`](crate::enums::GL_INT_VEC2)                  | [`ivec2`](crate::enums::ivec2)                     |
    /// | [`GL_INT_VEC3`](crate::enums::GL_INT_VEC3)                  | [`ivec3`](crate::enums::ivec3)                     |
    /// | [`GL_INT_VEC4`](crate::enums::GL_INT_VEC4)                  | [`ivec4`](crate::enums::ivec4)                     |
    /// | [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT)          | [`unsigned int`](`crate::enums::unsigned` int)       |
    /// | [`GL_UNSIGNED_INT_VEC2`](crate::enums::GL_UNSIGNED_INT_VEC2) | [`uvec2`](crate::enums::uvec2)                    |
    /// | [`GL_UNSIGNED_INT_VEC3`](crate::enums::GL_UNSIGNED_INT_VEC3) | [`uvec3`](crate::enums::uvec3)                    |
    /// | [`GL_UNSIGNED_INT_VEC4`](crate::enums::GL_UNSIGNED_INT_VEC4) | [`uvec4`](crate::enums::uvec4)                    |
    /// | [`GL_BOOL`](crate::enums::GL_BOOL)                          | [`bool`](crate::enums::bool)                       |
    /// | [`GL_BOOL_VEC2`](crate::enums::GL_BOOL_VEC2)                | [`bvec2`](crate::enums::bvec2)                     |
    /// | [`GL_BOOL_VEC3`](crate::enums::GL_BOOL_VEC3)                | [`bvec3`](crate::enums::bvec3)                     |
    /// | [`GL_BOOL_VEC4`](crate::enums::GL_BOOL_VEC4)                | [`bvec4`](crate::enums::bvec4)                     |
    /// | [`GL_FLOAT_MAT2`](crate::enums::GL_FLOAT_MAT2)              | [`mat2`](crate::enums::mat2)                       |
    /// | [`GL_FLOAT_MAT3`](crate::enums::GL_FLOAT_MAT3)              | [`mat3`](crate::enums::mat3)                       |
    /// | [`GL_FLOAT_MAT4`](crate::enums::GL_FLOAT_MAT4)              | [`mat4`](crate::enums::mat4)                       |
    /// | [`GL_FLOAT_MAT2x3`](crate::enums::GL_FLOAT_MAT2x3)          | [`mat2x3`](crate::enums::mat2x3)                   |
    /// | [`GL_FLOAT_MAT2x4`](crate::enums::GL_FLOAT_MAT2x4)          | [`mat2x4`](crate::enums::mat2x4)                   |
    /// | [`GL_FLOAT_MAT3x2`](crate::enums::GL_FLOAT_MAT3x2)          | [`mat3x2`](crate::enums::mat3x2)                   |
    /// | [`GL_FLOAT_MAT3x4`](crate::enums::GL_FLOAT_MAT3x4)          | [`mat3x4`](crate::enums::mat3x4)                   |
    /// | [`GL_FLOAT_MAT4x2`](crate::enums::GL_FLOAT_MAT4x2)          | [`mat4x2`](crate::enums::mat4x2)                   |
    /// | [`GL_FLOAT_MAT4x3`](crate::enums::GL_FLOAT_MAT4x3)          | [`mat4x3`](crate::enums::mat4x3)                   |
    /// | [`GL_DOUBLE_MAT2`](crate::enums::GL_DOUBLE_MAT2)            | [`dmat2`](crate::enums::dmat2)                     |
    /// | [`GL_DOUBLE_MAT3`](crate::enums::GL_DOUBLE_MAT3)            | [`dmat3`](crate::enums::dmat3)                     |
    /// | [`GL_DOUBLE_MAT4`](crate::enums::GL_DOUBLE_MAT4)            | [`dmat4`](crate::enums::dmat4)                     |
    /// | [`GL_DOUBLE_MAT2x3`](crate::enums::GL_DOUBLE_MAT2x3)        | [`dmat2x3`](crate::enums::dmat2x3)                 |
    /// | [`GL_DOUBLE_MAT2x4`](crate::enums::GL_DOUBLE_MAT2x4)        | [`dmat2x4`](crate::enums::dmat2x4)                 |
    /// | [`GL_DOUBLE_MAT3x2`](crate::enums::GL_DOUBLE_MAT3x2)        | [`dmat3x2`](crate::enums::dmat3x2)                 |
    /// | [`GL_DOUBLE_MAT3x4`](crate::enums::GL_DOUBLE_MAT3x4)        | [`dmat3x4`](crate::enums::dmat3x4)                 |
    /// | [`GL_DOUBLE_MAT4x2`](crate::enums::GL_DOUBLE_MAT4x2)        | [`dmat4x2`](crate::enums::dmat4x2)                 |
    /// | [`GL_DOUBLE_MAT4x3`](crate::enums::GL_DOUBLE_MAT4x3)        | [`dmat4x3`](crate::enums::dmat4x3)                 |
    /// | [`GL_SAMPLER_1D`](crate::enums::GL_SAMPLER_1D)              | [`sampler1D`](crate::enums::sampler1D)             |
    /// | [`GL_SAMPLER_2D`](crate::enums::GL_SAMPLER_2D)              | [`sampler2D`](crate::enums::sampler2D)             |
    /// | [`GL_SAMPLER_3D`](crate::enums::GL_SAMPLER_3D)              | [`sampler3D`](crate::enums::sampler3D)             |
    /// | [`GL_SAMPLER_CUBE`](crate::enums::GL_SAMPLER_CUBE)          | [`samplerCube`](crate::enums::samplerCube)         |
    /// | [`GL_SAMPLER_1D_SHADOW`](crate::enums::GL_SAMPLER_1D_SHADOW) | [`sampler1DShadow`](crate::enums::sampler1DShadow) |
    /// | [`GL_SAMPLER_2D_SHADOW`](crate::enums::GL_SAMPLER_2D_SHADOW) | [`sampler2DShadow`](crate::enums::sampler2DShadow) |
    /// | [`GL_SAMPLER_1D_ARRAY`](crate::enums::GL_SAMPLER_1D_ARRAY)  | [`sampler1DArray`](crate::enums::sampler1DArray)   |
    /// | [`GL_SAMPLER_2D_ARRAY`](crate::enums::GL_SAMPLER_2D_ARRAY)  | [`sampler2DArray`](crate::enums::sampler2DArray)   |
    /// | [`GL_SAMPLER_1D_ARRAY_SHADOW`](crate::enums::GL_SAMPLER_1D_ARRAY_SHADOW) | [`sampler1DArrayShadow`](crate::enums::sampler1DArrayShadow) |
    /// | [`GL_SAMPLER_2D_ARRAY_SHADOW`](crate::enums::GL_SAMPLER_2D_ARRAY_SHADOW) | [`sampler2DArrayShadow`](crate::enums::sampler2DArrayShadow) |
    /// | [`GL_SAMPLER_2D_MULTISAMPLE`](crate::enums::GL_SAMPLER_2D_MULTISAMPLE) | [`sampler2DMS`](crate::enums::sampler2DMS) |
    /// | [`GL_SAMPLER_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_SAMPLER_2D_MULTISAMPLE_ARRAY) | [`sampler2DMSArray`](crate::enums::sampler2DMSArray) |
    /// | [`GL_SAMPLER_CUBE_SHADOW`](crate::enums::GL_SAMPLER_CUBE_SHADOW) | [`samplerCubeShadow`](crate::enums::samplerCubeShadow) |
    /// | [`GL_SAMPLER_BUFFER`](crate::enums::GL_SAMPLER_BUFFER)      | [`samplerBuffer`](crate::enums::samplerBuffer)     |
    /// | [`GL_SAMPLER_2D_RECT`](crate::enums::GL_SAMPLER_2D_RECT)    | [`sampler2DRect`](crate::enums::sampler2DRect)     |
    /// | [`GL_SAMPLER_2D_RECT_SHADOW`](crate::enums::GL_SAMPLER_2D_RECT_SHADOW) | [`sampler2DRectShadow`](crate::enums::sampler2DRectShadow) |
    /// | [`GL_INT_SAMPLER_1D`](crate::enums::GL_INT_SAMPLER_1D)      | [`isampler1D`](crate::enums::isampler1D)           |
    /// | [`GL_INT_SAMPLER_2D`](crate::enums::GL_INT_SAMPLER_2D)      | [`isampler2D`](crate::enums::isampler2D)           |
    /// | [`GL_INT_SAMPLER_3D`](crate::enums::GL_INT_SAMPLER_3D)      | [`isampler3D`](crate::enums::isampler3D)           |
    /// | [`GL_INT_SAMPLER_CUBE`](crate::enums::GL_INT_SAMPLER_CUBE)  | [`isamplerCube`](crate::enums::isamplerCube)       |
    /// | [`GL_INT_SAMPLER_1D_ARRAY`](crate::enums::GL_INT_SAMPLER_1D_ARRAY) | [`isampler1DArray`](crate::enums::isampler1DArray) |
    /// | [`GL_INT_SAMPLER_2D_ARRAY`](crate::enums::GL_INT_SAMPLER_2D_ARRAY) | [`isampler2DArray`](crate::enums::isampler2DArray) |
    /// | [`GL_INT_SAMPLER_2D_MULTISAMPLE`](crate::enums::GL_INT_SAMPLER_2D_MULTISAMPLE) | [`isampler2DMS`](crate::enums::isampler2DMS) |
    /// | [`GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY) | [`isampler2DMSArray`](crate::enums::isampler2DMSArray) |
    /// | [`GL_INT_SAMPLER_BUFFER`](crate::enums::GL_INT_SAMPLER_BUFFER) | [`isamplerBuffer`](crate::enums::isamplerBuffer) |
    /// | [`GL_INT_SAMPLER_2D_RECT`](crate::enums::GL_INT_SAMPLER_2D_RECT) | [`isampler2DRect`](crate::enums::isampler2DRect) |
    /// | [`GL_UNSIGNED_INT_SAMPLER_1D`](crate::enums::GL_UNSIGNED_INT_SAMPLER_1D) | [`usampler1D`](crate::enums::usampler1D) |
    /// | [`GL_UNSIGNED_INT_SAMPLER_2D`](crate::enums::GL_UNSIGNED_INT_SAMPLER_2D) | [`usampler2D`](crate::enums::usampler2D) |
    /// | [`GL_UNSIGNED_INT_SAMPLER_3D`](crate::enums::GL_UNSIGNED_INT_SAMPLER_3D) | [`usampler3D`](crate::enums::usampler3D) |
    /// | [`GL_UNSIGNED_INT_SAMPLER_CUBE`](crate::enums::GL_UNSIGNED_INT_SAMPLER_CUBE) | [`usamplerCube`](crate::enums::usamplerCube) |
    /// | [`GL_UNSIGNED_INT_SAMPLER_1D_ARRAY`](crate::enums::GL_UNSIGNED_INT_SAMPLER_1D_ARRAY) | [`usampler2DArray`](crate::enums::usampler2DArray) |
    /// | [`GL_UNSIGNED_INT_SAMPLER_2D_ARRAY`](crate::enums::GL_UNSIGNED_INT_SAMPLER_2D_ARRAY) | [`usampler2DArray`](crate::enums::usampler2DArray) |
    /// | [`GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE`](crate::enums::GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE) | [`usampler2DMS`](crate::enums::usampler2DMS) |
    /// | [`GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY) | [`usampler2DMSArray`](crate::enums::usampler2DMSArray) |
    /// | [`GL_UNSIGNED_INT_SAMPLER_BUFFER`](crate::enums::GL_UNSIGNED_INT_SAMPLER_BUFFER) | [`usamplerBuffer`](crate::enums::usamplerBuffer) |
    /// | [`GL_UNSIGNED_INT_SAMPLER_2D_RECT`](crate::enums::GL_UNSIGNED_INT_SAMPLER_2D_RECT) | [`usampler2DRect`](crate::enums::usampler2DRect) |
    ///
    ///
    /// If `pname` is [`GL_UNIFORM_SIZE`](crate::enums::GL_UNIFORM_SIZE), then
    /// an array identifying the size of the uniforms specified by the corresponding
    /// array of `uniformIndices` is returned. The sizes returned are in units
    /// of the type returned by a query of [`GL_UNIFORM_TYPE`](crate::enums::GL_UNIFORM_TYPE).
    /// For active uniforms that are arrays, the size is the number of active
    /// elements in the array; for all other uniforms, the size is one.
    ///
    /// If `pname` is [`GL_UNIFORM_NAME_LENGTH`](crate::enums::GL_UNIFORM_NAME_LENGTH),
    /// then an array identifying the length, including the terminating null character,
    /// of the uniform name strings specified by the corresponding array of `uniformIndices`
    /// is returned.
    ///
    /// If `pname` is [`GL_UNIFORM_BLOCK_INDEX`](crate::enums::GL_UNIFORM_BLOCK_INDEX),
    /// then an array identifying the uniform block index of each of the uniforms
    /// specified by the corresponding array of `uniformIndices` is returned. The
    /// uniform block index of a uniform associated with the default uniform block
    /// is -1.
    ///
    /// If `pname` is [`GL_UNIFORM_OFFSET`](crate::enums::GL_UNIFORM_OFFSET), then
    /// an array of uniform buffer offsets is returned. For uniforms in a named
    /// uniform block, the returned value will be its offset, in basic machine
    /// units, relative to the beginning of the uniform block in the buffer object
    /// data store. For atomic counter uniforms, the returned value will be its
    /// offset relative to the beginning of its active atomic counter buffer. For
    /// all other uniforms, -1 will be returned.
    ///
    /// If `pname` is [`GL_UNIFORM_ARRAY_STRIDE`](crate::enums::GL_UNIFORM_ARRAY_STRIDE),
    /// then an array identifying the stride between elements of each of the uniforms
    /// specified by the corresponding array of `uniformIndices` is returned. For
    /// uniforms in named uniform blocks and for uniforms declared as atomic counters,
    /// the stride is the difference, in basic machine units, of consecutive elements
    /// in an array, or zero for uniforms not declared as an array. For all other
    /// uniforms, a stride of -1 will be returned.
    ///
    /// If `pname` is [`GL_UNIFORM_MATRIX_STRIDE`](crate::enums::GL_UNIFORM_MATRIX_STRIDE),
    /// then an array identifying the stride between columns of a column-major
    /// matrix or rows of a row-major matrix, in basic machine units, of each of
    /// the uniforms specified by the corresponding array of `uniformIndices` is
    /// returned. The matrix stride of a uniform associated with the default uniform
    /// block is -1. Note that this information only makes sense for uniforms that
    /// are matrices. For uniforms that are not matrices, but are declared in a
    /// named uniform block, a matrix stride of zero is returned.
    ///
    /// If `pname` is [`GL_UNIFORM_IS_ROW_MAJOR`](crate::enums::GL_UNIFORM_IS_ROW_MAJOR),
    /// then an array identifying whether each of the uniforms specified by the
    /// corresponding array of `uniformIndices` is a row-major matrix or not is
    /// returned. A value of one indicates a row-major matrix, and a value of zero
    /// indicates a column-major matrix, a matrix in the default uniform block,
    /// or a non-matrix.
    ///
    /// If `pname` is [`GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX`](crate::enums::GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX),
    /// then an array identifying the active atomic counter buffer index of each
    /// of the uniforms specified by the corresponding array of `uniformIndices`
    /// is returned. For uniforms other than atomic counters, the returned buffer
    /// index is -1. The returned indices may be passed to [**glGetActiveAtomicCounterBufferiv**](crate::context::Context::oxidegl_get_active_atomic_counter_bufferiv)
    /// to query the properties of the associated buffer, and not necessarily the
    /// binding point specified in the uniform declaration.
    ///
    /// ### Notes
    /// The double types, [`GL_DOUBLE`](crate::enums::GL_DOUBLE), [`GL_DOUBLE_VEC2`](crate::enums::GL_DOUBLE_VEC2),
    /// [`GL_DOUBLE_VEC3`](crate::enums::GL_DOUBLE_VEC3), [`GL_DOUBLE_VEC4`](crate::enums::GL_DOUBLE_VEC4),
    /// [`GL_DOUBLE_MAT2`](crate::enums::GL_DOUBLE_MAT2), [`GL_DOUBLE_MAT3`](crate::enums::GL_DOUBLE_MAT3),
    /// [`GL_DOUBLE_MAT4`](crate::enums::GL_DOUBLE_MAT4), [`GL_DOUBLE_MAT2x3`](crate::enums::GL_DOUBLE_MAT2x3),
    /// [`GL_DOUBLE_MAT2x4`](crate::enums::GL_DOUBLE_MAT2x4), [`GL_DOUBLE_MAT3x2`](crate::enums::GL_DOUBLE_MAT3x2),
    /// [`GL_DOUBLE_MAT3x4`](crate::enums::GL_DOUBLE_MAT3x4), [`GL_DOUBLE_MAT4x2`](crate::enums::GL_DOUBLE_MAT4x2),
    /// and [`GL_DOUBLE_MAT4x3`](crate::enums::GL_DOUBLE_MAT4x3) are only available
    /// if the GL version is 4.1 or higher.
    ///
    /// [`GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX`](crate::enums::GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX)
    /// is only accepted by `pname` if the GL version is 4.2 or higher.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_VERTEX_UNIFORM_COMPONENTS`](crate::enums::GL_MAX_VERTEX_UNIFORM_COMPONENTS),
    /// [`GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS`](crate::enums::GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS),
    /// [`GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS`](crate::enums::GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS),
    /// [`GL_MAX_GEOMETRY_UNIFORM_COMPONENTS`](crate::enums::GL_MAX_GEOMETRY_UNIFORM_COMPONENTS),
    /// [`GL_MAX_FRAGMENT_UNIFORM_COMPONENTS`](crate::enums::GL_MAX_FRAGMENT_UNIFORM_COMPONENTS),
    /// or [`GL_MAX_COMBINED_UNIFORM_COMPONENTS`](crate::enums::GL_MAX_COMBINED_UNIFORM_COMPONENTS).
    ///
    /// [**glGetProgram**](crate::context::Context::oxidegl_get_program) with argument
    /// [`GL_ACTIVE_UNIFORMS`](crate::enums::GL_ACTIVE_UNIFORMS) or [`GL_ACTIVE_UNIFORM_MAX_LENGTH`](crate::enums::GL_ACTIVE_UNIFORM_MAX_LENGTH).
    ///
    /// [**glIsProgram**](crate::context::Context::oxidegl_is_program)

    pub unsafe fn oxidegl_get_active_uniformsiv(
        &mut self,
        program: GLuint,
        uniform_count: GLsizei,
        uniform_indices: *const GLuint,
        pname: UniformPName,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_active_uniformsiv not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the program object to be queried.
    ///
    /// `maxCount`
    ///
    /// > Specifies the size of the array for storing the returned object names.
    ///
    /// `count`
    ///
    /// > Returns the number of names actually returned in `shaders`.
    ///
    /// `shaders`
    ///
    /// > Specifies an array that is used to return the names of attached shader
    /// > objects.
    ///
    /// ### Description
    /// [**glGetAttachedShaders**](crate::context::Context::oxidegl_get_attached_shaders)
    /// returns the names of the shader objects attached to `program`. The names
    /// of shader objects that are attached to `program` will be returned in `shaders.`
    /// The actual number of shader names written into `shaders` is returned in
    /// `count.` If no shader objects are attached to `program`, `count` is set
    /// to 0. The maximum number of shader names that may be returned in `shaders`
    /// is specified by `maxCount`.
    ///
    /// If the number of names actually returned is not required (for instance,
    /// if it has just been obtained by calling [**glGetProgram**](crate::context::Context::oxidegl_get_program)
    /// ), a value of [`NULL`](crate::enums::NULL) may be passed for count. If
    /// no shader objects are attached to `program`, a value of 0 will be returned
    /// in `count`. The actual number of attached shaders can be obtained by calling
    /// [**glGetProgram**](crate::context::Context::oxidegl_get_program) with the
    /// value [`GL_ATTACHED_SHADERS`](crate::enums::GL_ATTACHED_SHADERS).
    ///
    /// ### Associated Gets
    /// [**glGetProgram**](crate::context::Context::oxidegl_get_program) with argument
    /// [`GL_ATTACHED_SHADERS`](crate::enums::GL_ATTACHED_SHADERS)
    ///
    /// [**glIsProgram**](crate::context::Context::oxidegl_is_program)

    pub unsafe fn oxidegl_get_attached_shaders(
        &mut self,
        program: GLuint,
        max_count: GLsizei,
        count: *mut GLsizei,
        shaders: *mut GLuint,
    ) {
        panic!("command oxidegl_get_attached_shaders not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the program object to be queried.
    ///
    /// `name`
    ///
    /// > Points to a null terminated string containing the name of the attribute
    /// > variable whose location is to be queried.
    ///
    /// ### Description
    /// [**glGetAttribLocation**](crate::context::Context::oxidegl_get_attrib_location)
    /// queries the previously linked program object specified by `program` for
    /// the attribute variable specified by `name` and returns the index of the
    /// generic vertex attribute that is bound to that attribute variable. If `name`
    /// is a matrix attribute variable, the index of the first column of the matrix
    /// is returned. If the named attribute variable is not an active attribute
    /// in the specified program object or if `name` starts with the reserved prefix
    /// "gl_", a value of -1 is returned.
    ///
    /// The association between an attribute variable name and a generic attribute
    /// index can be specified at any time by calling [**glBindAttribLocation**](crate::context::Context::oxidegl_bind_attrib_location).
    /// Attribute bindings do not go into effect until [**glLinkProgram**](crate::context::Context::oxidegl_link_program)
    /// is called. After a program object has been linked successfully, the index
    /// values for attribute variables remain fixed until the next link command
    /// occurs. The attribute values can only be queried after a link if the link
    /// was successful. [**glGetAttribLocation**](crate::context::Context::oxidegl_get_attrib_location)
    /// returns the binding that actually went into effect the last time [**glLinkProgram**](crate::context::Context::oxidegl_link_program)
    /// was called for the specified program object. Attribute bindings that have
    /// been specified since the last link operation are not returned by [**glGetAttribLocation**](crate::context::Context::oxidegl_get_attrib_location).
    ///
    /// ### Associated Gets
    /// [**glGetActiveAttrib**](crate::context::Context::oxidegl_get_active_attrib)
    /// with argument `program` and the index of an active attribute
    ///
    /// [**glIsProgram**](crate::context::Context::oxidegl_is_program)

    pub unsafe fn oxidegl_get_attrib_location(
        &mut self,
        program: GLuint,
        name: *const GLchar,
    ) -> GLint {
        panic!("command oxidegl_get_attrib_location not yet implemented");
    }
    /// ### Parameters
    /// `texture`
    ///
    /// > Specifies the name of the source texture object. Must be [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D),
    /// > [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY), [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D),
    /// > [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY), [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D),
    /// > [`GL_TEXTURE_CUBE_MAP`](crate::enums::GL_TEXTURE_CUBE_MAP), [`GL_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_CUBE_MAP_ARRAY)
    /// > or [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE). In specific,
    /// > buffer and multisample textures are not permitted.
    ///
    /// `level`
    ///
    /// > Specifies the level-of-detail number. Level 0 is the base image level.
    /// > Level $n$ is the $n$th mipmap reduction image.
    ///
    /// `xoffset`
    ///
    /// > Specifies a texel offset in the x direction within the texture array.
    ///
    /// `yoffset`
    ///
    /// > Specifies a texel offset in the y direction within the texture array.
    ///
    /// `zoffset`
    ///
    /// > Specifies a texel offset in the z direction within the texture array.
    ///
    /// `width`
    ///
    /// > Specifies the width of the texture subimage. Must be a multiple of the
    /// > compressed block's width, unless the `offset` is zero and the size equals
    /// > the texture image size.
    ///
    /// `height`
    ///
    /// > Specifies the height of the texture subimage. Must be a multiple of the
    /// > compressed block's height, unless the `offset` is zero and the size equals
    /// > the texture image size.
    ///
    /// `depth`
    ///
    /// > Specifies the depth of the texture subimage. Must be a multiple of the
    /// > compressed block's depth, unless the `offset` is zero and the size equals
    /// > the texture image size.
    ///
    /// `bufSize`
    ///
    /// > Specifies the size of the buffer to receive the retrieved pixel data.
    ///
    /// `pixels`
    ///
    /// > Returns the texture subimage. Should be a pointer to an array of the type
    /// > specified by type.
    ///
    /// ### Description
    /// [**glGetCompressedTextureSubImage**](crate::context::Context::oxidegl_get_compressed_texture_sub_image)
    /// can be used to obtain a sub-region of a compressed texture image instead
    /// of the whole image, as long as the compressed data are arranged into fixed-size
    /// blocks of texels. `texture` is the name of the texture object, and must
    /// not be a buffer or multisample texture. The effective `target` is the value
    /// of [`GL_TEXTURE_TARGET`](crate::enums::GL_TEXTURE_TARGET) for texture.
    /// `level` and `pixels` have the same meaning as the corresponding arguments
    /// of [**glCompressedTexSubImage3D**](crate::context::Context::oxidegl_compressed_tex_sub_image3_d).
    /// `bufSize` indicates the size of the buffer to receive the retrieved pixel
    /// data.
    ///
    /// For cube map textures, the behavior is as though [**glGetCompressedTexImage**](crate::context::Context::oxidegl_get_compressed_tex_image)
    /// were called once for each requested face (selected by `zoffset` and `depth`,
    /// as described below) with target corresponding to the requested texture
    /// cube map face as indicated by the table presented below. `pixels` is offset
    /// appropriately for each successive image.
    ///
    /// | Layer number        | Cube Map Face        |
    /// |---------------------|----------------------|
    /// | 0                   | [`GL_TEXTURE_CUBE_MAP_POSITIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_X) |
    /// | 1                   | [`GL_TEXTURE_CUBE_MAP_NEGATIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_X) |
    /// | 2                   | [`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Y) |
    /// | 3                   | [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Y) |
    /// | 4                   | [`GL_TEXTURE_CUBE_MAP_POSITIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Z) |
    /// | 5                   | [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Z) |
    ///
    /// `xoffset`, `yoffset` and `zoffset` indicate the position of the subregion
    /// to return. `width`, `height` and `depth` indicate the size of the region
    /// to return. These arguments have the same meaning as for [**glCompressedTexSubImage3D**](crate::context::Context::oxidegl_compressed_tex_sub_image3_d),
    /// though there are extra restrictions, described in the errors section below.
    ///
    /// The mapping between the `xoffset`, `yoffset`, `zoffset`, `width`, `height`
    /// and `depth` parameters and the faces, layers, and layer-faces for cube
    /// map, array, and cube map array textures is the same as for glGetTextureSubImage.
    ///
    /// The `xoffset`, `yoffset`, `zoffset` offsets and `width`, `height` and `depth`
    /// sizes must be multiples of the values of [`GL_PACK_COMPRESSED_BLOCK_WIDTH`](crate::enums::GL_PACK_COMPRESSED_BLOCK_WIDTH),
    /// [`GL_PACK_COMPRESSED_BLOCK_HEIGHT`](crate::enums::GL_PACK_COMPRESSED_BLOCK_HEIGHT),
    /// and [`GL_PACK_COMPRESSED_BLOCK_DEPTH`](crate::enums::GL_PACK_COMPRESSED_BLOCK_DEPTH)
    /// respectively, unless `offset` is zero and the corresponding `size` is the
    /// same as the texture size in that dimension.
    ///
    /// Pixel storage modes are treated as for [**glGetCompressedTexSubImage**](crate::context::Context::oxidegl_get_compressed_tex_sub_image).
    /// The texel at( `xoffset`, `yoffset`, `zoffset`) will be stored at the location
    /// indicated by `pixels` and the current pixel packing parameters.

    pub unsafe fn oxidegl_get_compressed_texture_sub_image(
        &mut self,
        texture: GLuint,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        zoffset: GLint,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        buf_size: GLsizei,
        pixels: *mut GLvoid,
    ) {
        panic!("command oxidegl_get_compressed_texture_sub_image not yet implemented");
    }
    /// ### Parameters
    /// `count`
    ///
    /// > The number of debug messages to retrieve from the log.
    ///
    /// `bufSize`
    ///
    /// > The size of the buffer whose address is given by `messageLog`.
    ///
    /// `sources`
    ///
    /// > The address of an array of variables to receive the sources of the retrieved
    /// > messages.
    ///
    /// `types`
    ///
    /// > The address of an array of variables to receive the types of the retrieved
    /// > messages.
    ///
    /// `ids`
    ///
    /// > The address of an array of unsigned integers to receive the ids of the
    /// > retrieved messages.
    ///
    /// `severities`
    ///
    /// > The address of an array of variables to receive the severites of the retrieved
    /// > messages.
    ///
    /// `lengths`
    ///
    /// > The address of an array of variables to receive the lengths of the received
    /// > messages.
    ///
    /// `messageLog`
    ///
    /// > The address of an array of characters that will receive the messages.
    ///
    /// ### Description
    /// [**glGetDebugMessageLog**](crate::context::Context::oxidegl_get_debug_message_log)
    /// retrieves messages from the debug message log. A maximum of `count` messages
    /// are retrieved from the log. If `sources` is not NULL then the source of
    /// each message is written into up to `count` elements of the array. If `types`
    /// is not NULL then the type of each message is written into up to `count`
    /// elements of the array. If `id` is not NULL then the identifier of each
    /// message is written into up to `count` elements of the array. If `severities`
    /// is not NULL then the severity of each message is written into up to `count`
    /// elements of the array. If `lengths` is not NULL then the length of each
    /// message is written into up to `count` elements of the array.
    ///
    /// `messageLog` specifies the address of a character array into which the
    /// debug messages will be written. Each message will be concatenated onto
    /// the array starting at the first element of `messageLog`. `bufSize` specifies
    /// the size of the array `messageLog`. If a message will not fit into the
    /// remaining space in `messageLog` then the function terminates and returns
    /// the number of messages written so far, which may be zero.
    ///
    /// If [**glGetDebugMessageLog**](crate::context::Context::oxidegl_get_debug_message_log)
    /// returns zero then no messages are present in the debug log, or there was
    /// not enough space in `messageLog` to retrieve the first message in the queue.
    /// If `messageLog` is NULL then no messages are written and the value of `bufSize`
    /// is ignored.
    ///
    /// ### Notes
    /// Although debug messages may be enabled in a non-debug context, the quantity
    /// and detail of such messages may be substantially inferior to those in a
    /// debug context. In particular, a valid implementation of the debug message
    /// queue in a non-debug context may produce no messages at all.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_DEBUG_LOGGED_MESSAGES`](crate::enums::GL_DEBUG_LOGGED_MESSAGES)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH`](crate::enums::GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_DEBUG_MESSAGE_LENGTH`](crate::enums::GL_MAX_DEBUG_MESSAGE_LENGTH)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_DEBUG_LOGGED_MESSAGES`](crate::enums::GL_MAX_DEBUG_LOGGED_MESSAGES)

    pub unsafe fn oxidegl_get_debug_message_log(
        &mut self,
        count: GLuint,
        buf_size: GLsizei,
        sources: DebugSource,
        types: DebugType,
        ids: *mut GLuint,
        severities: DebugSeverity,
        lengths: *mut GLsizei,
        message_log: *mut GLchar,
    ) -> GLuint {
        panic!("command oxidegl_get_debug_message_log not yet implemented");
    }
    /// ### Description
    /// [**glGetError**](crate::context::Context::oxidegl_get_error) returns the
    /// value of the error flag. Each detectable error is assigned a numeric code
    /// and symbolic name. When an error occurs, the error flag is set to the appropriate
    /// error code value. No other errors are recorded until [**glGetError**](crate::context::Context::oxidegl_get_error)
    /// is called, the error code is returned, and the flag is reset to [`GL_NO_ERROR`](crate::enums::GL_NO_ERROR).
    /// If a call to [**glGetError**](crate::context::Context::oxidegl_get_error)
    /// returns [`GL_NO_ERROR`](crate::enums::GL_NO_ERROR), there has been no detectable
    /// error since the last call to [**glGetError**](crate::context::Context::oxidegl_get_error),
    /// or since the GL was initialized.
    ///
    /// To allow for distributed implementations, there may be several error flags.
    /// If any single error flag has recorded an error, the value of that flag
    /// is returned and that flag is reset to [`GL_NO_ERROR`](crate::enums::GL_NO_ERROR)
    /// when [**glGetError**](crate::context::Context::oxidegl_get_error) is called.
    /// If more than one flag has recorded an error, [**glGetError**](crate::context::Context::oxidegl_get_error)
    /// returns and clears an arbitrary error flag value. Thus, [**glGetError**](crate::context::Context::oxidegl_get_error)
    /// should always be called in a loop, until it returns [`GL_NO_ERROR`](crate::enums::GL_NO_ERROR),
    /// if all error flags are to be reset.
    ///
    /// Initially, all error flags are set to [`GL_NO_ERROR`](crate::enums::GL_NO_ERROR).
    ///
    /// The following errors are currently defined:
    ///
    /// [`GL_NO_ERROR`](crate::enums::GL_NO_ERROR)
    ///
    /// > No error has been recorded. The value of this symbolic constant is guaranteed
    /// > to be 0.
    ///
    /// [`GL_INVALID_ENUM`](crate::enums::GL_INVALID_ENUM)
    ///
    /// > An unacceptable value is specified for an enumerated argument. The offending
    /// > command is ignored and has no other side effect than to set the error flag.
    ///
    /// [`GL_INVALID_VALUE`](crate::enums::GL_INVALID_VALUE)
    ///
    /// > A numeric argument is out of range. The offending command is ignored and
    /// > has no other side effect than to set the error flag.
    ///
    /// [`GL_INVALID_OPERATION`](crate::enums::GL_INVALID_OPERATION)
    ///
    /// > The specified operation is not allowed in the current state. The offending
    /// > command is ignored and has no other side effect than to set the error flag.
    ///
    /// [`GL_INVALID_FRAMEBUFFER_OPERATION`](crate::enums::GL_INVALID_FRAMEBUFFER_OPERATION)
    ///
    /// > The framebuffer object is not complete. The offending command is ignored
    /// > and has no other side effect than to set the error flag.
    ///
    /// [`GL_OUT_OF_MEMORY`](crate::enums::GL_OUT_OF_MEMORY)
    ///
    /// > There is not enough memory left to execute the command. The state of the
    /// > GL is undefined, except for the state of the error flags, after this error
    /// > is recorded.
    ///
    /// [`GL_STACK_UNDERFLOW`](crate::enums::GL_STACK_UNDERFLOW)
    ///
    /// > An attempt has been made to perform an operation that would cause an internal
    /// > stack to underflow.
    ///
    /// [`GL_STACK_OVERFLOW`](crate::enums::GL_STACK_OVERFLOW)
    ///
    /// > An attempt has been made to perform an operation that would cause an internal
    /// > stack to overflow.
    ///
    /// When an error flag is set, results of a GL operation are undefined only
    /// if [`GL_OUT_OF_MEMORY`](crate::enums::GL_OUT_OF_MEMORY) has occurred. In
    /// all other cases, the command generating the error is ignored and has no
    /// effect on the GL state or frame buffer contents. If the generating command
    /// returns a value, it returns 0. If [**glGetError**](crate::context::Context::oxidegl_get_error)
    /// itself generates an error, it returns 0.

    pub fn oxidegl_get_error(&mut self) -> GLenum {
        panic!("command oxidegl_get_error not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > The name of the program containing varying out variable whose binding to
    /// > query
    ///
    /// `name`
    ///
    /// > The name of the user-defined varying out variable whose index to query
    ///
    /// ### Description
    /// [**glGetFragDataIndex**](crate::context::Context::oxidegl_get_frag_data_index)
    /// returns the index of the fragment color to which the variable `name` was
    /// bound when the program object `program` was last linked. If `name` is not
    /// a varying out variable of `program`, or if an error occurs, -1 will be
    /// returned.
    ///
    /// ### Notes
    /// [**glGetFragDataIndex**](crate::context::Context::oxidegl_get_frag_data_index)
    /// is available only if the GL version is 3.3 or greater.

    pub unsafe fn oxidegl_get_frag_data_index(
        &mut self,
        program: GLuint,
        name: *const GLchar,
    ) -> GLint {
        panic!("command oxidegl_get_frag_data_index not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > The name of the program containing varying out variable whose binding to
    /// > query
    ///
    /// `name`
    ///
    /// > The name of the user-defined varying out variable whose binding to query
    ///
    /// ### Description
    /// [**glGetFragDataLocation**](crate::context::Context::oxidegl_get_frag_data_location)
    /// retrieves the assigned color number binding for the user-defined varying
    /// out variable `name` for program `program`. `program` must have previously
    /// been linked. `name` must be a null-terminated string. If `name` is not
    /// the name of an active user-defined varying out fragment shader variable
    /// within `program`, -1 will be returned.

    pub unsafe fn oxidegl_get_frag_data_location(
        &mut self,
        program: GLuint,
        name: *const GLchar,
    ) -> GLint {
        panic!("command oxidegl_get_frag_data_location not yet implemented");
    }
    /// ### Description
    /// Certain events can result in a reset of the GL context. Such a reset causes
    /// all context state to be lost and requires the application to recreate all
    /// objects in the affected context.
    ///
    /// [**glGetGraphicsResetStatus**](crate::context::Context::oxidegl_get_graphics_reset_status)
    /// can return one of the following constants:
    ///
    /// [`GL_NO_ERROR`](crate::enums::GL_NO_ERROR)
    ///
    /// > Indicates that the GL context has not been in a reset state since the last
    /// > call.
    ///
    /// [`GL_GUILTY_CONTEXT_RESET`](crate::enums::GL_GUILTY_CONTEXT_RESET)
    ///
    /// > Indicates that a reset has been detected that is attributable to the current
    /// > GL context.
    ///
    /// [`GL_INNOCENT_CONTEXT_RESET`](crate::enums::GL_INNOCENT_CONTEXT_RESET)
    ///
    /// > Indicates a reset has been detected that is not attributable to the current
    /// > GL context.
    ///
    /// [`GL_UNKNOWN_CONTEXT_RESET`](crate::enums::GL_UNKNOWN_CONTEXT_RESET)
    ///
    /// > Indicates a detected graphics reset whose cause is unknown.
    ///
    /// If a reset status other than [`GL_NO_ERROR`](crate::enums::GL_NO_ERROR)
    /// is returned and subsequent calls return [`GL_NO_ERROR`](crate::enums::GL_NO_ERROR),
    /// the context reset was encountered and completed. If a reset status is
    /// repeatedly returned, the context may be in the process of resetting.
    ///
    /// Reset notification behavior is determined at context creation time, and
    /// may be queried by calling [**`GetIntegerv`**](crate::context::Context::oxide_get_integerv)
    /// with the symbolic constant [`GL_RESET_NOTIFICATION_STRATEGY`](crate::enums::GL_RESET_NOTIFICATION_STRATEGY).
    ///
    /// If the reset notification behavior is [`GL_NO_RESET_NOTIFICATION`](crate::enums::GL_NO_RESET_NOTIFICATION),
    /// then the implementation will never deliver notification of reset events,
    /// and [**glGetGraphicsResetStatus**](crate::context::Context::oxidegl_get_graphics_reset_status)
    /// will always return [`GL_NO_ERROR`](crate::enums::GL_NO_ERROR).
    ///
    /// If the behavior is [`GL_LOSE_CONTEXT_ON_RESET`](crate::enums::GL_LOSE_CONTEXT_ON_RESET),
    /// a graphics reset will result in the loss of all context state, requiring
    /// the recreation of all associated objects. In this case [**glGetGraphicsResetStatus**](crate::context::Context::oxidegl_get_graphics_reset_status)
    /// may return any of the values described above.
    ///
    /// If a graphics reset notification occurs in a context, a notification must
    /// also occur in all other contexts which share objects with that context.
    ///
    /// After a graphics reset has occurred on a context, subsequent GL commands
    /// on that context (or any context which shares with that context) will generate
    /// a [`GL_CONTEXT_LOST`](crate::enums::GL_CONTEXT_LOST) error. Such commands
    /// will not have side effects (in particular, they will not modify memory
    /// passed by pointer for query results), and will not block indefinitely or
    /// cause termination of the application. There are two important exceptions
    /// to this behavior:
    ///
    /// > [**glGetError**](crate::context::Context::oxidegl_get_error) and [**glGetGraphicsResetStatus**](crate::context::Context::oxidegl_get_graphics_reset_status)
    /// > behave normally following a graphics reset, so that the application can
    /// > determine a reset has occurred, and when it is safe to destroy and re-create
    /// > the context.
    ///
    /// > Any commands which might cause a polling application to block indefinitely
    /// > will generate a [`GL_CONTEXT_LOST`](crate::enums::GL_CONTEXT_LOST) error,
    /// > but will also return a value indicating completion to the application.
    /// > Such commands include: [**glGetSynciv**](crate::context::Context::oxidegl_get_synciv)
    /// >> with pname [`GL_SYNC_STATUS`](crate::enums::GL_SYNC_STATUS) ignores the
    /// >> other parameters and returns [`GL_SIGNALED`](crate::enums::GL_SIGNALED)
    /// >> in `values`.
    ///
    /// >> [**glGetQueryObjectuiv**](crate::context::Context::oxidegl_get_query_objectuiv)
    /// >> with pname [`GL_QUERY_RESULT_AVAILABLE`](crate::enums::GL_QUERY_RESULT_AVAILABLE)
    /// >> ignores the other parameters and returns [`TRUE`](crate::enums::TRUE) in
    /// >> `params`.
    ///
    ///

    pub fn oxidegl_get_graphics_reset_status(&mut self) -> GLenum {
        panic!("command oxidegl_get_graphics_reset_status not yet implemented");
    }
    /// ### Parameters
    /// `pname`
    ///
    /// > Specifies the sample parameter name. `pname` must be [`GL_SAMPLE_POSITION`](crate::enums::GL_SAMPLE_POSITION).
    ///
    /// `index`
    ///
    /// > Specifies the index of the sample whose position to query.
    ///
    /// `val`
    ///
    /// > Specifies the address of an array to receive the position of the sample.
    ///
    /// ### Description
    /// [**glGetMultisamplefv**](crate::context::Context::oxidegl_get_multisamplefv)
    /// queries the location of a given sample. `pname` specifies the sample parameter
    /// to retrieve and must be [`GL_SAMPLE_POSITION`](crate::enums::GL_SAMPLE_POSITION).
    /// `index` corresponds to the sample for which the location should be returned.
    /// The sample location is returned as two floating-point values in `val[0]`
    /// and `val[1]`, each between 0 and 1, corresponding to the `x` and `y` locations
    /// respectively in the GL pixel space of that sample. (0.5, 0.5) this corresponds
    /// to the pixel center. `index` must be between zero and the value of [`GL_SAMPLES`](crate::enums::GL_SAMPLES)
    /// minus one.
    ///
    /// If the multisample mode does not have fixed sample locations, the returned
    /// values may only reflect the locations of samples within some pixels.

    pub unsafe fn oxidegl_get_multisamplefv(
        &mut self,
        pname: GLenum,
        index: GLuint,
        val: *mut GLfloat,
    ) {
        panic!("command oxidegl_get_multisamplefv not yet implemented");
    }
    /// ### Parameters
    /// `identifier`
    ///
    /// > The namespace from which the name of the object is allocated.
    ///
    /// `name`
    ///
    /// > The name of the object whose label to retrieve.
    ///
    /// `bufSize`
    ///
    /// > The length of the buffer whose address is in `label`.
    ///
    /// `length`
    ///
    /// > The address of a variable to receive the length of the object label.
    ///
    /// `label`
    ///
    /// > The address of a string that will receive the object label.
    ///
    /// ### Description
    /// [**glGetObjectLabel**](crate::context::Context::oxidegl_get_object_label)
    /// retrieves the label of the object identified by `name` within the namespace
    /// given by `identifier`. `identifier` must be one of [`GL_BUFFER`](crate::enums::GL_BUFFER),
    /// [`GL_SHADER`](crate::enums::GL_SHADER), [`GL_PROGRAM`](crate::enums::GL_PROGRAM),
    /// [`GL_VERTEX_ARRAY`](crate::enums::GL_VERTEX_ARRAY), [`GL_QUERY`](crate::enums::GL_QUERY),
    /// [`GL_PROGRAM_PIPELINE`](crate::enums::GL_PROGRAM_PIPELINE), [`GL_TRANSFORM_FEEDBACK`](crate::enums::GL_TRANSFORM_FEEDBACK),
    /// [`GL_SAMPLER`](crate::enums::GL_SAMPLER), [`GL_TEXTURE`](crate::enums::GL_TEXTURE),
    /// [`GL_RENDERBUFFER`](crate::enums::GL_RENDERBUFFER), [`GL_FRAMEBUFFER`](crate::enums::GL_FRAMEBUFFER),
    /// to indicate the namespace containing the names of buffers, shaders, programs,
    /// vertex array objects, query objects, program pipelines, transform feedback
    /// objects, samplers, textures, renderbuffers and frame buffers, respectively.
    ///
    /// `label` is the address of a string that will be used to store the object
    /// label. `bufSize` specifies the number of characters in the array identified
    /// by `label`. `length` contains the address of a variable which will receive
    /// the number of characters in the object label. If `length` is NULL, then
    /// it is ignored and no data is written. Likewise, if `label` is NULL, or
    /// if `bufSize` is zero then no data is written to `label`.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_LABEL_LENGTH`](crate::enums::GL_MAX_LABEL_LENGTH).

    pub unsafe fn oxidegl_get_object_label(
        &mut self,
        identifier: ObjectIdentifier,
        name: GLuint,
        buf_size: GLsizei,
        length: *mut GLsizei,
        label: *mut GLchar,
    ) {
        panic!("command oxidegl_get_object_label not yet implemented");
    }
    /// ### Parameters
    /// `ptr`
    ///
    /// > The name of the sync object whose label to retrieve.
    ///
    /// `bufSize`
    ///
    /// > The length of the buffer whose address is in `label`.
    ///
    /// `length`
    ///
    /// > The address of a variable to receive the length of the object label.
    ///
    /// `label`
    ///
    /// > The address of a string that will receive the object label.
    ///
    /// ### Description
    /// [**glGetObjectPtrLabel**](crate::context::Context::oxidegl_get_object_ptr_label)
    /// retrieves the label of the sync object identified by `ptr`.
    ///
    /// `label` is the address of a string that will be used to store the object
    /// label. `bufSize` specifies the number of characters in the array identified
    /// by `label`. `length` contains the address of a variable which will receive
    /// the number of characters in the object label. If `length` is NULL, then
    /// it is ignored and no data is written. Likewise, if `label` is NULL, or
    /// if `bufSize` is zero then no data is written to `label`.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_LABEL_LENGTH`](crate::enums::GL_MAX_LABEL_LENGTH).

    pub unsafe fn oxidegl_get_object_ptr_label(
        &mut self,
        ptr: *const GLvoid,
        buf_size: GLsizei,
        length: *mut GLsizei,
        label: *mut GLchar,
    ) {
        panic!("command oxidegl_get_object_ptr_label not yet implemented");
    }
    /// ### Parameters
    /// `pname`
    ///
    /// > Specifies the pointer to be returned. Must be one of [`GL_DEBUG_CALLBACK_FUNCTION`](crate::enums::GL_DEBUG_CALLBACK_FUNCTION)
    /// > or [`GL_DEBUG_CALLBACK_USER_PARAM`](crate::enums::GL_DEBUG_CALLBACK_USER_PARAM).
    ///
    /// `params`
    ///
    /// > Returns the pointer value specified by `pname`.
    ///
    /// ### Description
    /// [**glGetPointerv**](crate::context::Context::oxidegl_get_pointerv) returns
    /// pointer information. `pname` indicates the pointer to be returned, and
    /// `params` is a pointer to a location in which to place the returned data.
    /// The parameters that may be queried include:
    ///
    /// [`GL_DEBUG_CALLBACK_FUNCTION`](crate::enums::GL_DEBUG_CALLBACK_FUNCTION)
    ///
    /// > Returns the current callback function set with the `callback` argument
    /// > of [**glDebugMessageCallback**](crate::context::Context::oxidegl_debug_message_callback).
    ///
    /// [`GL_DEBUG_CALLBACK_USER_PARAM`](crate::enums::GL_DEBUG_CALLBACK_USER_PARAM)
    ///
    /// > Returns the user parameter to the current callback function set with the
    /// > `userParam` argument of [**glDebugMessageCallback**](crate::context::Context::oxidegl_debug_message_callback).
    ///
    /// ### Notes
    /// [**glGetPointerv**](crate::context::Context::oxidegl_get_pointerv) is available
    /// in the OpenGL core profile only if the GL version is 4.3 or later. It is
    /// available in the compatibility profile for all GL versions, and accepts
    /// additional queries. However, these reference pages document only the core
    /// profile.

    pub unsafe fn oxidegl_get_pointerv(
        &mut self,
        pname: GetPointervPName,
        params: *mut *mut GLvoid,
    ) {
        panic!("command oxidegl_get_pointerv not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the program object to be queried.
    ///
    /// `pname`
    ///
    /// > Specifies the object parameter. Accepted symbolic names are [`GL_DELETE_STATUS`](crate::enums::GL_DELETE_STATUS),
    /// > [`GL_LINK_STATUS`](crate::enums::GL_LINK_STATUS), [`GL_VALIDATE_STATUS`](crate::enums::GL_VALIDATE_STATUS),
    /// > [`GL_INFO_LOG_LENGTH`](crate::enums::GL_INFO_LOG_LENGTH), [`GL_ATTACHED_SHADERS`](crate::enums::GL_ATTACHED_SHADERS),
    /// > [`GL_ACTIVE_ATOMIC_COUNTER_BUFFERS`](crate::enums::GL_ACTIVE_ATOMIC_COUNTER_BUFFERS),
    /// > [`GL_ACTIVE_ATTRIBUTES`](crate::enums::GL_ACTIVE_ATTRIBUTES), [`GL_ACTIVE_ATTRIBUTE_MAX_LENGTH`](crate::enums::GL_ACTIVE_ATTRIBUTE_MAX_LENGTH),
    /// > [`GL_ACTIVE_UNIFORMS`](crate::enums::GL_ACTIVE_UNIFORMS), [`GL_ACTIVE_UNIFORM_BLOCKS`](crate::enums::GL_ACTIVE_UNIFORM_BLOCKS),
    /// > [`GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH`](crate::enums::GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH),
    /// > [`GL_ACTIVE_UNIFORM_MAX_LENGTH`](crate::enums::GL_ACTIVE_UNIFORM_MAX_LENGTH),
    /// > [`GL_COMPUTE_WORK_GROUP_SIZE`](crate::enums::GL_COMPUTE_WORK_GROUP_SIZE),
    /// > [`GL_PROGRAM_BINARY_LENGTH`](crate::enums::GL_PROGRAM_BINARY_LENGTH), [`GL_TRANSFORM_FEEDBACK_BUFFER_MODE`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER_MODE),
    /// > [`GL_TRANSFORM_FEEDBACK_VARYINGS`](crate::enums::GL_TRANSFORM_FEEDBACK_VARYINGS),
    /// > [`GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH`](crate::enums::GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH),
    /// > [`GL_GEOMETRY_VERTICES_OUT`](crate::enums::GL_GEOMETRY_VERTICES_OUT), [`GL_GEOMETRY_INPUT_TYPE`](crate::enums::GL_GEOMETRY_INPUT_TYPE),
    /// > and [`GL_GEOMETRY_OUTPUT_TYPE`](crate::enums::GL_GEOMETRY_OUTPUT_TYPE).
    ///
    /// `params`
    ///
    /// > Returns the requested object parameter.
    ///
    /// ### Description
    /// [**glGetProgram**](crate::context::Context::oxidegl_get_program) returns
    /// in `params` the value of a parameter for a specific program object. The
    /// following parameters are defined:
    ///
    /// [`GL_DELETE_STATUS`](crate::enums::GL_DELETE_STATUS)
    ///
    ///
    /// > `params` returns [`GL_TRUE`](crate::enums::GL_TRUE) if `program` is currently
    /// > flagged for deletion, and [`GL_FALSE`](crate::enums::GL_FALSE) otherwise.
    ///
    /// [`GL_LINK_STATUS`](crate::enums::GL_LINK_STATUS)
    ///
    ///
    /// > `params` returns [`GL_TRUE`](crate::enums::GL_TRUE) if the last link operation
    /// > on `program` was successful, and [`GL_FALSE`](crate::enums::GL_FALSE) otherwise.
    ///
    /// [`GL_VALIDATE_STATUS`](crate::enums::GL_VALIDATE_STATUS)
    ///
    ///
    /// > `params` returns [`GL_TRUE`](crate::enums::GL_TRUE) or if the last validation
    /// > operation on `program` was successful, and [`GL_FALSE`](crate::enums::GL_FALSE)
    /// > otherwise.
    ///
    /// [`GL_INFO_LOG_LENGTH`](crate::enums::GL_INFO_LOG_LENGTH)
    ///
    ///
    /// > `params` returns the number of characters in the information log for `program`
    /// > including the null termination character (i.e., the size of the character
    /// > buffer required to store the information log). If `program` has no information
    /// > log, a value of 0 is returned.
    ///
    /// [`GL_ATTACHED_SHADERS`](crate::enums::GL_ATTACHED_SHADERS)
    ///
    ///
    /// > `params` returns the number of shader objects attached to `program`.
    ///
    /// [`GL_ACTIVE_ATOMIC_COUNTER_BUFFERS`](crate::enums::GL_ACTIVE_ATOMIC_COUNTER_BUFFERS)
    ///
    ///
    /// > `params` returns the number of active attribute atomic counter buffers
    /// > used by `program`.
    ///
    /// [`GL_ACTIVE_ATTRIBUTES`](crate::enums::GL_ACTIVE_ATTRIBUTES)
    ///
    ///
    /// > `params` returns the number of active attribute variables for `program`.
    ///
    /// [`GL_ACTIVE_ATTRIBUTE_MAX_LENGTH`](crate::enums::GL_ACTIVE_ATTRIBUTE_MAX_LENGTH)
    ///
    ///
    /// > `params` returns the length of the longest active attribute name for `program`,
    /// > including the null termination character (i.e., the size of the character
    /// > buffer required to store the longest attribute name). If no active attributes
    /// > exist, 0 is returned.
    ///
    /// [`GL_ACTIVE_UNIFORMS`](crate::enums::GL_ACTIVE_UNIFORMS)
    ///
    ///
    /// > `params` returns the number of active uniform variables for `program`.
    ///
    /// [`GL_ACTIVE_UNIFORM_MAX_LENGTH`](crate::enums::GL_ACTIVE_UNIFORM_MAX_LENGTH)
    ///
    ///
    /// > `params` returns the length of the longest active uniform variable name
    /// > for `program`, including the null termination character (i.e., the size
    /// > of the character buffer required to store the longest uniform variable
    /// > name). If no active uniform variables exist, 0 is returned.
    ///
    /// [`GL_PROGRAM_BINARY_LENGTH`](crate::enums::GL_PROGRAM_BINARY_LENGTH)
    ///
    ///
    /// > `params` returns the length of the program binary, in bytes that will be
    /// > returned by a call to [**glGetProgramBinary**](crate::context::Context::oxidegl_get_program_binary).
    /// > When a progam's [`GL_LINK_STATUS`](crate::enums::GL_LINK_STATUS) is [`GL_FALSE`](crate::enums::GL_FALSE),
    /// > its program binary length is zero.
    ///
    /// [`GL_COMPUTE_WORK_GROUP_SIZE`](crate::enums::GL_COMPUTE_WORK_GROUP_SIZE)
    ///
    ///
    /// > `params` returns an array of three integers containing the local work group
    /// > size of the compute program as specified by its input layout qualifier(s).
    /// > `program` must be the name of a program object that has been previously
    /// > linked successfully and contains a binary for the compute shader stage.
    ///
    /// [`GL_TRANSFORM_FEEDBACK_BUFFER_MODE`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER_MODE)
    ///
    ///
    /// > `params` returns a symbolic constant indicating the buffer mode used when
    /// > transform feedback is active. This may be [`GL_SEPARATE_ATTRIBS`](crate::enums::GL_SEPARATE_ATTRIBS)
    /// > or [`GL_INTERLEAVED_ATTRIBS`](crate::enums::GL_INTERLEAVED_ATTRIBS).
    ///
    /// [`GL_TRANSFORM_FEEDBACK_VARYINGS`](crate::enums::GL_TRANSFORM_FEEDBACK_VARYINGS)
    ///
    ///
    /// > `params` returns the number of varying variables to capture in transform
    /// > feedback mode for the program.
    ///
    /// [`GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH`](crate::enums::GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH)
    ///
    ///
    /// > `params` returns the length of the longest variable name to be used for
    /// > transform feedback, including the null-terminator.
    ///
    /// [`GL_GEOMETRY_VERTICES_OUT`](crate::enums::GL_GEOMETRY_VERTICES_OUT)
    ///
    ///
    /// > `params` returns the maximum number of vertices that the geometry shader
    /// > in `program` will output.
    ///
    /// [`GL_GEOMETRY_INPUT_TYPE`](crate::enums::GL_GEOMETRY_INPUT_TYPE)
    ///
    ///
    /// > `params` returns a symbolic constant indicating the primitive type accepted
    /// > as input to the geometry shader contained in `program`.
    ///
    /// [`GL_GEOMETRY_OUTPUT_TYPE`](crate::enums::GL_GEOMETRY_OUTPUT_TYPE)
    ///
    ///
    /// > `params` returns a symbolic constant indicating the primitive type that
    /// > will be output by the geometry shader contained in `program`.
    ///
    /// ### Notes
    /// [`GL_ACTIVE_UNIFORM_BLOCKS`](crate::enums::GL_ACTIVE_UNIFORM_BLOCKS) and
    /// [`GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH`](crate::enums::GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH)
    /// are available only if the GL version 3.1 or greater.
    ///
    /// [`GL_GEOMETRY_VERTICES_OUT`](crate::enums::GL_GEOMETRY_VERTICES_OUT), [`GL_GEOMETRY_INPUT_TYPE`](crate::enums::GL_GEOMETRY_INPUT_TYPE)
    /// and [`GL_GEOMETRY_OUTPUT_TYPE`](crate::enums::GL_GEOMETRY_OUTPUT_TYPE)
    /// are accepted only if the GL version is 3.2 or greater.
    ///
    /// [`GL_COMPUTE_WORK_GROUP_SIZE`](crate::enums::GL_COMPUTE_WORK_GROUP_SIZE)
    /// is accepted only if the GL version is 4.3 or greater.
    ///
    /// If an error is generated, no change is made to the contents of `params`.
    ///
    /// ### Associated Gets
    /// [**glGetActiveAttrib**](crate::context::Context::oxidegl_get_active_attrib)
    /// with argument `program`
    ///
    /// [**glGetActiveUniform**](crate::context::Context::oxidegl_get_active_uniform)
    /// with argument `program`
    ///
    /// [**glGetAttachedShaders**](crate::context::Context::oxidegl_get_attached_shaders)
    /// with argument `program`
    ///
    /// [**glGetProgramInfoLog**](crate::context::Context::oxidegl_get_program_info_log)
    /// with argument `program`
    ///
    /// [**glIsProgram**](crate::context::Context::oxidegl_is_program)

    pub unsafe fn oxidegl_get_programiv(
        &mut self,
        program: GLuint,
        pname: ProgramProperty,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_programiv not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the name of a program object whose binary representation to retrieve.
    ///
    /// `bufSize`
    ///
    /// > Specifies the size of the buffer whose address is given by `binary`.
    ///
    /// `length`
    ///
    /// > Specifies the address of a variable to receive the number of bytes written
    /// > into `binary`.
    ///
    /// `binaryFormat`
    ///
    /// > Specifies the address of a variable to receive a token indicating the format
    /// > of the binary data returned by the GL.
    ///
    /// `binary`
    ///
    /// > Specifies the address an array into which the GL will return `program`
    /// > 's binary representation.
    ///
    /// ### Description
    /// [**glGetProgramBinary**](crate::context::Context::oxidegl_get_program_binary)
    /// returns a binary representation of the compiled and linked executable for
    /// `program` into the array of bytes whose address is specified in `binary`.
    /// The maximum number of bytes that may be written into `binary` is specified
    /// by `bufSize`. If the program binary is greater in size than `bufSize` bytes,
    /// then an error is generated, otherwise the actual number of bytes written
    /// into `binary` is returned in the variable whose address is given by `length`.
    /// If `length` is [`NULL`](crate::enums::NULL), then no length is returned.
    ///
    /// The format of the program binary written into `binary` is returned in the
    /// variable whose address is given by `binaryFormat`, and may be implementation
    /// dependent. The binary produced by the GL may subsequently be returned to
    /// the GL by calling [**glProgramBinary**](crate::context::Context::oxidegl_program_binary),
    /// with `binaryFormat` and `length` set to the values returned by [**glGetProgramBinary**](crate::context::Context::oxidegl_get_program_binary),
    /// and passing the returned binary data in the `binary` parameter.
    ///
    /// ### Associated Gets
    /// [**glGetProgram**](crate::context::Context::oxidegl_get_program) with argument
    /// [`GL_PROGRAM_BINARY_LENGTH`](crate::enums::GL_PROGRAM_BINARY_LENGTH)

    pub unsafe fn oxidegl_get_program_binary(
        &mut self,
        program: GLuint,
        buf_size: GLsizei,
        length: *mut GLsizei,
        binary_format: *mut GLenum,
        binary: *mut GLvoid,
    ) {
        panic!("command oxidegl_get_program_binary not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the program object whose information log is to be queried.
    ///
    /// `maxLength`
    ///
    /// > Specifies the size of the character buffer for storing the returned information
    /// > log.
    ///
    /// `length`
    ///
    /// > Returns the length of the string returned in `infoLog` (excluding the null
    /// > terminator).
    ///
    /// `infoLog`
    ///
    /// > Specifies an array of characters that is used to return the information
    /// > log.
    ///
    /// ### Description
    /// [**glGetProgramInfoLog**](crate::context::Context::oxidegl_get_program_info_log)
    /// returns the information log for the specified program object. The information
    /// log for a program object is modified when the program object is linked
    /// or validated. The string that is returned will be null terminated.
    ///
    /// [**glGetProgramInfoLog**](crate::context::Context::oxidegl_get_program_info_log)
    /// returns in `infoLog` as much of the information log as it can, up to a
    /// maximum of `maxLength` characters. The number of characters actually returned,
    /// excluding the null termination character, is specified by `length`. If
    /// the length of the returned string is not required, a value of [`NULL`](crate::enums::NULL)
    /// can be passed in the `length` argument. The size of the buffer required
    /// to store the returned information log can be obtained by calling [**glGetProgram**](crate::context::Context::oxidegl_get_program)
    /// with the value [`GL_INFO_LOG_LENGTH`](crate::enums::GL_INFO_LOG_LENGTH).
    ///
    /// The information log for a program object is either an empty string, or
    /// a string containing information about the last link operation, or a string
    /// containing information about the last validation operation. It may contain
    /// diagnostic messages, warning messages, and other information. When a program
    /// object is created, its information log will be a string of length 0.
    ///
    /// ### Notes
    /// The information log for a program object is the OpenGL implementer's primary
    /// mechanism for conveying information about linking and validating. Therefore,
    /// the information log can be helpful to application developers during the
    /// development process, even when these operations are successful. Application
    /// developers should not expect different OpenGL implementations to produce
    /// identical information logs.
    ///
    /// ### Associated Gets
    /// [**glGetProgram**](crate::context::Context::oxidegl_get_program) with argument
    /// [`GL_INFO_LOG_LENGTH`](crate::enums::GL_INFO_LOG_LENGTH)
    ///
    /// [**glIsProgram**](crate::context::Context::oxidegl_is_program)

    pub unsafe fn oxidegl_get_program_info_log(
        &mut self,
        program: GLuint,
        buf_size: GLsizei,
        length: *mut GLsizei,
        info_log: *mut GLchar,
    ) {
        panic!("command oxidegl_get_program_info_log not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > The name of a program object whose interface to query.
    ///
    /// `programInterface`
    ///
    /// > A token identifying the interface within `program` to query.
    ///
    /// `pname`
    ///
    /// > The name of the parameter within `programInterface` to query.
    ///
    /// `params`
    ///
    /// > The address of a variable to retrieve the value of `pname` for the program
    /// > interface.
    ///
    /// ### Description
    /// [**glGetProgramInterfaceiv**](crate::context::Context::oxidegl_get_program_interfaceiv)
    /// queries the property of the interface identifed by `programInterface` in
    /// `program`, the property name of which is given by `pname`.
    ///
    /// `program` must be the name of an existing program object. `programInterface`
    /// is the name of the interface within `program` to query and must be one
    /// of the following values:
    ///
    /// [`GL_UNIFORM`](crate::enums::GL_UNIFORM)
    ///
    /// > The query is targeted at the set of active uniforms within `program`.
    ///
    /// [`GL_UNIFORM_BLOCK`](crate::enums::GL_UNIFORM_BLOCK)
    ///
    /// > The query is targeted at the set of active uniform blocks within `program`.
    ///
    /// [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER)
    ///
    /// > The query is targeted at the set of active atomic counter buffer binding
    /// > points within `program`.
    ///
    /// [`GL_PROGRAM_INPUT`](crate::enums::GL_PROGRAM_INPUT)
    ///
    /// > The query is targeted at the set of active input variables used by the
    /// > first shader stage of `program`. If `program` contains multiple shader
    /// > stages then input variables from any stage other than the first will not
    /// > be enumerated.
    ///
    /// [`GL_PROGRAM_OUTPUT`](crate::enums::GL_PROGRAM_OUTPUT)
    ///
    /// > The query is targeted at the set of active output variables produced by
    /// > the last shader stage of `program`. If `program` contains multiple shader
    /// > stages then output variables from any stage other than the last will not
    /// > be enumerated.
    ///
    /// [`GL_VERTEX_SUBROUTINE`](crate::enums::GL_VERTEX_SUBROUTINE)
    ///
    /// [`GL_TESS_CONTROL_SUBROUTINE`](crate::enums::GL_TESS_CONTROL_SUBROUTINE)
    ///
    /// [`GL_TESS_EVALUATION_SUBROUTINE`](crate::enums::GL_TESS_EVALUATION_SUBROUTINE)
    ///
    /// [`GL_GEOMETRY_SUBROUTINE`](crate::enums::GL_GEOMETRY_SUBROUTINE)
    ///
    /// [`GL_FRAGMENT_SUBROUTINE`](crate::enums::GL_FRAGMENT_SUBROUTINE)
    ///
    /// [`GL_COMPUTE_SUBROUTINE`](crate::enums::GL_COMPUTE_SUBROUTINE)
    ///
    /// > The query is targeted at the set of active subroutines for the vertex,
    /// > tessellation control, tessellation evaluation, geometry, fragment and compute
    /// > shader stages of `program`, respectively.
    ///
    /// [`GL_VERTEX_SUBROUTINE_UNIFORM`](crate::enums::GL_VERTEX_SUBROUTINE_UNIFORM)
    ///
    /// [`GL_TESS_CONTROL_SUBROUTINE_UNIFORM`](crate::enums::GL_TESS_CONTROL_SUBROUTINE_UNIFORM)
    ///
    /// [`GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`](crate::enums::GL_TESS_EVALUATION_SUBROUTINE_UNIFORM)
    ///
    /// [`GL_GEOMETRY_SUBROUTINE_UNIFORM`](crate::enums::GL_GEOMETRY_SUBROUTINE_UNIFORM)
    ///
    /// [`GL_FRAGMENT_SUBROUTINE_UNIFORM`](crate::enums::GL_FRAGMENT_SUBROUTINE_UNIFORM)
    ///
    /// [`GL_COMPUTE_SUBROUTINE_UNIFORM`](crate::enums::GL_COMPUTE_SUBROUTINE_UNIFORM)
    ///
    /// > The query is targeted at the set of active subroutine uniform variables
    /// > used by the vertex, tessellation control, tessellation evaluation, geometry,
    /// > fragment and compute shader stages of `program`, respectively.
    ///
    /// [`GL_TRANSFORM_FEEDBACK_VARYING`](crate::enums::GL_TRANSFORM_FEEDBACK_VARYING)
    ///
    /// > The query is targeted at the set of output variables from the last non-fragment
    /// > stage of `program` that would be captured if transform feedback were active.
    ///
    /// [`GL_BUFFER_VARIABLE`](crate::enums::GL_BUFFER_VARIABLE)
    ///
    /// > The query is targeted at the set of active buffer variables used by `program`.
    ///
    /// [`GL_SHADER_STORAGE_BLOCK`](crate::enums::GL_SHADER_STORAGE_BLOCK)
    ///
    /// > The query is targeted at the set of active shader storage blocks used by
    /// > `program`.
    ///
    /// [`GL_TRANSFORM_FEEDBACK_BUFFER`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER)
    ///
    /// > The query is targeted at the set of active buffer binding points to which
    /// > output variables in the [`GL_TRANSFORM_FEEDBACK_VARYING`](crate::enums::GL_TRANSFORM_FEEDBACK_VARYING)
    /// > interface are written.
    ///
    /// `pname` identifies the property of `programInterface` to return in `params`.
    ///
    /// If `pname` is [`GL_ACTIVE_RESOURCES`](crate::enums::GL_ACTIVE_RESOURCES),
    /// the value returned is the number of resources in the active resource list
    /// for `programInterface`. If the list of active resources for `programInterface`
    /// is empty, zero is returned.
    ///
    /// If `pname` is [`GL_MAX_NAME_LENGTH`](crate::enums::GL_MAX_NAME_LENGTH),
    /// the value returned is the length of the longest active name string for
    /// an active resource in `programInterface`. This length includes an extra
    /// character for the null terminator. If the list of active resources for
    /// `programInterface` is empty, zero is returned. It is an error to specify
    /// [`GL_MAX_NAME_LENGTH`](crate::enums::GL_MAX_NAME_LENGTH) when `programInterface`
    /// is [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER),
    /// as active atomic counter buffer resources are not assigned name strings.
    ///
    /// If `pname` is [`GL_MAX_NUM_ACTIVE_VARIABLES`](crate::enums::GL_MAX_NUM_ACTIVE_VARIABLES),
    /// the value returned is the number of active variables belonging to the
    /// interface block or atomic counter buffer resource in `programInterface`
    /// with the most active variables. If the list of active resources for `programInterface`
    /// is empty, zero is returned. When `pname` is [`GL_MAX_NUM_ACTIVE_VARIABLES`](crate::enums::GL_MAX_NUM_ACTIVE_VARIABLES),
    /// `programInterface` must be [`GL_UNIFORM_BLOCK`](crate::enums::GL_UNIFORM_BLOCK),
    /// [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER), or
    /// [`GL_SHADER_STORAGE_BLOCK`](crate::enums::GL_SHADER_STORAGE_BLOCK).
    ///
    /// If `pname` is [`GL_MAX_NUM_COMPATIBLE_SUBROUTINES`](crate::enums::GL_MAX_NUM_COMPATIBLE_SUBROUTINES),
    /// the value returned is the number of compatible subroutines belonging to
    /// the active subroutine uniform in `programInterface` with the most compatible
    /// subroutines. If the list of active resources for `programInterface` is
    /// empty, zero is returned. When `pname` is [`GL_MAX_NUM_COMPATIBLE_SUBROUTINES`](crate::enums::GL_MAX_NUM_COMPATIBLE_SUBROUTINES),
    /// `programInterface` must be one of [`GL_VERTEX_SUBROUTINE_UNIFORM`](crate::enums::GL_VERTEX_SUBROUTINE_UNIFORM),
    /// [`GL_TESS_CONTROL_SUBROUTINE_UNIFORM`](crate::enums::GL_TESS_CONTROL_SUBROUTINE_UNIFORM),
    /// [`GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`](crate::enums::GL_TESS_EVALUATION_SUBROUTINE_UNIFORM),
    /// [`GL_GEOMETRY_SUBROUTINE_UNIFORM`](crate::enums::GL_GEOMETRY_SUBROUTINE_UNIFORM),
    /// [`GL_FRAGMENT_SUBROUTINE_UNIFORM`](crate::enums::GL_FRAGMENT_SUBROUTINE_UNIFORM),
    /// or [`GL_COMPUTE_SUBROUTINE_UNIFORM`](crate::enums::GL_COMPUTE_SUBROUTINE_UNIFORM).
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_LABEL_LENGTH`](crate::enums::GL_MAX_LABEL_LENGTH).

    pub unsafe fn oxidegl_get_program_interfaceiv(
        &mut self,
        program: GLuint,
        program_interface: ProgramInterface,
        pname: ProgramInterfacePName,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_program_interfaceiv not yet implemented");
    }
    /// ### Parameters
    /// `pipeline`
    ///
    /// > Specifies the name of a program pipeline object whose parameter retrieve.
    ///
    /// `pname`
    ///
    /// > Specifies the name of the parameter to retrieve.
    ///
    /// `params`
    ///
    /// > Specifies the address of a variable into which will be written the value
    /// > or values of `pname` for `pipeline`.
    ///
    /// ### Description
    /// [**glGetProgramPipelineiv**](crate::context::Context::oxidegl_get_program_pipelineiv)
    /// retrieves the value of a property of the program pipeline object `pipeline`.
    /// `pname` specifies the name of the parameter whose value to retrieve. The
    /// value of the parameter is written to the variable whose address is given
    /// by `params`.
    ///
    /// If `pname` is [`GL_ACTIVE_PROGRAM`](crate::enums::GL_ACTIVE_PROGRAM), the
    /// name of the active program object of the program pipeline object is returned
    /// in `params`.
    ///
    /// If `pname` is [`GL_VERTEX_SHADER`](crate::enums::GL_VERTEX_SHADER), the
    /// name of the current program object for the vertex shader type of the program
    /// pipeline object is returned in `params`.
    ///
    /// If `pname` is [`GL_TESS_CONTROL_SHADER`](crate::enums::GL_TESS_CONTROL_SHADER),
    /// the name of the current program object for the tessellation control shader
    /// type of the program pipeline object is returned in `params`.
    ///
    /// If `pname` is [`GL_TESS_EVALUATION_SHADER`](crate::enums::GL_TESS_EVALUATION_SHADER),
    /// the name of the current program object for the tessellation evaluation
    /// shader type of the program pipeline object is returned in `params`.
    ///
    /// If `pname` is [`GL_GEOMETRY_SHADER`](crate::enums::GL_GEOMETRY_SHADER),
    /// the name of the current program object for the geometry shader type of
    /// the program pipeline object is returned in `params`.
    ///
    /// If `pname` is [`GL_FRAGMENT_SHADER`](crate::enums::GL_FRAGMENT_SHADER),
    /// the name of the current program object for the fragment shader type of
    /// the program pipeline object is returned in `params`.
    ///
    /// If `pname` is [`GL_INFO_LOG_LENGTH`](crate::enums::GL_INFO_LOG_LENGTH),
    /// the length of the info log, including the null terminator, is returned
    /// in `params`. If there is no info log, zero is returned.

    pub unsafe fn oxidegl_get_program_pipelineiv(
        &mut self,
        pipeline: GLuint,
        pname: PipelineParameterName,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_program_pipelineiv not yet implemented");
    }
    /// ### Parameters
    /// `pipeline`
    ///
    /// > Specifies the name of a program pipeline object from which to retrieve
    /// > the info log.
    ///
    /// `bufSize`
    ///
    /// > Specifies the maximum number of characters, including the null terminator,
    /// > that may be written into `infoLog`.
    ///
    /// `length`
    ///
    /// > Specifies the address of a variable into which will be written the number
    /// > of characters written into `infoLog`.
    ///
    /// `infoLog`
    ///
    /// > Specifies the address of an array of characters into which will be written
    /// > the info log for `pipeline`.
    ///
    /// ### Description
    /// [**glGetProgramPipelineInfoLog**](crate::context::Context::oxidegl_get_program_pipeline_info_log)
    /// retrieves the info log for the program pipeline object `pipeline`. The
    /// info log, including its null terminator, is written into the array of characters
    /// whose address is given by `infoLog`. The maximum number of characters that
    /// may be written into `infoLog` is given by `bufSize`, and the actual number
    /// of characters written into `infoLog` is returned in the integer whose address
    /// is given by `length`. If `length` is [`NULL`](crate::enums::NULL), no length
    /// is returned.
    ///
    /// The actual length of the info log for the program pipeline may be determined
    /// by calling [**glGetProgramPipeline**](crate::context::Context::oxidegl_get_program_pipeline)
    /// with `pname` set to [`GL_INFO_LOG_LENGTH`](crate::enums::GL_INFO_LOG_LENGTH).
    ///
    /// ### Associated Gets
    /// [**glGetProgramPipeline**](crate::context::Context::oxidegl_get_program_pipeline)
    /// with parameter [`GL_INFO_LOG_LENGTH`](crate::enums::GL_INFO_LOG_LENGTH).

    pub unsafe fn oxidegl_get_program_pipeline_info_log(
        &mut self,
        pipeline: GLuint,
        buf_size: GLsizei,
        length: *mut GLsizei,
        info_log: *mut GLchar,
    ) {
        panic!("command oxidegl_get_program_pipeline_info_log not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > The name of a program object whose resources to query.
    ///
    /// `programInterface`
    ///
    /// > A token identifying the interface within `program` containing the resource
    /// > named `name`.
    ///
    /// ### Description
    /// [**glGetProgramResourceiv**](crate::context::Context::oxidegl_get_program_resourceiv)
    /// returns values for multiple properties of a single active resource with
    /// an index of `index` in the interface `programInterface` of program object
    /// `program`. For each resource, values for `propCount` properties specified
    /// by the array `props` are returned. `propCount` may not be zero. An error
    /// is generated if any value in `props` is not one of the properties described
    /// immediately belowor if any value in `props` is not allowed for `programInterface`.
    /// The set of allowed `programInterface` values for each property can be
    /// found in the following table:
    ///
    /// | Property      | Supported Interfaces                              |
    /// |---------------|---------------------------------------------------|
    /// | [`GL_NAME_LENGTH`](crate::enums::GL_NAME_LENGTH) | Any except [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER) and [`GL_TRANSFORM_FEEDBACK_BUFFER`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER) |
    /// | [`GL_TYPE`](crate::enums::GL_TYPE) | [`GL_UNIFORM`](crate::enums::GL_UNIFORM), [`GL_PROGRAM_INPUT`](crate::enums::GL_PROGRAM_INPUT), [`GL_PROGRAM_OUTPUT`](crate::enums::GL_PROGRAM_OUTPUT), [`GL_TRANSFORM_FEEDBACK_VARYING`](crate::enums::GL_TRANSFORM_FEEDBACK_VARYING), [`GL_BUFFER_VARIABLE`](crate::enums::GL_BUFFER_VARIABLE) |
    /// | [`GL_ARRAY_SIZE`](crate::enums::GL_ARRAY_SIZE) | [`GL_UNIFORM`](crate::enums::GL_UNIFORM), [`GL_BUFFER_VARIABLE`](crate::enums::GL_BUFFER_VARIABLE), [`GL_PROGRAM_INPUT`](crate::enums::GL_PROGRAM_INPUT), [`GL_PROGRAM_OUTPUT, VERTEX_SUBROUTINE_UNIFORM`](`crate::enums::GL_PROGRAM_OUTPUT`, `VERTEX_SUBROUTINE_UNIFORM`), [`GL_TESS_CONTROL_SUBROUTINE_UNIFORM`](crate::enums::GL_TESS_CONTROL_SUBROUTINE_UNIFORM), [`GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`](crate::enums::GL_TESS_EVALUATION_SUBROUTINE_UNIFORM), [`GL_GEOMETRY_SUBROUTINE_UNIFORM`](crate::enums::GL_GEOMETRY_SUBROUTINE_UNIFORM), [`GL_FRAGMENT_SUBROUTINE_UNIFORM`](crate::enums::GL_FRAGMENT_SUBROUTINE_UNIFORM), [`GL_COMPUTE_SUBROUTINE_UNIFORM`](crate::enums::GL_COMPUTE_SUBROUTINE_UNIFORM), [`GL_TRANSFORM_FEEDBACK_VARYING`](crate::enums::GL_TRANSFORM_FEEDBACK_VARYING) |
    /// | [`GL_OFFSET`](crate::enums::GL_OFFSET) | [`GL_UNIFORM`](crate::enums::GL_UNIFORM), [`GL_BUFFER_VARIABLE`](crate::enums::GL_BUFFER_VARIABLE), [`GL_TRANSFORM_FEEDBACK_VARYING`](crate::enums::GL_TRANSFORM_FEEDBACK_VARYING) |
    /// | [`GL_BLOCK_INDEX`](crate::enums::GL_BLOCK_INDEX) | [`GL_UNIFORM`](crate::enums::GL_UNIFORM), [`GL_BUFFER_VARIABLE`](crate::enums::GL_BUFFER_VARIABLE) |
    /// | [`GL_ARRAY_STRIDE`](crate::enums::GL_ARRAY_STRIDE) | [`GL_UNIFORM`](crate::enums::GL_UNIFORM), [`GL_BUFFER_VARIABLE`](crate::enums::GL_BUFFER_VARIABLE) |
    /// | [`GL_MATRIX_STRIDE`](crate::enums::GL_MATRIX_STRIDE) | [`GL_UNIFORM`](crate::enums::GL_UNIFORM), [`GL_BUFFER_VARIABLE`](crate::enums::GL_BUFFER_VARIABLE) |
    /// | [`GL_IS_ROW_MAJOR`](crate::enums::GL_IS_ROW_MAJOR) | [`GL_UNIFORM`](crate::enums::GL_UNIFORM), [`GL_BUFFER_VARIABLE`](crate::enums::GL_BUFFER_VARIABLE) |
    /// | [`GL_ATOMIC_COUNTER_BUFFER_INDEX`](crate::enums::GL_ATOMIC_COUNTER_BUFFER_INDEX) | [`GL_UNIFORM`](crate::enums::GL_UNIFORM) |
    /// | [`GL_TEXTURE_BUFFER`](crate::enums::GL_TEXTURE_BUFFER) | *none*   |
    /// | [`GL_BUFFER_BINDING`](crate::enums::GL_BUFFER_BINDING) | [`GL_UNIFORM_BLOCK`](crate::enums::GL_UNIFORM_BLOCK), [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER), [`GL_SHADER_STORAGE_BLOCK`](crate::enums::GL_SHADER_STORAGE_BLOCK), [`GL_TRANSFORM_FEEDBACK_BUFFER`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER) |
    /// | [`GL_BUFFER_DATA_SIZE`](crate::enums::GL_BUFFER_DATA_SIZE) | [`GL_UNIFORM_BLOCK`](crate::enums::GL_UNIFORM_BLOCK), [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER), [`GL_SHADER_STORAGE_BLOCK`](crate::enums::GL_SHADER_STORAGE_BLOCK) |
    /// | [`GL_NUM_ACTIVE_VARIABLES`](crate::enums::GL_NUM_ACTIVE_VARIABLES) | [`GL_UNIFORM_BLOCK`](crate::enums::GL_UNIFORM_BLOCK), [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER), [`GL_SHADER_STORAGE_BLOCK`](crate::enums::GL_SHADER_STORAGE_BLOCK), [`GL_TRANSFORM_FEEDBACK_BUFFER`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER) |
    /// | [`GL_ACTIVE_VARIABLES`](crate::enums::GL_ACTIVE_VARIABLES) | [`GL_UNIFORM_BLOCK`](crate::enums::GL_UNIFORM_BLOCK), [`GL_ATOMIC_COUNTER_BUFFER`](crate::enums::GL_ATOMIC_COUNTER_BUFFER), [`GL_SHADER_STORAGE_BLOCK`](crate::enums::GL_SHADER_STORAGE_BLOCK), [`GL_TRANSFORM_FEEDBACK_BUFFER`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER) |
    /// | [`GL_REFERENCED_BY_VERTEX_SHADER`](crate::enums::GL_REFERENCED_BY_VERTEX_SHADER) | [`GL_UNIFORM`](crate::enums::GL_UNIFORM), [`GL_UNIFORM_BLOCK`](crate::enums::GL_UNIFORM_BLOCK), [`GL_ATOMIC_COUNTER_SHADER`](crate::enums::GL_ATOMIC_COUNTER_SHADER), [`GL_BUFFER`](crate::enums::GL_BUFFER), [`GL_SHADER_STORAGE_BLOCK`](crate::enums::GL_SHADER_STORAGE_BLOCK), [`GL_BUFFER_VARIABLE`](crate::enums::GL_BUFFER_VARIABLE), [`GL_PROGRAM_INPUT`](crate::enums::GL_PROGRAM_INPUT), [`GL_PROGRAM_OUTPUT`](crate::enums::GL_PROGRAM_OUTPUT) |
    /// | [`GL_REFERENCED_BY_TESS_CONTROL_SHADER`](crate::enums::GL_REFERENCED_BY_TESS_CONTROL_SHADER) | [`GL_UNIFORM`](crate::enums::GL_UNIFORM), [`GL_UNIFORM_BLOCK`](crate::enums::GL_UNIFORM_BLOCK), [`GL_ATOMIC_COUNTER_SHADER`](crate::enums::GL_ATOMIC_COUNTER_SHADER), [`GL_BUFFER`](crate::enums::GL_BUFFER), [`GL_SHADER_STORAGE_BLOCK`](crate::enums::GL_SHADER_STORAGE_BLOCK), [`GL_BUFFER_VARIABLE`](crate::enums::GL_BUFFER_VARIABLE), [`GL_PROGRAM_INPUT`](crate::enums::GL_PROGRAM_INPUT), [`GL_PROGRAM_OUTPUT`](crate::enums::GL_PROGRAM_OUTPUT) |
    /// | [`GL_REFERENCED_BY_TESS_EVALUATION_SHADER`](crate::enums::GL_REFERENCED_BY_TESS_EVALUATION_SHADER) | [`GL_UNIFORM`](crate::enums::GL_UNIFORM), [`GL_UNIFORM_BLOCK`](crate::enums::GL_UNIFORM_BLOCK), [`GL_ATOMIC_COUNTER_SHADER`](crate::enums::GL_ATOMIC_COUNTER_SHADER), [`GL_BUFFER`](crate::enums::GL_BUFFER), [`GL_SHADER_STORAGE_BLOCK`](crate::enums::GL_SHADER_STORAGE_BLOCK), [`GL_BUFFER_VARIABLE`](crate::enums::GL_BUFFER_VARIABLE), [`GL_PROGRAM_INPUT`](crate::enums::GL_PROGRAM_INPUT), [`GL_PROGRAM_OUTPUT`](crate::enums::GL_PROGRAM_OUTPUT) |
    /// | [`GL_REFERENCED_BY_GEOMETRY_SHADER`](crate::enums::GL_REFERENCED_BY_GEOMETRY_SHADER) | [`GL_UNIFORM`](crate::enums::GL_UNIFORM), [`GL_UNIFORM_BLOCK`](crate::enums::GL_UNIFORM_BLOCK), [`GL_ATOMIC_COUNTER_SHADER`](crate::enums::GL_ATOMIC_COUNTER_SHADER), [`GL_BUFFER`](crate::enums::GL_BUFFER), [`GL_SHADER_STORAGE_BLOCK`](crate::enums::GL_SHADER_STORAGE_BLOCK), [`GL_BUFFER_VARIABLE`](crate::enums::GL_BUFFER_VARIABLE), [`GL_PROGRAM_INPUT`](crate::enums::GL_PROGRAM_INPUT), [`GL_PROGRAM_OUTPUT`](crate::enums::GL_PROGRAM_OUTPUT) |
    /// | [`GL_REFERENCED_BY_FRAGMENT_SHADER`](crate::enums::GL_REFERENCED_BY_FRAGMENT_SHADER) | [`GL_UNIFORM`](crate::enums::GL_UNIFORM), [`GL_UNIFORM_BLOCK`](crate::enums::GL_UNIFORM_BLOCK), [`GL_ATOMIC_COUNTER_SHADER`](crate::enums::GL_ATOMIC_COUNTER_SHADER), [`GL_BUFFER`](crate::enums::GL_BUFFER), [`GL_SHADER_STORAGE_BLOCK`](crate::enums::GL_SHADER_STORAGE_BLOCK), [`GL_BUFFER_VARIABLE`](crate::enums::GL_BUFFER_VARIABLE), [`GL_PROGRAM_INPUT`](crate::enums::GL_PROGRAM_INPUT), [`GL_PROGRAM_OUTPUT`](crate::enums::GL_PROGRAM_OUTPUT) |
    /// | [`GL_REFERENCED_BY_COMPUTE_SHADER`](crate::enums::GL_REFERENCED_BY_COMPUTE_SHADER) | [`GL_UNIFORM`](crate::enums::GL_UNIFORM), [`GL_UNIFORM_BLOCK`](crate::enums::GL_UNIFORM_BLOCK), [`GL_ATOMIC_COUNTER_SHADER`](crate::enums::GL_ATOMIC_COUNTER_SHADER), [`GL_BUFFER`](crate::enums::GL_BUFFER), [`GL_SHADER_STORAGE_BLOCK`](crate::enums::GL_SHADER_STORAGE_BLOCK), [`GL_BUFFER_VARIABLE`](crate::enums::GL_BUFFER_VARIABLE), [`GL_PROGRAM_INPUT`](crate::enums::GL_PROGRAM_INPUT), [`GL_PROGRAM_OUTPUT`](crate::enums::GL_PROGRAM_OUTPUT) |
    /// | [`GL_NUM_COMPATIBLE_SUBROUTINES`](crate::enums::GL_NUM_COMPATIBLE_SUBROUTINES) | [`GL_VERTEX_SUBROUTINE_UNIFORM`](crate::enums::GL_VERTEX_SUBROUTINE_UNIFORM), [`GL_TESS_CONTROL_SUBROUTINE_UNIFORM`](crate::enums::GL_TESS_CONTROL_SUBROUTINE_UNIFORM), [`GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`](crate::enums::GL_TESS_EVALUATION_SUBROUTINE_UNIFORM), [`GL_GEOMETRY_SUBROUTINE_UNIFORM`](crate::enums::GL_GEOMETRY_SUBROUTINE_UNIFORM), [`GL_FRAGMENT_SUBROUTINE_UNIFORM`](crate::enums::GL_FRAGMENT_SUBROUTINE_UNIFORM), [`GL_COMPUTE_SUBROUTINE_UNIFORM`](crate::enums::GL_COMPUTE_SUBROUTINE_UNIFORM) |
    /// | [`GL_COMPATIBLE_SUBROUTINES`](crate::enums::GL_COMPATIBLE_SUBROUTINES) | [`GL_VERTEX_SUBROUTINE_UNIFORM`](crate::enums::GL_VERTEX_SUBROUTINE_UNIFORM), [`GL_TESS_CONTROL_SUBROUTINE_UNIFORM`](crate::enums::GL_TESS_CONTROL_SUBROUTINE_UNIFORM), [`GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`](crate::enums::GL_TESS_EVALUATION_SUBROUTINE_UNIFORM), [`GL_GEOMETRY_SUBROUTINE_UNIFORM`](crate::enums::GL_GEOMETRY_SUBROUTINE_UNIFORM), [`GL_FRAGMENT_SUBROUTINE_UNIFORM`](crate::enums::GL_FRAGMENT_SUBROUTINE_UNIFORM), [`GL_COMPUTE_SUBROUTINE_UNIFORM`](crate::enums::GL_COMPUTE_SUBROUTINE_UNIFORM) |
    /// | [`GL_TOP_LEVEL_ARRAY_SIZE`](crate::enums::GL_TOP_LEVEL_ARRAY_SIZE) | [`GL_BUFFER_VARIABLE`](crate::enums::GL_BUFFER_VARIABLE) |
    /// | [`GL_TOP_LEVEL_ARRAY_STRIDE`](crate::enums::GL_TOP_LEVEL_ARRAY_STRIDE) | [`GL_BUFFER_VARIABLE`](crate::enums::GL_BUFFER_VARIABLE) |
    /// | [`GL_LOCATION`](crate::enums::GL_LOCATION) | [`GL_UNIFORM`](crate::enums::GL_UNIFORM), [`GL_PROGRAM_INPUT`](crate::enums::GL_PROGRAM_INPUT), [`GL_PROGRAM_OUTPUT`](crate::enums::GL_PROGRAM_OUTPUT), [`GL_VERTEX_SUBROUTINE_UNIFORM`](crate::enums::GL_VERTEX_SUBROUTINE_UNIFORM), [`GL_TESS_CONTROL_SUBROUTINE_UNIFORM`](crate::enums::GL_TESS_CONTROL_SUBROUTINE_UNIFORM), [`GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`](crate::enums::GL_TESS_EVALUATION_SUBROUTINE_UNIFORM), [`GL_GEOMETRY_SUBROUTINE_UNIFORM`](crate::enums::GL_GEOMETRY_SUBROUTINE_UNIFORM), [`GL_FRAGMENT_SUBROUTINE_UNIFORM`](crate::enums::GL_FRAGMENT_SUBROUTINE_UNIFORM), [`GL_COMPUTE_SUBROUTINE_UNIFORM`](crate::enums::GL_COMPUTE_SUBROUTINE_UNIFORM) |
    /// | [`GL_LOCATION_INDEX`](crate::enums::GL_LOCATION_INDEX) | [`GL_PROGRAM_OUTPUT`](crate::enums::GL_PROGRAM_OUTPUT) |
    /// | [`GL_IS_PER_PATCH`](crate::enums::GL_IS_PER_PATCH) | [`GL_PROGRAM_INPUT`](crate::enums::GL_PROGRAM_INPUT), [`GL_PROGRAM_OUTPUT`](crate::enums::GL_PROGRAM_OUTPUT) |
    /// | [`GL_LOCATION_COMPONENT`](crate::enums::GL_LOCATION_COMPONENT) | [`GL_PROGRAM_INPUT`](crate::enums::GL_PROGRAM_INPUT), [`GL_PROGRAM_OUTPUT`](crate::enums::GL_PROGRAM_OUTPUT) |
    /// | [`GL_TRANSFORM_FEEDBACK_BUFFER_INDEX`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER_INDEX) | [`GL_TRANSFORM_FEEDBACK_VARYING`](crate::enums::GL_TRANSFORM_FEEDBACK_VARYING) |
    /// | [`GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE) | [`GL_TRANSFORM_FEEDBACK_BUFFER`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER) |
    ///
    /// For the property [`GL_NAME_LENGTH`](crate::enums::GL_NAME_LENGTH), a single
    /// integer identifying the length of the name string associated with an active
    /// variable, interface block, or subroutine is written to `params`. The name
    /// length includes a terminating null character.
    ///
    /// For the property [`GL_TYPE`](crate::enums::GL_TYPE), a single integer identifying
    /// the type of an active variable is written to `params`. The integer returned
    /// is one of the values found in table 2.16.
    ///
    /// For the property [`GL_ARRAY_SIZE`](crate::enums::GL_ARRAY_SIZE), a single
    /// integer identifying the number of active array elements of an active variable
    /// is written to `params`. The array size returned is in units of the type
    /// associated with the property [`GL_TYPE`](crate::enums::GL_TYPE). For active
    /// variables not corresponding to an array of basic types, the value zero
    /// is written to `params`.
    ///
    /// For the property [`GL_BLOCK_INDEX`](crate::enums::GL_BLOCK_INDEX), a single
    /// integer identifying the index of the active interface block containing
    /// an active variable is written to `params`. If the variable is not the member
    /// of an interface block, the value -1 is written to `params`.
    ///
    /// For the property [`GL_OFFSET`](crate::enums::GL_OFFSET), a single integer
    /// identifying the offset of an active variable is written to `params`. For
    /// variables in the [`GL_UNIFORM`](crate::enums::GL_UNIFORM) and [`GL_BUFFER_VARIABLE`](crate::enums::GL_BUFFER_VARIABLE)
    /// interfaces that are backed by a buffer object, the value written is the
    /// offset of that variable relative to the base of the buffer range holding
    /// its value. For variables in the [`GL_TRANSFORM_FEEDBACK_VARYING`](crate::enums::GL_TRANSFORM_FEEDBACK_VARYING)
    /// interface, the value written is the offset in the transform feedback buffer
    /// storage assigned to each vertex captured in transform feedback mode where
    /// the value of the variable will be stored. Such offsets are specified via
    /// the [**glTransformFeedbackVaryings**](crate::context::Context::oxidegl_transform_feedback_varyings).
    /// Offsets are expressed in basic machine units. For all variables not recorded
    /// in transform feedback mode, including the special names `params`.
    ///
    /// For the property [`GL_ARRAY_STRIDE`](crate::enums::GL_ARRAY_STRIDE), a
    /// single integer identifying the stride between array elements in an active
    /// variable is written to `params`. For active variables declared as an array
    /// of basic types, the value written is the difference, in basic machine units,
    /// between the offsets of consecutive elements in an array. For active variables
    /// not declared as an array of basic types, zero is written to `params`. For
    /// active variables not backed by a buffer object, -1 is written to `params`,
    /// regardless of the variable type.
    ///
    /// For the property [`GL_MATRIX_STRIDE`](crate::enums::GL_MATRIX_STRIDE), a
    /// single integer identifying the stride between columns of a column-major
    /// matrix or rows of a row-major matrix is written to `params`. For active
    /// variables declared a single matrix or array of matrices, the value written
    /// is the difference, in basic machine units, between the offsets of consecutive
    /// columns or rows in each matrix. For active variables not declared as a
    /// matrix or array of matrices, zero is written to `params`. For active variables
    /// not backed by a buffer object, -1 is written to `params`, regardless of
    /// the variable type.
    ///
    /// For the property [`GL_IS_ROW_MAJOR`](crate::enums::GL_IS_ROW_MAJOR), a
    /// single integer identifying whether an active variable is a row-major matrix
    /// is written to `params`. For active variables backed by a buffer object,
    /// declared as a single matrix or array of matrices, and stored in row-major
    /// order, one is written to `params`. For all other active variables, zero
    /// is written to `params`.
    ///
    /// For the property [`GL_ATOMIC_COUNTER_BUFFER_INDEX`](crate::enums::GL_ATOMIC_COUNTER_BUFFER_INDEX),
    /// a single integer identifying the index of the active atomic counter buffer
    /// containing an active variable is written to `params`. If the variable is
    /// not an atomic counter uniform, the value -1 is written to `params`.
    ///
    /// For the property [`GL_BUFFER_BINDING`](crate::enums::GL_BUFFER_BINDING),
    /// to index of the buffer binding point associated with the active uniform
    /// block, shader storage block, atomic counter buffer or transform feedback
    /// buffer is written to `params`.
    ///
    /// For the property [`GL_BUFFER_DATA_SIZE`](crate::enums::GL_BUFFER_DATA_SIZE),
    /// then the implementation-dependent minimum total buffer object size, in
    /// basic machine units, required to hold all active variables associated with
    /// an active uniform block, shader storage block, or atomic counter buffer
    /// is written to `params`. If the final member of an active shader storage
    /// block is array with no declared size, the minimum buffer size is computed
    /// assuming the array was declared as an array with one element.
    ///
    /// For the property [`GL_NUM_ACTIVE_VARIABLES`](crate::enums::GL_NUM_ACTIVE_VARIABLES),
    /// the number of active variables associated with an active uniform block,
    /// shader storage block, atomic counter buffer or transform feedback buffer
    /// is written to `params`.
    ///
    /// For the property [`GL_ACTIVE_VARIABLES`](crate::enums::GL_ACTIVE_VARIABLES),
    /// an array of active variable indices associated with an active uniform
    /// block, shader storage block, atomic counter buffer or transform feedback
    /// buffer is written to `params`. The number of values written to `params`
    /// for an active resource is given by the value of the property [`GL_NUM_ACTIVE_VARIABLES`](crate::enums::GL_NUM_ACTIVE_VARIABLES)
    /// for the resource.
    ///
    /// For the properties [`GL_REFERENCED_BY_VERTEX_SHADER`](crate::enums::GL_REFERENCED_BY_VERTEX_SHADER),
    /// [`GL_REFERENCED_BY_TESS_CONTROL_SHADER`](crate::enums::GL_REFERENCED_BY_TESS_CONTROL_SHADER),
    /// [`GL_REFERENCED_BY_TESS_EVALUATION_SHADER`](crate::enums::GL_REFERENCED_BY_TESS_EVALUATION_SHADER),
    /// [`GL_REFERENCED_BY_GEOMETRY_SHADER`](crate::enums::GL_REFERENCED_BY_GEOMETRY_SHADER),
    /// [`GL_REFERENCED_BY_FRAGMENT_SHADER`](crate::enums::GL_REFERENCED_BY_FRAGMENT_SHADER),
    /// and [`GL_REFERENCED_BY_COMPUTE_SHADER`](crate::enums::GL_REFERENCED_BY_COMPUTE_SHADER),
    /// a single integer is written to `params`, identifying whether the active
    /// resource is referenced by the vertex, tessellation control, tessellation
    /// evaluation, geometry, or fragment shaders, respectively, in the program
    /// object. The value one is written to `params` if an active variable is referenced
    /// by the corresponding shader, or if an active uniform block, shader storage
    /// block, or atomic counter buffer contains at least one variable referenced
    /// by the corresponding shader. Otherwise, the value zero is written to `params`.
    ///
    /// For the property [`GL_TOP_LEVEL_ARRAY_SIZE`](crate::enums::GL_TOP_LEVEL_ARRAY_SIZE),
    /// a single integer identifying the number of active array elements of the
    /// top-level shader storage block member containing to the active variable
    /// is written to `params`. If the top-level block member is not declared as
    /// an array, the value one is written to `params`. If the top-level block
    /// member is an array with no declared size, the value zero is written to
    /// `params`.
    ///
    /// For the property [`GL_TOP_LEVEL_ARRAY_STRIDE`](crate::enums::GL_TOP_LEVEL_ARRAY_STRIDE),
    /// a single integer identifying the stride between array elements of the
    /// top-level shader storage block member containing the active variable is
    /// written to `params`. For top-level block members declared as arrays, the
    /// value written is the difference, in basic machine units, between the offsets
    /// of the active variable for consecutive elements in the top-level array.
    /// For top-level block members not declared as an array, zero is written to
    /// `params`.
    ///
    /// For the property [`GL_LOCATION`](crate::enums::GL_LOCATION), a single integer
    /// identifying the assigned location for an active uniform, input, output,
    /// or subroutine uniform variable is written to `params`. For input, output,
    /// or uniform variables with locations specified by a layout qualifier, the
    /// specified location is used. For vertex shader input or fragment shader
    /// output variables without a layout qualifier, the location assigned when
    /// a program is linked is written to `params`. For all other input and output
    /// variables, the value -1 is written to `params`. For uniforms in uniform
    /// blocks, the value -1 is written to `params`.
    ///
    /// For the property [`GL_LOCATION_INDEX`](crate::enums::GL_LOCATION_INDEX),
    /// a single integer identifying the fragment color index of an active fragment
    /// shader output variable is written to `params`. If the active variable is
    /// an output for a non-fragment shader, the value -1 will be written to `params`.
    ///
    /// For the property [`GL_IS_PER_PATCH`](crate::enums::GL_IS_PER_PATCH), a
    /// single integer identifying whether the input or output is a per-patch attribute.
    /// If the active variable is a per-patch attribute (declared with the `params`;
    /// otherwise, the value zero is written to `params`.
    ///
    /// For the property [`GL_LOCATION_COMPONENT`](crate::enums::GL_LOCATION_COMPONENT),
    /// a single integer indicating the first component of the location assigned
    /// to an active input or output variable is written to `params`. For input
    /// and output variables with a component specified by a
    ///
    /// For the property [`GL_TRANSFORM_FEEDBACK_BUFFER_INDEX`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER_INDEX),
    /// a single integer identifying the index of the active transform feedback
    /// buffer associated with an active variable is written to `params`. For variables
    /// corresponding to the special names `params`.
    ///
    /// For the property [`GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE),
    /// a single integer identifying the stride, in basic machine units, between
    /// consecutive vertices written to the transform feedback buffer is written
    /// to `params`.

    pub unsafe fn oxidegl_get_program_resourceiv(
        &mut self,
        program: GLuint,
        program_interface: ProgramInterface,
        index: GLuint,
        prop_count: GLsizei,
        props: ProgramResourceProperty,
        count: GLsizei,
        length: *mut GLsizei,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_program_resourceiv not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > The name of a program object whose resources to query.
    ///
    /// `programInterface`
    ///
    /// > A token identifying the interface within `program` containing the resource
    /// > named `name`.
    ///
    /// `name`
    ///
    /// > The name of the resource to query the index of.
    ///
    /// ### Description
    /// [**glGetProgramResourceIndex**](crate::context::Context::oxidegl_get_program_resource_index)
    /// returns the unsigned integer index assigned to a resource named `name`
    /// in the interface type `programInterface` of program object `program`.
    ///
    /// `program` must be the name of an existing program object. `programInterface`
    /// is the name of the interface within `program` which contains the resource
    /// named `name` and must be one of the following values:
    ///
    /// [`GL_UNIFORM`](crate::enums::GL_UNIFORM)
    ///
    /// > The query is targeted at the set of active uniforms within `program`.
    ///
    /// [`GL_UNIFORM_BLOCK`](crate::enums::GL_UNIFORM_BLOCK)
    ///
    /// > The query is targeted at the set of active uniform blocks within `program`.
    ///
    /// [`GL_PROGRAM_INPUT`](crate::enums::GL_PROGRAM_INPUT)
    ///
    /// > The query is targeted at the set of active input variables used by the
    /// > first shader stage of `program`. If `program` contains multiple shader
    /// > stages then input variables from any stage other than the first will not
    /// > be enumerated.
    ///
    /// [`GL_PROGRAM_OUTPUT`](crate::enums::GL_PROGRAM_OUTPUT)
    ///
    /// > The query is targeted at the set of active output variables produced by
    /// > the last shader stage of `program`. If `program` contains multiple shader
    /// > stages then output variables from any stage other than the last will not
    /// > be enumerated.
    ///
    /// [`GL_VERTEX_SUBROUTINE`](crate::enums::GL_VERTEX_SUBROUTINE)
    ///
    /// [`GL_TESS_CONTROL_SUBROUTINE`](crate::enums::GL_TESS_CONTROL_SUBROUTINE)
    ///
    /// [`GL_TESS_EVALUATION_SUBROUTINE`](crate::enums::GL_TESS_EVALUATION_SUBROUTINE)
    ///
    /// [`GL_GEOMETRY_SUBROUTINE`](crate::enums::GL_GEOMETRY_SUBROUTINE)
    ///
    /// [`GL_FRAGMENT_SUBROUTINE`](crate::enums::GL_FRAGMENT_SUBROUTINE)
    ///
    /// [`GL_COMPUTE_SUBROUTINE`](crate::enums::GL_COMPUTE_SUBROUTINE)
    ///
    /// > The query is targeted at the set of active subroutines for the vertex,
    /// > tessellation control, tessellation evaluation, geometry, fragment and compute
    /// > shader stages of `program`, respectively.
    ///
    /// [`GL_VERTEX_SUBROUTINE_UNIFORM`](crate::enums::GL_VERTEX_SUBROUTINE_UNIFORM)
    ///
    /// [`GL_TESS_CONTROL_SUBROUTINE_UNIFORM`](crate::enums::GL_TESS_CONTROL_SUBROUTINE_UNIFORM)
    ///
    /// [`GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`](crate::enums::GL_TESS_EVALUATION_SUBROUTINE_UNIFORM)
    ///
    /// [`GL_GEOMETRY_SUBROUTINE_UNIFORM`](crate::enums::GL_GEOMETRY_SUBROUTINE_UNIFORM)
    ///
    /// [`GL_FRAGMENT_SUBROUTINE_UNIFORM`](crate::enums::GL_FRAGMENT_SUBROUTINE_UNIFORM)
    ///
    /// [`GL_COMPUTE_SUBROUTINE_UNIFORM`](crate::enums::GL_COMPUTE_SUBROUTINE_UNIFORM)
    ///
    /// > The query is targeted at the set of active subroutine uniform variables
    /// > used by the vertex, tessellation control, tessellation evaluation, geometry,
    /// > fragment and compute shader stages of `program`, respectively.
    ///
    /// [`GL_TRANSFORM_FEEDBACK_VARYING`](crate::enums::GL_TRANSFORM_FEEDBACK_VARYING)
    ///
    /// > The query is targeted at the set of output variables from the last non-fragment
    /// > stage of `program` that would be captured if transform feedback were active.
    ///
    /// [`GL_TRANSFORM_FEEDBACK_BUFFER`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER)
    ///
    /// > The query is targeted at the set of active buffer binding points to which
    /// > output variables in the [`GL_TRANSFORM_FEEDBACK_VARYING`](crate::enums::GL_TRANSFORM_FEEDBACK_VARYING)
    /// > interface are written.
    ///
    /// [`GL_BUFFER_VARIABLE`](crate::enums::GL_BUFFER_VARIABLE)
    ///
    /// > The query is targeted at the set of active buffer variables used by `program`.
    ///
    /// [`GL_SHADER_STORAGE_BLOCK`](crate::enums::GL_SHADER_STORAGE_BLOCK)
    ///
    /// > The query is targeted at the set of active shader storage blocks used by
    /// > `program`.
    ///
    /// If `name` exactly matches the name string of one of the active resources
    /// for `programInterface`, the index of the matched resource is returned.
    /// Additionally, if `name` would exactly match the name string of an active
    /// resource if "\[0\]" were appended to `name`, the index of the matched resource
    /// is returned. Otherwise, `name` is considered not to be the name of an active
    /// resource, and [`GL_INVALID_INDEX`](crate::enums::GL_INVALID_INDEX) is returned.
    ///
    /// For the interface [`GL_TRANSFORM_FEEDBACK_VARYING`](crate::enums::GL_TRANSFORM_FEEDBACK_VARYING),
    /// the value [`GL_INVALID_INDEX`](crate::enums::GL_INVALID_INDEX) should
    /// be returned when querying the index assigned to the special names

    pub unsafe fn oxidegl_get_program_resource_index(
        &mut self,
        program: GLuint,
        program_interface: ProgramInterface,
        name: *const GLchar,
    ) -> GLuint {
        panic!("command oxidegl_get_program_resource_index not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > The name of a program object whose resources to query.
    ///
    /// `programInterface`
    ///
    /// > A token identifying the interface within `program` containing the resource
    /// > named `name`.
    ///
    /// `name`
    ///
    /// > The name of the resource to query the location of.
    ///
    /// ### Description
    /// [**glGetProgramResourceLocation**](crate::context::Context::oxidegl_get_program_resource_location)
    /// returns the location assigned to the variable named `name` in interface
    /// `programInterface` of program object `program`. `program` must be the name
    /// of a program that has been linked successfully. `programInterface` must
    /// be one of [`GL_UNIFORM`](crate::enums::GL_UNIFORM), [`GL_PROGRAM_INPUT`](crate::enums::GL_PROGRAM_INPUT),
    /// [`GL_PROGRAM_OUTPUT`](crate::enums::GL_PROGRAM_OUTPUT), [`GL_VERTEX_SUBROUTINE_UNIFORM`](crate::enums::GL_VERTEX_SUBROUTINE_UNIFORM),
    /// [`GL_TESS_CONTROL_SUBROUTINE_UNIFORM`](crate::enums::GL_TESS_CONTROL_SUBROUTINE_UNIFORM),
    /// [`GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`](crate::enums::GL_TESS_EVALUATION_SUBROUTINE_UNIFORM),
    /// [`GL_GEOMETRY_SUBROUTINE_UNIFORM`](crate::enums::GL_GEOMETRY_SUBROUTINE_UNIFORM),
    /// [`GL_FRAGMENT_SUBROUTINE_UNIFORM`](crate::enums::GL_FRAGMENT_SUBROUTINE_UNIFORM),
    /// [`GL_COMPUTE_SUBROUTINE_UNIFORM`](crate::enums::GL_COMPUTE_SUBROUTINE_UNIFORM),
    /// or [`GL_TRANSFORM_FEEDBACK_BUFFER`](crate::enums::GL_TRANSFORM_FEEDBACK_BUFFER).
    ///
    /// The value -1 will be returned if an error occurs, if `name` does not identify
    /// an active variable on `programInterface`, or if `name` identifies an active
    /// variable that does not have a valid location assigned, as described above.
    /// The locations returned by these commands are the same locations returned
    /// when querying the [`GL_LOCATION`](crate::enums::GL_LOCATION) and [`GL_LOCATION_INDEX`](crate::enums::GL_LOCATION_INDEX)
    /// resource properties.
    ///
    /// A string provided to [**glGetProgramResourceLocation**](crate::context::Context::oxidegl_get_program_resource_location)
    /// is considered to match an active variable if:
    ///
    /// > the string exactly matches the name of the active variable
    ///
    /// > if the string identifies the base name of an active array, where the string
    /// > would exactly match the name of the variable if the suffix "\[0\]" were
    /// > appended to the string
    ///
    /// > if the string identifies an active element of the array, where the string
    /// > ends with the concatenation of the "\[" character, an integer *with no
    /// > "+" sign, extra leading zeroes, or whitespace* identifying an array element,
    /// > and the "\]" character, the integer is less than the number of active elements
    /// > of the array variable, and where the string would exactly match the enumerated
    /// > name of the array if the decimal integer were replaced with zero.
    ///
    /// Any other string is considered not to identify an active variable. If the
    /// string specifies an element of an array variable, [**glGetProgramResourceLocation**](crate::context::Context::oxidegl_get_program_resource_location)
    /// returns the location assigned to that element. If it specifies the base
    /// name of an array, it identifies the resources associated with the first
    /// element of the array.

    pub unsafe fn oxidegl_get_program_resource_location(
        &mut self,
        program: GLuint,
        program_interface: ProgramInterface,
        name: *const GLchar,
    ) -> GLint {
        panic!("command oxidegl_get_program_resource_location not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > The name of a program object whose resources to query.
    ///
    /// `programInterface`
    ///
    /// > A token identifying the interface within `program` containing the resource
    /// > named `name`.
    ///
    /// `name`
    ///
    /// > The name of the resource to query the location of.
    ///
    /// ### Description
    /// [**glGetProgramResourceLocationIndex**](crate::context::Context::oxidegl_get_program_resource_location_index)
    /// returns the fragment color index assigned to the variable named `name`
    /// in interface `programInterface` of program object `program`. `program`
    /// must be the name of a program that has been linked successfully. `programInterface`
    /// must be [`GL_PROGRAM_OUTPUT`](crate::enums::GL_PROGRAM_OUTPUT).
    ///
    /// The value -1 will be returned if an error occurs, if `name` does not identify
    /// an active variable on `programInterface`, or if `name` identifies an active
    /// variable that does not have a valid location assigned, as described above.
    /// The locations returned by these commands are the same locations returned
    /// when querying the [`GL_LOCATION`](crate::enums::GL_LOCATION) and [`GL_LOCATION_INDEX`](crate::enums::GL_LOCATION_INDEX)
    /// resource properties.
    ///
    /// A string provided to [**glGetProgramResourceLocationIndex**](crate::context::Context::oxidegl_get_program_resource_location_index)
    /// is considered to match an active variable if:
    ///
    /// > the string exactly matches the name of the active variable
    ///
    /// > if the string identifies the base name of an active array, where the string
    /// > would exactly match the name of the variable if the suffix "\[0\]" were
    /// > appended to the string
    ///
    /// > if the string identifies an active element of the array, where the string
    /// > ends with the concatenation of the "\[" character, an integer *with no
    /// > "+" sign, extra leading zeroes, or whitespace* identifying an array element,
    /// > and the "\]" character, the integer is less than the number of active elements
    /// > of the array variable, and where the string would exactly match the enumerated
    /// > name of the array if the decimal integer were replaced with zero.
    ///
    /// Any other string is considered not to identify an active variable. If the
    /// string specifies an element of an array variable, [**glGetProgramResourceLocation**](crate::context::Context::oxidegl_get_program_resource_location)
    /// returns the location assigned to that element. If it specifies the base
    /// name of an array, it identifies the resources associated with the first
    /// element of the array.

    pub unsafe fn oxidegl_get_program_resource_location_index(
        &mut self,
        program: GLuint,
        program_interface: ProgramInterface,
        name: *const GLchar,
    ) -> GLint {
        panic!("command oxidegl_get_program_resource_location_index not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > The name of a program object whose resources to query.
    ///
    /// `programInterface`
    ///
    /// > A token identifying the interface within `program` containing the indexed
    /// > resource.
    ///
    /// `index`
    ///
    /// > The index of the resource within `programInterface` of `program`.
    ///
    /// `bufSize`
    ///
    /// > The size of the character array whose address is given by `name`.
    ///
    /// `length`
    ///
    /// > The address of a variable which will receive the length of the resource
    /// > name.
    ///
    /// `name`
    ///
    /// > The address of a character array into which will be written the name of
    /// > the resource.
    ///
    /// ### Description
    /// [**glGetProgramResourceName**](crate::context::Context::oxidegl_get_program_resource_name)
    /// retrieves the name string assigned to the single active resource with an
    /// index of `index` in the interface `programInterface` of program object
    /// `program`. `index` must be less than the number of entries in the active
    /// resource list for `programInterface`.
    ///
    /// `program` must be the name of an existing program object. `programInterface`
    /// is the name of the interface within `program` which contains the resource
    /// and must be one of the following values:
    ///
    /// [`GL_UNIFORM`](crate::enums::GL_UNIFORM)
    ///
    /// > The query is targeted at the set of active uniforms within `program`.
    ///
    /// [`GL_UNIFORM_BLOCK`](crate::enums::GL_UNIFORM_BLOCK)
    ///
    /// > The query is targeted at the set of active uniform blocks within `program`.
    ///
    /// [`GL_PROGRAM_INPUT`](crate::enums::GL_PROGRAM_INPUT)
    ///
    /// > The query is targeted at the set of active input variables used by the
    /// > first shader stage of `program`. If `program` contains multiple shader
    /// > stages then input variables from any stage other than the first will not
    /// > be enumerated.
    ///
    /// [`GL_PROGRAM_OUTPUT`](crate::enums::GL_PROGRAM_OUTPUT)
    ///
    /// > The query is targeted at the set of active output variables produced by
    /// > the last shader stage of `program`. If `program` contains multiple shader
    /// > stages then output variables from any stage other than the last will not
    /// > be enumerated.
    ///
    /// [`GL_VERTEX_SUBROUTINE`](crate::enums::GL_VERTEX_SUBROUTINE)
    ///
    /// [`GL_TESS_CONTROL_SUBROUTINE`](crate::enums::GL_TESS_CONTROL_SUBROUTINE)
    ///
    /// [`GL_TESS_EVALUATION_SUBROUTINE`](crate::enums::GL_TESS_EVALUATION_SUBROUTINE)
    ///
    /// [`GL_GEOMETRY_SUBROUTINE`](crate::enums::GL_GEOMETRY_SUBROUTINE)
    ///
    /// [`GL_FRAGMENT_SUBROUTINE`](crate::enums::GL_FRAGMENT_SUBROUTINE)
    ///
    /// [`GL_COMPUTE_SUBROUTINE`](crate::enums::GL_COMPUTE_SUBROUTINE)
    ///
    /// > The query is targeted at the set of active subroutines for the vertex,
    /// > tessellation control, tessellation evaluation, geometry, fragment and compute
    /// > shader stages of `program`, respectively.
    ///
    /// [`GL_VERTEX_SUBROUTINE_UNIFORM`](crate::enums::GL_VERTEX_SUBROUTINE_UNIFORM)
    ///
    /// [`GL_TESS_CONTROL_SUBROUTINE_UNIFORM`](crate::enums::GL_TESS_CONTROL_SUBROUTINE_UNIFORM)
    ///
    /// [`GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`](crate::enums::GL_TESS_EVALUATION_SUBROUTINE_UNIFORM)
    ///
    /// [`GL_GEOMETRY_SUBROUTINE_UNIFORM`](crate::enums::GL_GEOMETRY_SUBROUTINE_UNIFORM)
    ///
    /// [`GL_FRAGMENT_SUBROUTINE_UNIFORM`](crate::enums::GL_FRAGMENT_SUBROUTINE_UNIFORM)
    ///
    /// [`GL_COMPUTE_SUBROUTINE_UNIFORM`](crate::enums::GL_COMPUTE_SUBROUTINE_UNIFORM)
    ///
    /// > The query is targeted at the set of active subroutine uniform variables
    /// > used by the vertex, tessellation control, tessellation evaluation, geometry,
    /// > fragment and compute shader stages of `program`, respectively.
    ///
    /// [`GL_TRANSFORM_FEEDBACK_VARYING`](crate::enums::GL_TRANSFORM_FEEDBACK_VARYING)
    ///
    /// > The query is targeted at the set of output variables from the last non-fragment
    /// > stage of `program` that would be captured if transform feedback were active.
    ///
    /// [`GL_BUFFER_VARIABLE`](crate::enums::GL_BUFFER_VARIABLE)
    ///
    /// > The query is targeted at the set of active buffer variables used by `program`.
    ///
    /// [`GL_SHADER_STORAGE_BLOCK`](crate::enums::GL_SHADER_STORAGE_BLOCK)
    ///
    /// > The query is targeted at the set of active shader storage blocks used by
    /// > `program`.
    ///
    /// The name string assigned to the active resource identified by `index` is
    /// returned as a null-terminated string in the character array whose address
    /// is given in `name`. The actual number of characters written into `name`,
    /// excluding the null terminator, is returned in `length`. If `length` is
    /// NULL, no length is returned. The maximum number of characters that may
    /// be written into `name`, including the null terminator, is specified by
    /// `bufSize`. If the length of the name string *including the null terminator*
    /// is greater than `bufSize`, the first `bufSize` -1 characters of the name
    /// string will be written to `name`, followed by a null terminator. If `bufSize`
    /// is zero, no error will be generated but no characters will be written to
    /// `name`. The length of the longest name string for `programInterface` >,
    /// including a null terminator, can be queried by calling [**glGetProgramInterface**](crate::context::Context::oxidegl_get_program_interface)
    /// with a `pname` of [`GL_MAX_NAME_LENGTH`](crate::enums::GL_MAX_NAME_LENGTH).

    pub unsafe fn oxidegl_get_program_resource_name(
        &mut self,
        program: GLuint,
        program_interface: ProgramInterface,
        index: GLuint,
        buf_size: GLsizei,
        length: *mut GLsizei,
        name: *mut GLchar,
    ) {
        panic!("command oxidegl_get_program_resource_name not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the name of the program containing shader stage.
    ///
    /// `shadertype`
    ///
    /// > Specifies the shader stage from which to query for the subroutine parameter.
    /// > `shadertype` must be one of [`GL_VERTEX_SHADER`](crate::enums::GL_VERTEX_SHADER),
    /// > [`GL_TESS_CONTROL_SHADER`](crate::enums::GL_TESS_CONTROL_SHADER), [`GL_TESS_EVALUATION_SHADER`](crate::enums::GL_TESS_EVALUATION_SHADER),
    /// > [`GL_GEOMETRY_SHADER`](crate::enums::GL_GEOMETRY_SHADER) or [`GL_FRAGMENT_SHADER`](crate::enums::GL_FRAGMENT_SHADER).
    ///
    /// `pname`
    ///
    /// > Specifies the parameter of the shader to query. `pname` must be [`GL_ACTIVE_SUBROUTINE_UNIFORMS`](crate::enums::GL_ACTIVE_SUBROUTINE_UNIFORMS),
    /// > [`GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS`](crate::enums::GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS),
    /// > [`GL_ACTIVE_SUBROUTINES`](crate::enums::GL_ACTIVE_SUBROUTINES), [`GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH`](crate::enums::GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH),
    /// > or [`GL_ACTIVE_SUBROUTINE_MAX_LENGTH`](crate::enums::GL_ACTIVE_SUBROUTINE_MAX_LENGTH).
    ///
    /// `values`
    ///
    /// > Specifies the address of a variable into which the queried value or values
    /// > will be placed.
    ///
    /// ### Description
    /// [**glGetProgramStage**](crate::context::Context::oxidegl_get_program_stage)
    /// queries a parameter of a shader stage attached to a program object. `program`
    /// contains the name of the program to which the shader is attached. `shadertype`
    /// specifies the stage from which to query the parameter. `pname` specifies
    /// which parameter should be queried. The value or values of the parameter
    /// to be queried is returned in the variable whose address is given in `values`.
    ///
    /// If `pname` is [`GL_ACTIVE_SUBROUTINE_UNIFORMS`](crate::enums::GL_ACTIVE_SUBROUTINE_UNIFORMS),
    /// the number of active subroutine variables in the stage is returned in
    /// `values`.
    ///
    /// If `pname` is [`GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS`](crate::enums::GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS),
    /// the number of active subroutine variable locations in the stage is returned
    /// in `values`.
    ///
    /// If `pname` is [`GL_ACTIVE_SUBROUTINES`](crate::enums::GL_ACTIVE_SUBROUTINES),
    /// the number of active subroutines in the stage is returned in `values`.
    ///
    /// If `pname` is [`GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH`](crate::enums::GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH),
    /// the length of the longest subroutine uniform for the stage is returned
    /// in `values`.
    ///
    /// If `pname` is [`GL_ACTIVE_SUBROUTINE_MAX_LENGTH`](crate::enums::GL_ACTIVE_SUBROUTINE_MAX_LENGTH),
    /// the length of the longest subroutine name for the stage is returned in
    /// `values`. The returned name length includes space for the null-terminator.
    ///
    /// If there is no shader present of type `shadertype`, the returned value
    /// will be consistent with a shader containing no subroutines or subroutine
    /// uniforms.

    pub unsafe fn oxidegl_get_program_stageiv(
        &mut self,
        program: GLuint,
        shadertype: ShaderType,
        pname: ProgramStagePName,
        values: *mut GLint,
    ) {
        panic!("command oxidegl_get_program_stageiv not yet implemented");
    }
    /// ### Parameters
    /// `target`
    ///
    /// > Specifies a query object target. Must be [`GL_SAMPLES_PASSED`](crate::enums::GL_SAMPLES_PASSED),
    /// > [`GL_ANY_SAMPLES_PASSED`](crate::enums::GL_ANY_SAMPLES_PASSED), [`GL_ANY_SAMPLES_PASSED_CONSERVATIVE`](crate::enums::GL_ANY_SAMPLES_PASSED_CONSERVATIVE)
    /// > [`GL_PRIMITIVES_GENERATED`](crate::enums::GL_PRIMITIVES_GENERATED), [`GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`](crate::enums::GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN),
    /// > [`GL_TIME_ELAPSED`](crate::enums::GL_TIME_ELAPSED), or [`GL_TIMESTAMP`](crate::enums::GL_TIMESTAMP).
    ///
    /// `index`
    ///
    /// > Specifies the index of the query object target.
    ///
    /// `pname`
    ///
    /// > Specifies the symbolic name of a query object target parameter. Accepted
    /// > values are [`GL_CURRENT_QUERY`](crate::enums::GL_CURRENT_QUERY) or [`GL_QUERY_COUNTER_BITS`](crate::enums::GL_QUERY_COUNTER_BITS).
    ///
    /// `params`
    ///
    /// > Returns the requested data.
    ///
    /// ### Description
    /// [**glGetQueryIndexediv**](crate::context::Context::oxidegl_get_query_indexediv)
    /// returns in `params` a selected parameter of the indexed query object target
    /// specified by `target` and `index`. `index` specifies the index of the query
    /// object target and must be between zero and a target-specific maxiumum.
    ///
    /// `pname` names a specific query object target parameter. When `pname` is
    /// [`GL_CURRENT_QUERY`](crate::enums::GL_CURRENT_QUERY), the name of the currently
    /// active query for the specified `index` of `target`, or zero if no query
    /// is active, will be placed in `params`. If `pname` is [`GL_QUERY_COUNTER_BITS`](crate::enums::GL_QUERY_COUNTER_BITS),
    /// the implementation-dependent number of bits used to hold the result of
    /// queries for `target` is returned in `params`.
    ///
    /// ### Notes
    /// The target [`GL_ANY_SAMPLES_PASSED_CONSERVATIVE`](crate::enums::GL_ANY_SAMPLES_PASSED_CONSERVATIVE)
    /// is available only if the GL version is 4.3 or greater.
    ///
    /// If an error is generated, no change is made to the contents of `params`.
    ///
    /// Calling [**glGetQueryiv**](crate::context::Context::oxidegl_get_queryiv)
    /// is equivalent to calling [**glGetQueryIndexediv**](crate::context::Context::oxidegl_get_query_indexediv)
    /// with `index` set to zero.

    pub unsafe fn oxidegl_get_query_indexediv(
        &mut self,
        target: QueryTarget,
        index: GLuint,
        pname: QueryParameterName,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_query_indexediv not yet implemented");
    }
    /// ### Parameters
    /// `target`
    ///
    /// > Specifies a query object target. Must be [`GL_SAMPLES_PASSED`](crate::enums::GL_SAMPLES_PASSED),
    /// > [`GL_ANY_SAMPLES_PASSED`](crate::enums::GL_ANY_SAMPLES_PASSED), [`GL_ANY_SAMPLES_PASSED_CONSERVATIVE`](crate::enums::GL_ANY_SAMPLES_PASSED_CONSERVATIVE)
    /// > [`GL_PRIMITIVES_GENERATED`](crate::enums::GL_PRIMITIVES_GENERATED), [`GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`](crate::enums::GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN),
    /// > [`GL_TIME_ELAPSED`](crate::enums::GL_TIME_ELAPSED), or [`GL_TIMESTAMP`](crate::enums::GL_TIMESTAMP).
    ///
    /// `pname`
    ///
    /// > Specifies the symbolic name of a query object target parameter. Accepted
    /// > values are [`GL_CURRENT_QUERY`](crate::enums::GL_CURRENT_QUERY) or [`GL_QUERY_COUNTER_BITS`](crate::enums::GL_QUERY_COUNTER_BITS).
    ///
    /// `params`
    ///
    /// > Returns the requested data.
    ///
    /// ### Description
    /// [**glGetQueryiv**](crate::context::Context::oxidegl_get_queryiv) returns
    /// in `params` a selected parameter of the query object target specified by
    /// `target`.
    ///
    /// `pname` names a specific query object target parameter. When `pname` is
    /// [`GL_CURRENT_QUERY`](crate::enums::GL_CURRENT_QUERY), the name of the currently
    /// active query for `target`, or zero if no query is active, will be placed
    /// in `params`. If `pname` is [`GL_QUERY_COUNTER_BITS`](crate::enums::GL_QUERY_COUNTER_BITS),
    /// the implementation-dependent number of bits used to hold the result of
    /// queries for `target` is returned in `params`.
    ///
    /// ### Notes
    /// The target [`GL_ANY_SAMPLES_PASSED_CONSERVATIVE`](crate::enums::GL_ANY_SAMPLES_PASSED_CONSERVATIVE)
    /// is available only if the GL version is 4.3 or greater.
    ///
    /// If an error is generated, no change is made to the contents of `params`.

    pub unsafe fn oxidegl_get_queryiv(
        &mut self,
        target: QueryTarget,
        pname: QueryParameterName,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_queryiv not yet implemented");
    }
    /// ### Parameters
    /// `shader`
    ///
    /// > Specifies the shader object to be queried.
    ///
    /// `pname`
    ///
    /// > Specifies the object parameter. Accepted symbolic names are [`GL_SHADER_TYPE`](crate::enums::GL_SHADER_TYPE),
    /// > [`GL_DELETE_STATUS`](crate::enums::GL_DELETE_STATUS), [`GL_COMPILE_STATUS`](crate::enums::GL_COMPILE_STATUS),
    /// > [`GL_INFO_LOG_LENGTH`](crate::enums::GL_INFO_LOG_LENGTH), [`GL_SHADER_SOURCE_LENGTH`](crate::enums::GL_SHADER_SOURCE_LENGTH).
    ///
    /// `params`
    ///
    /// > Returns the requested object parameter.
    ///
    /// ### Description
    /// [**glGetShader**](crate::context::Context::oxidegl_get_shader) returns
    /// in `params` the value of a parameter for a specific shader object. The
    /// following parameters are defined:
    ///
    /// [`GL_SHADER_TYPE`](crate::enums::GL_SHADER_TYPE)
    ///
    /// > `params` returns [`GL_VERTEX_SHADER`](crate::enums::GL_VERTEX_SHADER) if
    /// > `shader` is a vertex shader object, [`GL_GEOMETRY_SHADER`](crate::enums::GL_GEOMETRY_SHADER)
    /// > if `shader` is a geometry shader object, and [`GL_FRAGMENT_SHADER`](crate::enums::GL_FRAGMENT_SHADER)
    /// > if `shader` is a fragment shader object.
    ///
    /// [`GL_DELETE_STATUS`](crate::enums::GL_DELETE_STATUS)
    ///
    /// > `params` returns [`GL_TRUE`](crate::enums::GL_TRUE) if `shader` is currently
    /// > flagged for deletion, and [`GL_FALSE`](crate::enums::GL_FALSE) otherwise.
    ///
    /// [`GL_COMPILE_STATUS`](crate::enums::GL_COMPILE_STATUS)
    ///
    /// > `params` returns [`GL_TRUE`](crate::enums::GL_TRUE) if the last compile
    /// > operation on `shader` was successful, and [`GL_FALSE`](crate::enums::GL_FALSE)
    /// > otherwise.
    ///
    /// [`GL_INFO_LOG_LENGTH`](crate::enums::GL_INFO_LOG_LENGTH)
    ///
    /// > `params` returns the number of characters in the information log for `shader`
    /// > including the null termination character (i.e., the size of the character
    /// > buffer required to store the information log). If `shader` has no information
    /// > log, a value of 0 is returned.
    ///
    /// [`GL_SHADER_SOURCE_LENGTH`](crate::enums::GL_SHADER_SOURCE_LENGTH)
    ///
    /// > `params` returns the length of the concatenation of the source strings
    /// > that make up the shader source for the `shader`, including the null termination
    /// > character. (i.e., the size of the character buffer required to store the
    /// > shader source). If no source code exists, 0 is returned.
    ///
    /// ### Notes
    /// If an error is generated, no change is made to the contents of `params`.
    ///
    /// ### Associated Gets
    /// [**glGetShaderInfoLog**](crate::context::Context::oxidegl_get_shader_info_log)
    /// with argument `shader`
    ///
    /// [**glGetShaderSource**](crate::context::Context::oxidegl_get_shader_source)
    /// with argument `shader`
    ///
    /// [**glIsShader**](crate::context::Context::oxidegl_is_shader)

    pub unsafe fn oxidegl_get_shaderiv(
        &mut self,
        shader: GLuint,
        pname: ShaderParameterName,
        params: *mut GLint,
    ) {
        panic!("command oxidegl_get_shaderiv not yet implemented");
    }
    /// ### Parameters
    /// `shader`
    ///
    /// > Specifies the shader object whose information log is to be queried.
    ///
    /// `maxLength`
    ///
    /// > Specifies the size of the character buffer for storing the returned information
    /// > log.
    ///
    /// `length`
    ///
    /// > Returns the length of the string returned in `infoLog` (excluding the null
    /// > terminator).
    ///
    /// `infoLog`
    ///
    /// > Specifies an array of characters that is used to return the information
    /// > log.
    ///
    /// ### Description
    /// [**glGetShaderInfoLog**](crate::context::Context::oxidegl_get_shader_info_log)
    /// returns the information log for the specified shader object. The information
    /// log for a shader object is modified when the shader is compiled. The string
    /// that is returned will be null terminated.
    ///
    /// [**glGetShaderInfoLog**](crate::context::Context::oxidegl_get_shader_info_log)
    /// returns in `infoLog` as much of the information log as it can, up to a
    /// maximum of `maxLength` characters. The number of characters actually returned,
    /// excluding the null termination character, is specified by `length`. If
    /// the length of the returned string is not required, a value of [`NULL`](crate::enums::NULL)
    /// can be passed in the `length` argument. The size of the buffer required
    /// to store the returned information log can be obtained by calling [**glGetShader**](crate::context::Context::oxidegl_get_shader)
    /// with the value [`GL_INFO_LOG_LENGTH`](crate::enums::GL_INFO_LOG_LENGTH).
    ///
    /// The information log for a shader object is a string that may contain diagnostic
    /// messages, warning messages, and other information about the last compile
    /// operation. When a shader object is created, its information log will be
    /// a string of length 0.
    ///
    /// ### Notes
    /// The information log for a shader object is the OpenGL implementer's primary
    /// mechanism for conveying information about the compilation process. Therefore,
    /// the information log can be helpful to application developers during the
    /// development process, even when compilation is successful. Application developers
    /// should not expect different OpenGL implementations to produce identical
    /// information logs.
    ///
    /// ### Associated Gets
    /// [**glGetShader**](crate::context::Context::oxidegl_get_shader) with argument
    /// [`GL_INFO_LOG_LENGTH`](crate::enums::GL_INFO_LOG_LENGTH)
    ///
    /// [**glIsShader**](crate::context::Context::oxidegl_is_shader)

    pub unsafe fn oxidegl_get_shader_info_log(
        &mut self,
        shader: GLuint,
        buf_size: GLsizei,
        length: *mut GLsizei,
        info_log: *mut GLchar,
    ) {
        panic!("command oxidegl_get_shader_info_log not yet implemented");
    }
    /// ### Parameters
    /// `shaderType`
    ///
    /// > Specifies the type of shader whose precision to query. `shaderType` must
    /// > be [`GL_VERTEX_SHADER`](crate::enums::GL_VERTEX_SHADER) or [`GL_FRAGMENT_SHADER`](crate::enums::GL_FRAGMENT_SHADER).
    ///
    /// `precisionType`
    ///
    /// > Specifies the numeric format whose precision and range to query.
    ///
    /// `range`
    ///
    /// > Specifies the address of array of two integers into which encodings of
    /// > the implementation's numeric range are returned.
    ///
    /// `precision`
    ///
    /// > Specifies the address of an integer into which the numeric precision of
    /// > the implementation is written.
    ///
    /// ### Description
    /// [**glGetShaderPrecisionFormat**](crate::context::Context::oxidegl_get_shader_precision_format)
    /// retrieves the numeric range and precision for the implementation's representation
    /// of quantities in different numeric formats in specified shader type. `shaderType`
    /// specifies the type of shader for which the numeric precision and range
    /// is to be retrieved and must be one of [`GL_VERTEX_SHADER`](crate::enums::GL_VERTEX_SHADER)
    /// or [`GL_FRAGMENT_SHADER`](crate::enums::GL_FRAGMENT_SHADER). `precisionType`
    /// specifies the numeric format to query and must be one of [`GL_LOW_FLOAT`](crate::enums::GL_LOW_FLOAT),
    /// [`GL_MEDIUM_FLOAT`](crate::enums::GL_MEDIUM_FLOAT) [`GL_HIGH_FLOAT`](crate::enums::GL_HIGH_FLOAT),
    /// [`GL_LOW_INT`](crate::enums::GL_LOW_INT), [`GL_MEDIUM_INT`](crate::enums::GL_MEDIUM_INT),
    /// or [`GL_HIGH_INT`](crate::enums::GL_HIGH_INT).
    ///
    /// `range` points to an array of two integers into which the format's numeric
    /// range will be returned. If min and max are the smallest values representable
    /// in the format, then the values returned are defined to be: `range` \[0\]
    ///= floor(log2(\|min\|)) and `range` \[1\]= floor(log2(\|max\|)).
    ///
    /// `precision` specifies the address of an integer into which will be written
    /// the log2 value of the number of bits of precision of the format. If the
    /// smallest representable value greater than 1 is 1+ *eps*, then the integer
    /// addressed by `precision` will contain floor(-log2(eps)).

    pub unsafe fn oxidegl_get_shader_precision_format(
        &mut self,
        shadertype: ShaderType,
        precisiontype: PrecisionType,
        range: *mut GLint,
        precision: *mut GLint,
    ) {
        panic!("command oxidegl_get_shader_precision_format not yet implemented");
    }
    /// ### Parameters
    /// `shader`
    ///
    /// > Specifies the shader object to be queried.
    ///
    /// `bufSize`
    ///
    /// > Specifies the size of the character buffer for storing the returned source
    /// > code string.
    ///
    /// `length`
    ///
    /// > Returns the length of the string returned in `source` (excluding the null
    /// > terminator).
    ///
    /// `source`
    ///
    /// > Specifies an array of characters that is used to return the source code
    /// > string.
    ///
    /// ### Description
    /// [**glGetShaderSource**](crate::context::Context::oxidegl_get_shader_source)
    /// returns the concatenation of the source code strings from the shader object
    /// specified by `shader`. The source code strings for a shader object are
    /// the result of a previous call to [**glShaderSource**](crate::context::Context::oxidegl_shader_source).
    /// The string returned by the function will be null terminated.
    ///
    /// [**glGetShaderSource**](crate::context::Context::oxidegl_get_shader_source)
    /// returns in `source` as much of the source code string as it can, up to
    /// a maximum of `bufSize` characters. The number of characters actually returned,
    /// excluding the null termination character, is specified by `length`. If
    /// the length of the returned string is not required, a value of [`NULL`](crate::enums::NULL)
    /// can be passed in the `length` argument. The size of the buffer required
    /// to store the returned source code string can be obtained by calling [**glGetShader**](crate::context::Context::oxidegl_get_shader)
    /// with the value [`GL_SHADER_SOURCE_LENGTH`](crate::enums::GL_SHADER_SOURCE_LENGTH).
    ///
    /// ### Associated Gets
    /// [**glGetShader**](crate::context::Context::oxidegl_get_shader) with argument
    /// [`GL_SHADER_SOURCE_LENGTH`](crate::enums::GL_SHADER_SOURCE_LENGTH)
    ///
    /// [**glIsShader**](crate::context::Context::oxidegl_is_shader)

    pub unsafe fn oxidegl_get_shader_source(
        &mut self,
        shader: GLuint,
        buf_size: GLsizei,
        length: *mut GLsizei,
        source: *mut GLchar,
    ) {
        panic!("command oxidegl_get_shader_source not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the name of the program containing shader stage.
    ///
    /// `shadertype`
    ///
    /// > Specifies the shader stage from which to query for subroutine uniform index.
    /// > `shadertype` must be one of [`GL_VERTEX_SHADER`](crate::enums::GL_VERTEX_SHADER),
    /// > [`GL_TESS_CONTROL_SHADER`](crate::enums::GL_TESS_CONTROL_SHADER), [`GL_TESS_EVALUATION_SHADER`](crate::enums::GL_TESS_EVALUATION_SHADER),
    /// > [`GL_GEOMETRY_SHADER`](crate::enums::GL_GEOMETRY_SHADER) or [`GL_FRAGMENT_SHADER`](crate::enums::GL_FRAGMENT_SHADER).
    ///
    /// `name`
    ///
    /// > Specifies the name of the subroutine uniform whose index to query.
    ///
    /// ### Description
    /// [**glGetSubroutineIndex**](crate::context::Context::oxidegl_get_subroutine_index)
    /// returns the index of a subroutine uniform within a shader stage attached
    /// to a program object. `program` contains the name of the program to which
    /// the shader is attached. `shadertype` specifies the stage from which to
    /// query shader subroutine index. `name` contains the null-terminated name
    /// of the subroutine uniform whose name to query.
    ///
    /// If `name` is not the name of a subroutine uniform in the shader stage,
    /// [`GL_INVALID_INDEX`](crate::enums::GL_INVALID_INDEX) is returned, but no
    /// error is generated. If `name` is the name of a subroutine uniform in the
    /// shader stage, a value between zero and the value of [`GL_ACTIVE_SUBROUTINES`](crate::enums::GL_ACTIVE_SUBROUTINES)
    /// minus one will be returned. Subroutine indices are assigned using consecutive
    /// integers in the range from zero to the value of [`GL_ACTIVE_SUBROUTINES`](crate::enums::GL_ACTIVE_SUBROUTINES)
    /// minus one for the shader stage.

    pub unsafe fn oxidegl_get_subroutine_index(
        &mut self,
        program: GLuint,
        shadertype: ShaderType,
        name: *const GLchar,
    ) -> GLuint {
        panic!("command oxidegl_get_subroutine_index not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the name of the program containing shader stage.
    ///
    /// `shadertype`
    ///
    /// > Specifies the shader stage from which to query for subroutine uniform index.
    /// > `shadertype` must be one of [`GL_VERTEX_SHADER`](crate::enums::GL_VERTEX_SHADER),
    /// > [`GL_TESS_CONTROL_SHADER`](crate::enums::GL_TESS_CONTROL_SHADER), [`GL_TESS_EVALUATION_SHADER`](crate::enums::GL_TESS_EVALUATION_SHADER),
    /// > [`GL_GEOMETRY_SHADER`](crate::enums::GL_GEOMETRY_SHADER) or [`GL_FRAGMENT_SHADER`](crate::enums::GL_FRAGMENT_SHADER).
    ///
    /// `name`
    ///
    /// > Specifies the name of the subroutine uniform whose index to query.
    ///
    /// ### Description
    /// [**glGetSubroutineUniformLocation**](crate::context::Context::oxidegl_get_subroutine_uniform_location)
    /// returns the location of the subroutine uniform variable `name` in the shader
    /// stage of type `shadertype` attached to `program`, with behavior otherwise
    /// identical to [**glGetUniformLocation**](crate::context::Context::oxidegl_get_uniform_location).
    ///
    /// If `name` is not the name of a subroutine uniform in the shader stage,
    /// -1 is returned, but no error is generated. If `name` is the name of a subroutine
    /// uniform in the shader stage, a value between zero and the value of [`GL_ACTIVE_SUBROUTINE_LOCATIONS`](crate::enums::GL_ACTIVE_SUBROUTINE_LOCATIONS)
    /// minus one will be returned. Subroutine locations are assigned using consecutive
    /// integers in the range from zero to the value of [`GL_ACTIVE_SUBROUTINE_LOCATIONS`](crate::enums::GL_ACTIVE_SUBROUTINE_LOCATIONS)
    /// minus one for the shader stage. For active subroutine uniforms declared
    /// as arrays, the declared array elements are assigned consecutive locations.

    pub unsafe fn oxidegl_get_subroutine_uniform_location(
        &mut self,
        program: GLuint,
        shadertype: ShaderType,
        name: *const GLchar,
    ) -> GLint {
        panic!("command oxidegl_get_subroutine_uniform_location not yet implemented");
    }
    /// ### Parameters
    /// `sync`
    ///
    /// > Specifies the sync object whose properties to query.
    ///
    /// `pname`
    ///
    /// > Specifies the parameter whose value to retrieve from the sync object specified
    /// > in `sync`.
    ///
    /// `bufSize`
    ///
    /// > Specifies the size of the buffer whose address is given in `values`.
    ///
    /// `length`
    ///
    /// > Specifies the address of an variable to receive the number of integers
    /// > placed in `values`.
    ///
    /// `values`
    ///
    /// > Specifies the address of an array to receive the values of the queried
    /// > parameter.
    ///
    /// ### Description
    /// [**glGetSynciv**](crate::context::Context::oxidegl_get_synciv) retrieves
    /// properties of a sync object. `sync` specifies the name of the sync object
    /// whose properties to retrieve.
    ///
    /// On success, [**glGetSynciv**](crate::context::Context::oxidegl_get_synciv)
    /// replaces up to `bufSize` integers in `values` with the corresponding property
    /// values of the object being queried. The actual number of integers replaced
    /// is returned in the variable whose address is specified in `length`. If
    /// `length` is
    ///
    /// If `pname` is [`GL_OBJECT_TYPE`](crate::enums::GL_OBJECT_TYPE), a single
    /// value representing the specific type of the sync object is placed in `values`.
    /// The only type supported is [`GL_SYNC_FENCE`](crate::enums::GL_SYNC_FENCE).
    ///
    /// If `pname` is [`GL_SYNC_STATUS`](crate::enums::GL_SYNC_STATUS), a single
    /// value representing the status of the sync object( [`GL_SIGNALED`](crate::enums::GL_SIGNALED)
    /// or [`GL_UNSIGNALED`](crate::enums::GL_UNSIGNALED)) is placed in `values`.
    ///
    /// If `pname` is [`GL_SYNC_CONDITION`](crate::enums::GL_SYNC_CONDITION), a
    /// single value representing the condition of the sync object is placed in
    /// `values`. The only condition supported is [`GL_SYNC_GPU_COMMANDS_COMPLETE`](crate::enums::GL_SYNC_GPU_COMMANDS_COMPLETE).
    ///
    /// If `pname` is [`GL_SYNC_FLAGS`](crate::enums::GL_SYNC_FLAGS), a single
    /// value representing the flags with which the sync object was created is
    /// placed in `values`. No flags are currently supported `flags` is expected
    /// to be used in future extensions to the sync objects.
    ///
    ///
    /// If an error occurs, nothing will be written to `values` or `length`.

    pub unsafe fn oxidegl_get_synciv(
        &mut self,
        sync: GLsync,
        pname: SyncParameterName,
        count: GLsizei,
        length: *mut GLsizei,
        values: *mut GLint,
    ) {
        panic!("command oxidegl_get_synciv not yet implemented");
    }
    /// ### Parameters
    /// `texture`
    ///
    /// > Specifies the name of the source texture object. Must be [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D),
    /// > [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY), [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D),
    /// > [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY), [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D),
    /// > [`GL_TEXTURE_CUBE_MAP`](crate::enums::GL_TEXTURE_CUBE_MAP), [`GL_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_CUBE_MAP_ARRAY)
    /// > or [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE). In specific,
    /// > buffer and multisample textures are not permitted.
    ///
    /// `level`
    ///
    /// > Specifies the level-of-detail number. Level 0 is the base image level.
    /// > Level $n$ is the $n$th mipmap reduction image.
    ///
    /// `xoffset`
    ///
    /// > Specifies a texel offset in the x direction within the texture array.
    ///
    /// `yoffset`
    ///
    /// > Specifies a texel offset in the y direction within the texture array.
    ///
    /// `zoffset`
    ///
    /// > Specifies a texel offset in the z direction within the texture array.
    ///
    /// `width`
    ///
    /// > Specifies the width of the texture subimage.
    ///
    /// `height`
    ///
    /// > Specifies the height of the texture subimage.
    ///
    /// `depth`
    ///
    /// > Specifies the depth of the texture subimage.
    ///
    /// `format`
    ///
    /// > Specifies the format of the pixel data. The following symbolic values are
    /// > accepted: [`GL_RED`](crate::enums::GL_RED), [`GL_RG`](crate::enums::GL_RG),
    /// > [`GL_RGB`](crate::enums::GL_RGB), [`GL_BGR`](crate::enums::GL_BGR), [`GL_RGBA`](crate::enums::GL_RGBA),
    /// > [`GL_BGRA`](crate::enums::GL_BGRA), [`GL_DEPTH_COMPONENT`](crate::enums::GL_DEPTH_COMPONENT)
    /// > and [`GL_STENCIL_INDEX`](crate::enums::GL_STENCIL_INDEX).
    ///
    /// `type`
    ///
    /// > Specifies the data type of the pixel data. The following symbolic values
    /// > are accepted: [`GL_UNSIGNED_BYTE`](crate::enums::GL_UNSIGNED_BYTE), [`GL_BYTE`](crate::enums::GL_BYTE),
    /// > [`GL_UNSIGNED_SHORT`](crate::enums::GL_UNSIGNED_SHORT), [`GL_SHORT`](crate::enums::GL_SHORT),
    /// > [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT), [`GL_INT`](crate::enums::GL_INT),
    /// > [`GL_FLOAT`](crate::enums::GL_FLOAT), [`GL_UNSIGNED_BYTE_3_3_2`](crate::enums::GL_UNSIGNED_BYTE_3_3_2),
    /// > [`GL_UNSIGNED_BYTE_2_3_3_REV`](crate::enums::GL_UNSIGNED_BYTE_2_3_3_REV),
    /// > [`GL_UNSIGNED_SHORT_5_6_5`](crate::enums::GL_UNSIGNED_SHORT_5_6_5), [`GL_UNSIGNED_SHORT_5_6_5_REV`](crate::enums::GL_UNSIGNED_SHORT_5_6_5_REV),
    /// > [`GL_UNSIGNED_SHORT_4_4_4_4`](crate::enums::GL_UNSIGNED_SHORT_4_4_4_4),
    /// > [`GL_UNSIGNED_SHORT_4_4_4_4_REV`](crate::enums::GL_UNSIGNED_SHORT_4_4_4_4_REV),
    /// > [`GL_UNSIGNED_SHORT_5_5_5_1`](crate::enums::GL_UNSIGNED_SHORT_5_5_5_1),
    /// > [`GL_UNSIGNED_SHORT_1_5_5_5_REV`](crate::enums::GL_UNSIGNED_SHORT_1_5_5_5_REV),
    /// > [`GL_UNSIGNED_INT_8_8_8_8`](crate::enums::GL_UNSIGNED_INT_8_8_8_8), [`GL_UNSIGNED_INT_8_8_8_8_REV`](crate::enums::GL_UNSIGNED_INT_8_8_8_8_REV),
    /// > [`GL_UNSIGNED_INT_10_10_10_2`](crate::enums::GL_UNSIGNED_INT_10_10_10_2),
    /// > and [`GL_UNSIGNED_INT_2_10_10_10_REV`](crate::enums::GL_UNSIGNED_INT_2_10_10_10_REV).
    ///
    /// `bufSize`
    ///
    /// > Specifies the size of the buffer to receive the retrieved pixel data.
    ///
    /// `pixels`
    ///
    /// > Returns the texture subimage. Should be a pointer to an array of the type
    /// > specified by `type`.
    ///
    /// ### Description
    /// [**glGetTextureSubImage**](crate::context::Context::oxidegl_get_texture_sub_image)
    /// returns a texture subimage into pixels.
    ///
    /// `texture` is the name of the source texture object and must not be a buffer
    /// or multisample texture. The effective `target` parameter is the value of
    /// [`GL_TEXTURE_TARGET`](crate::enums::GL_TEXTURE_TARGET) for texture. `Level`,
    /// `format`, `type` and `pixels` have the same meaning as for [**glGetTexImage**](crate::context::Context::oxidegl_get_tex_image).
    /// `bufSize` is the size of the buffer to receive the retrieved pixel data.
    ///
    /// For cube map textures, the behavior is as though [**`GetTextureImage`**](crate::context::Context::oxide_get_texture_image)
    /// were called, but only texels from the requested cube map faces (selected
    /// by `zoffset` and `depth`, as described below) were returned.
    ///
    /// `xoffset`, `yoffset` and `zoffset` values indicate the position of the
    /// subregion to return. `width`, `height` and `depth` indicate the size of
    /// the region to return. These parameters have the same meaning as for [**glTexSubImage3D**](crate::context::Context::oxidegl_tex_sub_image3_d),
    /// though for one- and two-dimensional textures there are extra restrictions,
    /// described in the errors section below.
    ///
    /// For one-dimensional array textures, `yoffset` is interpreted as the first
    /// layer to access and `height` is the number of layers to access.
    ///
    /// For two-dimensional array textures, `zoffset` is interpreted as the first
    /// layer to access and `depth` is the number of layers to access.
    ///
    /// Cube map textures are treated as an array of six slices in the z-dimension,
    /// where the value of `zoffset` is interpreted as specifying the cube map
    /// face for the corresponding layer (as presented in the table below) and
    /// `depth` is the number of faces to access:
    ///
    /// | Layer number        | Cube Map Face        |
    /// |---------------------|----------------------|
    /// | 0                   | `GL_TEXTURE_CUBE_MAP_POSITIVE_X` |
    /// | 1                   | `GL_TEXTURE_CUBE_MAP_NEGATIVE_X` |
    /// | 2                   | `GL_TEXTURE_CUBE_MAP_POSITIVE_Y` |
    /// | 3                   | `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y` |
    /// | 4                   | `GL_TEXTURE_CUBE_MAP_POSITIVE_Z` |
    /// | 5                   | `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z` |
    ///
    ///
    /// For cube map array textures, `zoffset` is the first layer-face to access,
    /// and `depth` is the number of layer-faces to access. A layer-face described
    /// by $k$ is translated into an array layer and face according to $$ layer
    ///= \left\lfloor{ layer \over 6} \right\rfloor$$ and $$ face= k \bmod 6. $$
    ///
    /// Component groups from the specified sub-region are packed and placed into
    /// memory as described for [**glGetTextureImage**](crate::context::Context::oxidegl_get_texture_image),
    /// starting with the texel at( `xoffset`, `yoffset`, `zoffset` ).

    pub unsafe fn oxidegl_get_texture_sub_image(
        &mut self,
        texture: GLuint,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        zoffset: GLint,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        format: PixelFormat,
        r#type: PixelType,
        buf_size: GLsizei,
        pixels: *mut GLvoid,
    ) {
        panic!("command oxidegl_get_texture_sub_image not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > The name of the target program object.
    ///
    /// `index`
    ///
    /// > The index of the varying variable whose information to retrieve.
    ///
    /// `bufSize`
    ///
    /// > The maximum number of characters, including the null terminator, that may
    /// > be written into `name`.
    ///
    /// `length`
    ///
    /// > The address of a variable which will receive the number of characters written
    /// > into `name`, excluding the null-terminator. If `length` is [`NULL`](crate::enums::NULL)
    /// > no length is returned.
    ///
    /// `size`
    ///
    /// > The address of a variable that will receive the size of the varying.
    ///
    /// `type`
    ///
    /// > The address of a variable that will receive the type of the varying.
    ///
    /// `name`
    ///
    /// > The address of a buffer into which will be written the name of the varying.
    ///
    /// ### Description
    /// Information about the set of varying variables in a linked program that
    /// will be captured during transform feedback may be retrieved by calling
    /// [**glGetTransformFeedbackVarying**](crate::context::Context::oxidegl_get_transform_feedback_varying).
    /// [**glGetTransformFeedbackVarying**](crate::context::Context::oxidegl_get_transform_feedback_varying)
    /// provides information about the varying variable selected by `index`. An
    /// `index` of 0 selects the first varying variable specified in the `varyings`
    /// array passed to [**glTransformFeedbackVaryings**](crate::context::Context::oxidegl_transform_feedback_varyings),
    /// and an `index` of the value of [`GL_TRANSFORM_FEEDBACK_VARYINGS`](crate::enums::GL_TRANSFORM_FEEDBACK_VARYINGS)
    /// minus one selects the last such variable.
    ///
    /// The name of the selected varying is returned as a null-terminated string
    /// in `name`. The actual number of characters written into `name`, excluding
    /// the null terminator, is returned in `length`. If `length` is NULL, no length
    /// is returned. The maximum number of characters that may be written into
    /// `name`, including the null terminator, is specified by `bufSize`.
    ///
    /// The length of the longest varying name in program is given by [`GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH`](crate::enums::GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH),
    /// which can be queried with [**glGetProgram**](crate::context::Context::oxidegl_get_program).
    ///
    /// For the selected varying variable, its type is returned into `type`. The
    /// size of the varying is returned into `size`. The value in `size` is in
    /// units of the type returned in `type`. The type returned can be any of the
    /// scalar, vector, or matrix attribute types returned by [**glGetActiveAttrib**](crate::context::Context::oxidegl_get_active_attrib).
    /// If an error occurred, the return parameters `length`, `size`, `type` and
    /// `name` will be unmodified. This command will return as much information
    /// about the varying variables as possible. If no information is available,
    /// `length` will be set to zero and `name` will be an empty string. This situation
    /// could arise if [**glGetTransformFeedbackVarying**](crate::context::Context::oxidegl_get_transform_feedback_varying)
    /// is called after a failed link.
    ///
    /// ### Associated Gets
    /// [**glGetProgram**](crate::context::Context::oxidegl_get_program) with argument
    /// [`GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH`](crate::enums::GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH).

    pub unsafe fn oxidegl_get_transform_feedback_varying(
        &mut self,
        program: GLuint,
        index: GLuint,
        buf_size: GLsizei,
        length: *mut GLsizei,
        size: *mut GLsizei,
        r#type: AttributeType,
        name: *mut GLchar,
    ) {
        panic!("command oxidegl_get_transform_feedback_varying not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the name of a program containing the uniform block.
    ///
    /// `uniformBlockName`
    ///
    /// > Specifies the address an array of characters to containing the name of
    /// > the uniform block whose index to retrieve.
    ///
    /// ### Description
    /// [**glGetUniformBlockIndex**](crate::context::Context::oxidegl_get_uniform_block_index)
    /// retrieves the index of a uniform block within `program`.
    ///
    /// `program` must be the name of a program object for which the command [**glLinkProgram**](crate::context::Context::oxidegl_link_program)
    /// must have been called in the past, although it is not required that [**glLinkProgram**](crate::context::Context::oxidegl_link_program)
    /// must have succeeded. The link could have failed because the number of active
    /// uniforms exceeded the limit.
    ///
    /// `uniformBlockName` must contain a nul-terminated string specifying the
    /// name of the uniform block.
    ///
    /// [**glGetUniformBlockIndex**](crate::context::Context::oxidegl_get_uniform_block_index)
    /// returns the uniform block index for the uniform block named `uniformBlockName`
    /// of `program`. If `uniformBlockName` does not identify an active uniform
    /// block of `program`, [**glGetUniformBlockIndex**](crate::context::Context::oxidegl_get_uniform_block_index)
    /// returns the special identifier, [`GL_INVALID_INDEX`](crate::enums::GL_INVALID_INDEX).
    /// Indices of the active uniform blocks of a program are assigned in consecutive
    /// order, beginning with zero.
    ///
    /// ### Notes
    /// [**glGetUniformBlockIndex**](crate::context::Context::oxidegl_get_uniform_block_index)
    /// is available only if the GL version is 3.1 or greater.

    pub unsafe fn oxidegl_get_uniform_block_index(
        &mut self,
        program: GLuint,
        uniform_block_name: *const GLchar,
    ) -> GLuint {
        panic!("command oxidegl_get_uniform_block_index not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the name of a program containing uniforms whose indices to query.
    ///
    /// `uniformCount`
    ///
    /// > Specifies the number of uniforms whose indices to query.
    ///
    /// `uniformNames`
    ///
    /// > Specifies the address of an array of pointers to buffers containing the
    /// > names of the queried uniforms.
    ///
    /// `uniformIndices`
    ///
    /// > Specifies the address of an array that will receive the indices of the
    /// > uniforms.
    ///
    /// ### Description
    /// [**glGetUniformIndices**](crate::context::Context::oxidegl_get_uniform_indices)
    /// retrieves the indices of a number of uniforms within `program`.
    ///
    /// `program` must be the name of a program object for which the command [**glLinkProgram**](crate::context::Context::oxidegl_link_program)
    /// must have been called in the past, although it is not required that [**glLinkProgram**](crate::context::Context::oxidegl_link_program)
    /// must have succeeded. The link could have failed because the number of active
    /// uniforms exceeded the limit.
    ///
    /// `uniformCount` indicates both the number of elements in the array of names
    /// `uniformNames` and the number of indices that may be written to `uniformIndices`.
    ///
    /// `uniformNames` contains a list of `uniformCount` name strings identifying
    /// the uniform names to be queried for indices. For each name string in `uniformNames`,
    /// the index assigned to the active uniform of that name will be written
    /// to the corresponding element of `uniformIndices`. If a string in `uniformNames`
    /// is not the name of an active uniform, the special value [`GL_INVALID_INDEX`](crate::enums::GL_INVALID_INDEX)
    /// will be written to the corresponding element of `uniformIndices`.
    ///
    /// If an error occurs, nothing is written to `uniformIndices`.
    ///
    /// ### Notes
    /// [**glGetUniformIndices**](crate::context::Context::oxidegl_get_uniform_indices)
    /// is available only if the GL version is 3.1 or greater.

    pub unsafe fn oxidegl_get_uniform_indices(
        &mut self,
        program: GLuint,
        uniform_count: GLsizei,
        uniform_names: GLchar,
        uniform_indices: *mut GLuint,
    ) {
        panic!("command oxidegl_get_uniform_indices not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the program object to be queried.
    ///
    /// `name`
    ///
    /// > Points to a null terminated string containing the name of the uniform variable
    /// > whose location is to be queried.
    ///
    /// ### Description
    /// [**glGetUniformLocation **](crate::context::Context::oxidegl_get_uniform_location
    ///) returns an integer that represents the location of a specific uniform
    /// variable within a program object. `name` must be a null terminated string
    /// that contains no white space. `name` must be an active uniform variable
    /// name in `program` that is not a structure, an array of structures, or a
    /// subcomponent of a vector or a matrix. This function returns -1 if `name`
    /// does not correspond to an active uniform variable in `program`, if `name`
    /// starts with the reserved prefix "gl_", or if `name` is associated with
    /// an atomic counter or a named uniform block.
    ///
    /// Uniform variables that are structures or arrays of structures may be queried
    /// by calling [**glGetUniformLocation**](crate::context::Context::oxidegl_get_uniform_location)
    /// for each field within the structure. The array element operator "\[\]"
    /// and the structure field operator "." may be used in `name` in order to
    /// select elements within an array or fields within a structure. The result
    /// of using these operators is not allowed to be another structure, an array
    /// of structures, or a subcomponent of a vector or a matrix. Except if the
    /// last part of `name` indicates a uniform variable array, the location of
    /// the first element of an array can be retrieved by using the name of the
    /// array, or by using the name appended by "\[0\]".
    ///
    /// The actual locations assigned to uniform variables are not known until
    /// the program object is linked successfully. After linking has occurred,
    /// the command [**glGetUniformLocation**](crate::context::Context::oxidegl_get_uniform_location)
    /// can be used to obtain the location of a uniform variable. This location
    /// value can then be passed to [**glUniform**](crate::context::Context::oxidegl_uniform)
    /// to set the value of the uniform variable or to [**glGetUniform**](crate::context::Context::oxidegl_get_uniform)
    /// in order to query the current value of the uniform variable. After a program
    /// object has been linked successfully, the index values for uniform variables
    /// remain fixed until the next link command occurs. Uniform variable locations
    /// and values can only be queried after a link if the link was successful.
    ///
    /// ### Associated Gets
    /// [**glGetActiveUniform**](crate::context::Context::oxidegl_get_active_uniform)
    /// with arguments `program` and the index of an active uniform variable
    ///
    /// [**glGetProgram**](crate::context::Context::oxidegl_get_program) with arguments
    /// `program` and [`GL_ACTIVE_UNIFORMS`](crate::enums::GL_ACTIVE_UNIFORMS)
    /// or [`GL_ACTIVE_UNIFORM_MAX_LENGTH`](crate::enums::GL_ACTIVE_UNIFORM_MAX_LENGTH)
    ///
    /// [**glGetUniform**](crate::context::Context::oxidegl_get_uniform) with arguments
    /// `program` and the name of a uniform variable
    ///
    /// [**glIsProgram**](crate::context::Context::oxidegl_is_program)

    pub unsafe fn oxidegl_get_uniform_location(
        &mut self,
        program: GLuint,
        name: *const GLchar,
    ) -> GLint {
        panic!("command oxidegl_get_uniform_location not yet implemented");
    }
    /// ### Parameters
    /// `shadertype`
    ///
    /// > Specifies the shader stage from which to query for subroutine uniform index.
    /// > `shadertype` must be one of [`GL_VERTEX_SHADER`](crate::enums::GL_VERTEX_SHADER),
    /// > [`GL_TESS_CONTROL_SHADER`](crate::enums::GL_TESS_CONTROL_SHADER), [`GL_TESS_EVALUATION_SHADER`](crate::enums::GL_TESS_EVALUATION_SHADER),
    /// > [`GL_GEOMETRY_SHADER`](crate::enums::GL_GEOMETRY_SHADER) or [`GL_FRAGMENT_SHADER`](crate::enums::GL_FRAGMENT_SHADER).
    ///
    /// `location`
    ///
    /// > Specifies the location of the subroutine uniform.
    ///
    /// `values`
    ///
    /// > Specifies the address of a variable to receive the value or values of the
    /// > subroutine uniform.
    ///
    /// ### Description
    /// [**glGetUniformSubroutine**](crate::context::Context::oxidegl_get_uniform_subroutine)
    /// retrieves the value of the subroutine uniform at location `location` for
    /// shader stage `shadertype` of the current program. `location` must be less
    /// than the value of [`GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS`](crate::enums::GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS)
    /// for the shader currently in use at shader stage `shadertype`. The value
    /// of the subroutine uniform is returned in `values`.

    pub unsafe fn oxidegl_get_uniform_subroutineuiv(
        &mut self,
        shadertype: ShaderType,
        location: GLint,
        params: *mut GLuint,
    ) {
        panic!("command oxidegl_get_uniform_subroutineuiv not yet implemented");
    }
    /// ### Parameters
    /// `vaobj`
    ///
    /// > specifies the name of the vertex array object to use for the query.
    ///
    /// `pname`
    ///
    /// > Name of the property to use for the query. Must be [`GL_ELEMENT_ARRAY_BUFFER_BINDING`](crate::enums::GL_ELEMENT_ARRAY_BUFFER_BINDING).
    ///
    /// `param`
    ///
    /// > Returns the requested value.
    ///
    /// ### Description
    /// This function provides a mean of querying properties of an existing vertex
    /// array object. The vertex array object does not have to be bound to the
    /// rendering context at the time of the call, but must have been bound at
    /// least once prior to this call.
    ///
    /// [**glGetVertexArrayiv**](crate::context::Context::oxidegl_get_vertex_arrayiv)
    /// can be used to retrieve ID of a buffer object that will be bound to the
    /// [`GL_ELEMENT_ARRAY_BUFFER`](crate::enums::GL_ELEMENT_ARRAY_BUFFER) binding
    /// point whenever the queried vertex array object is bound to the rendering
    /// context. The binding can be changed for an active vertex array object with
    /// a [**glBindBuffer**](crate::context::Context::oxidegl_bind_buffer) call.

    pub unsafe fn oxidegl_get_vertex_arrayiv(
        &mut self,
        vaobj: GLuint,
        pname: VertexArrayPName,
        param: *mut GLint,
    ) {
        panic!("command oxidegl_get_vertex_arrayiv not yet implemented");
    }
    /// ### Parameters
    /// `index`
    ///
    /// > Specifies the generic vertex attribute parameter to be returned.
    ///
    /// `pname`
    ///
    /// > Specifies the symbolic name of the generic vertex attribute parameter to
    /// > be returned. Must be [`GL_VERTEX_ATTRIB_ARRAY_POINTER`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_POINTER).
    ///
    /// `pointer`
    ///
    /// > Returns the pointer value.
    ///
    /// ### Description
    /// [**glGetVertexAttribPointerv**](crate::context::Context::oxidegl_get_vertex_attrib_pointerv)
    /// returns pointer information. `index` is the generic vertex attribute to
    /// be queried, `pname` is a symbolic constant indicating the pointer to be
    /// returned, and `params` is a pointer to a location in which to place the
    /// returned data.
    ///
    /// The `pointer` returned is a byte offset into the data store of the buffer
    /// object that was bound to the [`GL_ARRAY_BUFFER`](crate::enums::GL_ARRAY_BUFFER)
    /// target (see [**glBindBuffer**](crate::context::Context::oxidegl_bind_buffer))
    /// when the desired pointer was previously specified.
    ///
    /// ### Notes
    /// The state returned is retrieved from the currently bound vertex array object.
    ///
    /// The initial value for each pointer is 0.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_VERTEX_ATTRIBS`](crate::enums::GL_MAX_VERTEX_ATTRIBS)

    pub unsafe fn oxidegl_get_vertex_attrib_pointerv(
        &mut self,
        index: GLuint,
        pname: GLenum,
        pointer: *mut *mut GLvoid,
    ) {
        panic!("command oxidegl_get_vertex_attrib_pointerv not yet implemented");
    }
    /// ### Parameters
    /// `target`
    ///
    /// > Specifies a symbolic constant indicating the behavior to be controlled.
    /// > [`GL_LINE_SMOOTH_HINT`](crate::enums::GL_LINE_SMOOTH_HINT), [`GL_POLYGON_SMOOTH_HINT`](crate::enums::GL_POLYGON_SMOOTH_HINT),
    /// > [`GL_TEXTURE_COMPRESSION_HINT`](crate::enums::GL_TEXTURE_COMPRESSION_HINT),
    /// > and [`GL_FRAGMENT_SHADER_DERIVATIVE_HINT`](crate::enums::GL_FRAGMENT_SHADER_DERIVATIVE_HINT)
    /// > are accepted.
    ///
    /// `mode`
    ///
    /// > Specifies a symbolic constant indicating the desired behavior. [`GL_FASTEST`](crate::enums::GL_FASTEST),
    /// > [`GL_NICEST`](crate::enums::GL_NICEST), and [`GL_DONT_CARE`](crate::enums::GL_DONT_CARE)
    /// > are accepted.
    ///
    /// ### Description
    /// Certain aspects of GL behavior, when there is room for interpretation,
    /// can be controlled with hints. A hint is specified with two arguments. `target`
    /// is a symbolic constant indicating the behavior to be controlled, and `mode`
    /// is another symbolic constant indicating the desired behavior. The initial
    /// value for each `target` is [`GL_DONT_CARE`](crate::enums::GL_DONT_CARE).
    /// `mode` can be one of the following:
    ///
    /// [`GL_FASTEST`](crate::enums::GL_FASTEST)
    ///
    ///
    /// > The most efficient option should be chosen.
    ///
    /// [`GL_NICEST`](crate::enums::GL_NICEST)
    ///
    ///
    /// > The most correct, or highest quality, option should be chosen.
    ///
    /// [`GL_DONT_CARE`](crate::enums::GL_DONT_CARE)
    ///
    ///
    /// > No preference.
    ///
    /// Though the implementation aspects that can be hinted are well defined,
    /// the interpretation of the hints depends on the implementation. The hint
    /// aspects that can be specified with `target`, along with suggested semantics,
    /// are as follows:
    ///
    /// [`GL_FRAGMENT_SHADER_DERIVATIVE_HINT`](crate::enums::GL_FRAGMENT_SHADER_DERIVATIVE_HINT)
    ///
    ///
    /// > Indicates the accuracy of the derivative calculation for the GL shading
    /// > language fragment processing built-in functions: [`dFdx`](crate::enums::dFdx),
    /// > [`dFdy`](crate::enums::dFdy), and [`fwidth`](crate::enums::fwidth).
    ///
    /// [`GL_LINE_SMOOTH_HINT`](crate::enums::GL_LINE_SMOOTH_HINT)
    ///
    ///
    /// > Indicates the sampling quality of antialiased lines. If a larger filter
    /// > function is applied, hinting [`GL_NICEST`](crate::enums::GL_NICEST) can
    /// > result in more pixel fragments being generated during rasterization.
    ///
    /// [`GL_POLYGON_SMOOTH_HINT`](crate::enums::GL_POLYGON_SMOOTH_HINT)
    ///
    ///
    /// > Indicates the sampling quality of antialiased polygons. Hinting [`GL_NICEST`](crate::enums::GL_NICEST)
    /// > can result in more pixel fragments being generated during rasterization,
    /// > if a larger filter function is applied.
    ///
    /// [`GL_TEXTURE_COMPRESSION_HINT`](crate::enums::GL_TEXTURE_COMPRESSION_HINT)
    ///
    ///
    /// > Indicates the quality and performance of the compressing texture images.
    /// > Hinting [`GL_FASTEST`](crate::enums::GL_FASTEST) indicates that texture
    /// > images should be compressed as quickly as possible, while [`GL_NICEST`](crate::enums::GL_NICEST)
    /// > indicates that texture images should be compressed with as little image
    /// > quality loss as possible. [`GL_NICEST`](crate::enums::GL_NICEST) should
    /// > be selected if the texture is to be retrieved by [**glGetCompressedTexImage**](crate::context::Context::oxidegl_get_compressed_tex_image)
    /// > for reuse.
    ///
    /// ### Notes
    /// The interpretation of hints depends on the implementation. Some implementations
    /// ignore [**glHint**](crate::context::Context::oxidegl_hint) settings.

    pub fn oxidegl_hint(&mut self, target: HintTarget, mode: HintMode) {
        panic!("command oxidegl_hint not yet implemented");
    }
    /// ### Parameters
    /// `buffer`
    ///
    /// > The name of a buffer object whose data store to invalidate.
    ///
    /// ### Description
    /// [**glInvalidateBufferData**](crate::context::Context::oxidegl_invalidate_buffer_data)
    /// invalidates all of the content of the data store of a buffer object. After
    /// invalidation, the content of the buffer's data store becomes undefined.
    ///
    /// ### Associated Gets
    /// [**glGetBufferParameter**](crate::context::Context::oxidegl_get_buffer_parameter)
    /// with argument [`GL_BUFFER_SIZE`](crate::enums::GL_BUFFER_SIZE)

    pub fn oxidegl_invalidate_buffer_data(&mut self, buffer: GLuint) {
        panic!("command oxidegl_invalidate_buffer_data not yet implemented");
    }
    /// ### Parameters
    /// `buffer`
    ///
    /// > The name of a buffer object, a subrange of whose data store to invalidate.
    ///
    /// `offset`
    ///
    /// > The offset within the buffer's data store of the start of the range to
    /// > be invalidated.
    ///
    /// `length`
    ///
    /// > The length of the range within the buffer's data store to be invalidated.
    ///
    /// ### Description
    /// [**glInvalidateBufferSubData**](crate::context::Context::oxidegl_invalidate_buffer_sub_data)
    /// invalidates all or part of the content of the data store of a buffer object.
    /// After invalidation, the content of the specified range of the buffer's
    /// data store becomes undefined. The start of the range is given by `offset`
    /// and its size is given by `length`, both measured in basic machine units.
    ///
    /// ### Associated Gets
    /// [**glGetBufferParameter**](crate::context::Context::oxidegl_get_buffer_parameter)
    /// with argument [`GL_BUFFER_SIZE`](crate::enums::GL_BUFFER_SIZE)

    pub fn oxidegl_invalidate_buffer_sub_data(
        &mut self,
        buffer: GLuint,
        offset: GLintptr,
        length: GLsizeiptr,
    ) {
        panic!("command oxidegl_invalidate_buffer_sub_data not yet implemented");
    }
    /// ### Parameters
    /// `texture`
    ///
    /// > The name of a texture object to invalidate.
    ///
    /// `level`
    ///
    /// > The level of detail of the texture object to invalidate.
    ///
    /// ### Description
    /// [**glInvalidateTexSubImage**](crate::context::Context::oxidegl_invalidate_tex_sub_image)
    /// invalidates all of a texture image. `texture` and `level` indicated which
    /// texture image is being invalidated. After this command, data in the texture
    /// image has undefined values.
    ///
    /// `level` must be greater than or equal to zero and be less than the base
    /// 2 logarithm of the maximum texture width, height, or depth.
    ///
    /// For textures of targets [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE),
    /// [`GL_TEXTURE_BUFFER`](crate::enums::GL_TEXTURE_BUFFER), [`GL_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE),
    /// or [`GL_TEXTURE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE_ARRAY),
    /// level must be zero.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_TEXTURE_SIZE`](crate::enums::GL_MAX_TEXTURE_SIZE)

    pub fn oxidegl_invalidate_tex_image(&mut self, texture: GLuint, level: GLint) {
        panic!("command oxidegl_invalidate_tex_image not yet implemented");
    }
    /// ### Parameters
    /// `texture`
    ///
    /// > The name of a texture object a subregion of which to invalidate.
    ///
    /// `level`
    ///
    /// > The level of detail of the texture object within which the region resides.
    ///
    /// `xoffset`
    ///
    /// > The X offset of the region to be invalidated.
    ///
    /// `yoffset`
    ///
    /// > The Y offset of the region to be invalidated.
    ///
    /// `zoffset`
    ///
    /// > The Z offset of the region to be invalidated.
    ///
    /// `width`
    ///
    /// > The width of the region to be invalidated.
    ///
    /// `height`
    ///
    /// > The height of the region to be invalidated.
    ///
    /// `depth`
    ///
    /// > The depth of the region to be invalidated.
    ///
    /// ### Description
    /// [**glInvalidateTexSubImage**](crate::context::Context::oxidegl_invalidate_tex_sub_image)
    /// invalidates all or part of a texture image. `texture` and `level` indicated
    /// which texture image is being invalidated. After this command, data in that
    /// subregion have undefined values. `xoffset`, `yoffset`, `zoffset`, `width`,
    /// `height`, and `depth` are interpreted as they are in [**glTexSubImage3D**](crate::context::Context::oxidegl_tex_sub_image3_d).
    /// For texture targets that don't have certain dimensions, this command treats
    /// those dimensions as having a size of 1. For example, to invalidate a portion
    /// of a two- dimensional texture, the application would use `zoffset` equal
    /// to zero and `depth` equal to one. Cube map textures are treated as an array
    /// of six slices in the z-dimension, where a value of `zoffset` is interpreted
    /// as specifying face [`GL_TEXTURE_CUBE_MAP_POSITIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_X)+
    /// `zoffset`.
    ///
    /// `level` must be greater than or equal to zero and be less than the base
    /// 2 logarithm of the maximum texture width, height, or depth. `xoffset`, `yoffset`
    /// and `zoffset` must be greater than or equal to zero and be less than the
    /// width, height or depth of the image, respectively. Furthermore, `xoffset`+
    /// `width`, `yoffset`+ `height`, and `zoffset`+ `depth` must be less than
    /// or equal to the width, height or depth of the image, respectively.
    ///
    /// For textures of targets [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE),
    /// [`GL_TEXTURE_BUFFER`](crate::enums::GL_TEXTURE_BUFFER), [`GL_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE),
    /// or [`GL_TEXTURE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE_ARRAY),
    /// level must be zero.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_TEXTURE_SIZE`](crate::enums::GL_MAX_TEXTURE_SIZE)

    pub fn oxidegl_invalidate_tex_sub_image(
        &mut self,
        texture: GLuint,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        zoffset: GLint,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
    ) {
        panic!("command oxidegl_invalidate_tex_sub_image not yet implemented");
    }
    /// ### Parameters
    /// `framebuffer`
    ///
    /// > Specifies a value that may be the name of a framebuffer object.
    ///
    /// ### Description
    /// [**glIsFramebuffer**](crate::context::Context::oxidegl_is_framebuffer)
    /// returns [`GL_TRUE`](crate::enums::GL_TRUE) if `framebuffer` is currently
    /// the name of a framebuffer object. If `framebuffer` is zero, or if [`framebuffer`](crate::enums::framebuffer)
    /// is not the name of a framebuffer object, or if an error occurs, [**glIsFramebuffer**](crate::context::Context::oxidegl_is_framebuffer)
    /// returns [`GL_FALSE`](crate::enums::GL_FALSE). If `framebuffer` is a name
    /// returned by [**glGenFramebuffers**](crate::context::Context::oxidegl_gen_framebuffers),
    /// by that has not yet been bound through a call to [**glBindFramebuffer**](crate::context::Context::oxidegl_bind_framebuffer),
    /// then the name is not a framebuffer object and [**glIsFramebuffer**](crate::context::Context::oxidegl_is_framebuffer)
    /// returns [`GL_FALSE`](crate::enums::GL_FALSE).

    pub fn oxidegl_is_framebuffer(&mut self, framebuffer: GLuint) -> GLboolean {
        panic!("command oxidegl_is_framebuffer not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies a potential program object.
    ///
    /// ### Description
    /// [**glIsProgram**](crate::context::Context::oxidegl_is_program) returns
    /// [`GL_TRUE`](crate::enums::GL_TRUE) if `program` is the name of a program
    /// object previously created with [**glCreateProgram**](crate::context::Context::oxidegl_create_program)
    /// and not yet deleted with [**glDeleteProgram**](crate::context::Context::oxidegl_delete_program).
    /// If `program` is zero or a non-zero value that is not the name of a program
    /// object, or if an error occurs, [**glIsProgram**](crate::context::Context::oxidegl_is_program)
    /// returns [`GL_FALSE`](crate::enums::GL_FALSE).
    ///
    /// ### Notes
    /// No error is generated if `program` is not a valid program object name.
    ///
    /// A program object marked for deletion with [**glDeleteProgram**](crate::context::Context::oxidegl_delete_program)
    /// but still in use as part of current rendering state is still considered
    /// a program object and [**glIsProgram**](crate::context::Context::oxidegl_is_program)
    /// will return [`GL_TRUE`](crate::enums::GL_TRUE).
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with the argument [`GL_CURRENT_PROGRAM`](crate::enums::GL_CURRENT_PROGRAM)
    ///
    /// [**glGetActiveAttrib**](crate::context::Context::oxidegl_get_active_attrib)
    /// with arguments `program` and the index of an active attribute variable
    ///
    /// [**glGetActiveUniform**](crate::context::Context::oxidegl_get_active_uniform)
    /// with arguments `program` and the index of an active uniform variable
    ///
    /// [**glGetAttachedShaders**](crate::context::Context::oxidegl_get_attached_shaders)
    /// with argument `program`
    ///
    /// [**glGetAttribLocation**](crate::context::Context::oxidegl_get_attrib_location)
    /// with arguments `program` and the name of an attribute variable
    ///
    /// [**glGetProgram**](crate::context::Context::oxidegl_get_program) with arguments
    /// `program` and the parameter to be queried
    ///
    /// [**glGetProgramInfoLog**](crate::context::Context::oxidegl_get_program_info_log)
    /// with argument `program`
    ///
    /// [**glGetUniform**](crate::context::Context::oxidegl_get_uniform) with arguments
    /// `program` and the location of a uniform variable
    ///
    /// [**glGetUniformLocation**](crate::context::Context::oxidegl_get_uniform_location)
    /// with arguments `program` and the name of a uniform variable

    pub fn oxidegl_is_program(&mut self, program: GLuint) -> GLboolean {
        panic!("command oxidegl_is_program not yet implemented");
    }
    /// ### Parameters
    /// `pipeline`
    ///
    /// > Specifies a value that may be the name of a program pipeline object.
    ///
    /// ### Description
    /// [**glIsProgramPipeline**](crate::context::Context::oxidegl_is_program_pipeline)
    /// returns [`GL_TRUE`](crate::enums::GL_TRUE) if `pipeline` is currently the
    /// name of a program pipeline object. If `pipeline` is zero, or if [`pipeline`](crate::enums::pipeline)
    /// is not the name of a program pipeline object, or if an error occurs, [**glIsProgramPipeline**](crate::context::Context::oxidegl_is_program_pipeline)
    /// returns [`GL_FALSE`](crate::enums::GL_FALSE). If `pipeline` is a name returned
    /// by [**glGenProgramPipelines**](crate::context::Context::oxidegl_gen_program_pipelines),
    /// but that has not yet been bound through a call to [**glBindProgramPipeline**](crate::context::Context::oxidegl_bind_program_pipeline),
    /// then the name is not a program pipeline object and [**glIsProgramPipeline**](crate::context::Context::oxidegl_is_program_pipeline)
    /// returns [`GL_FALSE`](crate::enums::GL_FALSE).

    pub fn oxidegl_is_program_pipeline(&mut self, pipeline: GLuint) -> GLboolean {
        panic!("command oxidegl_is_program_pipeline not yet implemented");
    }
    /// ### Parameters
    /// `id`
    ///
    /// > Specifies a value that may be the name of a query object.
    ///
    /// ### Description
    /// [**glIsQuery**](crate::context::Context::oxidegl_is_query) returns [`GL_TRUE`](crate::enums::GL_TRUE)
    /// if `id` is currently the name of a query object. If `id` is zero, or is
    /// a non-zero value that is not currently the name of a query object, or if
    /// an error occurs, [**glIsQuery**](crate::context::Context::oxidegl_is_query)
    /// returns [`GL_FALSE`](crate::enums::GL_FALSE).
    ///
    /// A name returned by [**glGenQueries**](crate::context::Context::oxidegl_gen_queries),
    /// but not yet associated with a query object by calling [**glBeginQuery**](crate::context::Context::oxidegl_begin_query),
    /// is not the name of a query object.

    pub fn oxidegl_is_query(&mut self, id: GLuint) -> GLboolean {
        panic!("command oxidegl_is_query not yet implemented");
    }
    /// ### Parameters
    /// `renderbuffer`
    ///
    /// > Specifies a value that may be the name of a renderbuffer object.
    ///
    /// ### Description
    /// [**glIsRenderbuffer**](crate::context::Context::oxidegl_is_renderbuffer)
    /// returns [`GL_TRUE`](crate::enums::GL_TRUE) if `renderbuffer` is currently
    /// the name of a renderbuffer object. If `renderbuffer` is zero, or if `renderbuffer`
    /// is not the name of a renderbuffer object, or if an error occurs, [**glIsRenderbuffer**](crate::context::Context::oxidegl_is_renderbuffer)
    /// returns [`GL_FALSE`](crate::enums::GL_FALSE). If `renderbuffer` is a name
    /// returned by [**glGenRenderbuffers**](crate::context::Context::oxidegl_gen_renderbuffers),
    /// by that has not yet been bound through a call to [**glBindRenderbuffer**](crate::context::Context::oxidegl_bind_renderbuffer)
    /// or [**glFramebufferRenderbuffer**](crate::context::Context::oxidegl_framebuffer_renderbuffer),
    /// then the name is not a renderbuffer object and [**glIsRenderbuffer**](crate::context::Context::oxidegl_is_renderbuffer)
    /// returns [`GL_FALSE`](crate::enums::GL_FALSE).

    pub fn oxidegl_is_renderbuffer(&mut self, renderbuffer: GLuint) -> GLboolean {
        panic!("command oxidegl_is_renderbuffer not yet implemented");
    }
    /// ### Parameters
    /// `id`
    ///
    /// > Specifies a value that may be the name of a sampler object.
    ///
    /// ### Description
    /// [**glIsSampler**](crate::context::Context::oxidegl_is_sampler) returns
    /// [`GL_TRUE`](crate::enums::GL_TRUE) if `id` is currently the name of a sampler
    /// object. If `id` is zero, or is a non-zero value that is not currently the
    /// name of a sampler object, or if an error occurs, [**glIsSampler**](crate::context::Context::oxidegl_is_sampler)
    /// returns [`GL_FALSE`](crate::enums::GL_FALSE).
    ///
    /// A name returned by [**glGenSamplers**](crate::context::Context::oxidegl_gen_samplers),
    /// is the name of a sampler object.
    ///
    /// ### Notes
    /// [**glIsSampler**](crate::context::Context::oxidegl_is_sampler) is available
    /// only if the GL version is 3.3 or higher.

    pub fn oxidegl_is_sampler(&mut self, sampler: GLuint) -> GLboolean {
        panic!("command oxidegl_is_sampler not yet implemented");
    }
    /// ### Parameters
    /// `shader`
    ///
    /// > Specifies a potential shader object.
    ///
    /// ### Description
    /// [**glIsShader**](crate::context::Context::oxidegl_is_shader) returns [`GL_TRUE`](crate::enums::GL_TRUE)
    /// if `shader` is the name of a shader object previously created with [**glCreateShader**](crate::context::Context::oxidegl_create_shader)
    /// and not yet deleted with [**glDeleteShader**](crate::context::Context::oxidegl_delete_shader).
    /// If `shader` is zero or a non-zero value that is not the name of a shader
    /// object, or if an error occurs, [**glIsShader **](crate::context::Context::oxidegl_is_shader
    ///) returns [`GL_FALSE`](crate::enums::GL_FALSE).
    ///
    /// ### Notes
    /// No error is generated if `shader` is not a valid shader object name.
    ///
    /// A shader object marked for deletion with [**glDeleteShader**](crate::context::Context::oxidegl_delete_shader)
    /// but still attached to a program object is still considered a shader object
    /// and [**glIsShader**](crate::context::Context::oxidegl_is_shader) will return
    /// [`GL_TRUE`](crate::enums::GL_TRUE).
    ///
    /// ### Associated Gets
    /// [**glGetAttachedShaders**](crate::context::Context::oxidegl_get_attached_shaders)
    /// with a valid program object
    ///
    /// [**glGetShader**](crate::context::Context::oxidegl_get_shader) with arguments
    /// `shader` and a parameter to be queried
    ///
    /// [**glGetShaderInfoLog**](crate::context::Context::oxidegl_get_shader_info_log)
    /// with argument `object`
    ///
    /// [**glGetShaderSource**](crate::context::Context::oxidegl_get_shader_source)
    /// with argument `object`

    pub fn oxidegl_is_shader(&mut self, shader: GLuint) -> GLboolean {
        panic!("command oxidegl_is_shader not yet implemented");
    }
    /// ### Parameters
    /// `sync`
    ///
    /// > Specifies a value that may be the name of a sync object.
    ///
    /// ### Description
    /// [**glIsSync**](crate::context::Context::oxidegl_is_sync) returns [`GL_TRUE`](crate::enums::GL_TRUE)
    /// if `sync` is currently the name of a sync object. If `sync` is not the
    /// name of a sync object, or if an error occurs, [**glIsSync**](crate::context::Context::oxidegl_is_sync)
    /// returns [`GL_FALSE`](crate::enums::GL_FALSE). Note that zero is not the
    /// name of a sync object.
    ///
    /// ### Notes
    /// [**glIsSync**](crate::context::Context::oxidegl_is_sync) is available only
    /// if the GL version is 3.2 or greater.

    pub fn oxidegl_is_sync(&mut self, sync: GLsync) -> GLboolean {
        panic!("command oxidegl_is_sync not yet implemented");
    }
    /// ### Parameters
    /// `texture`
    ///
    /// > Specifies a value that may be the name of a texture.
    ///
    /// ### Description
    /// [**glIsTexture**](crate::context::Context::oxidegl_is_texture) returns
    /// [`GL_TRUE`](crate::enums::GL_TRUE) if `texture` is currently the name of
    /// a texture. If `texture` is zero, or is a non-zero value that is not currently
    /// the name of a texture, or if an error occurs, [**glIsTexture**](crate::context::Context::oxidegl_is_texture)
    /// returns [`GL_FALSE`](crate::enums::GL_FALSE).
    ///
    /// A name returned by [**glGenTextures**](crate::context::Context::oxidegl_gen_textures),
    /// but not yet associated with a texture by calling [**glBindTexture**](crate::context::Context::oxidegl_bind_texture),
    /// is not the name of a texture.

    pub fn oxidegl_is_texture(&mut self, texture: GLuint) -> GLboolean {
        panic!("command oxidegl_is_texture not yet implemented");
    }
    /// ### Parameters
    /// `id`
    ///
    /// > Specifies a value that may be the name of a transform feedback object.
    ///
    /// ### Description
    /// [**glIsTransformFeedback**](crate::context::Context::oxidegl_is_transform_feedback)
    /// returns [`GL_TRUE`](crate::enums::GL_TRUE) if `id` is currently the name
    /// of a transform feedback object. If `id` is zero, or if [`id`](crate::enums::id)
    /// is not the name of a transform feedback object, or if an error occurs,
    /// [**glIsTransformFeedback**](crate::context::Context::oxidegl_is_transform_feedback)
    /// returns [`GL_FALSE`](crate::enums::GL_FALSE). If `id` is a name returned
    /// by [**glGenTransformFeedbacks**](crate::context::Context::oxidegl_gen_transform_feedbacks),
    /// but that has not yet been bound through a call to [**glBindTransformFeedback**](crate::context::Context::oxidegl_bind_transform_feedback),
    /// then the name is not a transform feedback object and [**glIsTransformFeedback**](crate::context::Context::oxidegl_is_transform_feedback)
    /// returns [`GL_FALSE`](crate::enums::GL_FALSE).

    pub fn oxidegl_is_transform_feedback(&mut self, id: GLuint) -> GLboolean {
        panic!("command oxidegl_is_transform_feedback not yet implemented");
    }

    /// ### Parameters
    /// `width`
    ///
    /// > Specifies the width of rasterized lines. The initial value is 1.
    ///
    /// ### Description
    /// [**glLineWidth**](crate::context::Context::oxidegl_line_width) specifies
    /// the rasterized width of both aliased and antialiased lines. Using a line
    /// width other than 1 has different effects, depending on whether line antialiasing
    /// is enabled. To enable and disable line antialiasing, call [**glEnable**](crate::context::Context::oxidegl_enable)
    /// and [**glDisable**](crate::context::Context::oxidegl_disable) with argument
    /// [`GL_LINE_SMOOTH`](crate::enums::GL_LINE_SMOOTH). Line antialiasing is
    /// initially disabled.
    ///
    /// If line antialiasing is disabled, the actual width is determined by rounding
    /// the supplied width to the nearest integer. (If the rounding results in
    /// the value 0, it is as if the line width were 1.) If `[inlineq]` *i* pixels
    /// are filled in each column that is rasterized, where *i* is the rounded
    /// value of `width`. Otherwise, *i* pixels are filled in each row that is
    /// rasterized.
    ///
    /// If antialiasing is enabled, line rasterization produces a fragment for
    /// each pixel square that intersects the region lying within the rectangle
    /// having width equal to the current line width, length equal to the actual
    /// length of the line, and centered on the mathematical line segment. The
    /// coverage value for each fragment is the window coordinate area of the intersection
    /// of the rectangular region with the corresponding pixel square. This value
    /// is saved and used in the final rasterization step.
    ///
    /// Not all widths can be supported when line antialiasing is enabled. If an
    /// unsupported width is requested, the nearest supported width is used. Only
    /// width 1 is guaranteed to be supported; others depend on the implementation.
    /// Likewise, there is a range for aliased line widths as well. To query the
    /// range of supported widths and the size difference between supported widths
    /// within the range, call [**glGet**](crate::context::Context::oxidegl_get)
    /// with arguments [`GL_ALIASED_LINE_WIDTH_RANGE`](crate::enums::GL_ALIASED_LINE_WIDTH_RANGE),
    /// [`GL_SMOOTH_LINE_WIDTH_RANGE`](crate::enums::GL_SMOOTH_LINE_WIDTH_RANGE),
    /// and [`GL_SMOOTH_LINE_WIDTH_GRANULARITY`](crate::enums::GL_SMOOTH_LINE_WIDTH_GRANULARITY).
    ///
    /// ### Notes
    /// The line width specified by [**glLineWidth**](crate::context::Context::oxidegl_line_width)
    /// is always returned when [`GL_LINE_WIDTH`](crate::enums::GL_LINE_WIDTH)
    /// is queried. Clamping and rounding for aliased and antialiased lines have
    /// no effect on the specified value.
    ///
    /// Nonantialiased line width may be clamped to an implementation-dependent
    /// maximum. Call [**glGet**](crate::context::Context::oxidegl_get) with [`GL_ALIASED_LINE_WIDTH_RANGE`](crate::enums::GL_ALIASED_LINE_WIDTH_RANGE)
    /// to determine the maximum width.
    ///
    /// In OpenGL 1.2, the tokens [`GL_LINE_WIDTH_RANGE`](crate::enums::GL_LINE_WIDTH_RANGE)
    /// and [`GL_LINE_WIDTH_GRANULARITY`](crate::enums::GL_LINE_WIDTH_GRANULARITY)
    /// were replaced by [`GL_ALIASED_LINE_WIDTH_RANGE`](crate::enums::GL_ALIASED_LINE_WIDTH_RANGE),
    /// [`GL_SMOOTH_LINE_WIDTH_RANGE`](crate::enums::GL_SMOOTH_LINE_WIDTH_RANGE),
    /// and [`GL_SMOOTH_LINE_WIDTH_GRANULARITY`](crate::enums::GL_SMOOTH_LINE_WIDTH_GRANULARITY).
    /// The old names are retained for backward compatibility, but should not
    /// be used in new code.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_LINE_WIDTH`](crate::enums::GL_LINE_WIDTH)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_ALIASED_LINE_WIDTH_RANGE`](crate::enums::GL_ALIASED_LINE_WIDTH_RANGE)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_SMOOTH_LINE_WIDTH_RANGE`](crate::enums::GL_SMOOTH_LINE_WIDTH_RANGE)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_SMOOTH_LINE_WIDTH_GRANULARITY`](crate::enums::GL_SMOOTH_LINE_WIDTH_GRANULARITY)
    ///
    /// [**glIsEnabled**](crate::context::Context::oxidegl_is_enabled) with argument
    /// [`GL_LINE_SMOOTH`](crate::enums::GL_LINE_SMOOTH)

    pub fn oxidegl_line_width(&mut self, width: GLfloat) {
        panic!("command oxidegl_line_width not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the handle of the program object to be linked.
    ///
    /// ### Description
    /// [**glLinkProgram**](crate::context::Context::oxidegl_link_program) links
    /// the program object specified by `program`. If any shader objects of type
    /// [`GL_VERTEX_SHADER`](crate::enums::GL_VERTEX_SHADER) are attached to `program`,
    /// they will be used to create an executable that will run on the programmable
    /// vertex processor. If any shader objects of type [`GL_GEOMETRY_SHADER`](crate::enums::GL_GEOMETRY_SHADER)
    /// are attached to `program`, they will be used to create an executable that
    /// will run on the programmable geometry processor. If any shader objects
    /// of type [`GL_FRAGMENT_SHADER`](crate::enums::GL_FRAGMENT_SHADER) are attached
    /// to `program`, they will be used to create an executable that will run on
    /// the programmable fragment processor.
    ///
    /// The status of the link operation will be stored as part of the program
    /// object's state. This value will be set to [`GL_TRUE`](crate::enums::GL_TRUE)
    /// if the program object was linked without errors and is ready for use, and
    /// [`GL_FALSE`](crate::enums::GL_FALSE) otherwise. It can be queried by calling
    /// [**glGetProgram**](crate::context::Context::oxidegl_get_program) with arguments
    /// `program` and [`GL_LINK_STATUS`](crate::enums::GL_LINK_STATUS).
    ///
    /// As a result of a successful link operation, all active user-defined uniform
    /// variables belonging to `program` will be initialized to 0, and each of
    /// the program object's active uniform variables will be assigned a location
    /// that can be queried by calling [**glGetUniformLocation**](crate::context::Context::oxidegl_get_uniform_location).
    /// Also, any active user-defined attribute variables that have not been bound
    /// to a generic vertex attribute index will be bound to one at this time.
    ///
    /// Linking of a program object can fail for a number of reasons as specified
    /// in the *OpenGL Shading Language Specification*. The following lists some
    /// of the conditions that will cause a link error.
    ///
    /// > The number of active attribute variables supported by the implementation
    /// > has been exceeded.
    ///
    /// > The storage limit for uniform variables has been exceeded.
    ///
    /// > The number of active uniform variables supported by the implementation
    /// > has been exceeded.
    ///
    /// > The [**main**](crate::context::Context::oxidemain) function is missing
    /// > for the vertex, geometry or fragment shader.
    ///
    /// > A varying variable actually used in the fragment shader is not declared
    /// > in the same way (or is not declared at all) in the vertex shader, or geometry
    /// > shader if present.
    ///
    /// > A reference to a function or variable name is unresolved.
    ///
    /// > A shared global is declared with two different types or two different initial
    /// > values.
    ///
    /// > One or more of the attached shader objects has not been successfully compiled.
    ///
    /// > Binding a generic attribute matrix caused some rows of the matrix to fall
    /// > outside the allowed maximum of [`GL_MAX_VERTEX_ATTRIBS`](crate::enums::GL_MAX_VERTEX_ATTRIBS).
    ///
    /// > Not enough contiguous vertex attribute slots could be found to bind attribute
    /// > matrices.
    ///
    /// > The program object contains objects to form a fragment shader but does
    /// > not contain objects to form a vertex shader.
    ///
    /// > The program object contains objects to form a geometry shader but does
    /// > not contain objects to form a vertex shader.
    ///
    /// > The program object contains objects to form a geometry shader and the input
    /// > primitive type, output primitive type, or maximum output vertex count is
    /// > not specified in any compiled geometry shader object.
    ///
    /// > The program object contains objects to form a geometry shader and the input
    /// > primitive type, output primitive type, or maximum output vertex count is
    /// > specified differently in multiple geometry shader objects.
    ///
    /// > The number of active outputs in the fragment shader is greater than the
    /// > value of [`GL_MAX_DRAW_BUFFERS`](crate::enums::GL_MAX_DRAW_BUFFERS).
    ///
    /// > The program has an active output assigned to a location greater than or
    /// > equal to the value of [`GL_MAX_DUAL_SOURCE_DRAW_BUFFERS`](crate::enums::GL_MAX_DUAL_SOURCE_DRAW_BUFFERS)
    /// > and has an active output assigned an index greater than or equal to one.
    ///
    /// > More than one varying out variable is bound to the same number and index.
    ///
    /// > The explicit binding assigments do not leave enough space for the linker
    /// > to automatically assign a location for a varying out array, which requires
    /// > multiple contiguous locations.
    ///
    /// > The `count` specified by [**glTransformFeedbackVaryings**](crate::context::Context::oxidegl_transform_feedback_varyings)
    /// > is non-zero, but the program object has no vertex or geometry shader.
    ///
    /// > Any variable name specified to [**glTransformFeedbackVaryings**](crate::context::Context::oxidegl_transform_feedback_varyings)
    /// > in the `varyings` array is not declared as an output in the vertex shader
    /// > (or the geometry shader, if active).
    ///
    /// > Any two entries in the `varyings` array given [**glTransformFeedbackVaryings**](crate::context::Context::oxidegl_transform_feedback_varyings)
    /// > specify the same varying variable.
    ///
    /// > The total number of components to capture in any transform feedback varying
    /// > variable is greater than the constant [`GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS`](crate::enums::GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS)
    /// > and the buffer mode is [`GL_SEPARATE_ATTRIBS`](crate::enums::GL_SEPARATE_ATTRIBS).
    ///
    /// When a program object has been successfully linked, the program object
    /// can be made part of current state by calling [**glUseProgram**](crate::context::Context::oxidegl_use_program).
    /// Whether or not the link operation was successful, the program object's
    /// information log will be overwritten. The information log can be retrieved
    /// by calling [**glGetProgramInfoLog**](crate::context::Context::oxidegl_get_program_info_log).
    ///
    /// [**glLinkProgram**](crate::context::Context::oxidegl_link_program) will
    /// also install the generated executables as part of the current rendering
    /// state if the link operation was successful and the specified program object
    /// is already currently in use as a result of a previous call to [**glUseProgram**](crate::context::Context::oxidegl_use_program).
    /// If the program object currently in use is relinked unsuccessfully, its
    /// link status will be set to [`GL_FALSE`](crate::enums::GL_FALSE), but the
    /// executables and associated state will remain part of the current state
    /// until a subsequent call to [**glUseProgram**](crate::context::Context::oxidegl_use_program)
    /// removes it from use. After it is removed from use, it cannot be made part
    /// of current state until it has been successfully relinked.
    ///
    /// If `program` contains shader objects of type [`GL_VERTEX_SHADER`](crate::enums::GL_VERTEX_SHADER),
    /// and optionally of type [`GL_GEOMETRY_SHADER`](crate::enums::GL_GEOMETRY_SHADER),
    /// but does not contain shader objects of type [`GL_FRAGMENT_SHADER`](crate::enums::GL_FRAGMENT_SHADER),
    /// the vertex shader executable will be installed on the programmable vertex
    /// processor, the geometry shader executable, if present, will be installed
    /// on the programmable geometry processor, but no executable will be installed
    /// on the fragment processor. The results of rasterizing primitives with such
    /// a program will be undefined.
    ///
    /// The program object's information log is updated and the program is generated
    /// at the time of the link operation. After the link operation, applications
    /// are free to modify attached shader objects, compile attached shader objects,
    /// detach shader objects, delete shader objects, and attach additional shader
    /// objects. None of these operations affects the information log or the program
    /// that is part of the program object.
    ///
    /// ### Notes
    /// If the link operation is unsuccessful, any information about a previous
    /// link operation on `program` is lost (i.e., a failed link does not restore
    /// the old state of `program` ). Certain information can still be retrieved
    /// from `program` even after an unsuccessful link operation. See for instance
    /// [**glGetActiveAttrib**](crate::context::Context::oxidegl_get_active_attrib)
    /// and [**glGetActiveUniform**](crate::context::Context::oxidegl_get_active_uniform).
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with the argument [`GL_CURRENT_PROGRAM`](crate::enums::GL_CURRENT_PROGRAM)
    ///
    /// [**glGetActiveAttrib**](crate::context::Context::oxidegl_get_active_attrib)
    /// with argument `program` and the index of an active attribute variable
    ///
    /// [**glGetActiveUniform**](crate::context::Context::oxidegl_get_active_uniform)
    /// with argument `program` and the index of an active uniform variable
    ///
    /// [**glGetAttachedShaders**](crate::context::Context::oxidegl_get_attached_shaders)
    /// with argument `program`
    ///
    /// [**glGetAttribLocation**](crate::context::Context::oxidegl_get_attrib_location)
    /// with argument `program` and an attribute variable name
    ///
    /// [**glGetProgram**](crate::context::Context::oxidegl_get_program) with arguments
    /// `program` and [`GL_LINK_STATUS`](crate::enums::GL_LINK_STATUS)
    ///
    /// [**glGetProgramInfoLog**](crate::context::Context::oxidegl_get_program_info_log)
    /// with argument `program`
    ///
    /// [**glGetUniform**](crate::context::Context::oxidegl_get_uniform) with argument
    /// `program` and a uniform variable location
    ///
    /// [**glGetUniformLocation**](crate::context::Context::oxidegl_get_uniform_location)
    /// with argument `program` and a uniform variable name
    ///
    /// [**glIsProgram**](crate::context::Context::oxidegl_is_program)

    pub fn oxidegl_link_program(&mut self, program: GLuint) {
        panic!("command oxidegl_link_program not yet implemented");
    }
    /// ### Parameters
    /// `opcode`
    ///
    /// > Specifies a symbolic constant that selects a logical operation. The following
    /// > symbols are accepted: [`GL_CLEAR`](crate::enums::GL_CLEAR), [`GL_SET`](crate::enums::GL_SET),
    /// > [`GL_COPY`](crate::enums::GL_COPY), [`GL_COPY_INVERTED`](crate::enums::GL_COPY_INVERTED),
    /// > [`GL_NOOP`](crate::enums::GL_NOOP), [`GL_INVERT`](crate::enums::GL_INVERT),
    /// > [`GL_AND`](crate::enums::GL_AND), [`GL_NAND`](crate::enums::GL_NAND), [`GL_OR`](crate::enums::GL_OR),
    /// > [`GL_NOR`](crate::enums::GL_NOR), [`GL_XOR`](crate::enums::GL_XOR), [`GL_EQUIV`](crate::enums::GL_EQUIV),
    /// > [`GL_AND_REVERSE`](crate::enums::GL_AND_REVERSE), [`GL_AND_INVERTED`](crate::enums::GL_AND_INVERTED),
    /// > [`GL_OR_REVERSE`](crate::enums::GL_OR_REVERSE), and [`GL_OR_INVERTED`](crate::enums::GL_OR_INVERTED).
    /// > The initial value is [`GL_COPY`](crate::enums::GL_COPY).
    ///
    /// ### Description
    /// [**glLogicOp**](crate::context::Context::oxidegl_logic_op) specifies a
    /// logical operation that, when enabled, is applied between the incoming RGBA
    /// color and the RGBA color at the corresponding location in the frame buffer.
    /// To enable or disable the logical operation, call [**glEnable**](crate::context::Context::oxidegl_enable)
    /// and [**glDisable**](crate::context::Context::oxidegl_disable) using the
    /// symbolic constant [`GL_COLOR_LOGIC_OP`](crate::enums::GL_COLOR_LOGIC_OP).
    /// The initial value is disabled.
    ///
    ///
    /// |* Opcode*      |* Resulting Operation*                              |
    /// |---------------|----------------------------------------------------|
    /// | [`GL_CLEAR`](crate::enums::GL_CLEAR) | 0                           |
    /// | [`GL_SET`](crate::enums::GL_SET) | 1                               |
    /// | [`GL_COPY`](crate::enums::GL_COPY) | s                             |
    /// | [`GL_COPY_INVERTED`](crate::enums::GL_COPY_INVERTED) | ~s          |
    /// | [`GL_NOOP`](crate::enums::GL_NOOP) | d                             |
    /// | [`GL_INVERT`](crate::enums::GL_INVERT) | ~d                        |
    /// | [`GL_AND`](crate::enums::GL_AND) | s& d                            |
    /// | [`GL_NAND`](crate::enums::GL_NAND) | ~(s& d)                       |
    /// | [`GL_OR`](crate::enums::GL_OR) | s| d                              |
    /// | [`GL_NOR`](crate::enums::GL_NOR) | ~(s| d)                         |
    /// | [`GL_XOR`](crate::enums::GL_XOR) | s^ d                            |
    /// | [`GL_EQUIV`](crate::enums::GL_EQUIV) | ~(s^ d)                     |
    /// | [`GL_AND_REVERSE`](crate::enums::GL_AND_REVERSE) | s& ~d           |
    /// | [`GL_AND_INVERTED`](crate::enums::GL_AND_INVERTED) | ~s& d         |
    /// | [`GL_OR_REVERSE`](crate::enums::GL_OR_REVERSE) | s| ~d             |
    /// | [`GL_OR_INVERTED`](crate::enums::GL_OR_INVERTED) | ~s| d           |
    ///
    /// `opcode` is a symbolic constant chosen from the list above. In the explanation
    /// of the logical operations, *s* represents the incoming color and *d* represents
    /// the color in the frame buffer. Standard C-language operators are used.
    /// As these bitwise operators suggest, the logical operation is applied independently
    /// to each bit pair of the source and destination colors.
    ///
    /// ### Notes
    /// When more than one RGBA color buffer is enabled for drawing, logical operations
    /// are performed separately for each enabled buffer, using for the destination
    /// value the contents of that buffer (see [**glDrawBuffer**](crate::context::Context::oxidegl_draw_buffer)
    /// ).
    ///
    /// Logic operations have no effect on floating point draw buffers. However,
    /// if [`GL_COLOR_LOGIC_OP`](crate::enums::GL_COLOR_LOGIC_OP) is enabled, blending
    /// is still disabled in this case.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_LOGIC_OP_MODE`](crate::enums::GL_LOGIC_OP_MODE).
    ///
    /// [**glIsEnabled**](crate::context::Context::oxidegl_is_enabled) with argument
    /// [`GL_COLOR_LOGIC_OP`](crate::enums::GL_COLOR_LOGIC_OP).

    pub fn oxidegl_logic_op(&mut self, opcode: LogicOp) {
        panic!("command oxidegl_logic_op not yet implemented");
    }
    /// ### Parameters
    /// `value`
    ///
    /// > Specifies the rate at which samples are shaded within each covered pixel.
    ///
    /// ### Description
    /// [**glMinSampleShading**](crate::context::Context::oxidegl_min_sample_shading)
    /// specifies the rate at which samples are shaded within a covered pixel.
    /// Sample-rate shading is enabled by calling [**glEnable**](crate::context::Context::oxidegl_enable)
    /// with the parameter [`GL_SAMPLE_SHADING`](crate::enums::GL_SAMPLE_SHADING).
    /// If [`GL_MULTISAMPLE`](crate::enums::GL_MULTISAMPLE) or [`GL_SAMPLE_SHADING`](crate::enums::GL_SAMPLE_SHADING)
    /// is disabled, sample shading has no effect. Otherwise, an implementation
    /// must provide at least as many unique color values for each covered fragment
    /// as specified by `value` times `samples` where `samples` is the value of
    /// [`GL_SAMPLES`](crate::enums::GL_SAMPLES) for the current framebuffer. At
    /// least 1 sample for each covered fragment is generated.
    ///
    /// A `value` of 1.0 indicates that each sample in the framebuffer should be
    /// independently shaded. A `value` of 0.0 effectively allows the GL to ignore
    /// sample rate shading. Any value between 0.0 and 1.0 allows the GL to shade
    /// only a subset of the total samples within each covered fragment. Which
    /// samples are shaded and the algorithm used to select that subset of the
    /// fragment's samples is implementation dependent.
    ///
    /// ### Notes
    /// The type of the `value` parameter was changed from `GLclampf` to `GLfloat`.
    /// This change is transparent to user code and is described in detail on the
    /// [**removedTypes**](crate::context::Context::oxideremoved_types) page.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MIN_SAMPLE_SHADING`](crate::enums::GL_MIN_SAMPLE_SHADING).
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_SAMPLES`](crate::enums::GL_SAMPLES).

    pub fn oxidegl_min_sample_shading(&mut self, value: GLfloat) {
        panic!("command oxidegl_min_sample_shading not yet implemented");
    }
    /// ### Parameters
    /// `mode`
    ///
    /// > Specifies what kind of primitives to render. Symbolic constants [`GL_POINTS`](crate::enums::GL_POINTS),
    /// > [`GL_LINE_STRIP`](crate::enums::GL_LINE_STRIP), [`GL_LINE_LOOP`](crate::enums::GL_LINE_LOOP),
    /// > [`GL_LINES`](crate::enums::GL_LINES), [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY),
    /// > [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY), [`GL_TRIANGLE_STRIP`](crate::enums::GL_TRIANGLE_STRIP),
    /// > [`GL_TRIANGLE_FAN`](crate::enums::GL_TRIANGLE_FAN), [`GL_TRIANGLES`](crate::enums::GL_TRIANGLES),
    /// > [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY),
    /// > [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY) and [`GL_PATCHES`](crate::enums::GL_PATCHES)
    /// > are accepted.
    ///
    /// `first`
    ///
    /// > Points to an array of starting indices in the enabled arrays.
    ///
    /// `count`
    ///
    /// > Points to an array of the number of indices to be rendered.
    ///
    /// `drawcount`
    ///
    /// > Specifies the size of the first and count
    ///
    /// ### Description
    /// [**glMultiDrawArrays**](crate::context::Context::oxidegl_multi_draw_arrays)
    /// specifies multiple sets of geometric primitives with very few subroutine
    /// calls. Instead of calling a GL procedure to pass each individual vertex,
    /// normal, texture coordinate, edge flag, or color, you can prespecify separate
    /// arrays of vertices, normals, and colors and use them to construct a sequence
    /// of primitives with a single call to [**glMultiDrawArrays**](crate::context::Context::oxidegl_multi_draw_arrays).
    ///
    /// [**glMultiDrawArrays**](crate::context::Context::oxidegl_multi_draw_arrays)
    /// behaves identically to [**glDrawArrays**](crate::context::Context::oxidegl_draw_arrays)
    /// except that `drawcount` separate ranges of elements are specified instead.
    ///
    /// When [**glMultiDrawArrays**](crate::context::Context::oxidegl_multi_draw_arrays)
    /// is called, it uses `count` sequential elements from each enabled array
    /// to construct a sequence of geometric primitives, beginning with element
    /// `first`. `mode` specifies what kind of primitives are constructed, and
    /// how the array elements construct those primitives.
    ///
    /// Vertex attributes that are modified by [**glMultiDrawArrays**](crate::context::Context::oxidegl_multi_draw_arrays)
    /// have an unspecified value after [**glMultiDrawArrays**](crate::context::Context::oxidegl_multi_draw_arrays)
    /// returns. Attributes that aren't modified remain well defined.
    ///
    /// ### Notes
    /// [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY), [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY),
    /// [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY)
    /// and [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY) are
    /// available only if the GL version is 3.2 or greater.

    pub unsafe fn oxidegl_multi_draw_arrays(
        &mut self,
        mode: PrimitiveType,
        first: *const GLint,
        count: *const GLsizei,
        drawcount: GLsizei,
    ) {
        panic!("command oxidegl_multi_draw_arrays not yet implemented");
    }
    /// ### Parameters
    /// `mode`
    ///
    /// > Specifies what kind of primitives to render. Symbolic constants [`GL_POINTS`](crate::enums::GL_POINTS),
    /// > [`GL_LINE_STRIP`](crate::enums::GL_LINE_STRIP), [`GL_LINE_LOOP`](crate::enums::GL_LINE_LOOP),
    /// > [`GL_LINES`](crate::enums::GL_LINES), [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY),
    /// > [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY), [`GL_TRIANGLE_STRIP`](crate::enums::GL_TRIANGLE_STRIP),
    /// > [`GL_TRIANGLE_FAN`](crate::enums::GL_TRIANGLE_FAN), [`GL_TRIANGLES`](crate::enums::GL_TRIANGLES),
    /// > [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY),
    /// > [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY), and [`GL_PATCHES`](crate::enums::GL_PATCHES)
    /// > are accepted.
    ///
    /// `indirect`
    ///
    /// > Specifies the address of an array of structures containing the draw parameters.
    ///
    /// `drawcount`
    ///
    /// > Specifies the number of elements in the array of draw parameter structures.
    ///
    /// `stride`
    ///
    /// > Specifies the distance in basic machine units between elements of the draw
    /// > parameter array.
    ///
    /// ### Description
    /// [**glMultiDrawArraysIndirect**](crate::context::Context::oxidegl_multi_draw_arrays_indirect)
    /// specifies multiple geometric primitives with very few subroutine calls.
    /// [**glMultiDrawArraysIndirect**](crate::context::Context::oxidegl_multi_draw_arrays_indirect)
    /// behaves similarly to a multitude of calls to [**glDrawArraysInstancedBaseInstance**](crate::context::Context::oxidegl_draw_arrays_instanced_base_instance),
    /// execept that the parameters to each call to [**glDrawArraysInstancedBaseInstance**](crate::context::Context::oxidegl_draw_arrays_instanced_base_instance)
    /// are stored in an array in memory at the address given by `indirect`, separated
    /// by the stride, in basic machine units, specified by `stride`. If `stride`
    /// is zero, then the array is assumed to be tightly packed in memory.
    ///
    /// The parameters addressed by `indirect` are packed into an array of structures,
    /// each element of which takes the form (in C):
    ///
    /// A single call to [**glMultiDrawArraysIndirect**](crate::context::Context::oxidegl_multi_draw_arrays_indirect)
    /// is equivalent, assuming no errors are generated to:
    ///
    /// If a buffer is bound to the [`GL_DRAW_INDIRECT_BUFFER`](crate::enums::GL_DRAW_INDIRECT_BUFFER)
    /// binding at the time of a call to [**glMultiDrawArraysIndirect**](crate::context::Context::oxidegl_multi_draw_arrays_indirect),
    /// `indirect` is interpreted as an offset, in basic machine units, into that
    /// buffer and the parameter data is read from the buffer rather than from
    /// client memory.
    ///
    /// In contrast to [**glDrawArraysInstancedBaseInstance**](crate::context::Context::oxidegl_draw_arrays_instanced_base_instance),
    /// the
    ///
    /// Vertex attributes that are modified by [**glMultiDrawArraysIndirect**](crate::context::Context::oxidegl_multi_draw_arrays_indirect)
    /// have an unspecified value after [**glMultiDrawArraysIndirect**](crate::context::Context::oxidegl_multi_draw_arrays_indirect)
    /// returns. Attributes that aren't modified remain well defined.
    ///
    /// ### Notes
    /// The `baseInstance` member of the `DrawArraysIndirectCommand` structure
    /// is defined only if the GL version is 4.2 or greater. For versions of the
    /// GL less than 4.2, this parameter is present but is reserved and should
    /// be set to zero. On earlier versions of the GL, behavior is undefined if
    /// it is non-zero.
    ///
    /// [**glMultiDrawArraysIndirect**](crate::context::Context::oxidegl_multi_draw_arrays_indirect)
    /// is available only if the GL version is 4.3 or greater.

    pub unsafe fn oxidegl_multi_draw_arrays_indirect(
        &mut self,
        mode: PrimitiveType,
        indirect: *const GLvoid,
        drawcount: GLsizei,
        stride: GLsizei,
    ) {
        panic!("command oxidegl_multi_draw_arrays_indirect not yet implemented");
    }
    /// ### Parameters
    /// `mode`
    ///
    /// > Specifies what kind of primitives to render. Symbolic constants [`GL_POINTS`](crate::enums::GL_POINTS),
    /// > [`GL_LINE_STRIP`](crate::enums::GL_LINE_STRIP), [`GL_LINE_LOOP`](crate::enums::GL_LINE_LOOP),
    /// > [`GL_LINES`](crate::enums::GL_LINES), [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY),
    /// > [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY), [`GL_TRIANGLE_STRIP`](crate::enums::GL_TRIANGLE_STRIP),
    /// > [`GL_TRIANGLE_FAN`](crate::enums::GL_TRIANGLE_FAN), [`GL_TRIANGLES`](crate::enums::GL_TRIANGLES),
    /// > [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY),
    /// > [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY) and [`GL_PATCHES`](crate::enums::GL_PATCHES)
    /// > are accepted.
    ///
    /// `count`
    ///
    /// > Points to an array of the elements counts.
    ///
    /// `type`
    ///
    /// > Specifies the type of the values in `indices`. Must be one of [`GL_UNSIGNED_BYTE`](crate::enums::GL_UNSIGNED_BYTE),
    /// > [`GL_UNSIGNED_SHORT`](crate::enums::GL_UNSIGNED_SHORT), or [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT).
    ///
    /// `indices`
    ///
    /// > Specifies a pointer to the location where the indices are stored.
    ///
    /// `drawcount`
    ///
    /// > Specifies the size of the `count` and `indices` arrays.
    ///
    /// ### Description
    /// [**glMultiDrawElements**](crate::context::Context::oxidegl_multi_draw_elements)
    /// specifies multiple sets of geometric primitives with very few subroutine
    /// calls. Instead of calling a GL function to pass each individual vertex,
    /// normal, texture coordinate, edge flag, or color, you can prespecify separate
    /// arrays of vertices, normals, and so on, and use them to construct a sequence
    /// of primitives with a single call to [**glMultiDrawElements**](crate::context::Context::oxidegl_multi_draw_elements).
    ///
    /// [**glMultiDrawElements**](crate::context::Context::oxidegl_multi_draw_elements)
    /// is identical in operation to [**glDrawElements**](crate::context::Context::oxidegl_draw_elements)
    /// except that `drawcount` separate lists of elements are specified.
    ///
    /// Vertex attributes that are modified by [**glMultiDrawElements**](crate::context::Context::oxidegl_multi_draw_elements)
    /// have an unspecified value after [**glMultiDrawElements**](crate::context::Context::oxidegl_multi_draw_elements)
    /// returns. Attributes that aren't modified maintain their previous values.
    ///
    /// ### Notes
    /// [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY), [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY),
    /// [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY)
    /// and [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY) are
    /// available only if the GL version is 3.2 or greater.

    pub unsafe fn oxidegl_multi_draw_elements(
        &mut self,
        mode: PrimitiveType,
        count: *const GLsizei,
        r#type: DrawElementsType,
        indices: *mut *const GLvoid,
        drawcount: GLsizei,
    ) {
        panic!("command oxidegl_multi_draw_elements not yet implemented");
    }
    /// ### Parameters
    /// `mode`
    ///
    /// > Specifies what kind of primitives to render. Symbolic constants [`GL_POINTS`](crate::enums::GL_POINTS),
    /// > [`GL_LINE_STRIP`](crate::enums::GL_LINE_STRIP), [`GL_LINE_LOOP`](crate::enums::GL_LINE_LOOP),
    /// > [`GL_LINES`](crate::enums::GL_LINES), [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY),
    /// > [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY), [`GL_TRIANGLE_STRIP`](crate::enums::GL_TRIANGLE_STRIP),
    /// > [`GL_TRIANGLE_FAN`](crate::enums::GL_TRIANGLE_FAN), [`GL_TRIANGLES`](crate::enums::GL_TRIANGLES),
    /// > [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY),
    /// > [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY) and [`GL_PATCHES`](crate::enums::GL_PATCHES)
    /// > are accepted.
    ///
    /// `count`
    ///
    /// > Points to an array of the elements counts.
    ///
    /// `type`
    ///
    /// > Specifies the type of the values in `indices`. Must be one of [`GL_UNSIGNED_BYTE`](crate::enums::GL_UNSIGNED_BYTE),
    /// > [`GL_UNSIGNED_SHORT`](crate::enums::GL_UNSIGNED_SHORT), or [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT).
    ///
    /// `indices`
    ///
    /// > Specifies a pointer to the location where the indices are stored.
    ///
    /// `drawcount`
    ///
    /// > Specifies the size of the `count`, `indices` and `basevertex` arrays.
    ///
    /// `basevertex`
    ///
    /// > Specifies a pointer to the location where the base vertices are stored.
    ///
    /// ### Description
    /// [**glMultiDrawElementsBaseVertex**](crate::context::Context::oxidegl_multi_draw_elements_base_vertex)
    /// behaves identically to [**glDrawElementsBaseVertex**](crate::context::Context::oxidegl_draw_elements_base_vertex),
    /// except that `drawcount` separate lists of elements are specifried instead.
    ///
    /// It has the same effect as: `drawcount`; i++) if( `count` \[i\]> 0) glDrawElementsBaseVertex(
    /// `mode`, `count` \[i\], `type`, `indices[i]`, `basevertex[i]` );
    ///
    /// ### Notes
    /// [**glMultiDrawElementsBaseVertex**](crate::context::Context::oxidegl_multi_draw_elements_base_vertex)
    /// is available only if the GL version is 3.1 or greater.
    ///
    /// [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY), [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY),
    /// [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY)
    /// and [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY) are
    /// available only if the GL version is 3.2 or greater.

    pub unsafe fn oxidegl_multi_draw_elements_base_vertex(
        &mut self,
        mode: PrimitiveType,
        count: *const GLsizei,
        r#type: DrawElementsType,
        indices: *mut *const GLvoid,
        drawcount: GLsizei,
        basevertex: *const GLint,
    ) {
        panic!("command oxidegl_multi_draw_elements_base_vertex not yet implemented");
    }
    /// ### Parameters
    /// `mode`
    ///
    /// > Specifies what kind of primitives to render. Symbolic constants [`GL_POINTS`](crate::enums::GL_POINTS),
    /// > [`GL_LINE_STRIP`](crate::enums::GL_LINE_STRIP), [`GL_LINE_LOOP`](crate::enums::GL_LINE_LOOP),
    /// > [`GL_LINES`](crate::enums::GL_LINES), [`GL_LINE_STRIP_ADJACENCY`](crate::enums::GL_LINE_STRIP_ADJACENCY),
    /// > [`GL_LINES_ADJACENCY`](crate::enums::GL_LINES_ADJACENCY), [`GL_TRIANGLE_STRIP`](crate::enums::GL_TRIANGLE_STRIP),
    /// > [`GL_TRIANGLE_FAN`](crate::enums::GL_TRIANGLE_FAN), [`GL_TRIANGLES`](crate::enums::GL_TRIANGLES),
    /// > [`GL_TRIANGLE_STRIP_ADJACENCY`](crate::enums::GL_TRIANGLE_STRIP_ADJACENCY),
    /// > [`GL_TRIANGLES_ADJACENCY`](crate::enums::GL_TRIANGLES_ADJACENCY), and [`GL_PATCHES`](crate::enums::GL_PATCHES)
    /// > are accepted.
    ///
    /// `type`
    ///
    /// > Specifies the type of data in the buffer bound to the [`GL_ELEMENT_ARRAY_BUFFER`](crate::enums::GL_ELEMENT_ARRAY_BUFFER)
    /// > binding.
    ///
    /// `indirect`
    ///
    /// > Specifies the address of a structure containing an array of draw parameters.
    ///
    /// `drawcount`
    ///
    /// > Specifies the number of elements in the array addressed by `indirect`.
    ///
    /// `stride`
    ///
    /// > Specifies the distance in basic machine units between elements of the draw
    /// > parameter array.
    ///
    /// ### Description
    /// [**glMultiDrawElementsIndirect**](crate::context::Context::oxidegl_multi_draw_elements_indirect)
    /// specifies multiple indexed geometric primitives with very few subroutine
    /// calls. [**glMultiDrawElementsIndirect**](crate::context::Context::oxidegl_multi_draw_elements_indirect)
    /// behaves similarly to a multitude of calls to [**glDrawElementsInstancedBaseVertexBaseInstance**](crate::context::Context::oxidegl_draw_elements_instanced_base_vertex_base_instance),
    /// execpt that the parameters to [**glDrawElementsInstancedBaseVertexBaseInstance**](crate::context::Context::oxidegl_draw_elements_instanced_base_vertex_base_instance)
    /// are stored in an array in memory at the address given by `indirect`, separated
    /// by the stride, in basic machine units, specified by `stride`. If `stride`
    /// is zero, then the array is assumed to be tightly packed in memory.
    ///
    /// The parameters addressed by `indirect` are packed into a structure that
    /// takes the form (in C):
    ///
    /// A single call to [**glMultiDrawElementsIndirect**](crate::context::Context::oxidegl_multi_draw_elements_indirect)
    /// is equivalent, assuming no errors are generated to:
    ///
    /// If a buffer is bound to the [`GL_DRAW_INDIRECT_BUFFER`](crate::enums::GL_DRAW_INDIRECT_BUFFER)
    /// binding at the time of a call to [**glDrawElementsIndirect**](crate::context::Context::oxidegl_draw_elements_indirect),
    /// `indirect` is interpreted as an offset, in basic machine units, into that
    /// buffer and the parameter data is read from the buffer rather than from
    /// client memory.
    ///
    /// Note that indices stored in client memory are not supported. If no buffer
    /// is bound to the [`GL_ELEMENT_ARRAY_BUFFER`](crate::enums::GL_ELEMENT_ARRAY_BUFFER)
    /// binding, an error will be generated.
    ///
    /// The results of the operation are undefined if the
    ///
    /// Vertex attributes that are modified by [**glDrawElementsIndirect**](crate::context::Context::oxidegl_draw_elements_indirect)
    /// have an unspecified value after [**glDrawElementsIndirect**](crate::context::Context::oxidegl_draw_elements_indirect)
    /// returns. Attributes that aren't modified remain well defined.
    ///
    /// ### Notes
    /// The `baseInstance` member of the `DrawElementsIndirectCommand` structure
    /// is defined only if the GL version is 4.2 or greater. For versions of the
    /// GL less than 4.2, this parameter is present but is reserved and should
    /// be set to zero. On earlier versions of the GL, behavior is undefined if
    /// it is non-zero.

    pub unsafe fn oxidegl_multi_draw_elements_indirect(
        &mut self,
        mode: PrimitiveType,
        r#type: DrawElementsType,
        indirect: *const GLvoid,
        drawcount: GLsizei,
        stride: GLsizei,
    ) {
        panic!("command oxidegl_multi_draw_elements_indirect not yet implemented");
    }
    /// ### Parameters
    /// `identifier`
    ///
    /// > The namespace from which the name of the object is allocated.
    ///
    /// `name`
    ///
    /// > The name of the object to label.
    ///
    /// `length`
    ///
    /// > The length of the label to be used for the object.
    ///
    /// `label`
    ///
    /// > The address of a string containing the label to assign to the object.
    ///
    /// ### Description
    /// [**glObjectLabel**](crate::context::Context::oxidegl_object_label) labels
    /// the object identified by `name` within the namespace given by `identifier`.
    /// `identifier` must be one of [`GL_BUFFER`](crate::enums::GL_BUFFER), [`GL_SHADER`](crate::enums::GL_SHADER),
    /// [`GL_PROGRAM`](crate::enums::GL_PROGRAM), [`GL_VERTEX_ARRAY`](crate::enums::GL_VERTEX_ARRAY),
    /// [`GL_QUERY`](crate::enums::GL_QUERY), [`GL_PROGRAM_PIPELINE`](crate::enums::GL_PROGRAM_PIPELINE),
    /// [`GL_TRANSFORM_FEEDBACK`](crate::enums::GL_TRANSFORM_FEEDBACK), [`GL_SAMPLER`](crate::enums::GL_SAMPLER),
    /// [`GL_TEXTURE`](crate::enums::GL_TEXTURE), [`GL_RENDERBUFFER`](crate::enums::GL_RENDERBUFFER),
    /// [`GL_FRAMEBUFFER`](crate::enums::GL_FRAMEBUFFER), to indicate the namespace
    /// containing the names of buffers, shaders, programs, vertex array objects,
    /// query objects, program pipelines, transform feedback objects, samplers,
    /// textures, renderbuffers and frame buffers, respectively.
    ///
    /// `label` is the address of a string that will be used to label an object.
    /// `length` contains the number of characters in `label`. If `length` is negative,
    /// it is implied that `label` contains a null-terminated string. If `label`
    /// is NULL, any debug label is effectively removed from the object.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_LABEL_LENGTH`](crate::enums::GL_MAX_LABEL_LENGTH).

    pub unsafe fn oxidegl_object_label(
        &mut self,
        identifier: ObjectIdentifier,
        name: GLuint,
        length: GLsizei,
        label: *const GLchar,
    ) {
        panic!("command oxidegl_object_label not yet implemented");
    }
    /// ### Parameters
    /// `ptr`
    ///
    /// > A pointer identifying a sync object.
    ///
    /// `length`
    ///
    /// > The length of the label to be used for the object.
    ///
    /// `label`
    ///
    /// > The address of a string containing the label to assign to the object.
    ///
    /// ### Description
    /// [**glObjectPtrLabel**](crate::context::Context::oxidegl_object_ptr_label)
    /// labels the sync object identified by `ptr`.
    ///
    /// `label` is the address of a string that will be used to label the object.
    /// `length` contains the number of characters in `label`. If `length` is negative,
    /// it is implied that `label` contains a null-terminated string. If `label`
    /// is NULL, any debug label is effectively removed from the object.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_LABEL_LENGTH`](crate::enums::GL_MAX_LABEL_LENGTH).

    pub unsafe fn oxidegl_object_ptr_label(
        &mut self,
        ptr: *const GLvoid,
        length: GLsizei,
        label: *const GLchar,
    ) {
        panic!("command oxidegl_object_ptr_label not yet implemented");
    }
    /// ### Description
    /// [**glPauseTransformFeedback**](crate::context::Context::oxidegl_pause_transform_feedback)
    /// pauses transform feedback operations on the currently active transform
    /// feedback object. When transform feedback operations are paused, transform
    /// feedback is still considered active and changing most transform feedback
    /// state related to the object results in an error. However, a new transform
    /// feedback object may be bound while transform feedback is paused.

    pub fn oxidegl_pause_transform_feedback(&mut self) {
        panic!("command oxidegl_pause_transform_feedback not yet implemented");
    }
    /// ### Parameters
    /// `size`
    ///
    /// > Specifies the diameter of rasterized points. The initial value is 1.
    ///
    /// ### Description
    /// [**glPointSize**](crate::context::Context::oxidegl_point_size) specifies
    /// the rasterized diameter of points. If point size mode is disabled (see
    /// [**glEnable**](crate::context::Context::oxidegl_enable) with parameter
    /// [`GL_PROGRAM_POINT_SIZE`](crate::enums::GL_PROGRAM_POINT_SIZE) ), this
    /// value will be used to rasterize points. Otherwise, the value written to
    /// the shading language built-in variable
    ///
    /// ### Notes
    /// The point size specified by [**glPointSize**](crate::context::Context::oxidegl_point_size)
    /// is always returned when [`GL_POINT_SIZE`](crate::enums::GL_POINT_SIZE)
    /// is queried. Clamping and rounding for points have no effect on the specified
    /// value.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_POINT_SIZE_RANGE`](crate::enums::GL_POINT_SIZE_RANGE)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_POINT_SIZE_GRANULARITY`](crate::enums::GL_POINT_SIZE_GRANULARITY)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_POINT_SIZE`](crate::enums::GL_POINT_SIZE)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_POINT_FADE_THRESHOLD_SIZE`](crate::enums::GL_POINT_FADE_THRESHOLD_SIZE)
    ///
    /// [**glIsEnabled**](crate::context::Context::oxidegl_is_enabled) with argument
    /// [`GL_PROGRAM_POINT_SIZE`](crate::enums::GL_PROGRAM_POINT_SIZE)

    pub fn oxidegl_point_size(&mut self, size: GLfloat) {
        panic!("command oxidegl_point_size not yet implemented");
    }
    /// ### Parameters
    /// `face`
    ///
    /// > Specifies the polygons that `mode` applies to. Must be [`GL_FRONT_AND_BACK`](crate::enums::GL_FRONT_AND_BACK)
    /// > for front- and back-facing polygons.
    ///
    /// `mode`
    ///
    /// > Specifies how polygons will be rasterized. Accepted values are [`GL_POINT`](crate::enums::GL_POINT),
    /// > [`GL_LINE`](crate::enums::GL_LINE), and [`GL_FILL`](crate::enums::GL_FILL).
    /// > The initial value is [`GL_FILL`](crate::enums::GL_FILL) for both front-
    /// > and back-facing polygons.
    ///
    /// ### Description
    /// [**glPolygonMode**](crate::context::Context::oxidegl_polygon_mode) controls
    /// the interpretation of polygons for rasterization. `face` describes which
    /// polygons `mode` applies to: both front and back-facing polygons( [`GL_FRONT_AND_BACK`](crate::enums::GL_FRONT_AND_BACK)
    /// ). The polygon mode affects only the final rasterization of polygons. In
    /// particular, a polygon's vertices are lit and the polygon is clipped and
    /// possibly culled before these modes are applied.
    ///
    /// Three modes are defined and can be specified in `mode`:
    ///
    /// [`GL_POINT`](crate::enums::GL_POINT)
    ///
    /// > Polygon vertices that are marked as the start of a boundary edge are drawn
    /// > as points. Point attributes such as [`GL_POINT_SIZE`](crate::enums::GL_POINT_SIZE)
    /// > and [`GL_POINT_SMOOTH`](crate::enums::GL_POINT_SMOOTH) control the rasterization
    /// > of the points. Polygon rasterization attributes other than [`GL_POLYGON_MODE`](crate::enums::GL_POLYGON_MODE)
    /// > have no effect.
    ///
    /// [`GL_LINE`](crate::enums::GL_LINE)
    ///
    /// > Boundary edges of the polygon are drawn as line segments. Line attributes
    /// > such as [`GL_LINE_WIDTH`](crate::enums::GL_LINE_WIDTH) and [`GL_LINE_SMOOTH`](crate::enums::GL_LINE_SMOOTH)
    /// > control the rasterization of the lines. Polygon rasterization attributes
    /// > other than [`GL_POLYGON_MODE`](crate::enums::GL_POLYGON_MODE) have no effect.
    ///
    /// [`GL_FILL`](crate::enums::GL_FILL)
    ///
    /// > The interior of the polygon is filled. Polygon attributes such as [`GL_POLYGON_SMOOTH`](crate::enums::GL_POLYGON_SMOOTH)
    /// > control the rasterization of the polygon.
    ///
    /// ### Notes
    /// Vertices are marked as boundary or nonboundary with an edge flag. Edge
    /// flags are generated internally by the GL when it decomposes triangle stips
    /// and fans.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_POLYGON_MODE`](crate::enums::GL_POLYGON_MODE)

    pub fn oxidegl_polygon_mode(&mut self, face: TriangleFace, mode: PolygonMode) {
        panic!("command oxidegl_polygon_mode not yet implemented");
    }
    /// ### Parameters
    /// `factor`
    ///
    /// > Specifies a scale factor that is used to create a variable depth offset
    /// > for each polygon. The initial value is 0.
    ///
    /// `units`
    ///
    /// > Is multiplied by an implementation-specific value to create a constant
    /// > depth offset. The initial value is 0.
    ///
    /// ### Description
    /// When [`GL_POLYGON_OFFSET_FILL`](crate::enums::GL_POLYGON_OFFSET_FILL), [`GL_POLYGON_OFFSET_LINE`](crate::enums::GL_POLYGON_OFFSET_LINE),
    /// or [`GL_POLYGON_OFFSET_POINT`](crate::enums::GL_POLYGON_OFFSET_POINT)
    /// is enabled, each fragment's *depth* value will be offset after it is interpolated
    /// from the *depth* values of the appropriate vertices. The value of the offset
    /// is `[inlineq]` `[inlineq]` `[inlineq]`
    ///
    /// [**glPolygonOffset**](crate::context::Context::oxidegl_polygon_offset)
    /// is useful for rendering hidden-line images, for applying decals to surfaces,
    /// and for rendering solids with highlighted edges.
    ///
    /// ### Associated Gets
    /// [**glIsEnabled**](crate::context::Context::oxidegl_is_enabled) with argument
    /// [`GL_POLYGON_OFFSET_FILL`](crate::enums::GL_POLYGON_OFFSET_FILL), [`GL_POLYGON_OFFSET_LINE`](crate::enums::GL_POLYGON_OFFSET_LINE),
    /// or [`GL_POLYGON_OFFSET_POINT`](crate::enums::GL_POLYGON_OFFSET_POINT).
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_POLYGON_OFFSET_FACTOR`](crate::enums::GL_POLYGON_OFFSET_FACTOR)
    /// or [`GL_POLYGON_OFFSET_UNITS`](crate::enums::GL_POLYGON_OFFSET_UNITS).

    pub fn oxidegl_polygon_offset(&mut self, factor: GLfloat, units: GLfloat) {
        panic!("command oxidegl_polygon_offset not yet implemented");
    }
    /// ### Description
    /// [**glPopDebugGroup**](crate::context::Context::oxidegl_pop_debug_group)
    /// pops the active debug group. After popping a debug group, the GL will also
    /// generate a debug output message describing its cause based on the `message`
    /// string, the source `source`, and an ID `id` submitted to the corresponding
    /// [**glPushDebugGroup**](crate::context::Context::oxidegl_push_debug_group)
    /// command. [`GL_DEBUG_TYPE_PUSH_GROUP`](crate::enums::GL_DEBUG_TYPE_PUSH_GROUP)
    /// and [`GL_DEBUG_TYPE_POP_GROUP`](crate::enums::GL_DEBUG_TYPE_POP_GROUP)
    /// share a single namespace for message `id`. `severity` has the value [`GL_DEBUG_SEVERITY_NOTIFICATION`](crate::enums::GL_DEBUG_SEVERITY_NOTIFICATION).
    /// The `type` has the value [`GL_DEBUG_TYPE_POP_GROUP`](crate::enums::GL_DEBUG_TYPE_POP_GROUP).
    /// Popping a debug group restores the debug output volume control of the
    /// parent debug group.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_DEBUG_MESSAGE_LENGTH`](crate::enums::GL_MAX_DEBUG_MESSAGE_LENGTH).

    pub fn oxidegl_pop_debug_group(&mut self) {
        panic!("command oxidegl_pop_debug_group not yet implemented");
    }
    /// ### Parameters
    /// `index`
    ///
    /// > Specifies the value to be interpreted as the primitive restart index.
    ///
    /// ### Description
    /// [**glPrimitiveRestartIndex**](crate::context::Context::oxidegl_primitive_restart_index)
    /// specifies a vertex array element that is treated specially when primitive
    /// restarting is enabled. This is known as the primitive restart index.
    ///
    /// When one of the [**Draw***](crate::context::Context::oxide_draw*) commands
    /// transfers a set of generic attribute array elements to the GL, if the index
    /// within the vertex arrays corresponding to that set is equal to the primitive
    /// restart index, then the GL does not process those elements as a vertex.
    /// Instead, it is as if the drawing command ended with the immediately preceding
    /// transfer, and another drawing command is immediately started with the same
    /// parameters, but only transferring the immediately following element through
    /// the end of the originally specified elements.
    ///
    /// When either [**glDrawElementsBaseVertex**](crate::context::Context::oxidegl_draw_elements_base_vertex),
    /// [**glDrawElementsInstancedBaseVertex**](crate::context::Context::oxidegl_draw_elements_instanced_base_vertex)
    /// or [**glMultiDrawElementsBaseVertex**](crate::context::Context::oxidegl_multi_draw_elements_base_vertex)
    /// is used, the primitive restart comparison occurs before the basevertex
    /// offset is added to the array index.
    ///
    /// ### Notes
    /// [**glPrimitiveRestartIndex**](crate::context::Context::oxidegl_primitive_restart_index)
    /// is available only if the GL version is 3.1 or greater.

    pub fn oxidegl_primitive_restart_index(&mut self, index: GLuint) {
        panic!("command oxidegl_primitive_restart_index not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the name of a program object into which to load a program binary.
    ///
    /// `binaryFormat`
    ///
    /// > Specifies the format of the binary data in binary.
    ///
    /// `binary`
    ///
    /// > Specifies the address an array containing the binary to be loaded into
    /// > `program`.
    ///
    /// `length`
    ///
    /// > Specifies the number of bytes contained in `binary`.
    ///
    /// ### Description
    /// [**glProgramBinary**](crate::context::Context::oxidegl_program_binary)
    /// loads a program object with a program binary previously returned from [**glGetProgramBinary**](crate::context::Context::oxidegl_get_program_binary).
    /// `binaryFormat` and `binary` must be those returned by a previous call to
    /// [**glGetProgramBinary**](crate::context::Context::oxidegl_get_program_binary),
    /// and `length` must be the length returned by [**glGetProgramBinary**](crate::context::Context::oxidegl_get_program_binary),
    /// or by [**glGetProgram**](crate::context::Context::oxidegl_get_program)
    /// when called with `pname` set to [`GL_PROGRAM_BINARY_LENGTH`](crate::enums::GL_PROGRAM_BINARY_LENGTH).
    /// If these conditions are not met, loading the program binary will fail
    /// and `program` 's [`GL_LINK_STATUS`](crate::enums::GL_LINK_STATUS) will
    /// be set to [`GL_FALSE`](crate::enums::GL_FALSE).
    ///
    /// A program object's program binary is replaced by calls to [**glLinkProgram**](crate::context::Context::oxidegl_link_program)
    /// or [**glProgramBinary**](crate::context::Context::oxidegl_program_binary).
    /// When linking success or failure is concerned, [**glProgramBinary**](crate::context::Context::oxidegl_program_binary)
    /// can be considered to perform an implicit linking operation. [**glLinkProgram**](crate::context::Context::oxidegl_link_program)
    /// and [**glProgramBinary**](crate::context::Context::oxidegl_program_binary)
    /// both set the program object's [`GL_LINK_STATUS`](crate::enums::GL_LINK_STATUS)
    /// to [`GL_TRUE`](crate::enums::GL_TRUE) or [`GL_FALSE`](crate::enums::GL_FALSE).
    ///
    /// A successful call to [**glProgramBinary**](crate::context::Context::oxidegl_program_binary)
    /// will reset all uniform variables to their initial values. The initial value
    /// is either the value of the variable's initializer as specified in the original
    /// shader source, or zero if no initializer was present. Additionally, all
    /// vertex shader input and fragment shader output assignments that were in
    /// effect when the program was linked before saving are restored with [**glProgramBinary**](crate::context::Context::oxidegl_program_binary)
    /// is called.
    ///
    /// ### Notes
    /// A program binary may fail to load if the implementation determines that
    /// there has been a change in hardware or software configuration from when
    /// the program binary was produced such as having been compiled with an incompatible
    /// or outdated version of the compiler.
    ///
    /// ### Associated Gets
    /// [**glGetProgram**](crate::context::Context::oxidegl_get_program) with argument
    /// [`GL_PROGRAM_BINARY_LENGTH`](crate::enums::GL_PROGRAM_BINARY_LENGTH)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_NUM_PROGRAM_BINARY_FORMATS`](crate::enums::GL_NUM_PROGRAM_BINARY_FORMATS)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_PROGRAM_BINARY_FORMATS`](crate::enums::GL_PROGRAM_BINARY_FORMATS)

    pub unsafe fn oxidegl_program_binary(
        &mut self,
        program: GLuint,
        binary_format: GLenum,
        binary: *const GLvoid,
        length: GLsizei,
    ) {
        panic!("command oxidegl_program_binary not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the name of a program object whose parameter to modify.
    ///
    /// `pname`
    ///
    /// > Specifies the name of the parameter to modify.
    ///
    /// `value`
    ///
    /// > Specifies the new value of the parameter specified by `pname` for `program`.
    ///
    /// ### Description
    /// [**glProgramParameter**](crate::context::Context::oxidegl_program_parameter)
    /// specifies a new value for the parameter nameed by `pname` for the program
    /// object `program`.
    ///
    /// If `pname` is [`GL_PROGRAM_BINARY_RETRIEVABLE_HINT`](crate::enums::GL_PROGRAM_BINARY_RETRIEVABLE_HINT),
    /// `value` should be [`GL_FALSE`](crate::enums::GL_FALSE) or [`GL_TRUE`](crate::enums::GL_TRUE)
    /// to indicate to the implementation the intention of the application to retrieve
    /// the program's binary representation with [**glGetProgramBinary**](crate::context::Context::oxidegl_get_program_binary).
    /// The implementation may use this information to store information that
    /// may be useful for a future query of the program's binary. It is recommended
    /// to set [`GL_PROGRAM_BINARY_RETRIEVABLE_HINT`](crate::enums::GL_PROGRAM_BINARY_RETRIEVABLE_HINT)
    /// for the program to [`GL_TRUE`](crate::enums::GL_TRUE) before calling [**glLinkProgram**](crate::context::Context::oxidegl_link_program),
    /// and using the program at run-time if the binary is to be retrieved later.
    ///
    /// If `pname` is [`GL_PROGRAM_SEPARABLE`](crate::enums::GL_PROGRAM_SEPARABLE),
    /// `value` must be [`GL_TRUE`](crate::enums::GL_TRUE) or [`GL_FALSE`](crate::enums::GL_FALSE)
    /// and indicates whether `program` can be bound to individual pipeline stages
    /// via [**glUseProgramStages**](crate::context::Context::oxidegl_use_program_stages).
    /// A program's [`GL_PROGRAM_SEPARABLE`](crate::enums::GL_PROGRAM_SEPARABLE)
    /// parameter must be set to [`GL_TRUE`](crate::enums::GL_TRUE) *before* [**glLinkProgram**](crate::context::Context::oxidegl_link_program)
    /// is called in order for it to be usable with a program pipeline object.
    /// The initial state of [`GL_PROGRAM_SEPARABLE`](crate::enums::GL_PROGRAM_SEPARABLE)
    /// is [`GL_FALSE`](crate::enums::GL_FALSE).
    ///
    /// ### Associated Gets
    /// [**glGetProgram**](crate::context::Context::oxidegl_get_program).

    pub fn oxidegl_program_parameteri(
        &mut self,
        program: GLuint,
        pname: ProgramParameterPName,
        value: GLint,
    ) {
        panic!("command oxidegl_program_parameteri not yet implemented");
    }
    /// ### Parameters
    /// `provokeMode`
    ///
    /// > Specifies the vertex to be used as the source of data for flat shaded varyings.
    ///
    /// ### Description
    /// *Flatshading* a vertex shader varying output means to assign all vetices
    /// of the primitive the same value for that output. The vertex from which
    /// these values is derived is known as the *provoking vertex* and [**glProvokingVertex**](crate::context::Context::oxidegl_provoking_vertex)
    /// specifies which vertex is to be used as the source of data for flat shaded
    /// varyings.
    ///
    /// `provokeMode` must be either [`GL_FIRST_VERTEX_CONVENTION`](crate::enums::GL_FIRST_VERTEX_CONVENTION)
    /// or [`GL_LAST_VERTEX_CONVENTION`](crate::enums::GL_LAST_VERTEX_CONVENTION),
    /// and controls the selection of the vertex whose values are assigned to
    /// flatshaded varying outputs. The interpretation of these values for the
    /// supported primitive types is:
    /// |* Primitive Type of Polygon*                                 |* First Vertex Convention*                                |* Last Vertex Convention*                                |
    /// |-------------------------------------------------------------|----------------------------------------------------------|---------------------------------------------------------|
    /// | point                                                       | *i*                                                      | *i*                                                     |
    /// | independent line                                            | 2 *i*- 1                                                 | 2 *i*                                                   |
    /// | line loop                                                   | *i*                                                      | *i*+ 1, if *i*< *n*;  1, if *i*= *n*;                   |
    /// | line strip                                                  | *i*                                                      | *i*+ 1                                                  |
    /// | independent triangle                                        | 3 *i*- 2                                                 | 3 *i*                                                   |
    /// | triangle strip                                              | *i*                                                      | *i*+ 2                                                  |
    /// | triangle fan                                                | *i*+ 1                                                   | *i*+ 2                                                  |
    /// | line adjacency                                              | 4 *i*- 2                                                 | 4 *i*- 1                                                |
    /// | line strip adjacency                                        | *i*+ 1                                                   | *i*+ 2                                                  |
    /// | triangle adjacency                                          | 6 *i*- 5                                                 | 6 *i*- 1                                                |
    /// | triangle strip adjacency                                    | 2 *i*- 1                                                 | 2 *i*+ 3                                                |
    ///
    ///
    /// If a vertex or geometry shader is active, user-defined varying outputs
    /// may be flatshaded by using the
    ///
    /// ### Notes
    /// [**glProvokingVertex**](crate::context::Context::oxidegl_provoking_vertex)
    /// is available only if the GL version is 3.2 or greater.

    pub fn oxidegl_provoking_vertex(&mut self, mode: VertexProvokingMode) {
        panic!("command oxidegl_provoking_vertex not yet implemented");
    }
    /// ### Parameters
    /// `source`
    ///
    /// > The source of the debug message.
    ///
    /// `id`
    ///
    /// > The identifier of the message.
    ///
    /// `length`
    ///
    /// > The length of the message to be sent to the debug output stream.
    ///
    /// `message`
    ///
    /// > The a string containing the message to be sent to the debug output stream.
    ///
    /// ### Description
    /// [**glPushDebugGroup**](crate::context::Context::oxidegl_push_debug_group)
    /// pushes a debug group described by the string `message` into the command
    /// stream. The value of `id` specifies the ID of messages generated. The parameter
    /// `length` contains the number of characters in `message`. If `length` is
    /// negative, it is implied that `message` contains a null terminated string.
    /// The message has the specified `source` and `id`, the `type` [`GL_DEBUG_TYPE_PUSH_GROUP`](crate::enums::GL_DEBUG_TYPE_PUSH_GROUP),
    /// and `severity` [`GL_DEBUG_SEVERITY_NOTIFICATION`](crate::enums::GL_DEBUG_SEVERITY_NOTIFICATION).
    /// The GL will put a new debug group on top of the debug group stack which
    /// inherits the control of the volume of debug output of the debug group previously
    /// residing on the top of the debug group stack. Because debug groups are
    /// strictly hierarchical, any additional control of the debug output volume
    /// will only apply within the active debug group and the debug groups pushed
    /// on top of the active debug group.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_DEBUG_MESSAGE_LENGTH`](crate::enums::GL_MAX_DEBUG_MESSAGE_LENGTH).

    pub unsafe fn oxidegl_push_debug_group(
        &mut self,
        source: DebugSource,
        id: GLuint,
        length: GLsizei,
        message: *const GLchar,
    ) {
        panic!("command oxidegl_push_debug_group not yet implemented");
    }
    /// ### Parameters
    /// `id`
    ///
    /// > Specify the name of a query object into which to record the GL time.
    ///
    /// `target`
    ///
    /// > Specify the counter to query. `target` must be [`GL_TIMESTAMP`](crate::enums::GL_TIMESTAMP).
    ///
    /// ### Description
    /// [**glQueryCounter**](crate::context::Context::oxidegl_query_counter) causes
    /// the GL to record the current time into the query object named `id`. `target`
    /// must be [`GL_TIMESTAMP`](crate::enums::GL_TIMESTAMP). The time is recorded
    /// after all previous commands on the GL client and server state and the framebuffer
    /// have been fully realized. When the time is recorded, the query result for
    /// that object is marked available. [**glQueryCounter**](crate::context::Context::oxidegl_query_counter)
    /// timer queries can be used within a [**glBeginQuery**](crate::context::Context::oxidegl_begin_query)/
    /// [**glEndQuery**](crate::context::Context::oxidegl_end_query) block where
    /// the target is [`GL_TIME_ELAPSED`](crate::enums::GL_TIME_ELAPSED) and it
    /// does not affect the result of that query object.
    ///
    /// ### Notes
    /// [**glQueryCounter**](crate::context::Context::oxidegl_query_counter) is
    /// available only if the GL version is 3.3 or higher.

    pub fn oxidegl_query_counter(&mut self, id: GLuint, target: GLenum) {
        panic!("command oxidegl_query_counter not yet implemented");
    }
    /// ### Description
    /// [**glReleaseShaderCompiler**](crate::context::Context::oxidegl_release_shader_compiler)
    /// provides a hint to the implementation that it may free internal resources
    /// associated with its shader compiler. [**glCompileShader**](crate::context::Context::oxidegl_compile_shader)
    /// may subsequently be called and the implementation may at that time reallocate
    /// resources previously freed by the call to [**glReleaseShaderCompiler**](crate::context::Context::oxidegl_release_shader_compiler).

    pub fn oxidegl_release_shader_compiler(&mut self) {
        panic!("command oxidegl_release_shader_compiler not yet implemented");
    }
    /// ### Description
    /// [**glResumeTransformFeedback**](crate::context::Context::oxidegl_resume_transform_feedback)
    /// resumes transform feedback operations on the currently active transform
    /// feedback object. When transform feedback operations are paused, transform
    /// feedback is still considered active and changing most transform feedback
    /// state related to the object results in an error. However, a new transform
    /// feedback object may be bound while transform feedback is paused.

    pub fn oxidegl_resume_transform_feedback(&mut self) {
        panic!("command oxidegl_resume_transform_feedback not yet implemented");
    }
    /// ### Parameters
    /// `value`
    ///
    /// > Specify a single floating-point sample coverage value. The value is clamped
    /// > to the range `[inlineq]`
    ///
    /// `invert`
    ///
    /// > Specify a single boolean value representing if the coverage masks should
    /// > be inverted. [`GL_TRUE`](crate::enums::GL_TRUE) and [`GL_FALSE`](crate::enums::GL_FALSE)
    /// > are accepted. The initial value is [`GL_FALSE`](crate::enums::GL_FALSE).
    ///
    /// ### Description
    /// Multisampling samples a pixel multiple times at various implementation-dependent
    /// subpixel locations to generate antialiasing effects. Multisampling transparently
    /// antialiases points, lines, polygons, and images if it is enabled.
    ///
    /// `value` is used in constructing a temporary mask used in determining which
    /// samples will be used in resolving the final fragment color. This mask is
    /// bitwise-anded with the coverage mask generated from the multisampling computation.
    /// If the `invert` flag is set, the temporary mask is inverted (all bits flipped)
    /// and then the bitwise-and is computed.
    ///
    /// If an implementation does not have any multisample buffers available, or
    /// multisampling is disabled, rasterization occurs with only a single sample
    /// computing a pixel's final RGB color.
    ///
    /// Provided an implementation supports multisample buffers, and multisampling
    /// is enabled, then a pixel's final color is generated by combining several
    /// samples per pixel. Each sample contains color, depth, and stencil information,
    /// allowing those operations to be performed on each sample.
    ///
    /// ### Notes
    /// The type of the `value` parameter was changed from `GLclampf` to `GLfloat`.
    /// This change is transparent to user code and is described in detail on the
    /// [**removedTypes**](crate::context::Context::oxideremoved_types) page.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_SAMPLE_COVERAGE_VALUE`](crate::enums::GL_SAMPLE_COVERAGE_VALUE)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_SAMPLE_COVERAGE_INVERT`](crate::enums::GL_SAMPLE_COVERAGE_INVERT)
    ///
    /// [**glIsEnabled**](crate::context::Context::oxidegl_is_enabled) with argument
    /// [`GL_MULTISAMPLE`](crate::enums::GL_MULTISAMPLE)
    ///
    /// [**glIsEnabled**](crate::context::Context::oxidegl_is_enabled) with argument
    /// [`GL_SAMPLE_ALPHA_TO_COVERAGE`](crate::enums::GL_SAMPLE_ALPHA_TO_COVERAGE)
    ///
    /// [**glIsEnabled**](crate::context::Context::oxidegl_is_enabled) with argument
    /// [`GL_SAMPLE_ALPHA_TO_ONE`](crate::enums::GL_SAMPLE_ALPHA_TO_ONE)
    ///
    /// [**glIsEnabled**](crate::context::Context::oxidegl_is_enabled) with argument
    /// [`GL_SAMPLE_COVERAGE`](crate::enums::GL_SAMPLE_COVERAGE)

    pub fn oxidegl_sample_coverage(&mut self, value: GLfloat, invert: GLboolean) {
        panic!("command oxidegl_sample_coverage not yet implemented");
    }
    /// ### Parameters
    /// `maskNumber`
    ///
    /// > Specifies which 32-bit sub-word of the sample mask to update.
    ///
    /// `mask`
    ///
    /// > Specifies the new value of the mask sub-word.
    ///
    /// ### Description
    /// [**glSampleMaski**](crate::context::Context::oxidegl_sample_maski) sets
    /// one 32-bit sub-word of the multi-word sample mask, [`GL_SAMPLE_MASK_VALUE`](crate::enums::GL_SAMPLE_MASK_VALUE).
    ///
    /// `maskIndex` specifies which 32-bit sub-word of the sample mask to update,
    /// and `mask` specifies the new value to use for that sub-word. `maskIndex`
    /// must be less than the value of [`GL_MAX_SAMPLE_MASK_WORDS`](crate::enums::GL_MAX_SAMPLE_MASK_WORDS).
    /// Bit *B* of mask word *M* corresponds to sample 32 x *M*+ *B*.
    ///
    /// ### Notes
    /// [**glSampleMaski**](crate::context::Context::oxidegl_sample_maski) is available
    /// only if the GL version is 3.2 or greater, or if the

    pub fn oxidegl_sample_maski(&mut self, mask_number: GLuint, mask: GLbitfield) {
        panic!("command oxidegl_sample_maski not yet implemented");
    }
    /// ### Parameters
    /// `x`
    ///
    /// `y`
    ///
    /// > Specify the lower left corner of the scissor box. Initially (0, 0).
    ///
    /// `width`
    ///
    /// `height`
    ///
    /// > Specify the width and height of the scissor box. When a GL context is first
    /// > attached to a window, `width` and `height` are set to the dimensions of
    /// > that window.
    ///
    /// ### Description
    /// [**glScissor**](crate::context::Context::oxidegl_scissor) defines a rectangle,
    /// called the scissor box, in window coordinates. The first two arguments,
    /// `x` and `y`, specify the lower left corner of the box. `width` and `height`
    /// specify the width and height of the box.
    ///
    /// To enable and disable the scissor test, call [**glEnable**](crate::context::Context::oxidegl_enable)
    /// and [**glDisable**](crate::context::Context::oxidegl_disable) with argument
    /// [`GL_SCISSOR_TEST`](crate::enums::GL_SCISSOR_TEST). The test is initially
    /// disabled. While the test is enabled, only pixels that lie within the scissor
    /// box can be modified by drawing commands. Window coordinates have integer
    /// values at the shared corners of frame buffer pixels.
    ///
    /// When the scissor test is disabled, it is as though the scissor box includes
    /// the entire window.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_SCISSOR_BOX`](crate::enums::GL_SCISSOR_BOX)
    ///
    /// [**glIsEnabled**](crate::context::Context::oxidegl_is_enabled) with argument
    /// [`GL_SCISSOR_TEST`](crate::enums::GL_SCISSOR_TEST)

    pub fn oxidegl_scissor(&mut self, x: GLint, y: GLint, width: GLsizei, height: GLsizei) {
        panic!("command oxidegl_scissor not yet implemented");
    }
    /// ### Parameters
    /// `first`
    ///
    /// > Specifies the index of the first viewport whose scissor box to modify.
    ///
    /// `count`
    ///
    /// > Specifies the number of scissor boxes to modify.
    ///
    /// `v`
    ///
    /// > Specifies the address of an array containing the left, bottom, width and
    /// > height of each scissor box, in that order.
    ///
    /// ### Description
    /// [**glScissorArrayv**](crate::context::Context::oxidegl_scissor_arrayv)
    /// defines rectangles, called scissor boxes, in window coordinates for each
    /// viewport. `first` specifies the index of the first scissor box to modify
    /// and `count` specifies the number of scissor boxes to modify. `first` must
    /// be less than the value of [`GL_MAX_VIEWPORTS`](crate::enums::GL_MAX_VIEWPORTS),
    /// and `first`+ `count` must be less than or equal to the value of [`GL_MAX_VIEWPORTS`](crate::enums::GL_MAX_VIEWPORTS).
    /// `v` specifies the address of an array containing integers specifying the
    /// lower left corner of the scissor boxes, and the width and height of the
    /// scissor boxes, in that order.
    ///
    /// To enable and disable the scissor test, call [**glEnable**](crate::context::Context::oxidegl_enable)
    /// and [**glDisable**](crate::context::Context::oxidegl_disable) with argument
    /// [`GL_SCISSOR_TEST`](crate::enums::GL_SCISSOR_TEST). The test is initially
    /// disabled for all viewports. While the test is enabled, only pixels that
    /// lie within the scissor box can be modified by drawing commands. Window
    /// coordinates have integer values at the shared corners of frame buffer pixels.
    ///
    /// When the scissor test is disabled, it is as though the scissor box includes
    /// the entire window.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_SCISSOR_BOX`](crate::enums::GL_SCISSOR_BOX)
    ///
    /// [**glIsEnabled**](crate::context::Context::oxidegl_is_enabled) with argument
    /// [`GL_SCISSOR_TEST`](crate::enums::GL_SCISSOR_TEST)

    pub unsafe fn oxidegl_scissor_arrayv(
        &mut self,
        first: GLuint,
        count: GLsizei,
        v: *const GLint,
    ) {
        panic!("command oxidegl_scissor_arrayv not yet implemented");
    }
    /// ### Parameters
    /// `count`
    ///
    /// > Specifies the number of shader object handles contained in `shaders`.
    ///
    /// `shaders`
    ///
    /// > Specifies the address of an array of shader handles into which to load
    /// > pre-compiled shader binaries.
    ///
    /// `binaryFormat`
    ///
    /// > Specifies the format of the shader binaries contained in `binary`.
    ///
    /// `binary`
    ///
    /// > Specifies the address of an array of bytes containing pre-compiled binary
    /// > shader code.
    ///
    /// `length`
    ///
    /// > Specifies the length of the array whose address is given in `binary`.
    ///
    /// ### Description
    /// [**glShaderBinary**](crate::context::Context::oxidegl_shader_binary) loads
    /// pre-compiled shader binary code into the `count` shader objects whose handles
    /// are given in `shaders`. `binary` points to `length` bytes of binary shader
    /// code stored in client memory. `binaryFormat` specifies the format of the
    /// pre-compiled code.
    ///
    /// The binary image contained in `binary` will be decoded according to the
    /// extension specification defining the specified `binaryFormat` token. OpenGL
    /// does not define any specific binary formats, but it does provide a mechanism
    /// to obtain token vaues for such formats provided by such extensions.
    ///
    /// Depending on the types of the shader objects in `shaders`, [**glShaderBinary**](crate::context::Context::oxidegl_shader_binary)
    /// will individually load binary vertex or fragment shaders, or load an executable
    /// binary that contains an optimized pair of vertex and fragment shaders stored
    /// in the same binary.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with parameter [`GL_NUM_SHADER_BINARY_FORMATS`](crate::enums::GL_NUM_SHADER_BINARY_FORMATS).
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with parameter [`GL_SHADER_BINARY_FORMATS`](crate::enums::GL_SHADER_BINARY_FORMATS).

    pub unsafe fn oxidegl_shader_binary(
        &mut self,
        count: GLsizei,
        shaders: *const GLuint,
        binary_format: GLenum,
        binary: *const GLvoid,
        length: GLsizei,
    ) {
        panic!("command oxidegl_shader_binary not yet implemented");
    }
    /// ### Parameters
    /// `shader`
    ///
    /// > Specifies the handle of the shader object whose source code is to be replaced.
    ///
    /// `count`
    ///
    /// > Specifies the number of elements in the `string` and `length` arrays.
    ///
    /// `string`
    ///
    /// > Specifies an array of pointers to strings containing the source code to
    /// > be loaded into the shader.
    ///
    /// `length`
    ///
    /// > Specifies an array of string lengths.
    ///
    /// ### Description
    /// [**glShaderSource**](crate::context::Context::oxidegl_shader_source) sets
    /// the source code in `shader` to the source code in the array of strings
    /// specified by `string`. Any source code previously stored in the shader
    /// object is completely replaced. The number of strings in the array is specified
    /// by `count`. If `length` is [`NULL`](crate::enums::NULL), each string is
    /// assumed to be null terminated. If `length` is a value other than [`NULL`](crate::enums::NULL),
    /// it points to an array containing a string length for each of the corresponding
    /// elements of `string`. Each element in the `length` array may contain the
    /// length of the corresponding string (the null character is not counted as
    /// part of the string length) or a value less than 0 to indicate that the
    /// string is null terminated. The source code strings are not scanned or parsed
    /// at this time; they are simply copied into the specified shader object.
    ///
    /// ### Notes
    /// OpenGL copies the shader source code strings when [**glShaderSource**](crate::context::Context::oxidegl_shader_source)
    /// is called, so an application may free its copy of the source code strings
    /// immediately after the function returns.
    ///
    /// ### Associated Gets
    /// [**glGetShader**](crate::context::Context::oxidegl_get_shader) with arguments
    /// `shader` and [`GL_SHADER_SOURCE_LENGTH`](crate::enums::GL_SHADER_SOURCE_LENGTH)
    ///
    /// [**glGetShaderSource**](crate::context::Context::oxidegl_get_shader_source)
    /// with argument `shader`
    ///
    /// [**glIsShader**](crate::context::Context::oxidegl_is_shader)

    pub unsafe fn oxidegl_shader_source(
        &mut self,
        shader: GLuint,
        count: GLsizei,
        string: GLchar,
        length: *const GLint,
    ) {
        panic!("command oxidegl_shader_source not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > The name of the program containing the block whose binding to change.
    ///
    /// `storageBlockIndex`
    ///
    /// > The index storage block within the program.
    ///
    /// `storageBlockBinding`
    ///
    /// > The index storage block binding to associate with the specified storage
    /// > block.
    ///
    /// ### Description
    /// [**glShaderStorageBlockBinding**](crate::context::Context::oxidegl_shader_storage_block_binding),
    /// changes the active shader storage block with an assigned index of `storageBlockIndex`
    /// in program object `program`. `storageBlockIndex` must be an active shader
    /// storage block index in `program`. `storageBlockBinding` must be less than
    /// the value of [`GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS`](crate::enums::GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS).
    /// If successful, [**glShaderStorageBlockBinding**](crate::context::Context::oxidegl_shader_storage_block_binding)
    /// specifies that `program` will use the data store of the buffer object bound
    /// to the binding point `storageBlockBinding` to read and write the values
    /// of the buffer variables in the shader storage block identified by `storageBlockIndex`.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with arguments [`GL_SHADER_STORAGE_BUFFER_BINDING`](crate::enums::GL_SHADER_STORAGE_BUFFER_BINDING),
    /// [`GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS`](crate::enums::GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS),
    /// [`GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS`](crate::enums::GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS),
    /// [`GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS`](crate::enums::GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS),
    /// [`GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS`](crate::enums::GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS),
    /// [`GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS`](crate::enums::GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS),
    /// [`GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS`](crate::enums::GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS),
    /// [`GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS`](crate::enums::GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS)
    /// or [`GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS`](crate::enums::GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS),
    /// [`GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS`](crate::enums::GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS),
    /// or [`GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES`](crate::enums::GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES).

    pub fn oxidegl_shader_storage_block_binding(
        &mut self,
        program: GLuint,
        storage_block_index: GLuint,
        storage_block_binding: GLuint,
    ) {
        panic!("command oxidegl_shader_storage_block_binding not yet implemented");
    }
    /// ### Parameters
    /// `func`
    ///
    /// > Specifies the test function. Eight symbolic constants are valid: [`GL_NEVER`](crate::enums::GL_NEVER),
    /// > [`GL_LESS`](crate::enums::GL_LESS), [`GL_LEQUAL`](crate::enums::GL_LEQUAL),
    /// > [`GL_GREATER`](crate::enums::GL_GREATER), [`GL_GEQUAL`](crate::enums::GL_GEQUAL),
    /// > [`GL_EQUAL`](crate::enums::GL_EQUAL), [`GL_NOTEQUAL`](crate::enums::GL_NOTEQUAL),
    /// > and [`GL_ALWAYS`](crate::enums::GL_ALWAYS). The initial value is [`GL_ALWAYS`](crate::enums::GL_ALWAYS).
    ///
    /// `ref`
    ///
    /// > Specifies the reference value for the stencil test. `ref` is clamped to
    /// > the range `[inlineq]` `[inlineq]`
    ///
    /// `mask`
    ///
    /// > Specifies a mask that is ANDed with both the reference value and the stored
    /// > stencil value when the test is done. The initial value is all 1's.
    ///
    /// ### Description
    /// Stenciling, like depth-buffering, enables and disables drawing on a per-pixel
    /// basis. Stencil planes are first drawn into using GL drawing primitives,
    /// then geometry and images are rendered using the stencil planes to mask
    /// out portions of the screen. Stenciling is typically used in multipass rendering
    /// algorithms to achieve special effects, such as decals, outlining, and constructive
    /// solid geometry rendering.
    ///
    /// The stencil test conditionally eliminates a pixel based on the outcome
    /// of a comparison between the reference value and the value in the stencil
    /// buffer. To enable and disable the test, call [**glEnable**](crate::context::Context::oxidegl_enable)
    /// and [**glDisable**](crate::context::Context::oxidegl_disable) with argument
    /// [`GL_STENCIL_TEST`](crate::enums::GL_STENCIL_TEST). To specify actions
    /// based on the outcome of the stencil test, call [**glStencilOp**](crate::context::Context::oxidegl_stencil_op)
    /// or [**glStencilOpSeparate**](crate::context::Context::oxidegl_stencil_op_separate).
    ///
    /// There can be two separate sets of `func`, `ref`, and `mask` parameters;
    /// one affects back-facing polygons, and the other affects front-facing polygons
    /// as well as other non-polygon primitives. [**glStencilFunc**](crate::context::Context::oxidegl_stencil_func)
    /// sets both front and back stencil state to the same values. Use [**glStencilFuncSeparate**](crate::context::Context::oxidegl_stencil_func_separate)
    /// to set front and back stencil state to different values.
    ///
    /// `func` is a symbolic constant that determines the stencil comparison function.
    /// It accepts one of eight values, shown in the following list. `ref` is an
    /// integer reference value that is used in the stencil comparison. It is clamped
    /// to the range `[inlineq]` `[inlineq]` `mask` is bitwise `ANDed` with both
    /// the reference value and the stored stencil value, with the `ANDed` values
    /// participating in the comparison.
    ///
    /// If *stencil* represents the value stored in the corresponding stencil buffer
    /// location, the following list shows the effect of each comparison function
    /// that can be specified by `func`. Only if the comparison succeeds is the
    /// pixel passed through to the next stage in the rasterization process (see
    /// [**glStencilOp**](crate::context::Context::oxidegl_stencil_op) ). All tests
    /// treat *stencil* values as unsigned integers in the range `[inlineq]` `[inlineq]`
    ///
    /// The following values are accepted by `func`:
    ///
    /// [`GL_NEVER`](crate::enums::GL_NEVER)
    ///
    /// > Always fails.
    ///
    /// [`GL_LESS`](crate::enums::GL_LESS)
    ///
    /// > Passes if( `ref`& `mask`)<( *stencil*& `mask` ).
    ///
    /// [`GL_LEQUAL`](crate::enums::GL_LEQUAL)
    ///
    /// > Passes if( `ref`& `mask`) <=( *stencil*& `mask` ).
    ///
    /// [`GL_GREATER`](crate::enums::GL_GREATER)
    ///
    /// > Passes if( `ref`& `mask`)>( *stencil*& `mask` ).
    ///
    /// [`GL_GEQUAL`](crate::enums::GL_GEQUAL)
    ///
    /// > Passes if( `ref`& `mask`) >=( *stencil*& `mask` ).
    ///
    /// [`GL_EQUAL`](crate::enums::GL_EQUAL)
    ///
    /// > Passes if( `ref`& `mask`)=( *stencil*& `mask` ).
    ///
    /// [`GL_NOTEQUAL`](crate::enums::GL_NOTEQUAL)
    ///
    /// > Passes if( `ref`& `mask`) !=( *stencil*& `mask` ).
    ///
    /// [`GL_ALWAYS`](crate::enums::GL_ALWAYS)
    ///
    /// > Always passes.
    ///
    /// ### Notes
    /// Initially, the stencil test is disabled. If there is no stencil buffer,
    /// no stencil modification can occur and it is as if the stencil test always
    /// passes.
    ///
    /// [**glStencilFunc**](crate::context::Context::oxidegl_stencil_func) is the
    /// same as calling [**glStencilFuncSeparate**](crate::context::Context::oxidegl_stencil_func_separate)
    /// with `face` set to [`GL_FRONT_AND_BACK`](crate::enums::GL_FRONT_AND_BACK).
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_STENCIL_FUNC`](crate::enums::GL_STENCIL_FUNC),
    /// [`GL_STENCIL_VALUE_MASK`](crate::enums::GL_STENCIL_VALUE_MASK), [`GL_STENCIL_REF`](crate::enums::GL_STENCIL_REF),
    /// [`GL_STENCIL_BACK_FUNC`](crate::enums::GL_STENCIL_BACK_FUNC), [`GL_STENCIL_BACK_VALUE_MASK`](crate::enums::GL_STENCIL_BACK_VALUE_MASK),
    /// [`GL_STENCIL_BACK_REF`](crate::enums::GL_STENCIL_BACK_REF), or [`GL_STENCIL_BITS`](crate::enums::GL_STENCIL_BITS)
    ///
    /// [**glIsEnabled**](crate::context::Context::oxidegl_is_enabled) with argument
    /// [`GL_STENCIL_TEST`](crate::enums::GL_STENCIL_TEST)

    pub fn oxidegl_stencil_func(&mut self, func: StencilFunction, r#ref: GLint, mask: GLuint) {
        panic!("command oxidegl_stencil_func not yet implemented");
    }
    /// ### Parameters
    /// `face`
    ///
    /// > Specifies whether front and/or back stencil state is updated. Three symbolic
    /// > constants are valid: [`GL_FRONT`](crate::enums::GL_FRONT), [`GL_BACK`](crate::enums::GL_BACK),
    /// > and [`GL_FRONT_AND_BACK`](crate::enums::GL_FRONT_AND_BACK).
    ///
    /// `func`
    ///
    /// > Specifies the test function. Eight symbolic constants are valid: [`GL_NEVER`](crate::enums::GL_NEVER),
    /// > [`GL_LESS`](crate::enums::GL_LESS), [`GL_LEQUAL`](crate::enums::GL_LEQUAL),
    /// > [`GL_GREATER`](crate::enums::GL_GREATER), [`GL_GEQUAL`](crate::enums::GL_GEQUAL),
    /// > [`GL_EQUAL`](crate::enums::GL_EQUAL), [`GL_NOTEQUAL`](crate::enums::GL_NOTEQUAL),
    /// > and [`GL_ALWAYS`](crate::enums::GL_ALWAYS). The initial value is [`GL_ALWAYS`](crate::enums::GL_ALWAYS).
    ///
    /// `ref`
    ///
    /// > Specifies the reference value for the stencil test. `ref` is clamped to
    /// > the range `[inlineq]` `[inlineq]`
    ///
    /// `mask`
    ///
    /// > Specifies a mask that is ANDed with both the reference value and the stored
    /// > stencil value when the test is done. The initial value is all 1's.
    ///
    /// ### Description
    /// Stenciling, like depth-buffering, enables and disables drawing on a per-pixel
    /// basis. You draw into the stencil planes using GL drawing primitives, then
    /// render geometry and images, using the stencil planes to mask out portions
    /// of the screen. Stenciling is typically used in multipass rendering algorithms
    /// to achieve special effects, such as decals, outlining, and constructive
    /// solid geometry rendering.
    ///
    /// The stencil test conditionally eliminates a pixel based on the outcome
    /// of a comparison between the reference value and the value in the stencil
    /// buffer. To enable and disable the test, call [**glEnable**](crate::context::Context::oxidegl_enable)
    /// and [**glDisable**](crate::context::Context::oxidegl_disable) with argument
    /// [`GL_STENCIL_TEST`](crate::enums::GL_STENCIL_TEST). To specify actions
    /// based on the outcome of the stencil test, call [**glStencilOp**](crate::context::Context::oxidegl_stencil_op)
    /// or [**glStencilOpSeparate**](crate::context::Context::oxidegl_stencil_op_separate).
    ///
    /// There can be two separate sets of `func`, `ref`, and `mask` parameters;
    /// one affects back-facing polygons, and the other affects front-facing polygons
    /// as well as other non-polygon primitives. [**glStencilFunc**](crate::context::Context::oxidegl_stencil_func)
    /// sets both front and back stencil state to the same values, as if [**glStencilFuncSeparate**](crate::context::Context::oxidegl_stencil_func_separate)
    /// were called with `face` set to [`GL_FRONT_AND_BACK`](crate::enums::GL_FRONT_AND_BACK).
    ///
    /// `func` is a symbolic constant that determines the stencil comparison function.
    /// It accepts one of eight values, shown in the following list. `ref` is an
    /// integer reference value that is used in the stencil comparison. It is clamped
    /// to the range `[inlineq]` `[inlineq]` `mask` is bitwise `ANDed` with both
    /// the reference value and the stored stencil value, with the `ANDed` values
    /// participating in the comparison.
    ///
    /// If *stencil* represents the value stored in the corresponding stencil buffer
    /// location, the following list shows the effect of each comparison function
    /// that can be specified by `func`. Only if the comparison succeeds is the
    /// pixel passed through to the next stage in the rasterization process (see
    /// [**glStencilOp**](crate::context::Context::oxidegl_stencil_op) ). All tests
    /// treat *stencil* values as unsigned integers in the range `[inlineq]` `[inlineq]`
    ///
    /// The following values are accepted by `func`:
    ///
    /// [`GL_NEVER`](crate::enums::GL_NEVER)
    ///
    /// > Always fails.
    ///
    /// [`GL_LESS`](crate::enums::GL_LESS)
    ///
    /// > Passes if( `ref`& `mask`)<( *stencil*& `mask` ).
    ///
    /// [`GL_LEQUAL`](crate::enums::GL_LEQUAL)
    ///
    /// > Passes if( `ref`& `mask`) <=( *stencil*& `mask` ).
    ///
    /// [`GL_GREATER`](crate::enums::GL_GREATER)
    ///
    /// > Passes if( `ref`& `mask`)>( *stencil*& `mask` ).
    ///
    /// [`GL_GEQUAL`](crate::enums::GL_GEQUAL)
    ///
    /// > Passes if( `ref`& `mask`) >=( *stencil*& `mask` ).
    ///
    /// [`GL_EQUAL`](crate::enums::GL_EQUAL)
    ///
    /// > Passes if( `ref`& `mask`)=( *stencil*& `mask` ).
    ///
    /// [`GL_NOTEQUAL`](crate::enums::GL_NOTEQUAL)
    ///
    /// > Passes if( `ref`& `mask`) !=( *stencil*& `mask` ).
    ///
    /// [`GL_ALWAYS`](crate::enums::GL_ALWAYS)
    ///
    /// > Always passes.
    ///
    /// ### Notes
    /// Initially, the stencil test is disabled. If there is no stencil buffer,
    /// no stencil modification can occur and it is as if the stencil test always
    /// passes.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_STENCIL_FUNC`](crate::enums::GL_STENCIL_FUNC),
    /// [`GL_STENCIL_VALUE_MASK`](crate::enums::GL_STENCIL_VALUE_MASK), [`GL_STENCIL_REF`](crate::enums::GL_STENCIL_REF),
    /// [`GL_STENCIL_BACK_FUNC`](crate::enums::GL_STENCIL_BACK_FUNC), [`GL_STENCIL_BACK_VALUE_MASK`](crate::enums::GL_STENCIL_BACK_VALUE_MASK),
    /// [`GL_STENCIL_BACK_REF`](crate::enums::GL_STENCIL_BACK_REF), or [`GL_STENCIL_BITS`](crate::enums::GL_STENCIL_BITS)
    ///
    /// [**glIsEnabled**](crate::context::Context::oxidegl_is_enabled) with argument
    /// [`GL_STENCIL_TEST`](crate::enums::GL_STENCIL_TEST)

    pub fn oxidegl_stencil_func_separate(
        &mut self,
        face: TriangleFace,
        func: StencilFunction,
        r#ref: GLint,
        mask: GLuint,
    ) {
        panic!("command oxidegl_stencil_func_separate not yet implemented");
    }
    /// ### Parameters
    /// `mask`
    ///
    /// > Specifies a bit mask to enable and disable writing of individual bits in
    /// > the stencil planes. Initially, the mask is all 1's.
    ///
    /// ### Description
    /// [**glStencilMask**](crate::context::Context::oxidegl_stencil_mask) controls
    /// the writing of individual bits in the stencil planes. The least significant
    /// `[inlineq]` `mask`, where `[inlineq]`
    ///
    /// There can be two separate `mask` writemasks; one affects back-facing polygons,
    /// and the other affects front-facing polygons as well as other non-polygon
    /// primitives. [**glStencilMask**](crate::context::Context::oxidegl_stencil_mask)
    /// sets both front and back stencil writemasks to the same values. Use [**glStencilMaskSeparate**](crate::context::Context::oxidegl_stencil_mask_separate)
    /// to set front and back stencil writemasks to different values.
    ///
    /// ### Notes
    /// [**glStencilMask**](crate::context::Context::oxidegl_stencil_mask) is the
    /// same as calling [**glStencilMaskSeparate**](crate::context::Context::oxidegl_stencil_mask_separate)
    /// with `face` set to [`GL_FRONT_AND_BACK`](crate::enums::GL_FRONT_AND_BACK).
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_STENCIL_WRITEMASK`](crate::enums::GL_STENCIL_WRITEMASK),
    /// [`GL_STENCIL_BACK_WRITEMASK`](crate::enums::GL_STENCIL_BACK_WRITEMASK),
    /// or [`GL_STENCIL_BITS`](crate::enums::GL_STENCIL_BITS)

    pub fn oxidegl_stencil_mask(&mut self, mask: GLuint) {
        panic!("command oxidegl_stencil_mask not yet implemented");
    }
    /// ### Parameters
    /// `face`
    ///
    /// > Specifies whether the front and/or back stencil writemask is updated. Three
    /// > symbolic constants are valid: [`GL_FRONT`](crate::enums::GL_FRONT), [`GL_BACK`](crate::enums::GL_BACK),
    /// > and [`GL_FRONT_AND_BACK`](crate::enums::GL_FRONT_AND_BACK).
    ///
    /// `mask`
    ///
    /// > Specifies a bit mask to enable and disable writing of individual bits in
    /// > the stencil planes. Initially, the mask is all 1's.
    ///
    /// ### Description
    /// [**glStencilMaskSeparate**](crate::context::Context::oxidegl_stencil_mask_separate)
    /// controls the writing of individual bits in the stencil planes. The least
    /// significant `[inlineq]` `mask`, where `[inlineq]`
    ///
    /// There can be two separate `mask` writemasks; one affects back-facing polygons,
    /// and the other affects front-facing polygons as well as other non-polygon
    /// primitives. [**glStencilMask**](crate::context::Context::oxidegl_stencil_mask)
    /// sets both front and back stencil writemasks to the same values, as if [**glStencilMaskSeparate**](crate::context::Context::oxidegl_stencil_mask_separate)
    /// were called with `face` set to [`GL_FRONT_AND_BACK`](crate::enums::GL_FRONT_AND_BACK).
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_STENCIL_WRITEMASK`](crate::enums::GL_STENCIL_WRITEMASK),
    /// [`GL_STENCIL_BACK_WRITEMASK`](crate::enums::GL_STENCIL_BACK_WRITEMASK),
    /// or [`GL_STENCIL_BITS`](crate::enums::GL_STENCIL_BITS)

    pub fn oxidegl_stencil_mask_separate(&mut self, face: TriangleFace, mask: GLuint) {
        panic!("command oxidegl_stencil_mask_separate not yet implemented");
    }
    /// ### Parameters
    /// `sfail`
    ///
    /// > Specifies the action to take when the stencil test fails. Eight symbolic
    /// > constants are accepted: [`GL_KEEP`](crate::enums::GL_KEEP), [`GL_ZERO`](crate::enums::GL_ZERO),
    /// > [`GL_REPLACE`](crate::enums::GL_REPLACE), [`GL_INCR`](crate::enums::GL_INCR),
    /// > [`GL_INCR_WRAP`](crate::enums::GL_INCR_WRAP), [`GL_DECR`](crate::enums::GL_DECR),
    /// > [`GL_DECR_WRAP`](crate::enums::GL_DECR_WRAP), and [`GL_INVERT`](crate::enums::GL_INVERT).
    /// > The initial value is [`GL_KEEP`](crate::enums::GL_KEEP).
    ///
    /// `dpfail`
    ///
    /// > Specifies the stencil action when the stencil test passes, but the depth
    /// > test fails. `dpfail` accepts the same symbolic constants as `sfail`. The
    /// > initial value is [`GL_KEEP`](crate::enums::GL_KEEP).
    ///
    /// `dppass`
    ///
    /// > Specifies the stencil action when both the stencil test and the depth test
    /// > pass, or when the stencil test passes and either there is no depth buffer
    /// > or depth testing is not enabled. `dppass` accepts the same symbolic constants
    /// > as `sfail`. The initial value is [`GL_KEEP`](crate::enums::GL_KEEP).
    ///
    /// ### Description
    /// Stenciling, like depth-buffering, enables and disables drawing on a per-pixel
    /// basis. You draw into the stencil planes using GL drawing primitives, then
    /// render geometry and images, using the stencil planes to mask out portions
    /// of the screen. Stenciling is typically used in multipass rendering algorithms
    /// to achieve special effects, such as decals, outlining, and constructive
    /// solid geometry rendering.
    ///
    /// The stencil test conditionally eliminates a pixel based on the outcome
    /// of a comparison between the value in the stencil buffer and a reference
    /// value. To enable and disable the test, call [**glEnable**](crate::context::Context::oxidegl_enable)
    /// and [**glDisable**](crate::context::Context::oxidegl_disable) with argument
    /// [`GL_STENCIL_TEST`](crate::enums::GL_STENCIL_TEST); to control it, call
    /// [**glStencilFunc**](crate::context::Context::oxidegl_stencil_func) or [**glStencilFuncSeparate**](crate::context::Context::oxidegl_stencil_func_separate).
    ///
    /// There can be two separate sets of `sfail`, `dpfail`, and `dppass` parameters;
    /// one affects back-facing polygons, and the other affects front-facing polygons
    /// as well as other non-polygon primitives. [**glStencilOp**](crate::context::Context::oxidegl_stencil_op)
    /// sets both front and back stencil state to the same values. Use [**glStencilOpSeparate**](crate::context::Context::oxidegl_stencil_op_separate)
    /// to set front and back stencil state to different values.
    ///
    /// [**glStencilOp**](crate::context::Context::oxidegl_stencil_op) takes three
    /// arguments that indicate what happens to the stored stencil value while
    /// stenciling is enabled. If the stencil test fails, no change is made to
    /// the pixel's color or depth buffers, and `sfail` specifies what happens
    /// to the stencil buffer contents. The following eight actions are possible.
    ///
    /// [`GL_KEEP`](crate::enums::GL_KEEP)
    ///
    /// > Keeps the current value.
    ///
    /// [`GL_ZERO`](crate::enums::GL_ZERO)
    ///
    /// > Sets the stencil buffer value to 0.
    ///
    /// [`GL_REPLACE`](crate::enums::GL_REPLACE)
    ///
    /// > Sets the stencil buffer value to *ref*, as specified by [**glStencilFunc**](crate::context::Context::oxidegl_stencil_func).
    ///
    /// [`GL_INCR`](crate::enums::GL_INCR)
    ///
    /// > Increments the current stencil buffer value. Clamps to the maximum representable
    /// > unsigned value.
    ///
    /// [`GL_INCR_WRAP`](crate::enums::GL_INCR_WRAP)
    ///
    /// > Increments the current stencil buffer value. Wraps stencil buffer value
    /// > to zero when incrementing the maximum representable unsigned value.
    ///
    /// [`GL_DECR`](crate::enums::GL_DECR)
    ///
    /// > Decrements the current stencil buffer value. Clamps to 0.
    ///
    /// [`GL_DECR_WRAP`](crate::enums::GL_DECR_WRAP)
    ///
    /// > Decrements the current stencil buffer value. Wraps stencil buffer value
    /// > to the maximum representable unsigned value when decrementing a stencil
    /// > buffer value of zero.
    ///
    /// [`GL_INVERT`](crate::enums::GL_INVERT)
    ///
    /// > Bitwise inverts the current stencil buffer value.
    ///
    /// Stencil buffer values are treated as unsigned integers. When incremented
    /// and decremented, values are clamped to 0 and `[inlineq]` `[inlineq]` [`GL_STENCIL_BITS`](crate::enums::GL_STENCIL_BITS).
    ///
    /// The other two arguments to [**glStencilOp**](crate::context::Context::oxidegl_stencil_op)
    /// specify stencil buffer actions that depend on whether subsequent depth
    /// buffer tests succeed( `dppass`) or fail( `dpfail`) (see [**glDepthFunc**](crate::context::Context::oxidegl_depth_func)
    /// ). The actions are specified using the same eight symbolic constants as
    /// `sfail`. Note that `dpfail` is ignored when there is no depth buffer, or
    /// when the depth buffer is not enabled. In these cases, `sfail` and `dppass`
    /// specify stencil action when the stencil test fails and passes, respectively.
    ///
    /// ### Notes
    /// Initially the stencil test is disabled. If there is no stencil buffer,
    /// no stencil modification can occur and it is as if the stencil tests always
    /// pass, regardless of any call to [**glStencilOp**](crate::context::Context::oxidegl_stencil_op).
    ///
    /// [**glStencilOp**](crate::context::Context::oxidegl_stencil_op) is the same
    /// as calling [**glStencilOpSeparate**](crate::context::Context::oxidegl_stencil_op_separate)
    /// with `face` set to [`GL_FRONT_AND_BACK`](crate::enums::GL_FRONT_AND_BACK).
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_STENCIL_FAIL`](crate::enums::GL_STENCIL_FAIL),
    /// [`GL_STENCIL_PASS_DEPTH_PASS`](crate::enums::GL_STENCIL_PASS_DEPTH_PASS),
    /// [`GL_STENCIL_PASS_DEPTH_FAIL`](crate::enums::GL_STENCIL_PASS_DEPTH_FAIL),
    /// [`GL_STENCIL_BACK_FAIL`](crate::enums::GL_STENCIL_BACK_FAIL), [`GL_STENCIL_BACK_PASS_DEPTH_PASS`](crate::enums::GL_STENCIL_BACK_PASS_DEPTH_PASS),
    /// [`GL_STENCIL_BACK_PASS_DEPTH_FAIL`](crate::enums::GL_STENCIL_BACK_PASS_DEPTH_FAIL),
    /// or [`GL_STENCIL_BITS`](crate::enums::GL_STENCIL_BITS)
    ///
    /// [**glIsEnabled**](crate::context::Context::oxidegl_is_enabled) with argument
    /// [`GL_STENCIL_TEST`](crate::enums::GL_STENCIL_TEST)

    pub fn oxidegl_stencil_op(&mut self, fail: StencilOp, zfail: StencilOp, zpass: StencilOp) {
        panic!("command oxidegl_stencil_op not yet implemented");
    }
    /// ### Parameters
    /// `face`
    ///
    /// > Specifies whether front and/or back stencil state is updated. Three symbolic
    /// > constants are valid: [`GL_FRONT`](crate::enums::GL_FRONT), [`GL_BACK`](crate::enums::GL_BACK),
    /// > and [`GL_FRONT_AND_BACK`](crate::enums::GL_FRONT_AND_BACK).
    ///
    /// `sfail`
    ///
    /// > Specifies the action to take when the stencil test fails. Eight symbolic
    /// > constants are accepted: [`GL_KEEP`](crate::enums::GL_KEEP), [`GL_ZERO`](crate::enums::GL_ZERO),
    /// > [`GL_REPLACE`](crate::enums::GL_REPLACE), [`GL_INCR`](crate::enums::GL_INCR),
    /// > [`GL_INCR_WRAP`](crate::enums::GL_INCR_WRAP), [`GL_DECR`](crate::enums::GL_DECR),
    /// > [`GL_DECR_WRAP`](crate::enums::GL_DECR_WRAP), and [`GL_INVERT`](crate::enums::GL_INVERT).
    /// > The initial value is [`GL_KEEP`](crate::enums::GL_KEEP).
    ///
    /// `dpfail`
    ///
    /// > Specifies the stencil action when the stencil test passes, but the depth
    /// > test fails. `dpfail` accepts the same symbolic constants as `sfail`. The
    /// > initial value is [`GL_KEEP`](crate::enums::GL_KEEP).
    ///
    /// `dppass`
    ///
    /// > Specifies the stencil action when both the stencil test and the depth test
    /// > pass, or when the stencil test passes and either there is no depth buffer
    /// > or depth testing is not enabled. `dppass` accepts the same symbolic constants
    /// > as `sfail`. The initial value is [`GL_KEEP`](crate::enums::GL_KEEP).
    ///
    /// ### Description
    /// Stenciling, like depth-buffering, enables and disables drawing on a per-pixel
    /// basis. You draw into the stencil planes using GL drawing primitives, then
    /// render geometry and images, using the stencil planes to mask out portions
    /// of the screen. Stenciling is typically used in multipass rendering algorithms
    /// to achieve special effects, such as decals, outlining, and constructive
    /// solid geometry rendering.
    ///
    /// The stencil test conditionally eliminates a pixel based on the outcome
    /// of a comparison between the value in the stencil buffer and a reference
    /// value. To enable and disable the test, call [**glEnable**](crate::context::Context::oxidegl_enable)
    /// and [**glDisable**](crate::context::Context::oxidegl_disable) with argument
    /// [`GL_STENCIL_TEST`](crate::enums::GL_STENCIL_TEST); to control it, call
    /// [**glStencilFunc**](crate::context::Context::oxidegl_stencil_func) or [**glStencilFuncSeparate**](crate::context::Context::oxidegl_stencil_func_separate).
    ///
    /// There can be two separate sets of `sfail`, `dpfail`, and `dppass` parameters;
    /// one affects back-facing polygons, and the other affects front-facing polygons
    /// as well as other non-polygon primitives. [**glStencilOp**](crate::context::Context::oxidegl_stencil_op)
    /// sets both front and back stencil state to the same values, as if [**glStencilOpSeparate**](crate::context::Context::oxidegl_stencil_op_separate)
    /// were called with `face` set to [`GL_FRONT_AND_BACK`](crate::enums::GL_FRONT_AND_BACK).
    ///
    /// [**glStencilOpSeparate**](crate::context::Context::oxidegl_stencil_op_separate)
    /// takes three arguments that indicate what happens to the stored stencil
    /// value while stenciling is enabled. If the stencil test fails, no change
    /// is made to the pixel's color or depth buffers, and `sfail` specifies what
    /// happens to the stencil buffer contents. The following eight actions are
    /// possible.
    ///
    /// [`GL_KEEP`](crate::enums::GL_KEEP)
    ///
    /// > Keeps the current value.
    ///
    /// [`GL_ZERO`](crate::enums::GL_ZERO)
    ///
    /// > Sets the stencil buffer value to 0.
    ///
    /// [`GL_REPLACE`](crate::enums::GL_REPLACE)
    ///
    /// > Sets the stencil buffer value to *ref*, as specified by [**glStencilFunc**](crate::context::Context::oxidegl_stencil_func).
    ///
    /// [`GL_INCR`](crate::enums::GL_INCR)
    ///
    /// > Increments the current stencil buffer value. Clamps to the maximum representable
    /// > unsigned value.
    ///
    /// [`GL_INCR_WRAP`](crate::enums::GL_INCR_WRAP)
    ///
    /// > Increments the current stencil buffer value. Wraps stencil buffer value
    /// > to zero when incrementing the maximum representable unsigned value.
    ///
    /// [`GL_DECR`](crate::enums::GL_DECR)
    ///
    /// > Decrements the current stencil buffer value. Clamps to 0.
    ///
    /// [`GL_DECR_WRAP`](crate::enums::GL_DECR_WRAP)
    ///
    /// > Decrements the current stencil buffer value. Wraps stencil buffer value
    /// > to the maximum representable unsigned value when decrementing a stencil
    /// > buffer value of zero.
    ///
    /// [`GL_INVERT`](crate::enums::GL_INVERT)
    ///
    /// > Bitwise inverts the current stencil buffer value.
    ///
    /// Stencil buffer values are treated as unsigned integers. When incremented
    /// and decremented, values are clamped to 0 and `[inlineq]` `[inlineq]` [`GL_STENCIL_BITS`](crate::enums::GL_STENCIL_BITS).
    ///
    /// The other two arguments to [**glStencilOpSeparate**](crate::context::Context::oxidegl_stencil_op_separate)
    /// specify stencil buffer actions that depend on whether subsequent depth
    /// buffer tests succeed( `dppass`) or fail( `dpfail`) (see [**glDepthFunc**](crate::context::Context::oxidegl_depth_func)
    /// ). The actions are specified using the same eight symbolic constants as
    /// `sfail`. Note that `dpfail` is ignored when there is no depth buffer, or
    /// when the depth buffer is not enabled. In these cases, `sfail` and `dppass`
    /// specify stencil action when the stencil test fails and passes, respectively.
    ///
    /// ### Notes
    /// Initially the stencil test is disabled. If there is no stencil buffer,
    /// no stencil modification can occur and it is as if the stencil test always
    /// passes.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_STENCIL_FAIL`](crate::enums::GL_STENCIL_FAIL),
    /// [`GL_STENCIL_PASS_DEPTH_PASS`](crate::enums::GL_STENCIL_PASS_DEPTH_PASS),
    /// [`GL_STENCIL_PASS_DEPTH_FAIL`](crate::enums::GL_STENCIL_PASS_DEPTH_FAIL),
    /// [`GL_STENCIL_BACK_FAIL`](crate::enums::GL_STENCIL_BACK_FAIL), [`GL_STENCIL_BACK_PASS_DEPTH_PASS`](crate::enums::GL_STENCIL_BACK_PASS_DEPTH_PASS),
    /// [`GL_STENCIL_BACK_PASS_DEPTH_FAIL`](crate::enums::GL_STENCIL_BACK_PASS_DEPTH_FAIL),
    /// or [`GL_STENCIL_BITS`](crate::enums::GL_STENCIL_BITS)
    ///
    /// [**glIsEnabled**](crate::context::Context::oxidegl_is_enabled) with argument
    /// [`GL_STENCIL_TEST`](crate::enums::GL_STENCIL_TEST)

    pub fn oxidegl_stencil_op_separate(
        &mut self,
        face: TriangleFace,
        sfail: StencilOp,
        dpfail: StencilOp,
        dppass: StencilOp,
    ) {
        panic!("command oxidegl_stencil_op_separate not yet implemented");
    }
    /// ### Parameters
    /// `target`
    ///
    /// > Specifies the target texture. Must be [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D)
    /// > or [`GL_PROXY_TEXTURE_1D`](crate::enums::GL_PROXY_TEXTURE_1D).
    ///
    /// `level`
    ///
    /// > Specifies the level-of-detail number. Level 0 is the base image level.
    /// > Level *n* is the *n* th mipmap reduction image.
    ///
    /// `internalformat`
    ///
    /// > Specifies the number of color components in the texture. Must be one of
    /// > base internal formats given in Table 1, one of the sized internal formats
    /// > given in Table 2, or one of the compressed internal formats given in Table
    /// > 3, below.
    ///
    /// `width`
    ///
    /// > Specifies the width of the texture image. All implementations support texture
    /// > images that are at least 1024 texels wide. The height of the 1D texture
    /// > image is 1.
    ///
    /// `border`
    ///
    /// > This value must be 0.
    ///
    /// `format`
    ///
    /// > Specifies the format of the pixel data. The following symbolic values are
    /// > accepted: [`GL_RED`](crate::enums::GL_RED), [`GL_RG`](crate::enums::GL_RG),
    /// > [`GL_RGB`](crate::enums::GL_RGB), [`GL_BGR`](crate::enums::GL_BGR), [`GL_RGBA`](crate::enums::GL_RGBA),
    /// > [`GL_BGRA`](crate::enums::GL_BGRA), [`GL_RED_INTEGER`](crate::enums::GL_RED_INTEGER),
    /// > [`GL_RG_INTEGER`](crate::enums::GL_RG_INTEGER), [`GL_RGB_INTEGER`](crate::enums::GL_RGB_INTEGER),
    /// > [`GL_BGR_INTEGER`](crate::enums::GL_BGR_INTEGER), [`GL_RGBA_INTEGER`](crate::enums::GL_RGBA_INTEGER),
    /// > [`GL_BGRA_INTEGER`](crate::enums::GL_BGRA_INTEGER), [`GL_STENCIL_INDEX`](crate::enums::GL_STENCIL_INDEX),
    /// > [`GL_DEPTH_COMPONENT`](crate::enums::GL_DEPTH_COMPONENT), [`GL_DEPTH_STENCIL`](crate::enums::GL_DEPTH_STENCIL).
    ///
    /// `type`
    ///
    /// > Specifies the data type of the pixel data. The following symbolic values
    /// > are accepted: [`GL_UNSIGNED_BYTE`](crate::enums::GL_UNSIGNED_BYTE), [`GL_BYTE`](crate::enums::GL_BYTE),
    /// > [`GL_UNSIGNED_SHORT`](crate::enums::GL_UNSIGNED_SHORT), [`GL_SHORT`](crate::enums::GL_SHORT),
    /// > [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT), [`GL_INT`](crate::enums::GL_INT),
    /// > [`GL_HALF_FLOAT`](crate::enums::GL_HALF_FLOAT), [`GL_FLOAT`](crate::enums::GL_FLOAT),
    /// > [`GL_UNSIGNED_BYTE_3_3_2`](crate::enums::GL_UNSIGNED_BYTE_3_3_2), [`GL_UNSIGNED_BYTE_2_3_3_REV`](crate::enums::GL_UNSIGNED_BYTE_2_3_3_REV),
    /// > [`GL_UNSIGNED_SHORT_5_6_5`](crate::enums::GL_UNSIGNED_SHORT_5_6_5), [`GL_UNSIGNED_SHORT_5_6_5_REV`](crate::enums::GL_UNSIGNED_SHORT_5_6_5_REV),
    /// > [`GL_UNSIGNED_SHORT_4_4_4_4`](crate::enums::GL_UNSIGNED_SHORT_4_4_4_4),
    /// > [`GL_UNSIGNED_SHORT_4_4_4_4_REV`](crate::enums::GL_UNSIGNED_SHORT_4_4_4_4_REV),
    /// > [`GL_UNSIGNED_SHORT_5_5_5_1`](crate::enums::GL_UNSIGNED_SHORT_5_5_5_1),
    /// > [`GL_UNSIGNED_SHORT_1_5_5_5_REV`](crate::enums::GL_UNSIGNED_SHORT_1_5_5_5_REV),
    /// > [`GL_UNSIGNED_INT_8_8_8_8`](crate::enums::GL_UNSIGNED_INT_8_8_8_8), [`GL_UNSIGNED_INT_8_8_8_8_REV`](crate::enums::GL_UNSIGNED_INT_8_8_8_8_REV),
    /// > [`GL_UNSIGNED_INT_10_10_10_2`](crate::enums::GL_UNSIGNED_INT_10_10_10_2),
    /// > and [`GL_UNSIGNED_INT_2_10_10_10_REV`](crate::enums::GL_UNSIGNED_INT_2_10_10_10_REV).
    ///
    /// `data`
    ///
    /// > Specifies a pointer to the image data in memory.
    ///
    /// ### Description
    /// Texturing maps a portion of a specified texture image onto each graphical
    /// primitive for which texturing is enabled. To enable and disable one-dimensional
    /// texturing, call [**glEnable**](crate::context::Context::oxidegl_enable)
    /// and [**glDisable**](crate::context::Context::oxidegl_disable) with argument
    /// [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D).
    ///
    /// Texture images are defined with [**glTexImage1D**](crate::context::Context::oxidegl_tex_image1_d).
    /// The arguments describe the parameters of the texture image, such as width,
    /// width of the border, level-of-detail number (see [**glTexParameter**](crate::context::Context::oxidegl_tex_parameter)
    /// ), and the internal resolution and format used to store the image. The
    /// last three arguments describe how the image is represented in memory.
    ///
    /// If `target` is [`GL_PROXY_TEXTURE_1D`](crate::enums::GL_PROXY_TEXTURE_1D),
    /// no data is read from `data`, but all of the texture image state is recalculated,
    /// checked for consistency, and checked against the implementation's capabilities.
    /// If the implementation cannot handle a texture of the requested texture
    /// size, it sets all of the image state to 0, but does not generate an error
    /// (see [**glGetError**](crate::context::Context::oxidegl_get_error) ). To
    /// query for an entire mipmap array, use an image array level greater than
    /// or equal to 1.
    ///
    /// If `target` is [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D), data is
    /// read from `data` as a sequence of signed or unsigned bytes, shorts, or
    /// longs, or single-precision floating-point values, depending on `type`. These
    /// values are grouped into sets of one, two, three, or four values, depending
    /// on `format`, to form elements. Each data byte is treated as eight 1-bit
    /// elements, with bit ordering determined by [`GL_UNPACK_LSB_FIRST`](crate::enums::GL_UNPACK_LSB_FIRST)
    /// (see [**glPixelStore**](crate::context::Context::oxidegl_pixel_store) ).
    ///
    /// If a non-zero named buffer object is bound to the [`GL_PIXEL_UNPACK_BUFFER`](crate::enums::GL_PIXEL_UNPACK_BUFFER)
    /// target (see [**glBindBuffer**](crate::context::Context::oxidegl_bind_buffer))
    /// while a texture image is specified, `data` is treated as a byte offset
    /// into the buffer object's data store.
    ///
    /// The first element corresponds to the left end of the texture array. Subsequent
    /// elements progress left-to-right through the remaining texels in the texture
    /// array. The final element corresponds to the right end of the texture array.
    ///
    /// `format` determines the composition of each element in `data`. It can assume
    /// one of these symbolic values:
    ///
    /// [`GL_RED`](crate::enums::GL_RED)
    ///
    /// > Each element is a single red component. The GL converts it to floating
    /// > point and assembles it into an RGBA element by attaching 0 for green and
    /// > blue, and 1 for alpha. Each component is clamped to the range \[0,1\].
    ///
    /// [`GL_RG`](crate::enums::GL_RG)
    ///
    /// > Each element is a single red/green double The GL converts it to floating
    /// > point and assembles it into an RGBA element by attaching 0 for blue, and
    /// > 1 for alpha. Each component is clamped to the range \[0,1\].
    ///
    /// [`GL_RGB`](crate::enums::GL_RGB)
    ///
    /// [`GL_BGR`](crate::enums::GL_BGR)
    ///
    /// > Each element is an RGB triple. The GL converts it to floating point and
    /// > assembles it into an RGBA element by attaching 1 for alpha. Each component
    /// > is clamped to the range \[0,1\].
    ///
    /// [`GL_RGBA`](crate::enums::GL_RGBA)
    ///
    /// [`GL_BGRA`](crate::enums::GL_BGRA)
    ///
    /// > Each element contains all four components. Each component clamped to the
    /// > range \[0,1\].
    ///
    /// [`GL_DEPTH_COMPONENT`](crate::enums::GL_DEPTH_COMPONENT)
    ///
    /// > Each element is a single depth value. The GL converts it to floating point
    /// > and clamps to the range \[0,1\].
    ///
    /// If an application wants to store the texture at a certain resolution or
    /// in a certain format, it can request the resolution and format with `internalformat`.
    /// The GL will choose an internal representation that closely approximates
    /// that requested by `internalformat`, but it may not match exactly. (The
    /// representations specified by [`GL_RED`](crate::enums::GL_RED), [`GL_RG`](crate::enums::GL_RG),
    /// [`GL_RGB`](crate::enums::GL_RGB) and [`GL_RGBA`](crate::enums::GL_RGBA)
    /// must match exactly.)
    ///
    /// `internalformat` may be one of the base internal formats shown in Table
    /// 1, below
    ///
    /// | *Base Internal Format*                               | *RGBA, Depth and Stencil Values*                                    | *Internal Components*                              |
    /// |------------------------------------------------------|---------------------------------------------------------------------|----------------------------------------------------|
    /// | [`GL_DEPTH_COMPONENT`](crate::enums::GL_DEPTH_COMPONENT) | Depth                                                           | D                                                  |
    /// | [`GL_DEPTH_STENCIL`](crate::enums::GL_DEPTH_STENCIL) | Depth, Stencil                                                      | D, S                                               |
    /// | [`GL_RED`](crate::enums::GL_RED)                     | Red                                                                 | R                                                  |
    /// | [`GL_RG`](crate::enums::GL_RG)                       | Red, Green                                                          | R, G                                               |
    /// | [`GL_RGB`](crate::enums::GL_RGB)                     | Red, Green, Blue                                                    | R, G, B                                            |
    /// | [`GL_RGBA`](crate::enums::GL_RGBA)                   | Red, Green, Blue, Alpha                                             | R, G, B, A                                         |
    ///
    ///
    /// `internalformat` may also be one of the sized internal formats shown in
    /// Table 2, below
    ///
    /// | *Sized Internal Format*                               | *Base Internal Format*                               | *Red Bits*       | *Green Bits*        | *Blue Bits*       | *Alpha Bits*        | *Shared Bits*        |
    /// |-------------------------------------------------------|------------------------------------------------------|------------------|---------------------|-------------------|---------------------|----------------------|
    /// | [`GL_R8`](crate::enums::GL_R8)                        | [`GL_RED`](crate::enums::GL_RED)                     | 8                |                     |                   |                     |                      |
    /// | [`GL_R8_SNORM`](crate::enums::GL_R8_SNORM)            | [`GL_RED`](crate::enums::GL_RED)                     | s8               |                     |                   |                     |                      |
    /// | [`GL_R16`](crate::enums::GL_R16)                      | [`GL_RED`](crate::enums::GL_RED)                     | 16               |                     |                   |                     |                      |
    /// | [`GL_R16_SNORM`](crate::enums::GL_R16_SNORM)          | [`GL_RED`](crate::enums::GL_RED)                     | s16              |                     |                   |                     |                      |
    /// | [`GL_RG8`](crate::enums::GL_RG8)                      | [`GL_RG`](crate::enums::GL_RG)                       | 8                | 8                   |                   |                     |                      |
    /// | [`GL_RG8_SNORM`](crate::enums::GL_RG8_SNORM)          | [`GL_RG`](crate::enums::GL_RG)                       | s8               | s8                  |                   |                     |                      |
    /// | [`GL_RG16`](crate::enums::GL_RG16)                    | [`GL_RG`](crate::enums::GL_RG)                       | 16               | 16                  |                   |                     |                      |
    /// | [`GL_RG16_SNORM`](crate::enums::GL_RG16_SNORM)        | [`GL_RG`](crate::enums::GL_RG)                       | s16              | s16                 |                   |                     |                      |
    /// | [`GL_R3_G3_B2`](crate::enums::GL_R3_G3_B2)            | [`GL_RGB`](crate::enums::GL_RGB)                     | 3                | 3                   | 2                 |                     |                      |
    /// | [`GL_RGB4`](crate::enums::GL_RGB4)                    | [`GL_RGB`](crate::enums::GL_RGB)                     | 4                | 4                   | 4                 |                     |                      |
    /// | [`GL_RGB5`](crate::enums::GL_RGB5)                    | [`GL_RGB`](crate::enums::GL_RGB)                     | 5                | 5                   | 5                 |                     |                      |
    /// | [`GL_RGB8`](crate::enums::GL_RGB8)                    | [`GL_RGB`](crate::enums::GL_RGB)                     | 8                | 8                   | 8                 |                     |                      |
    /// | [`GL_RGB8_SNORM`](crate::enums::GL_RGB8_SNORM)        | [`GL_RGB`](crate::enums::GL_RGB)                     | s8               | s8                  | s8                |                     |                      |
    /// | [`GL_RGB10`](crate::enums::GL_RGB10)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 10               | 10                  | 10                |                     |                      |
    /// | [`GL_RGB12`](crate::enums::GL_RGB12)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 12               | 12                  | 12                |                     |                      |
    /// | [`GL_RGB16_SNORM`](crate::enums::GL_RGB16_SNORM)      | [`GL_RGB`](crate::enums::GL_RGB)                     | 16               | 16                  | 16                |                     |                      |
    /// | [`GL_RGBA2`](crate::enums::GL_RGBA2)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 2                | 2                   | 2                 | 2                   |                      |
    /// | [`GL_RGBA4`](crate::enums::GL_RGBA4)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 4                | 4                   | 4                 | 4                   |                      |
    /// | [`GL_RGB5_A1`](crate::enums::GL_RGB5_A1)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 5                | 5                   | 5                 | 1                   |                      |
    /// | [`GL_RGBA8`](crate::enums::GL_RGBA8)                  | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 8                | 8                   | 8                 | 8                   |                      |
    /// | [`GL_RGBA8_SNORM`](crate::enums::GL_RGBA8_SNORM)      | [`GL_RGBA`](crate::enums::GL_RGBA)                   | s8               | s8                  | s8                | s8                  |                      |
    /// | [`GL_RGB10_A2`](crate::enums::GL_RGB10_A2)            | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 10               | 10                  | 10                | 2                   |                      |
    /// | [`GL_RGB10_A2UI`](crate::enums::GL_RGB10_A2UI)        | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui10             | ui10                | ui10              | ui2                 |                      |
    /// | [`GL_RGBA12`](crate::enums::GL_RGBA12)                | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 12               | 12                  | 12                | 12                  |                      |
    /// | [`GL_RGBA16`](crate::enums::GL_RGBA16)                | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 16               | 16                  | 16                | 16                  |                      |
    /// | [`GL_SRGB8`](crate::enums::GL_SRGB8)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 8                | 8                   | 8                 |                     |                      |
    /// | [`GL_SRGB8_ALPHA8`](crate::enums::GL_SRGB8_ALPHA8)    | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 8                | 8                   | 8                 | 8                   |                      |
    /// | [`GL_R16F`](crate::enums::GL_R16F)                    | [`GL_RED`](crate::enums::GL_RED)                     | f16              |                     |                   |                     |                      |
    /// | [`GL_RG16F`](crate::enums::GL_RG16F)                  | [`GL_RG`](crate::enums::GL_RG)                       | f16              | f16                 |                   |                     |                      |
    /// | [`GL_RGB16F`](crate::enums::GL_RGB16F)                | [`GL_RGB`](crate::enums::GL_RGB)                     | f16              | f16                 | f16               |                     |                      |
    /// | [`GL_RGBA16F`](crate::enums::GL_RGBA16F)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | f16              | f16                 | f16               | f16                 |                      |
    /// | [`GL_R32F`](crate::enums::GL_R32F)                    | [`GL_RED`](crate::enums::GL_RED)                     | f32              |                     |                   |                     |                      |
    /// | [`GL_RG32F`](crate::enums::GL_RG32F)                  | [`GL_RG`](crate::enums::GL_RG)                       | f32              | f32                 |                   |                     |                      |
    /// | [`GL_RGB32F`](crate::enums::GL_RGB32F)                | [`GL_RGB`](crate::enums::GL_RGB)                     | f32              | f32                 | f32               |                     |                      |
    /// | [`GL_RGBA32F`](crate::enums::GL_RGBA32F)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | f32              | f32                 | f32               | f32                 |                      |
    /// | [`GL_R11F_G11F_B10F`](crate::enums::GL_R11F_G11F_B10F) | [`GL_RGB`](crate::enums::GL_RGB)                    | f11              | f11                 | f10               |                     |                      |
    /// | [`GL_RGB9_E5`](crate::enums::GL_RGB9_E5)              | [`GL_RGB`](crate::enums::GL_RGB)                     | 9                | 9                   | 9                 |                     | 5                    |
    /// | [`GL_R8I`](crate::enums::GL_R8I)                      | [`GL_RED`](crate::enums::GL_RED)                     | i8               |                     |                   |                     |                      |
    /// | [`GL_R8UI`](crate::enums::GL_R8UI)                    | [`GL_RED`](crate::enums::GL_RED)                     | ui8              |                     |                   |                     |                      |
    /// | [`GL_R16I`](crate::enums::GL_R16I)                    | [`GL_RED`](crate::enums::GL_RED)                     | i16              |                     |                   |                     |                      |
    /// | [`GL_R16UI`](crate::enums::GL_R16UI)                  | [`GL_RED`](crate::enums::GL_RED)                     | ui16             |                     |                   |                     |                      |
    /// | [`GL_R32I`](crate::enums::GL_R32I)                    | [`GL_RED`](crate::enums::GL_RED)                     | i32              |                     |                   |                     |                      |
    /// | [`GL_R32UI`](crate::enums::GL_R32UI)                  | [`GL_RED`](crate::enums::GL_RED)                     | ui32             |                     |                   |                     |                      |
    /// | [`GL_RG8I`](crate::enums::GL_RG8I)                    | [`GL_RG`](crate::enums::GL_RG)                       | i8               | i8                  |                   |                     |                      |
    /// | [`GL_RG8UI`](crate::enums::GL_RG8UI)                  | [`GL_RG`](crate::enums::GL_RG)                       | ui8              | ui8                 |                   |                     |                      |
    /// | [`GL_RG16I`](crate::enums::GL_RG16I)                  | [`GL_RG`](crate::enums::GL_RG)                       | i16              | i16                 |                   |                     |                      |
    /// | [`GL_RG16UI`](crate::enums::GL_RG16UI)                | [`GL_RG`](crate::enums::GL_RG)                       | ui16             | ui16                |                   |                     |                      |
    /// | [`GL_RG32I`](crate::enums::GL_RG32I)                  | [`GL_RG`](crate::enums::GL_RG)                       | i32              | i32                 |                   |                     |                      |
    /// | [`GL_RG32UI`](crate::enums::GL_RG32UI)                | [`GL_RG`](crate::enums::GL_RG)                       | ui32             | ui32                |                   |                     |                      |
    /// | [`GL_RGB8I`](crate::enums::GL_RGB8I)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | i8               | i8                  | i8                |                     |                      |
    /// | [`GL_RGB8UI`](crate::enums::GL_RGB8UI)                | [`GL_RGB`](crate::enums::GL_RGB)                     | ui8              | ui8                 | ui8               |                     |                      |
    /// | [`GL_RGB16I`](crate::enums::GL_RGB16I)                | [`GL_RGB`](crate::enums::GL_RGB)                     | i16              | i16                 | i16               |                     |                      |
    /// | [`GL_RGB16UI`](crate::enums::GL_RGB16UI)              | [`GL_RGB`](crate::enums::GL_RGB)                     | ui16             | ui16                | ui16              |                     |                      |
    /// | [`GL_RGB32I`](crate::enums::GL_RGB32I)                | [`GL_RGB`](crate::enums::GL_RGB)                     | i32              | i32                 | i32               |                     |                      |
    /// | [`GL_RGB32UI`](crate::enums::GL_RGB32UI)              | [`GL_RGB`](crate::enums::GL_RGB)                     | ui32             | ui32                | ui32              |                     |                      |
    /// | [`GL_RGBA8I`](crate::enums::GL_RGBA8I)                | [`GL_RGBA`](crate::enums::GL_RGBA)                   | i8               | i8                  | i8                | i8                  |                      |
    /// | [`GL_RGBA8UI`](crate::enums::GL_RGBA8UI)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui8              | ui8                 | ui8               | ui8                 |                      |
    /// | [`GL_RGBA16I`](crate::enums::GL_RGBA16I)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | i16              | i16                 | i16               | i16                 |                      |
    /// | [`GL_RGBA16UI`](crate::enums::GL_RGBA16UI)            | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui16             | ui16                | ui16              | ui16                |                      |
    /// | [`GL_RGBA32I`](crate::enums::GL_RGBA32I)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | i32              | i32                 | i32               | i32                 |                      |
    /// | [`GL_RGBA32UI`](crate::enums::GL_RGBA32UI)            | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui32             | ui32                | ui32              | ui32                |                      |
    ///
    ///
    /// Finally, `internalformat` may also be one of the generic or compressed
    /// texture formats shown in Table 3 below
    ///
    /// | *Compressed Internal Format*                                  | *Base Internal Format*                               | *Type*     |
    /// |---------------------------------------------------------------|------------------------------------------------------|------------|
    /// | [`GL_COMPRESSED_RED`](crate::enums::GL_COMPRESSED_RED)        | [`GL_RED`](crate::enums::GL_RED)                     | Generic    |
    /// | [`GL_COMPRESSED_RG`](crate::enums::GL_COMPRESSED_RG)          | [`GL_RG`](crate::enums::GL_RG)                       | Generic    |
    /// | [`GL_COMPRESSED_RGB`](crate::enums::GL_COMPRESSED_RGB)        | [`GL_RGB`](crate::enums::GL_RGB)                     | Generic    |
    /// | [`GL_COMPRESSED_RGBA`](crate::enums::GL_COMPRESSED_RGBA)      | [`GL_RGBA`](crate::enums::GL_RGBA)                   | Generic    |
    /// | [`GL_COMPRESSED_SRGB`](crate::enums::GL_COMPRESSED_SRGB)      | [`GL_RGB`](crate::enums::GL_RGB)                     | Generic    |
    /// | [`GL_COMPRESSED_SRGB_ALPHA`](crate::enums::GL_COMPRESSED_SRGB_ALPHA) | [`GL_RGBA`](crate::enums::GL_RGBA)            | Generic    |
    /// | [`GL_COMPRESSED_RED_RGTC1`](crate::enums::GL_COMPRESSED_RED_RGTC1) | [`GL_RED`](crate::enums::GL_RED)                | Specific   |
    /// | [`GL_COMPRESSED_SIGNED_RED_RGTC1`](crate::enums::GL_COMPRESSED_SIGNED_RED_RGTC1) | [`GL_RED`](crate::enums::GL_RED)  | Specific   |
    /// | [`GL_COMPRESSED_RG_RGTC2`](crate::enums::GL_COMPRESSED_RG_RGTC2) | [`GL_RG`](crate::enums::GL_RG)                    | Specific   |
    /// | [`GL_COMPRESSED_SIGNED_RG_RGTC2`](crate::enums::GL_COMPRESSED_SIGNED_RG_RGTC2) | [`GL_RG`](crate::enums::GL_RG)      | Specific   |
    /// | [`GL_COMPRESSED_RGBA_BPTC_UNORM`](crate::enums::GL_COMPRESSED_RGBA_BPTC_UNORM) | [`GL_RGBA`](crate::enums::GL_RGBA)  | Specific   |
    /// | [`GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM`](crate::enums::GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM) | [`GL_RGBA`](crate::enums::GL_RGBA) | Specific |
    /// | [`GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT`](crate::enums::GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT) | [`GL_RGB`](crate::enums::GL_RGB) | Specific |
    /// | [`GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT`](crate::enums::GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT) | [`GL_RGB`](crate::enums::GL_RGB) | Specific |
    ///
    ///
    /// If the `internalformat` parameter is one of the generic compressed formats,
    /// [`GL_COMPRESSED_RED`](crate::enums::GL_COMPRESSED_RED), [`GL_COMPRESSED_RG`](crate::enums::GL_COMPRESSED_RG),
    /// [`GL_COMPRESSED_RGB`](crate::enums::GL_COMPRESSED_RGB), or [`GL_COMPRESSED_RGBA`](crate::enums::GL_COMPRESSED_RGBA),
    /// the GL will replace the internal format with the symbolic constant for
    /// a specific internal format and compress the texture before storage. If
    /// no corresponding internal format is available, or the GL can not compress
    /// that image for any reason, the internal format is instead replaced with
    /// a corresponding base internal format.
    ///
    /// If the `internalformat` parameter is [`GL_SRGB`](crate::enums::GL_SRGB),
    /// [`GL_SRGB8`](crate::enums::GL_SRGB8), [`GL_SRGB_ALPHA`](crate::enums::GL_SRGB_ALPHA)
    /// or [`GL_SRGB8_ALPHA8`](crate::enums::GL_SRGB8_ALPHA8), the texture is treated
    /// as if the red, green, or blue components are encoded in the sRGB color
    /// space. Any alpha component is left unchanged. The conversion from the sRGB
    /// encoded component `[inlineq]` `[inlineq]`
    ///
    /// `[inlineq]`
    ///
    /// Assume `[inlineq]`
    ///
    /// Use the [`GL_PROXY_TEXTURE_1D`](crate::enums::GL_PROXY_TEXTURE_1D) target
    /// to try out a resolution and format. The implementation will update and
    /// recompute its best match for the requested storage resolution and format.
    /// To then query this state, call [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter).
    /// If the texture cannot be accommodated, texture state is set to 0.
    ///
    /// A one-component texture image uses only the red component of the RGBA color
    /// from `data`. A two-component image uses the R and A values. A three-component
    /// image uses the R, G, and B values. A four-component image uses all of the
    /// RGBA components.
    ///
    /// Image-based shadowing can be enabled by comparing texture r coordinates
    /// to depth texture values to generate a boolean result. See [**glTexParameter**](crate::context::Context::oxidegl_tex_parameter)
    /// for details on texture comparison.
    ///
    /// ### Notes
    /// [**glPixelStore**](crate::context::Context::oxidegl_pixel_store) modes
    /// affect texture images.
    ///
    /// `data` may be a null pointer. In this case texture memory is allocated
    /// to accommodate a texture of width `width`. You can then download subtextures
    /// to initialize the texture memory. The image is undefined if the program
    /// tries to apply an uninitialized portion of the texture image to a primitive.
    ///
    /// [**glTexImage1D**](crate::context::Context::oxidegl_tex_image1_d) specifies
    /// the one-dimensional texture for the current texture unit, specified with
    /// [**glActiveTexture**](crate::context::Context::oxidegl_active_texture).
    ///
    /// [`GL_STENCIL_INDEX`](crate::enums::GL_STENCIL_INDEX) may be used for `format`
    /// only if the GL version is 4.4 or higher.
    ///
    /// ### Associated Gets
    /// [**glGetTexImage**](crate::context::Context::oxidegl_get_tex_image)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_PIXEL_UNPACK_BUFFER_BINDING`](crate::enums::GL_PIXEL_UNPACK_BUFFER_BINDING)

    pub unsafe fn oxidegl_tex_image1_d(
        &mut self,
        target: TextureTarget,
        level: GLint,
        internalformat: InternalFormat,
        width: GLsizei,
        border: GLint,
        format: PixelFormat,
        r#type: PixelType,
        pixels: *const GLvoid,
    ) {
        panic!("command oxidegl_tex_image1_d not yet implemented");
    }
    /// ### Parameters
    /// `target`
    ///
    /// > Specifies the target texture. Must be [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D),
    /// > [`GL_PROXY_TEXTURE_2D`](crate::enums::GL_PROXY_TEXTURE_2D), [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY),
    /// > [`GL_PROXY_TEXTURE_1D_ARRAY`](crate::enums::GL_PROXY_TEXTURE_1D_ARRAY),
    /// > [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE), [`GL_PROXY_TEXTURE_RECTANGLE`](crate::enums::GL_PROXY_TEXTURE_RECTANGLE),
    /// > [`GL_TEXTURE_CUBE_MAP_POSITIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_X),
    /// > [`GL_TEXTURE_CUBE_MAP_NEGATIVE_X`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_X),
    /// > [`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Y),
    /// > [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Y),
    /// > [`GL_TEXTURE_CUBE_MAP_POSITIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_POSITIVE_Z),
    /// > [`GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`](crate::enums::GL_TEXTURE_CUBE_MAP_NEGATIVE_Z),
    /// > or [`GL_PROXY_TEXTURE_CUBE_MAP`](crate::enums::GL_PROXY_TEXTURE_CUBE_MAP).
    ///
    /// `level`
    ///
    /// > Specifies the level-of-detail number. Level 0 is the base image level.
    /// > Level *n* is the *n* th mipmap reduction image. If `target` is [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE)
    /// > or [`GL_PROXY_TEXTURE_RECTANGLE`](crate::enums::GL_PROXY_TEXTURE_RECTANGLE),
    /// > `level` must be 0.
    ///
    /// `internalformat`
    ///
    /// > Specifies the number of color components in the texture. Must be one of
    /// > base internal formats given in Table 1, one of the sized internal formats
    /// > given in Table 2, or one of the compressed internal formats given in Table
    /// > 3, below.
    ///
    /// `width`
    ///
    /// > Specifies the width of the texture image. All implementations support texture
    /// > images that are at least 1024 texels wide.
    ///
    /// `height`
    ///
    /// > Specifies the height of the texture image, or the number of layers in a
    /// > texture array, in the case of the [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY)
    /// > and [`GL_PROXY_TEXTURE_1D_ARRAY`](crate::enums::GL_PROXY_TEXTURE_1D_ARRAY)
    /// > targets. All implementations support 2D texture images that are at least
    /// > 1024 texels high, and texture arrays that are at least 256 layers deep.
    ///
    /// `border`
    ///
    /// > This value must be 0.
    ///
    /// `format`
    ///
    /// > Specifies the format of the pixel data. The following symbolic values are
    /// > accepted: [`GL_RED`](crate::enums::GL_RED), [`GL_RG`](crate::enums::GL_RG),
    /// > [`GL_RGB`](crate::enums::GL_RGB), [`GL_BGR`](crate::enums::GL_BGR), [`GL_RGBA`](crate::enums::GL_RGBA),
    /// > [`GL_BGRA`](crate::enums::GL_BGRA), [`GL_RED_INTEGER`](crate::enums::GL_RED_INTEGER),
    /// > [`GL_RG_INTEGER`](crate::enums::GL_RG_INTEGER), [`GL_RGB_INTEGER`](crate::enums::GL_RGB_INTEGER),
    /// > [`GL_BGR_INTEGER`](crate::enums::GL_BGR_INTEGER), [`GL_RGBA_INTEGER`](crate::enums::GL_RGBA_INTEGER),
    /// > [`GL_BGRA_INTEGER`](crate::enums::GL_BGRA_INTEGER), [`GL_STENCIL_INDEX`](crate::enums::GL_STENCIL_INDEX),
    /// > [`GL_DEPTH_COMPONENT`](crate::enums::GL_DEPTH_COMPONENT), [`GL_DEPTH_STENCIL`](crate::enums::GL_DEPTH_STENCIL).
    ///
    /// `type`
    ///
    /// > Specifies the data type of the pixel data. The following symbolic values
    /// > are accepted: [`GL_UNSIGNED_BYTE`](crate::enums::GL_UNSIGNED_BYTE), [`GL_BYTE`](crate::enums::GL_BYTE),
    /// > [`GL_UNSIGNED_SHORT`](crate::enums::GL_UNSIGNED_SHORT), [`GL_SHORT`](crate::enums::GL_SHORT),
    /// > [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT), [`GL_INT`](crate::enums::GL_INT),
    /// > [`GL_HALF_FLOAT`](crate::enums::GL_HALF_FLOAT), [`GL_FLOAT`](crate::enums::GL_FLOAT),
    /// > [`GL_UNSIGNED_BYTE_3_3_2`](crate::enums::GL_UNSIGNED_BYTE_3_3_2), [`GL_UNSIGNED_BYTE_2_3_3_REV`](crate::enums::GL_UNSIGNED_BYTE_2_3_3_REV),
    /// > [`GL_UNSIGNED_SHORT_5_6_5`](crate::enums::GL_UNSIGNED_SHORT_5_6_5), [`GL_UNSIGNED_SHORT_5_6_5_REV`](crate::enums::GL_UNSIGNED_SHORT_5_6_5_REV),
    /// > [`GL_UNSIGNED_SHORT_4_4_4_4`](crate::enums::GL_UNSIGNED_SHORT_4_4_4_4),
    /// > [`GL_UNSIGNED_SHORT_4_4_4_4_REV`](crate::enums::GL_UNSIGNED_SHORT_4_4_4_4_REV),
    /// > [`GL_UNSIGNED_SHORT_5_5_5_1`](crate::enums::GL_UNSIGNED_SHORT_5_5_5_1),
    /// > [`GL_UNSIGNED_SHORT_1_5_5_5_REV`](crate::enums::GL_UNSIGNED_SHORT_1_5_5_5_REV),
    /// > [`GL_UNSIGNED_INT_8_8_8_8`](crate::enums::GL_UNSIGNED_INT_8_8_8_8), [`GL_UNSIGNED_INT_8_8_8_8_REV`](crate::enums::GL_UNSIGNED_INT_8_8_8_8_REV),
    /// > [`GL_UNSIGNED_INT_10_10_10_2`](crate::enums::GL_UNSIGNED_INT_10_10_10_2),
    /// > and [`GL_UNSIGNED_INT_2_10_10_10_REV`](crate::enums::GL_UNSIGNED_INT_2_10_10_10_REV).
    ///
    /// `data`
    ///
    /// > Specifies a pointer to the image data in memory.
    ///
    /// ### Description
    /// Texturing allows elements of an image array to be read by shaders.
    ///
    /// To define texture images, call [**glTexImage2D**](crate::context::Context::oxidegl_tex_image2_d).
    /// The arguments describe the parameters of the texture image, such as height,
    /// width, width of the border, level-of-detail number (see [**glTexParameter**](crate::context::Context::oxidegl_tex_parameter)
    /// ), and number of color components provided. The last three arguments describe
    /// how the image is represented in memory.
    ///
    /// If `target` is [`GL_PROXY_TEXTURE_2D`](crate::enums::GL_PROXY_TEXTURE_2D),
    /// [`GL_PROXY_TEXTURE_1D_ARRAY`](crate::enums::GL_PROXY_TEXTURE_1D_ARRAY),
    /// [`GL_PROXY_TEXTURE_CUBE_MAP`](crate::enums::GL_PROXY_TEXTURE_CUBE_MAP),
    /// or [`GL_PROXY_TEXTURE_RECTANGLE`](crate::enums::GL_PROXY_TEXTURE_RECTANGLE),
    /// no data is read from `data`, but all of the texture image state is recalculated,
    /// checked for consistency, and checked against the implementation's capabilities.
    /// If the implementation cannot handle a texture of the requested texture
    /// size, it sets all of the image state to 0, but does not generate an error
    /// (see [**glGetError**](crate::context::Context::oxidegl_get_error) ). To
    /// query for an entire mipmap array, use an image array level greater than
    /// or equal to 1.
    ///
    /// If `target` is [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D), [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE)
    /// or one of the [`GL_TEXTURE_CUBE_MAP`](crate::enums::GL_TEXTURE_CUBE_MAP)
    /// targets, data is read from `data` as a sequence of signed or unsigned bytes,
    /// shorts, or longs, or single-precision floating-point values, depending
    /// on `type`. These values are grouped into sets of one, two, three, or four
    /// values, depending on `format`, to form elements. Each data byte is treated
    /// as eight 1-bit elements, with bit ordering determined by [`GL_UNPACK_LSB_FIRST`](crate::enums::GL_UNPACK_LSB_FIRST)
    /// (see [**glPixelStore**](crate::context::Context::oxidegl_pixel_store) ).
    ///
    /// If `target` is [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY),
    /// data is interpreted as an array of one-dimensional images.
    ///
    /// If a non-zero named buffer object is bound to the [`GL_PIXEL_UNPACK_BUFFER`](crate::enums::GL_PIXEL_UNPACK_BUFFER)
    /// target (see [**glBindBuffer**](crate::context::Context::oxidegl_bind_buffer))
    /// while a texture image is specified, `data` is treated as a byte offset
    /// into the buffer object's data store.
    ///
    /// The first element corresponds to the lower left corner of the texture image.
    /// Subsequent elements progress left-to-right through the remaining texels
    /// in the lowest row of the texture image, and then in successively higher
    /// rows of the texture image. The final element corresponds to the upper right
    /// corner of the texture image.
    ///
    /// `format` determines the composition of each element in `data`. It can assume
    /// one of these symbolic values:
    ///
    /// [`GL_RED`](crate::enums::GL_RED)
    ///
    /// > Each element is a single red component. The GL converts it to floating
    /// > point and assembles it into an RGBA element by attaching 0 for green and
    /// > blue, and 1 for alpha. Each component is clamped to the range \[0,1\].
    ///
    /// [`GL_RG`](crate::enums::GL_RG)
    ///
    /// > Each element is a red/green double. The GL converts it to floating point
    /// > and assembles it into an RGBA element by attaching 0 for blue, and 1 for
    /// > alpha. Each component is clamped to the range \[0,1\].
    ///
    /// [`GL_RGB`](crate::enums::GL_RGB)
    ///
    /// [`GL_BGR`](crate::enums::GL_BGR)
    ///
    /// > Each element is an RGB triple. The GL converts it to floating point and
    /// > assembles it into an RGBA element by attaching 1 for alpha. Each component
    /// > is clamped to the range \[0,1\].
    ///
    /// [`GL_RGBA`](crate::enums::GL_RGBA)
    ///
    /// [`GL_BGRA`](crate::enums::GL_BGRA)
    ///
    /// > Each element contains all four components. Each component is clamped to
    /// > the range \[0,1\].
    ///
    /// [`GL_DEPTH_COMPONENT`](crate::enums::GL_DEPTH_COMPONENT)
    ///
    /// > Each element is a single depth value. The GL converts it to floating point
    /// > and clamps to the range \[0,1\].
    ///
    /// [`GL_DEPTH_STENCIL`](crate::enums::GL_DEPTH_STENCIL)
    ///
    /// > Each element is a pair of depth and stencil values. The depth component
    /// > of the pair is interpreted as in [`GL_DEPTH_COMPONENT`](crate::enums::GL_DEPTH_COMPONENT).
    /// > The stencil component is interpreted based on specified the depth+ stencil
    /// > internal format.
    ///
    /// If an application wants to store the texture at a certain resolution or
    /// in a certain format, it can request the resolution and format with `internalformat`.
    /// The GL will choose an internal representation that closely approximates
    /// that requested by `internalformat`, but it may not match exactly. (The
    /// representations specified by [`GL_RED`](crate::enums::GL_RED), [`GL_RG`](crate::enums::GL_RG),
    /// [`GL_RGB`](crate::enums::GL_RGB), and [`GL_RGBA`](crate::enums::GL_RGBA)
    /// must match exactly.)
    ///
    /// `internalformat` may be one of the base internal formats shown in Table
    /// 1, below
    ///
    /// | *Base Internal Format*                               | *RGBA, Depth and Stencil Values*                                    | *Internal Components*                              |
    /// |------------------------------------------------------|---------------------------------------------------------------------|----------------------------------------------------|
    /// | [`GL_DEPTH_COMPONENT`](crate::enums::GL_DEPTH_COMPONENT) | Depth                                                           | D                                                  |
    /// | [`GL_DEPTH_STENCIL`](crate::enums::GL_DEPTH_STENCIL) | Depth, Stencil                                                      | D, S                                               |
    /// | [`GL_RED`](crate::enums::GL_RED)                     | Red                                                                 | R                                                  |
    /// | [`GL_RG`](crate::enums::GL_RG)                       | Red, Green                                                          | R, G                                               |
    /// | [`GL_RGB`](crate::enums::GL_RGB)                     | Red, Green, Blue                                                    | R, G, B                                            |
    /// | [`GL_RGBA`](crate::enums::GL_RGBA)                   | Red, Green, Blue, Alpha                                             | R, G, B, A                                         |
    ///
    ///
    /// `internalformat` may also be one of the sized internal formats shown in
    /// Table 2, below
    ///
    /// | *Sized Internal Format*                               | *Base Internal Format*                               | *Red Bits*       | *Green Bits*        | *Blue Bits*       | *Alpha Bits*        | *Shared Bits*        |
    /// |-------------------------------------------------------|------------------------------------------------------|------------------|---------------------|-------------------|---------------------|----------------------|
    /// | [`GL_R8`](crate::enums::GL_R8)                        | [`GL_RED`](crate::enums::GL_RED)                     | 8                |                     |                   |                     |                      |
    /// | [`GL_R8_SNORM`](crate::enums::GL_R8_SNORM)            | [`GL_RED`](crate::enums::GL_RED)                     | s8               |                     |                   |                     |                      |
    /// | [`GL_R16`](crate::enums::GL_R16)                      | [`GL_RED`](crate::enums::GL_RED)                     | 16               |                     |                   |                     |                      |
    /// | [`GL_R16_SNORM`](crate::enums::GL_R16_SNORM)          | [`GL_RED`](crate::enums::GL_RED)                     | s16              |                     |                   |                     |                      |
    /// | [`GL_RG8`](crate::enums::GL_RG8)                      | [`GL_RG`](crate::enums::GL_RG)                       | 8                | 8                   |                   |                     |                      |
    /// | [`GL_RG8_SNORM`](crate::enums::GL_RG8_SNORM)          | [`GL_RG`](crate::enums::GL_RG)                       | s8               | s8                  |                   |                     |                      |
    /// | [`GL_RG16`](crate::enums::GL_RG16)                    | [`GL_RG`](crate::enums::GL_RG)                       | 16               | 16                  |                   |                     |                      |
    /// | [`GL_RG16_SNORM`](crate::enums::GL_RG16_SNORM)        | [`GL_RG`](crate::enums::GL_RG)                       | s16              | s16                 |                   |                     |                      |
    /// | [`GL_R3_G3_B2`](crate::enums::GL_R3_G3_B2)            | [`GL_RGB`](crate::enums::GL_RGB)                     | 3                | 3                   | 2                 |                     |                      |
    /// | [`GL_RGB4`](crate::enums::GL_RGB4)                    | [`GL_RGB`](crate::enums::GL_RGB)                     | 4                | 4                   | 4                 |                     |                      |
    /// | [`GL_RGB5`](crate::enums::GL_RGB5)                    | [`GL_RGB`](crate::enums::GL_RGB)                     | 5                | 5                   | 5                 |                     |                      |
    /// | [`GL_RGB8`](crate::enums::GL_RGB8)                    | [`GL_RGB`](crate::enums::GL_RGB)                     | 8                | 8                   | 8                 |                     |                      |
    /// | [`GL_RGB8_SNORM`](crate::enums::GL_RGB8_SNORM)        | [`GL_RGB`](crate::enums::GL_RGB)                     | s8               | s8                  | s8                |                     |                      |
    /// | [`GL_RGB10`](crate::enums::GL_RGB10)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 10               | 10                  | 10                |                     |                      |
    /// | [`GL_RGB12`](crate::enums::GL_RGB12)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 12               | 12                  | 12                |                     |                      |
    /// | [`GL_RGB16_SNORM`](crate::enums::GL_RGB16_SNORM)      | [`GL_RGB`](crate::enums::GL_RGB)                     | 16               | 16                  | 16                |                     |                      |
    /// | [`GL_RGBA2`](crate::enums::GL_RGBA2)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 2                | 2                   | 2                 | 2                   |                      |
    /// | [`GL_RGBA4`](crate::enums::GL_RGBA4)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 4                | 4                   | 4                 | 4                   |                      |
    /// | [`GL_RGB5_A1`](crate::enums::GL_RGB5_A1)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 5                | 5                   | 5                 | 1                   |                      |
    /// | [`GL_RGBA8`](crate::enums::GL_RGBA8)                  | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 8                | 8                   | 8                 | 8                   |                      |
    /// | [`GL_RGBA8_SNORM`](crate::enums::GL_RGBA8_SNORM)      | [`GL_RGBA`](crate::enums::GL_RGBA)                   | s8               | s8                  | s8                | s8                  |                      |
    /// | [`GL_RGB10_A2`](crate::enums::GL_RGB10_A2)            | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 10               | 10                  | 10                | 2                   |                      |
    /// | [`GL_RGB10_A2UI`](crate::enums::GL_RGB10_A2UI)        | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui10             | ui10                | ui10              | ui2                 |                      |
    /// | [`GL_RGBA12`](crate::enums::GL_RGBA12)                | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 12               | 12                  | 12                | 12                  |                      |
    /// | [`GL_RGBA16`](crate::enums::GL_RGBA16)                | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 16               | 16                  | 16                | 16                  |                      |
    /// | [`GL_SRGB8`](crate::enums::GL_SRGB8)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 8                | 8                   | 8                 |                     |                      |
    /// | [`GL_SRGB8_ALPHA8`](crate::enums::GL_SRGB8_ALPHA8)    | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 8                | 8                   | 8                 | 8                   |                      |
    /// | [`GL_R16F`](crate::enums::GL_R16F)                    | [`GL_RED`](crate::enums::GL_RED)                     | f16              |                     |                   |                     |                      |
    /// | [`GL_RG16F`](crate::enums::GL_RG16F)                  | [`GL_RG`](crate::enums::GL_RG)                       | f16              | f16                 |                   |                     |                      |
    /// | [`GL_RGB16F`](crate::enums::GL_RGB16F)                | [`GL_RGB`](crate::enums::GL_RGB)                     | f16              | f16                 | f16               |                     |                      |
    /// | [`GL_RGBA16F`](crate::enums::GL_RGBA16F)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | f16              | f16                 | f16               | f16                 |                      |
    /// | [`GL_R32F`](crate::enums::GL_R32F)                    | [`GL_RED`](crate::enums::GL_RED)                     | f32              |                     |                   |                     |                      |
    /// | [`GL_RG32F`](crate::enums::GL_RG32F)                  | [`GL_RG`](crate::enums::GL_RG)                       | f32              | f32                 |                   |                     |                      |
    /// | [`GL_RGB32F`](crate::enums::GL_RGB32F)                | [`GL_RGB`](crate::enums::GL_RGB)                     | f32              | f32                 | f32               |                     |                      |
    /// | [`GL_RGBA32F`](crate::enums::GL_RGBA32F)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | f32              | f32                 | f32               | f32                 |                      |
    /// | [`GL_R11F_G11F_B10F`](crate::enums::GL_R11F_G11F_B10F) | [`GL_RGB`](crate::enums::GL_RGB)                    | f11              | f11                 | f10               |                     |                      |
    /// | [`GL_RGB9_E5`](crate::enums::GL_RGB9_E5)              | [`GL_RGB`](crate::enums::GL_RGB)                     | 9                | 9                   | 9                 |                     | 5                    |
    /// | [`GL_R8I`](crate::enums::GL_R8I)                      | [`GL_RED`](crate::enums::GL_RED)                     | i8               |                     |                   |                     |                      |
    /// | [`GL_R8UI`](crate::enums::GL_R8UI)                    | [`GL_RED`](crate::enums::GL_RED)                     | ui8              |                     |                   |                     |                      |
    /// | [`GL_R16I`](crate::enums::GL_R16I)                    | [`GL_RED`](crate::enums::GL_RED)                     | i16              |                     |                   |                     |                      |
    /// | [`GL_R16UI`](crate::enums::GL_R16UI)                  | [`GL_RED`](crate::enums::GL_RED)                     | ui16             |                     |                   |                     |                      |
    /// | [`GL_R32I`](crate::enums::GL_R32I)                    | [`GL_RED`](crate::enums::GL_RED)                     | i32              |                     |                   |                     |                      |
    /// | [`GL_R32UI`](crate::enums::GL_R32UI)                  | [`GL_RED`](crate::enums::GL_RED)                     | ui32             |                     |                   |                     |                      |
    /// | [`GL_RG8I`](crate::enums::GL_RG8I)                    | [`GL_RG`](crate::enums::GL_RG)                       | i8               | i8                  |                   |                     |                      |
    /// | [`GL_RG8UI`](crate::enums::GL_RG8UI)                  | [`GL_RG`](crate::enums::GL_RG)                       | ui8              | ui8                 |                   |                     |                      |
    /// | [`GL_RG16I`](crate::enums::GL_RG16I)                  | [`GL_RG`](crate::enums::GL_RG)                       | i16              | i16                 |                   |                     |                      |
    /// | [`GL_RG16UI`](crate::enums::GL_RG16UI)                | [`GL_RG`](crate::enums::GL_RG)                       | ui16             | ui16                |                   |                     |                      |
    /// | [`GL_RG32I`](crate::enums::GL_RG32I)                  | [`GL_RG`](crate::enums::GL_RG)                       | i32              | i32                 |                   |                     |                      |
    /// | [`GL_RG32UI`](crate::enums::GL_RG32UI)                | [`GL_RG`](crate::enums::GL_RG)                       | ui32             | ui32                |                   |                     |                      |
    /// | [`GL_RGB8I`](crate::enums::GL_RGB8I)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | i8               | i8                  | i8                |                     |                      |
    /// | [`GL_RGB8UI`](crate::enums::GL_RGB8UI)                | [`GL_RGB`](crate::enums::GL_RGB)                     | ui8              | ui8                 | ui8               |                     |                      |
    /// | [`GL_RGB16I`](crate::enums::GL_RGB16I)                | [`GL_RGB`](crate::enums::GL_RGB)                     | i16              | i16                 | i16               |                     |                      |
    /// | [`GL_RGB16UI`](crate::enums::GL_RGB16UI)              | [`GL_RGB`](crate::enums::GL_RGB)                     | ui16             | ui16                | ui16              |                     |                      |
    /// | [`GL_RGB32I`](crate::enums::GL_RGB32I)                | [`GL_RGB`](crate::enums::GL_RGB)                     | i32              | i32                 | i32               |                     |                      |
    /// | [`GL_RGB32UI`](crate::enums::GL_RGB32UI)              | [`GL_RGB`](crate::enums::GL_RGB)                     | ui32             | ui32                | ui32              |                     |                      |
    /// | [`GL_RGBA8I`](crate::enums::GL_RGBA8I)                | [`GL_RGBA`](crate::enums::GL_RGBA)                   | i8               | i8                  | i8                | i8                  |                      |
    /// | [`GL_RGBA8UI`](crate::enums::GL_RGBA8UI)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui8              | ui8                 | ui8               | ui8                 |                      |
    /// | [`GL_RGBA16I`](crate::enums::GL_RGBA16I)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | i16              | i16                 | i16               | i16                 |                      |
    /// | [`GL_RGBA16UI`](crate::enums::GL_RGBA16UI)            | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui16             | ui16                | ui16              | ui16                |                      |
    /// | [`GL_RGBA32I`](crate::enums::GL_RGBA32I)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | i32              | i32                 | i32               | i32                 |                      |
    /// | [`GL_RGBA32UI`](crate::enums::GL_RGBA32UI)            | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui32             | ui32                | ui32              | ui32                |                      |
    ///
    ///
    /// Finally, `internalformat` may also be one of the generic or compressed
    /// texture formats shown in Table 3 below
    ///
    /// | *Compressed Internal Format*                                  | *Base Internal Format*                               | *Type*     |
    /// |---------------------------------------------------------------|------------------------------------------------------|------------|
    /// | [`GL_COMPRESSED_RED`](crate::enums::GL_COMPRESSED_RED)        | [`GL_RED`](crate::enums::GL_RED)                     | Generic    |
    /// | [`GL_COMPRESSED_RG`](crate::enums::GL_COMPRESSED_RG)          | [`GL_RG`](crate::enums::GL_RG)                       | Generic    |
    /// | [`GL_COMPRESSED_RGB`](crate::enums::GL_COMPRESSED_RGB)        | [`GL_RGB`](crate::enums::GL_RGB)                     | Generic    |
    /// | [`GL_COMPRESSED_RGBA`](crate::enums::GL_COMPRESSED_RGBA)      | [`GL_RGBA`](crate::enums::GL_RGBA)                   | Generic    |
    /// | [`GL_COMPRESSED_SRGB`](crate::enums::GL_COMPRESSED_SRGB)      | [`GL_RGB`](crate::enums::GL_RGB)                     | Generic    |
    /// | [`GL_COMPRESSED_SRGB_ALPHA`](crate::enums::GL_COMPRESSED_SRGB_ALPHA) | [`GL_RGBA`](crate::enums::GL_RGBA)            | Generic    |
    /// | [`GL_COMPRESSED_RED_RGTC1`](crate::enums::GL_COMPRESSED_RED_RGTC1) | [`GL_RED`](crate::enums::GL_RED)                | Specific   |
    /// | [`GL_COMPRESSED_SIGNED_RED_RGTC1`](crate::enums::GL_COMPRESSED_SIGNED_RED_RGTC1) | [`GL_RED`](crate::enums::GL_RED)  | Specific   |
    /// | [`GL_COMPRESSED_RG_RGTC2`](crate::enums::GL_COMPRESSED_RG_RGTC2) | [`GL_RG`](crate::enums::GL_RG)                    | Specific   |
    /// | [`GL_COMPRESSED_SIGNED_RG_RGTC2`](crate::enums::GL_COMPRESSED_SIGNED_RG_RGTC2) | [`GL_RG`](crate::enums::GL_RG)      | Specific   |
    /// | [`GL_COMPRESSED_RGBA_BPTC_UNORM`](crate::enums::GL_COMPRESSED_RGBA_BPTC_UNORM) | [`GL_RGBA`](crate::enums::GL_RGBA)  | Specific   |
    /// | [`GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM`](crate::enums::GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM) | [`GL_RGBA`](crate::enums::GL_RGBA) | Specific |
    /// | [`GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT`](crate::enums::GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT) | [`GL_RGB`](crate::enums::GL_RGB) | Specific |
    /// | [`GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT`](crate::enums::GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT) | [`GL_RGB`](crate::enums::GL_RGB) | Specific |
    ///
    ///
    /// If the `internalformat` parameter is one of the generic compressed formats,
    /// [`GL_COMPRESSED_RED`](crate::enums::GL_COMPRESSED_RED), [`GL_COMPRESSED_RG`](crate::enums::GL_COMPRESSED_RG),
    /// [`GL_COMPRESSED_RGB`](crate::enums::GL_COMPRESSED_RGB), or [`GL_COMPRESSED_RGBA`](crate::enums::GL_COMPRESSED_RGBA),
    /// the GL will replace the internal format with the symbolic constant for
    /// a specific internal format and compress the texture before storage. If
    /// no corresponding internal format is available, or the GL can not compress
    /// that image for any reason, the internal format is instead replaced with
    /// a corresponding base internal format.
    ///
    /// If the `internalformat` parameter is [`GL_SRGB`](crate::enums::GL_SRGB),
    /// [`GL_SRGB8`](crate::enums::GL_SRGB8), [`GL_SRGB_ALPHA`](crate::enums::GL_SRGB_ALPHA),
    /// or [`GL_SRGB8_ALPHA8`](crate::enums::GL_SRGB8_ALPHA8), the texture is
    /// treated as if the red, green, or blue components are encoded in the sRGB
    /// color space. Any alpha component is left unchanged. The conversion from
    /// the sRGB encoded component `[inlineq]` `[inlineq]`
    ///
    /// `[inlineq]`
    ///
    /// Assume `[inlineq]`
    ///
    /// Use the [`GL_PROXY_TEXTURE_2D`](crate::enums::GL_PROXY_TEXTURE_2D), [`GL_PROXY_TEXTURE_1D_ARRAY`](crate::enums::GL_PROXY_TEXTURE_1D_ARRAY),
    /// [`GL_PROXY_TEXTURE_RECTANGLE`](crate::enums::GL_PROXY_TEXTURE_RECTANGLE),
    /// or [`GL_PROXY_TEXTURE_CUBE_MAP`](crate::enums::GL_PROXY_TEXTURE_CUBE_MAP)
    /// target to try out a resolution and format. The implementation will update
    /// and recompute its best match for the requested storage resolution and format.
    /// To then query this state, call [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter).
    /// If the texture cannot be accommodated, texture state is set to 0.
    ///
    /// A one-component texture image uses only the red component of the RGBA color
    /// extracted from `data`. A two-component image uses the R and G values. A
    /// three-component image uses the R, G, and B values. A four-component image
    /// uses all of the RGBA components.
    ///
    /// Image-based shadowing can be enabled by comparing texture r coordinates
    /// to depth texture values to generate a boolean result. See [**glTexParameter**](crate::context::Context::oxidegl_tex_parameter)
    /// for details on texture comparison.
    ///
    /// ### Notes
    /// The [**glPixelStore**](crate::context::Context::oxidegl_pixel_store) mode
    /// affects texture images.
    ///
    /// `data` may be a null pointer. In this case, texture memory is allocated
    /// to accommodate a texture of width `width` and height `height`. You can
    /// then download subtextures to initialize this texture memory. The image
    /// is undefined if the user tries to apply an uninitialized portion of the
    /// texture image to a primitive.
    ///
    /// [**glTexImage2D**](crate::context::Context::oxidegl_tex_image2_d) specifies
    /// the two-dimensional texture for the current texture unit, specified with
    /// [**glActiveTexture**](crate::context::Context::oxidegl_active_texture).
    ///
    /// [`GL_STENCIL_INDEX`](crate::enums::GL_STENCIL_INDEX) may be used for `format`
    /// only if the GL version is 4.4 or higher.
    ///
    /// ### Associated Gets
    /// [**glGetTexImage**](crate::context::Context::oxidegl_get_tex_image)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_PIXEL_UNPACK_BUFFER_BINDING`](crate::enums::GL_PIXEL_UNPACK_BUFFER_BINDING)

    pub unsafe fn oxidegl_tex_image2_d(
        &mut self,
        target: TextureTarget,
        level: GLint,
        internalformat: InternalFormat,
        width: GLsizei,
        height: GLsizei,
        border: GLint,
        format: PixelFormat,
        r#type: PixelType,
        pixels: *const GLvoid,
    ) {
        panic!("command oxidegl_tex_image2_d not yet implemented");
    }
    /// ### Parameters
    /// `target`
    ///
    /// > Specifies the target of the operation. `target` must be [`GL_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE)
    /// > or [`GL_PROXY_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_PROXY_TEXTURE_2D_MULTISAMPLE).
    ///
    /// `samples`
    ///
    /// > The number of samples in the multisample texture's image.
    ///
    /// `internalformat`
    ///
    /// > The internal format to be used to store the multisample texture's image.
    /// > `internalformat` must specify a color-renderable, depth-renderable, or
    /// > stencil-renderable format.
    ///
    /// `width`
    ///
    /// > The width of the multisample texture's image, in texels.
    ///
    /// `height`
    ///
    /// > The height of the multisample texture's image, in texels.
    ///
    /// `fixedsamplelocations`
    ///
    /// > Specifies whether the image will use identical sample locations and the
    /// > same number of samples for all texels in the image, and the sample locations
    /// > will not depend on the internal format or size of the image.
    ///
    /// ### Description
    /// [**glTexImage2DMultisample**](crate::context::Context::oxidegl_tex_image2_d_multisample)
    /// establishes the data storage, format, dimensions and number of samples
    /// of a multisample texture's image.
    ///
    /// `target` must be [`GL_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE)
    /// or [`GL_PROXY_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_PROXY_TEXTURE_2D_MULTISAMPLE).
    /// `width` and `height` are the dimensions in texels of the texture, and must
    /// be in the range zero to the value of [`GL_MAX_TEXTURE_SIZE`](crate::enums::GL_MAX_TEXTURE_SIZE)
    /// minus one. `samples` specifies the number of samples in the image and must
    /// be in the range zero to the value of [`GL_MAX_SAMPLES`](crate::enums::GL_MAX_SAMPLES)
    /// minus one.
    ///
    /// `internalformat` must be a color-renderable, depth-renderable, or stencil-renderable
    /// format.
    ///
    /// If `fixedsamplelocations` is [`GL_TRUE`](crate::enums::GL_TRUE), the image
    /// will use identical sample locations and the same number of samples for
    /// all texels in the image, and the sample locations will not depend on the
    /// internal format or size of the image.
    ///
    /// When a multisample texture is accessed in a shader, the access takes one
    /// vector of integers describing which texel to fetch and an integer corresponding
    /// to the sample numbers describing which sample within the texel to fetch.
    /// No standard sampling instructions are allowed on the multisample texture
    /// targets.
    ///
    /// ### Notes
    /// [**glTexImage2DMultisample**](crate::context::Context::oxidegl_tex_image2_d_multisample)
    /// is available only if the GL version is 3.2 or greater.

    pub fn oxidegl_tex_image2_d_multisample(
        &mut self,
        target: TextureTarget,
        samples: GLsizei,
        internalformat: InternalFormat,
        width: GLsizei,
        height: GLsizei,
        fixedsamplelocations: GLboolean,
    ) {
        panic!("command oxidegl_tex_image2_d_multisample not yet implemented");
    }
    /// ### Parameters
    /// `target`
    ///
    /// > Specifies the target texture. Must be one of [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D),
    /// > [`GL_PROXY_TEXTURE_3D`](crate::enums::GL_PROXY_TEXTURE_3D), [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY)
    /// > or [`GL_PROXY_TEXTURE_2D_ARRAY`](crate::enums::GL_PROXY_TEXTURE_2D_ARRAY).
    ///
    /// `level`
    ///
    /// > Specifies the level-of-detail number. Level 0 is the base image level.
    /// > Level `[inlineq]` `[inlineq]`
    ///
    /// `internalformat`
    ///
    /// > Specifies the number of color components in the texture. Must be one of
    /// > base internal formats given in Table 1, one of the sized internal formats
    /// > given in Table 2, or one of the compressed internal formats given in Table
    /// > 3, below.
    ///
    /// `width`
    ///
    /// > Specifies the width of the texture image. All implementations support 3D
    /// > texture images that are at least 16 texels wide.
    ///
    /// `height`
    ///
    /// > Specifies the height of the texture image. All implementations support
    /// > 3D texture images that are at least 256 texels high.
    ///
    /// `depth`
    ///
    /// > Specifies the depth of the texture image, or the number of layers in a
    /// > texture array. All implementations support 3D texture images that are at
    /// > least 256 texels deep, and texture arrays that are at least 256 layers
    /// > deep.
    ///
    /// `border`
    ///
    /// > This value must be 0.
    ///
    /// `format`
    ///
    /// > Specifies the format of the pixel data. The following symbolic values are
    /// > accepted: [`GL_RED`](crate::enums::GL_RED), [`GL_RG`](crate::enums::GL_RG),
    /// > [`GL_RGB`](crate::enums::GL_RGB), [`GL_BGR`](crate::enums::GL_BGR), [`GL_RGBA`](crate::enums::GL_RGBA),
    /// > [`GL_BGRA`](crate::enums::GL_BGRA), [`GL_RED_INTEGER`](crate::enums::GL_RED_INTEGER),
    /// > [`GL_RG_INTEGER`](crate::enums::GL_RG_INTEGER), [`GL_RGB_INTEGER`](crate::enums::GL_RGB_INTEGER),
    /// > [`GL_BGR_INTEGER`](crate::enums::GL_BGR_INTEGER), [`GL_RGBA_INTEGER`](crate::enums::GL_RGBA_INTEGER),
    /// > [`GL_BGRA_INTEGER`](crate::enums::GL_BGRA_INTEGER), [`GL_STENCIL_INDEX`](crate::enums::GL_STENCIL_INDEX),
    /// > [`GL_DEPTH_COMPONENT`](crate::enums::GL_DEPTH_COMPONENT), [`GL_DEPTH_STENCIL`](crate::enums::GL_DEPTH_STENCIL).
    ///
    /// `type`
    ///
    /// > Specifies the data type of the pixel data. The following symbolic values
    /// > are accepted: [`GL_UNSIGNED_BYTE`](crate::enums::GL_UNSIGNED_BYTE), [`GL_BYTE`](crate::enums::GL_BYTE),
    /// > [`GL_UNSIGNED_SHORT`](crate::enums::GL_UNSIGNED_SHORT), [`GL_SHORT`](crate::enums::GL_SHORT),
    /// > [`GL_UNSIGNED_INT`](crate::enums::GL_UNSIGNED_INT), [`GL_INT`](crate::enums::GL_INT),
    /// > [`GL_HALF_FLOAT`](crate::enums::GL_HALF_FLOAT), [`GL_FLOAT`](crate::enums::GL_FLOAT),
    /// > [`GL_UNSIGNED_BYTE_3_3_2`](crate::enums::GL_UNSIGNED_BYTE_3_3_2), [`GL_UNSIGNED_BYTE_2_3_3_REV`](crate::enums::GL_UNSIGNED_BYTE_2_3_3_REV),
    /// > [`GL_UNSIGNED_SHORT_5_6_5`](crate::enums::GL_UNSIGNED_SHORT_5_6_5), [`GL_UNSIGNED_SHORT_5_6_5_REV`](crate::enums::GL_UNSIGNED_SHORT_5_6_5_REV),
    /// > [`GL_UNSIGNED_SHORT_4_4_4_4`](crate::enums::GL_UNSIGNED_SHORT_4_4_4_4),
    /// > [`GL_UNSIGNED_SHORT_4_4_4_4_REV`](crate::enums::GL_UNSIGNED_SHORT_4_4_4_4_REV),
    /// > [`GL_UNSIGNED_SHORT_5_5_5_1`](crate::enums::GL_UNSIGNED_SHORT_5_5_5_1),
    /// > [`GL_UNSIGNED_SHORT_1_5_5_5_REV`](crate::enums::GL_UNSIGNED_SHORT_1_5_5_5_REV),
    /// > [`GL_UNSIGNED_INT_8_8_8_8`](crate::enums::GL_UNSIGNED_INT_8_8_8_8), [`GL_UNSIGNED_INT_8_8_8_8_REV`](crate::enums::GL_UNSIGNED_INT_8_8_8_8_REV),
    /// > [`GL_UNSIGNED_INT_10_10_10_2`](crate::enums::GL_UNSIGNED_INT_10_10_10_2),
    /// > and [`GL_UNSIGNED_INT_2_10_10_10_REV`](crate::enums::GL_UNSIGNED_INT_2_10_10_10_REV).
    ///
    /// `data`
    ///
    /// > Specifies a pointer to the image data in memory.
    ///
    /// ### Description
    /// Texturing maps a portion of a specified texture image onto each graphical
    /// primitive for which texturing is enabled. To enable and disable three-dimensional
    /// texturing, call [**glEnable**](crate::context::Context::oxidegl_enable)
    /// and [**glDisable**](crate::context::Context::oxidegl_disable) with argument
    /// [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D).
    ///
    /// To define texture images, call [**glTexImage3D**](crate::context::Context::oxidegl_tex_image3_d).
    /// The arguments describe the parameters of the texture image, such as height,
    /// width, depth, width of the border, level-of-detail number (see [**glTexParameter**](crate::context::Context::oxidegl_tex_parameter)
    /// ), and number of color components provided. The last three arguments describe
    /// how the image is represented in memory.
    ///
    /// If `target` is [`GL_PROXY_TEXTURE_3D`](crate::enums::GL_PROXY_TEXTURE_3D),
    /// no data is read from `data`, but all of the texture image state is recalculated,
    /// checked for consistency, and checked against the implementation's capabilities.
    /// If the implementation cannot handle a texture of the requested texture
    /// size, it sets all of the image state to 0, but does not generate an error
    /// (see [**glGetError**](crate::context::Context::oxidegl_get_error) ). To
    /// query for an entire mipmap array, use an image array level greater than
    /// or equal to 1.
    ///
    /// If `target` is [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D), data is
    /// read from `data` as a sequence of signed or unsigned bytes, shorts, or
    /// longs, or single-precision floating-point values, depending on `type`. These
    /// values are grouped into sets of one, two, three, or four values, depending
    /// on `format`, to form elements. Each data byte is treated as eight 1-bit
    /// elements, with bit ordering determined by [`GL_UNPACK_LSB_FIRST`](crate::enums::GL_UNPACK_LSB_FIRST)
    /// (see [**glPixelStore**](crate::context::Context::oxidegl_pixel_store) ).
    ///
    /// If a non-zero named buffer object is bound to the [`GL_PIXEL_UNPACK_BUFFER`](crate::enums::GL_PIXEL_UNPACK_BUFFER)
    /// target (see [**glBindBuffer**](crate::context::Context::oxidegl_bind_buffer))
    /// while a texture image is specified, `data` is treated as a byte offset
    /// into the buffer object's data store.
    ///
    /// The first element corresponds to the lower left corner of the texture image.
    /// Subsequent elements progress left-to-right through the remaining texels
    /// in the lowest row of the texture image, and then in successively higher
    /// rows of the texture image. The final element corresponds to the upper right
    /// corner of the texture image.
    ///
    /// `format` determines the composition of each element in `data`. It can assume
    /// one of these symbolic values:
    ///
    /// [`GL_RED`](crate::enums::GL_RED)
    ///
    /// > Each element is a single red component. The GL converts it to floating
    /// > point and assembles it into an RGBA element by attaching 0 for green and
    /// > blue, and 1 for alpha. Each component is clamped to the range \[0,1\].
    ///
    /// [`GL_RG`](crate::enums::GL_RG)
    ///
    /// > Each element is a red and green pair. The GL converts each to floating
    /// > point and assembles it into an RGBA element by attaching 0 for blue, and
    /// > 1 for alpha. Each component is clamped to the range \[0,1\].
    ///
    /// [`GL_RGB`](crate::enums::GL_RGB)
    ///
    /// [`GL_BGR`](crate::enums::GL_BGR)
    ///
    /// > Each element is an RGB triple. The GL converts it to floating point and
    /// > assembles it into an RGBA element by attaching 1 for alpha. Each component
    /// > is clamped to the range \[0,1\].
    ///
    /// [`GL_RGBA`](crate::enums::GL_RGBA)
    ///
    /// [`GL_BGRA`](crate::enums::GL_BGRA)
    ///
    /// > Each element contains all four components. Each component is clamped to
    /// > the range \[0,1\].
    ///
    /// If an application wants to store the texture at a certain resolution or
    /// in a certain format, it can request the resolution and format with `internalformat`.
    /// The GL will choose an internal representation that closely approximates
    /// that requested by `internalformat`, but it may not match exactly. (The
    /// representations specified by [`GL_RED`](crate::enums::GL_RED), [`GL_RG`](crate::enums::GL_RG),
    /// [`GL_RGB`](crate::enums::GL_RGB), and [`GL_RGBA`](crate::enums::GL_RGBA)
    /// must match exactly.)
    ///
    /// `internalformat` may be one of the base internal formats shown in Table
    /// 1, below
    ///
    /// | *Base Internal Format*                               | *RGBA, Depth and Stencil Values*                                    | *Internal Components*                              |
    /// |------------------------------------------------------|---------------------------------------------------------------------|----------------------------------------------------|
    /// | [`GL_DEPTH_COMPONENT`](crate::enums::GL_DEPTH_COMPONENT) | Depth                                                           | D                                                  |
    /// | [`GL_DEPTH_STENCIL`](crate::enums::GL_DEPTH_STENCIL) | Depth, Stencil                                                      | D, S                                               |
    /// | [`GL_RED`](crate::enums::GL_RED)                     | Red                                                                 | R                                                  |
    /// | [`GL_RG`](crate::enums::GL_RG)                       | Red, Green                                                          | R, G                                               |
    /// | [`GL_RGB`](crate::enums::GL_RGB)                     | Red, Green, Blue                                                    | R, G, B                                            |
    /// | [`GL_RGBA`](crate::enums::GL_RGBA)                   | Red, Green, Blue, Alpha                                             | R, G, B, A                                         |
    ///
    ///
    /// `internalformat` may also be one of the sized internal formats shown in
    /// Table 2, below
    ///
    /// | *Sized Internal Format*                               | *Base Internal Format*                               | *Red Bits*       | *Green Bits*        | *Blue Bits*       | *Alpha Bits*        | *Shared Bits*        |
    /// |-------------------------------------------------------|------------------------------------------------------|------------------|---------------------|-------------------|---------------------|----------------------|
    /// | [`GL_R8`](crate::enums::GL_R8)                        | [`GL_RED`](crate::enums::GL_RED)                     | 8                |                     |                   |                     |                      |
    /// | [`GL_R8_SNORM`](crate::enums::GL_R8_SNORM)            | [`GL_RED`](crate::enums::GL_RED)                     | s8               |                     |                   |                     |                      |
    /// | [`GL_R16`](crate::enums::GL_R16)                      | [`GL_RED`](crate::enums::GL_RED)                     | 16               |                     |                   |                     |                      |
    /// | [`GL_R16_SNORM`](crate::enums::GL_R16_SNORM)          | [`GL_RED`](crate::enums::GL_RED)                     | s16              |                     |                   |                     |                      |
    /// | [`GL_RG8`](crate::enums::GL_RG8)                      | [`GL_RG`](crate::enums::GL_RG)                       | 8                | 8                   |                   |                     |                      |
    /// | [`GL_RG8_SNORM`](crate::enums::GL_RG8_SNORM)          | [`GL_RG`](crate::enums::GL_RG)                       | s8               | s8                  |                   |                     |                      |
    /// | [`GL_RG16`](crate::enums::GL_RG16)                    | [`GL_RG`](crate::enums::GL_RG)                       | 16               | 16                  |                   |                     |                      |
    /// | [`GL_RG16_SNORM`](crate::enums::GL_RG16_SNORM)        | [`GL_RG`](crate::enums::GL_RG)                       | s16              | s16                 |                   |                     |                      |
    /// | [`GL_R3_G3_B2`](crate::enums::GL_R3_G3_B2)            | [`GL_RGB`](crate::enums::GL_RGB)                     | 3                | 3                   | 2                 |                     |                      |
    /// | [`GL_RGB4`](crate::enums::GL_RGB4)                    | [`GL_RGB`](crate::enums::GL_RGB)                     | 4                | 4                   | 4                 |                     |                      |
    /// | [`GL_RGB5`](crate::enums::GL_RGB5)                    | [`GL_RGB`](crate::enums::GL_RGB)                     | 5                | 5                   | 5                 |                     |                      |
    /// | [`GL_RGB8`](crate::enums::GL_RGB8)                    | [`GL_RGB`](crate::enums::GL_RGB)                     | 8                | 8                   | 8                 |                     |                      |
    /// | [`GL_RGB8_SNORM`](crate::enums::GL_RGB8_SNORM)        | [`GL_RGB`](crate::enums::GL_RGB)                     | s8               | s8                  | s8                |                     |                      |
    /// | [`GL_RGB10`](crate::enums::GL_RGB10)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 10               | 10                  | 10                |                     |                      |
    /// | [`GL_RGB12`](crate::enums::GL_RGB12)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 12               | 12                  | 12                |                     |                      |
    /// | [`GL_RGB16_SNORM`](crate::enums::GL_RGB16_SNORM)      | [`GL_RGB`](crate::enums::GL_RGB)                     | 16               | 16                  | 16                |                     |                      |
    /// | [`GL_RGBA2`](crate::enums::GL_RGBA2)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 2                | 2                   | 2                 | 2                   |                      |
    /// | [`GL_RGBA4`](crate::enums::GL_RGBA4)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 4                | 4                   | 4                 | 4                   |                      |
    /// | [`GL_RGB5_A1`](crate::enums::GL_RGB5_A1)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 5                | 5                   | 5                 | 1                   |                      |
    /// | [`GL_RGBA8`](crate::enums::GL_RGBA8)                  | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 8                | 8                   | 8                 | 8                   |                      |
    /// | [`GL_RGBA8_SNORM`](crate::enums::GL_RGBA8_SNORM)      | [`GL_RGBA`](crate::enums::GL_RGBA)                   | s8               | s8                  | s8                | s8                  |                      |
    /// | [`GL_RGB10_A2`](crate::enums::GL_RGB10_A2)            | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 10               | 10                  | 10                | 2                   |                      |
    /// | [`GL_RGB10_A2UI`](crate::enums::GL_RGB10_A2UI)        | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui10             | ui10                | ui10              | ui2                 |                      |
    /// | [`GL_RGBA12`](crate::enums::GL_RGBA12)                | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 12               | 12                  | 12                | 12                  |                      |
    /// | [`GL_RGBA16`](crate::enums::GL_RGBA16)                | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 16               | 16                  | 16                | 16                  |                      |
    /// | [`GL_SRGB8`](crate::enums::GL_SRGB8)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | 8                | 8                   | 8                 |                     |                      |
    /// | [`GL_SRGB8_ALPHA8`](crate::enums::GL_SRGB8_ALPHA8)    | [`GL_RGBA`](crate::enums::GL_RGBA)                   | 8                | 8                   | 8                 | 8                   |                      |
    /// | [`GL_R16F`](crate::enums::GL_R16F)                    | [`GL_RED`](crate::enums::GL_RED)                     | f16              |                     |                   |                     |                      |
    /// | [`GL_RG16F`](crate::enums::GL_RG16F)                  | [`GL_RG`](crate::enums::GL_RG)                       | f16              | f16                 |                   |                     |                      |
    /// | [`GL_RGB16F`](crate::enums::GL_RGB16F)                | [`GL_RGB`](crate::enums::GL_RGB)                     | f16              | f16                 | f16               |                     |                      |
    /// | [`GL_RGBA16F`](crate::enums::GL_RGBA16F)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | f16              | f16                 | f16               | f16                 |                      |
    /// | [`GL_R32F`](crate::enums::GL_R32F)                    | [`GL_RED`](crate::enums::GL_RED)                     | f32              |                     |                   |                     |                      |
    /// | [`GL_RG32F`](crate::enums::GL_RG32F)                  | [`GL_RG`](crate::enums::GL_RG)                       | f32              | f32                 |                   |                     |                      |
    /// | [`GL_RGB32F`](crate::enums::GL_RGB32F)                | [`GL_RGB`](crate::enums::GL_RGB)                     | f32              | f32                 | f32               |                     |                      |
    /// | [`GL_RGBA32F`](crate::enums::GL_RGBA32F)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | f32              | f32                 | f32               | f32                 |                      |
    /// | [`GL_R11F_G11F_B10F`](crate::enums::GL_R11F_G11F_B10F) | [`GL_RGB`](crate::enums::GL_RGB)                    | f11              | f11                 | f10               |                     |                      |
    /// | [`GL_RGB9_E5`](crate::enums::GL_RGB9_E5)              | [`GL_RGB`](crate::enums::GL_RGB)                     | 9                | 9                   | 9                 |                     | 5                    |
    /// | [`GL_R8I`](crate::enums::GL_R8I)                      | [`GL_RED`](crate::enums::GL_RED)                     | i8               |                     |                   |                     |                      |
    /// | [`GL_R8UI`](crate::enums::GL_R8UI)                    | [`GL_RED`](crate::enums::GL_RED)                     | ui8              |                     |                   |                     |                      |
    /// | [`GL_R16I`](crate::enums::GL_R16I)                    | [`GL_RED`](crate::enums::GL_RED)                     | i16              |                     |                   |                     |                      |
    /// | [`GL_R16UI`](crate::enums::GL_R16UI)                  | [`GL_RED`](crate::enums::GL_RED)                     | ui16             |                     |                   |                     |                      |
    /// | [`GL_R32I`](crate::enums::GL_R32I)                    | [`GL_RED`](crate::enums::GL_RED)                     | i32              |                     |                   |                     |                      |
    /// | [`GL_R32UI`](crate::enums::GL_R32UI)                  | [`GL_RED`](crate::enums::GL_RED)                     | ui32             |                     |                   |                     |                      |
    /// | [`GL_RG8I`](crate::enums::GL_RG8I)                    | [`GL_RG`](crate::enums::GL_RG)                       | i8               | i8                  |                   |                     |                      |
    /// | [`GL_RG8UI`](crate::enums::GL_RG8UI)                  | [`GL_RG`](crate::enums::GL_RG)                       | ui8              | ui8                 |                   |                     |                      |
    /// | [`GL_RG16I`](crate::enums::GL_RG16I)                  | [`GL_RG`](crate::enums::GL_RG)                       | i16              | i16                 |                   |                     |                      |
    /// | [`GL_RG16UI`](crate::enums::GL_RG16UI)                | [`GL_RG`](crate::enums::GL_RG)                       | ui16             | ui16                |                   |                     |                      |
    /// | [`GL_RG32I`](crate::enums::GL_RG32I)                  | [`GL_RG`](crate::enums::GL_RG)                       | i32              | i32                 |                   |                     |                      |
    /// | [`GL_RG32UI`](crate::enums::GL_RG32UI)                | [`GL_RG`](crate::enums::GL_RG)                       | ui32             | ui32                |                   |                     |                      |
    /// | [`GL_RGB8I`](crate::enums::GL_RGB8I)                  | [`GL_RGB`](crate::enums::GL_RGB)                     | i8               | i8                  | i8                |                     |                      |
    /// | [`GL_RGB8UI`](crate::enums::GL_RGB8UI)                | [`GL_RGB`](crate::enums::GL_RGB)                     | ui8              | ui8                 | ui8               |                     |                      |
    /// | [`GL_RGB16I`](crate::enums::GL_RGB16I)                | [`GL_RGB`](crate::enums::GL_RGB)                     | i16              | i16                 | i16               |                     |                      |
    /// | [`GL_RGB16UI`](crate::enums::GL_RGB16UI)              | [`GL_RGB`](crate::enums::GL_RGB)                     | ui16             | ui16                | ui16              |                     |                      |
    /// | [`GL_RGB32I`](crate::enums::GL_RGB32I)                | [`GL_RGB`](crate::enums::GL_RGB)                     | i32              | i32                 | i32               |                     |                      |
    /// | [`GL_RGB32UI`](crate::enums::GL_RGB32UI)              | [`GL_RGB`](crate::enums::GL_RGB)                     | ui32             | ui32                | ui32              |                     |                      |
    /// | [`GL_RGBA8I`](crate::enums::GL_RGBA8I)                | [`GL_RGBA`](crate::enums::GL_RGBA)                   | i8               | i8                  | i8                | i8                  |                      |
    /// | [`GL_RGBA8UI`](crate::enums::GL_RGBA8UI)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui8              | ui8                 | ui8               | ui8                 |                      |
    /// | [`GL_RGBA16I`](crate::enums::GL_RGBA16I)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | i16              | i16                 | i16               | i16                 |                      |
    /// | [`GL_RGBA16UI`](crate::enums::GL_RGBA16UI)            | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui16             | ui16                | ui16              | ui16                |                      |
    /// | [`GL_RGBA32I`](crate::enums::GL_RGBA32I)              | [`GL_RGBA`](crate::enums::GL_RGBA)                   | i32              | i32                 | i32               | i32                 |                      |
    /// | [`GL_RGBA32UI`](crate::enums::GL_RGBA32UI)            | [`GL_RGBA`](crate::enums::GL_RGBA)                   | ui32             | ui32                | ui32              | ui32                |                      |
    ///
    ///
    /// Finally, `internalformat` may also be one of the generic or compressed
    /// texture formats shown in Table 3 below
    ///
    /// | *Compressed Internal Format*                                  | *Base Internal Format*                               | *Type*     |
    /// |---------------------------------------------------------------|------------------------------------------------------|------------|
    /// | [`GL_COMPRESSED_RED`](crate::enums::GL_COMPRESSED_RED)        | [`GL_RED`](crate::enums::GL_RED)                     | Generic    |
    /// | [`GL_COMPRESSED_RG`](crate::enums::GL_COMPRESSED_RG)          | [`GL_RG`](crate::enums::GL_RG)                       | Generic    |
    /// | [`GL_COMPRESSED_RGB`](crate::enums::GL_COMPRESSED_RGB)        | [`GL_RGB`](crate::enums::GL_RGB)                     | Generic    |
    /// | [`GL_COMPRESSED_RGBA`](crate::enums::GL_COMPRESSED_RGBA)      | [`GL_RGBA`](crate::enums::GL_RGBA)                   | Generic    |
    /// | [`GL_COMPRESSED_SRGB`](crate::enums::GL_COMPRESSED_SRGB)      | [`GL_RGB`](crate::enums::GL_RGB)                     | Generic    |
    /// | [`GL_COMPRESSED_SRGB_ALPHA`](crate::enums::GL_COMPRESSED_SRGB_ALPHA) | [`GL_RGBA`](crate::enums::GL_RGBA)            | Generic    |
    /// | [`GL_COMPRESSED_RED_RGTC1`](crate::enums::GL_COMPRESSED_RED_RGTC1) | [`GL_RED`](crate::enums::GL_RED)                | Specific   |
    /// | [`GL_COMPRESSED_SIGNED_RED_RGTC1`](crate::enums::GL_COMPRESSED_SIGNED_RED_RGTC1) | [`GL_RED`](crate::enums::GL_RED)  | Specific   |
    /// | [`GL_COMPRESSED_RG_RGTC2`](crate::enums::GL_COMPRESSED_RG_RGTC2) | [`GL_RG`](crate::enums::GL_RG)                    | Specific   |
    /// | [`GL_COMPRESSED_SIGNED_RG_RGTC2`](crate::enums::GL_COMPRESSED_SIGNED_RG_RGTC2) | [`GL_RG`](crate::enums::GL_RG)      | Specific   |
    /// | [`GL_COMPRESSED_RGBA_BPTC_UNORM`](crate::enums::GL_COMPRESSED_RGBA_BPTC_UNORM) | [`GL_RGBA`](crate::enums::GL_RGBA)  | Specific   |
    /// | [`GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM`](crate::enums::GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM) | [`GL_RGBA`](crate::enums::GL_RGBA) | Specific |
    /// | [`GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT`](crate::enums::GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT) | [`GL_RGB`](crate::enums::GL_RGB) | Specific |
    /// | [`GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT`](crate::enums::GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT) | [`GL_RGB`](crate::enums::GL_RGB) | Specific |
    ///
    ///
    /// If the `internalformat` parameter is one of the generic compressed formats,
    /// [`GL_COMPRESSED_RED`](crate::enums::GL_COMPRESSED_RED), [`GL_COMPRESSED_RG`](crate::enums::GL_COMPRESSED_RG),
    /// [`GL_COMPRESSED_RGB`](crate::enums::GL_COMPRESSED_RGB), or [`GL_COMPRESSED_RGBA`](crate::enums::GL_COMPRESSED_RGBA),
    /// the GL will replace the internal format with the symbolic constant for
    /// a specific internal format and compress the texture before storage. If
    /// no corresponding internal format is available, or the GL can not compress
    /// that image for any reason, the internal format is instead replaced with
    /// a corresponding base internal format.
    ///
    /// If the `internalformat` parameter is [`GL_SRGB`](crate::enums::GL_SRGB),
    /// [`GL_SRGB8`](crate::enums::GL_SRGB8), [`GL_SRGB_ALPHA`](crate::enums::GL_SRGB_ALPHA),
    /// or [`GL_SRGB8_ALPHA8`](crate::enums::GL_SRGB8_ALPHA8), the texture is
    /// treated as if the red, green, blue, or luminance components are encoded
    /// in the sRGB color space. Any alpha component is left unchanged. The conversion
    /// from the sRGB encoded component `[inlineq]` `[inlineq]`
    ///
    /// `[inlineq]`
    ///
    /// Assume `[inlineq]`
    ///
    /// Use the [`GL_PROXY_TEXTURE_3D`](crate::enums::GL_PROXY_TEXTURE_3D) target
    /// to try out a resolution and format. The implementation will update and
    /// recompute its best match for the requested storage resolution and format.
    /// To then query this state, call [**glGetTexLevelParameter**](crate::context::Context::oxidegl_get_tex_level_parameter).
    /// If the texture cannot be accommodated, texture state is set to 0.
    ///
    /// A one-component texture image uses only the red component of the RGBA color
    /// extracted from `data`. A two-component image uses the R and A values. A
    /// three-component image uses the R, G, and B values. A four-component image
    /// uses all of the RGBA components.
    ///
    /// ### Notes
    /// The [**glPixelStore**](crate::context::Context::oxidegl_pixel_store) mode
    /// affects texture images.
    ///
    /// `data` may be a null pointer. In this case texture memory is allocated
    /// to accommodate a texture of width `width`, height `height`, and depth `depth`.
    /// You can then download subtextures to initialize this texture memory. The
    /// image is undefined if the user tries to apply an uninitialized portion
    /// of the texture image to a primitive.
    ///
    /// [**glTexImage3D**](crate::context::Context::oxidegl_tex_image3_d) specifies
    /// the three-dimensional texture for the current texture unit, specified with
    /// [**glActiveTexture**](crate::context::Context::oxidegl_active_texture).
    ///
    /// [`GL_STENCIL_INDEX`](crate::enums::GL_STENCIL_INDEX) may be used for `format`
    /// only if the GL version is 4.4 or higher.
    ///
    /// ### Associated Gets
    /// [**glGetTexImage**](crate::context::Context::oxidegl_get_tex_image)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_PIXEL_UNPACK_BUFFER_BINDING`](crate::enums::GL_PIXEL_UNPACK_BUFFER_BINDING)

    pub unsafe fn oxidegl_tex_image3_d(
        &mut self,
        target: TextureTarget,
        level: GLint,
        internalformat: InternalFormat,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        border: GLint,
        format: PixelFormat,
        r#type: PixelType,
        pixels: *const GLvoid,
    ) {
        panic!("command oxidegl_tex_image3_d not yet implemented");
    }
    /// ### Parameters
    /// `target`
    ///
    /// > Specifies the target of the operation. `target` must be [`GL_TEXTURE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE_ARRAY)
    /// > or [`GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY).
    ///
    /// `samples`
    ///
    /// > The number of samples in the multisample texture's image.
    ///
    /// `internalformat`
    ///
    /// > The internal format to be used to store the multisample texture's image.
    /// > `internalformat` must specify a color-renderable, depth-renderable, or
    /// > stencil-renderable format.
    ///
    /// `width`
    ///
    /// > The width of the multisample texture's image, in texels.
    ///
    /// `height`
    ///
    /// > The height of the multisample texture's image, in texels.
    ///
    /// `fixedsamplelocations`
    ///
    /// > Specifies whether the image will use identical sample locations and the
    /// > same number of samples for all texels in the image, and the sample locations
    /// > will not depend on the internal format or size of the image.
    ///
    /// ### Description
    /// [**glTexImage3DMultisample**](crate::context::Context::oxidegl_tex_image3_d_multisample)
    /// establishes the data storage, format, dimensions and number of samples
    /// of a multisample texture's image.
    ///
    /// `target` must be [`GL_TEXTURE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE_ARRAY)
    /// or [`GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY).
    /// `width` and `height` are the dimensions in texels of the texture, and must
    /// be in the range zero to the value of [`GL_MAX_TEXTURE_SIZE`](crate::enums::GL_MAX_TEXTURE_SIZE)
    /// minus one. `depth` is the number of array slices in the array texture's
    /// image. `samples` specifies the number of samples in the image and must
    /// be in the range zero to the value of [`GL_MAX_SAMPLES`](crate::enums::GL_MAX_SAMPLES)
    /// minus one.
    ///
    /// `internalformat` must be a color-renderable, depth-renderable, or stencil-renderable
    /// format.
    ///
    /// If `fixedsamplelocations` is [`GL_TRUE`](crate::enums::GL_TRUE), the image
    /// will use identical sample locations and the same number of samples for
    /// all texels in the image, and the sample locations will not depend on the
    /// internal format or size of the image.
    ///
    /// When a multisample texture is accessed in a shader, the access takes one
    /// vector of integers describing which texel to fetch and an integer corresponding
    /// to the sample numbers describing which sample within the texel to fetch.
    /// No standard sampling instructions are allowed on the multisample texture
    /// targets.
    ///
    /// ### Notes
    /// [**glTexImage2DMultisample**](crate::context::Context::oxidegl_tex_image2_d_multisample)
    /// is available only if the GL version is 3.2 or greater.

    pub fn oxidegl_tex_image3_d_multisample(
        &mut self,
        target: TextureTarget,
        samples: GLsizei,
        internalformat: InternalFormat,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        fixedsamplelocations: GLboolean,
    ) {
        panic!("command oxidegl_tex_image3_d_multisample not yet implemented");
    }
    /// ### Description
    /// The values of rendered fragments are undefined when a shader stage fetches
    /// texels and the same texels are written via fragment shader outputs, even
    /// if the reads and writes are not in the same drawing command. To safely
    /// read the result of a written texel via a texel fetch in a subsequent drawing
    /// command, call [**glTextureBarrier**](crate::context::Context::oxidegl_texture_barrier)
    /// between the two drawing commands to guarantee that writes have completed
    /// and caches have been invalidated before subsequent drawing commands are
    /// executed.
    ///
    /// ### Notes
    /// The situation described above is referred to as a *rendering feedback loop*
    /// and is discussed in more detail in section 9.3 of the OpenGL 4.5 Specification.

    pub fn oxidegl_texture_barrier(&mut self) {
        panic!("command oxidegl_texture_barrier not yet implemented");
    }
    /// ### Parameters
    /// `texture`
    ///
    /// > Specifies the texture object to be initialized as a view.
    ///
    /// `target`
    ///
    /// > Specifies the target to be used for the newly initialized texture.
    ///
    /// `origtexture`
    ///
    /// > Specifies the name of a texture object of which to make a view.
    ///
    /// `internalformat`
    ///
    /// > Specifies the internal format for the newly created view.
    ///
    /// `minlevel`
    ///
    /// > Specifies lowest level of detail of the view.
    ///
    /// `numlevels`
    ///
    /// > Specifies the number of levels of detail to include in the view.
    ///
    /// `minlayer`
    ///
    /// > Specifies the index of the first layer to include in the view.
    ///
    /// `numlayers`
    ///
    /// > Specifies the number of layers to include in the view.
    ///
    /// ### Description
    /// [**glTextureView**](crate::context::Context::oxidegl_texture_view) initializes
    /// a texture object as an alias, or view of another texture object, sharing
    /// some or all of the parent texture's data store with the initialized texture.
    /// `texture` specifies a name previously reserved by a successful call to
    /// [**glGenTextures**](crate::context::Context::oxidegl_gen_textures) but
    /// that has not yet been bound or given a target. `target` specifies the target
    /// for the newly initialized texture and must be compatible with the target
    /// of the parent texture, given in `origtexture` as specified in the following
    /// table:
    ///
    /// | Original Target                           | Compatible New Targets                               |
    /// |-------------------------------------------|------------------------------------------------------|
    /// | [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D) | [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D), [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY) |
    /// | [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D) | [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D), [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY) |
    /// | [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D) | [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D)  |
    /// | [`GL_TEXTURE_CUBE_MAP`](crate::enums::GL_TEXTURE_CUBE_MAP) | [`GL_TEXTURE_CUBE_MAP`](crate::enums::GL_TEXTURE_CUBE_MAP), [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D), [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY), [`GL_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_CUBE_MAP_ARRAY) |
    /// | [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE) | [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE) |
    /// | [`GL_TEXTURE_BUFFER`](crate::enums::GL_TEXTURE_BUFFER) | *none*                                  |
    /// | [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY) | [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D), [`GL_TEXTURE_1D_ARRAY`](crate::enums::GL_TEXTURE_1D_ARRAY) |
    /// | [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY) | [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D), [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY) |
    /// | [`GL_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_CUBE_MAP_ARRAY) | [`GL_TEXTURE_CUBE_MAP`](crate::enums::GL_TEXTURE_CUBE_MAP), [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D), [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY), [`GL_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_CUBE_MAP_ARRAY) |
    /// | [`GL_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE) | [`GL_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE), [`GL_TEXTURE_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_MULTISAMPLE_ARRAY) |
    /// | [`GL_TEXTURE_2D_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE_ARRAY) | [`GL_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE), [`GL_TEXTURE_MULTISAMPLE_ARRAY`](crate::enums::GL_TEXTURE_MULTISAMPLE_ARRAY) |
    ///
    /// The value of [`GL_TEXTURE_IMMUTABLE_FORMAT`](crate::enums::GL_TEXTURE_IMMUTABLE_FORMAT)
    /// for `origtexture` must be [`GL_TRUE`](crate::enums::GL_TRUE). After initialization,
    /// `texture` inherits the data store of the parent texture, `origtexture`
    /// and is usable as a normal texture object with target `target`. Data in
    /// the shared store is reinterpreted with the new internal format specified
    /// by `internalformat`. `internalformat` must be compatible with the internal
    /// format of the parent texture as specified in the following table:
    ///
    /// | Class    | Internal Formats                            |
    /// |----------|---------------------------------------------|
    /// | 128-bit  | [`GL_RGBA32F`](crate::enums::GL_RGBA32F), [`GL_RGBA32UI`](crate::enums::GL_RGBA32UI), [`GL_RGBA32I`](crate::enums::GL_RGBA32I) |
    /// | 96-bit   | [`GL_RGB32F`](crate::enums::GL_RGB32F), [`GL_RGB32UI`](crate::enums::GL_RGB32UI), [`GL_RGB32I`](crate::enums::GL_RGB32I) |
    /// | 64-bit   | [`GL_RGBA16F`](crate::enums::GL_RGBA16F), [`GL_RG32F`](crate::enums::GL_RG32F), [`GL_RGBA16UI`](crate::enums::GL_RGBA16UI), [`GL_RG32UI`](crate::enums::GL_RG32UI), [`GL_RGBA16I`](crate::enums::GL_RGBA16I), [`GL_RG32I`](crate::enums::GL_RG32I), [`GL_RGBA16`](crate::enums::GL_RGBA16), [`GL_RGBA16_SNORM`](crate::enums::GL_RGBA16_SNORM) |
    /// | 48-bit   | [`GL_RGB16`](crate::enums::GL_RGB16), [`GL_RGB16_SNORM`](crate::enums::GL_RGB16_SNORM), [`GL_RGB16F`](crate::enums::GL_RGB16F), [`GL_RGB16UI`](crate::enums::GL_RGB16UI), [`GL_RGB16I`](crate::enums::GL_RGB16I) |
    /// | 32-bit   | [`GL_RG16F`](crate::enums::GL_RG16F), [`GL_R11F_G11F_B10F`](crate::enums::GL_R11F_G11F_B10F), [`GL_R32F`](crate::enums::GL_R32F), [`GL_RGB10_A2UI`](crate::enums::GL_RGB10_A2UI), [`GL_RGBA8UI`](crate::enums::GL_RGBA8UI), [`GL_RG16UI`](crate::enums::GL_RG16UI), [`GL_R32UI`](crate::enums::GL_R32UI), [`GL_RGBA8I`](crate::enums::GL_RGBA8I), [`GL_RG16I`](crate::enums::GL_RG16I), [`GL_R32I`](crate::enums::GL_R32I), [`GL_RGB10_A2`](crate::enums::GL_RGB10_A2), [`GL_RGBA8`](crate::enums::GL_RGBA8), [`GL_RG16`](crate::enums::GL_RG16), [`GL_RGBA8_SNORM`](crate::enums::GL_RGBA8_SNORM), [`GL_RG16_SNORM`](crate::enums::GL_RG16_SNORM), [`GL_SRGB8_ALPHA8`](crate::enums::GL_SRGB8_ALPHA8), [`GL_RGB9_E5`](crate::enums::GL_RGB9_E5) |
    /// | 24-bit   | [`GL_RGB8`](crate::enums::GL_RGB8), [`GL_RGB8_SNORM`](crate::enums::GL_RGB8_SNORM), [`GL_SRGB8`](crate::enums::GL_SRGB8), [`GL_RGB8UI`](crate::enums::GL_RGB8UI), [`GL_RGB8I`](crate::enums::GL_RGB8I) |
    /// | 16-bit   | [`GL_R16F`](crate::enums::GL_R16F), [`GL_RG8UI`](crate::enums::GL_RG8UI), [`GL_R16UI`](crate::enums::GL_R16UI), [`GL_RG8I`](crate::enums::GL_RG8I), [`GL_R16I`](crate::enums::GL_R16I), [`GL_RG8`](crate::enums::GL_RG8), [`GL_R16`](crate::enums::GL_R16), [`GL_RG8_SNORM`](crate::enums::GL_RG8_SNORM), [`GL_R16_SNORM`](crate::enums::GL_R16_SNORM) |
    /// | 8-bit    | [`GL_R8UI`](crate::enums::GL_R8UI), [`GL_R8I`](crate::enums::GL_R8I), [`GL_R8`](crate::enums::GL_R8), [`GL_R8_SNORM`](crate::enums::GL_R8_SNORM) |
    /// | [`GL_RGTC1_RED`](crate::enums::GL_RGTC1_RED) | [`GL_COMPRESSED_RED_RGTC1`](crate::enums::GL_COMPRESSED_RED_RGTC1), [`GL_COMPRESSED_SIGNED_RED_RGTC1`](crate::enums::GL_COMPRESSED_SIGNED_RED_RGTC1) |
    /// | [`GL_RGTC2_RG`](crate::enums::GL_RGTC2_RG) | [`GL_COMPRESSED_RG_RGTC2`](crate::enums::GL_COMPRESSED_RG_RGTC2), [`GL_COMPRESSED_SIGNED_RG_RGTC2`](crate::enums::GL_COMPRESSED_SIGNED_RG_RGTC2) |
    /// | [`GL_BPTC_UNORM`](crate::enums::GL_BPTC_UNORM) | [`GL_COMPRESSED_RGBA_BPTC_UNORM`](crate::enums::GL_COMPRESSED_RGBA_BPTC_UNORM), [`GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM`](crate::enums::GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM) |
    /// | [`GL_BPTC_FLOAT`](crate::enums::GL_BPTC_FLOAT) | [`GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT`](crate::enums::GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT), [`GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT`](crate::enums::GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT) |
    ///
    /// If the original texture is an array or has multiple mipmap levels, the
    /// parameters `minlayer`, `numlayers`, `minlevel`, and `numlevels` control
    /// which of those slices and levels are considered part of the texture. The
    /// `minlevel` and `minlayer` parameters are relative to the view of the original
    /// texture. If `numlayers` or `numlevels` extend beyond the original texture,
    /// they are clamped to the max extent of the original texture.
    ///
    /// If the new texture's target is [`GL_TEXTURE_CUBE_MAP`](crate::enums::GL_TEXTURE_CUBE_MAP),
    /// the clamped `numlayers` must be equal to 6. If the new texture's target
    /// is [`GL_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_CUBE_MAP_ARRAY),
    /// then `numlayers` counts layer-faces rather than layers, and the clamped
    /// `numlayers` must be a multiple of 6. If the new texture's target is [`GL_TEXTURE_CUBE_MAP`](crate::enums::GL_TEXTURE_CUBE_MAP)
    /// or [`GL_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_CUBE_MAP_ARRAY),
    /// the width and height of the original texture's levels must be equal.
    ///
    /// When the original texture's target is [`GL_TEXTURE_CUBE_MAP`](crate::enums::GL_TEXTURE_CUBE_MAP),
    /// the layer parameters are interpreted in the same order as if it were a
    /// [`GL_TEXTURE_CUBE_MAP_ARRAY`](crate::enums::GL_TEXTURE_CUBE_MAP_ARRAY)
    /// with 6 layer-faces.
    ///
    /// If `target` is [`GL_TEXTURE_1D`](crate::enums::GL_TEXTURE_1D), [`GL_TEXTURE_2D`](crate::enums::GL_TEXTURE_2D),
    /// [`GL_TEXTURE_3D`](crate::enums::GL_TEXTURE_3D), [`GL_TEXTURE_RECTANGLE`](crate::enums::GL_TEXTURE_RECTANGLE),
    /// or [`GL_TEXTURE_2D_MULTISAMPLE`](crate::enums::GL_TEXTURE_2D_MULTISAMPLE),
    /// `numlayers` must equal 1.
    ///
    /// The dimensions of the original texture must be less than or equal to the
    /// maximum supported dimensions of the new target. For example, if the original
    /// texture has a [`GL_TEXTURE_2D_ARRAY`](crate::enums::GL_TEXTURE_2D_ARRAY)
    /// target and its width is greater than [`GL_MAX_CUBE_MAP_TEXTURE_SIZE`](crate::enums::GL_MAX_CUBE_MAP_TEXTURE_SIZE),
    /// an error will be generated if [**glTextureView**](crate::context::Context::oxidegl_texture_view)
    /// is called to create a [`GL_TEXTURE_CUBE_MAP`](crate::enums::GL_TEXTURE_CUBE_MAP)
    /// view.
    ///
    /// Texture commands that take a `level` or `layer` parameter, such as [**glTexSubImage2D**](crate::context::Context::oxidegl_tex_sub_image2_d),
    /// interpret that parameter to be relative to the view of the texture. i.e.
    /// the mipmap level of the data store that would be updated via [**glTexSubImage2D**](crate::context::Context::oxidegl_tex_sub_image2_d)
    /// would be the sum of `level` and the value of [`GL_TEXTURE_VIEW_MIN_LEVEL`](crate::enums::GL_TEXTURE_VIEW_MIN_LEVEL).
    ///
    /// ### Associated Gets
    /// [**glTexParameter**](crate::context::Context::oxidegl_tex_parameter) with
    /// arguments [`GL_TEXTURE_VIEW_MIN_LEVEL`](crate::enums::GL_TEXTURE_VIEW_MIN_LEVEL),
    /// [`GL_TEXTURE_VIEW_NUM_LEVELS`](crate::enums::GL_TEXTURE_VIEW_NUM_LEVELS),
    /// [`GL_TEXTURE_VIEW_MIN_LAYER`](crate::enums::GL_TEXTURE_VIEW_MIN_LAYER),
    /// [`GL_TEXTURE_VIEW_NUM_LAYERS`](crate::enums::GL_TEXTURE_VIEW_NUM_LAYERS),
    /// or [`GL_TEXTURE_IMMUTABLE_LEVELS`](crate::enums::GL_TEXTURE_IMMUTABLE_LEVELS).

    pub fn oxidegl_texture_view(
        &mut self,
        texture: GLuint,
        target: TextureTarget,
        origtexture: GLuint,
        internalformat: SizedInternalFormat,
        minlevel: GLuint,
        numlevels: GLuint,
        minlayer: GLuint,
        numlayers: GLuint,
    ) {
        panic!("command oxidegl_texture_view not yet implemented");
    }
    /// ### Parameters
    /// `xfb`
    ///
    /// > Name of the transform feedback buffer object.
    ///
    /// `index`
    ///
    /// > Index of the binding point within `xfb`.
    ///
    /// `buffer`
    ///
    /// > Name of the buffer object to bind to the specified binding point.
    ///
    /// ### Description
    /// [**glTransformFeedbackBufferBase**](crate::context::Context::oxidegl_transform_feedback_buffer_base)
    /// binds the buffer object `buffer` to the binding point at index `index`
    /// of the transform feedback object `xfb`.
    ///
    /// ### Notes
    /// Calling [**glTransformFeedbackBufferBase**](crate::context::Context::oxidegl_transform_feedback_buffer_base)
    /// is equivalent to calling [**glTransformFeedbackBufferRange**](crate::context::Context::oxidegl_transform_feedback_buffer_range)
    /// with `offset` zero and `size` equal to the size of `buffer`.

    pub fn oxidegl_transform_feedback_buffer_base(
        &mut self,
        xfb: GLuint,
        index: GLuint,
        buffer: GLuint,
    ) {
        panic!("command oxidegl_transform_feedback_buffer_base not yet implemented");
    }
    /// ### Parameters
    /// `xfb`
    ///
    /// > Name of the transform feedback buffer object.
    ///
    /// `index`
    ///
    /// > Index of the binding point within `xfb`.
    ///
    /// `buffer`
    ///
    /// > Name of the buffer object to bind to the specified binding point.
    ///
    /// `offset`
    ///
    /// > The starting offset in basic machine units into the buffer object.
    ///
    /// `size`
    ///
    /// > The amount of data in basic machine units that can be read from or written
    /// > to the buffer object while used as an indexed target.
    ///
    /// ### Description
    /// [**glTransformFeedbackBufferRange**](crate::context::Context::oxidegl_transform_feedback_buffer_range)
    /// binds a range of the buffer object `buffer` represented by `offset` and
    /// `size` to the binding point at index `index` of the transform feedback
    /// object `xfb`.
    ///
    /// `offset` specifies the offset in basic machine units into the buffer object
    /// `buffer` and `size` specifies the amount of data that can be read from
    /// the buffer object while used as an indexed target.
    ///
    /// ### Notes

    pub fn oxidegl_transform_feedback_buffer_range(
        &mut self,
        xfb: GLuint,
        index: GLuint,
        buffer: GLuint,
        offset: GLintptr,
        size: GLsizeiptr,
    ) {
        panic!("command oxidegl_transform_feedback_buffer_range not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > The name of the target program object.
    ///
    /// `count`
    ///
    /// > The number of varying variables used for transform feedback.
    ///
    /// `varyings`
    ///
    /// > An array of `count` zero-terminated strings specifying the names of the
    /// > varying variables to use for transform feedback.
    ///
    /// `bufferMode`
    ///
    /// > Identifies the mode used to capture the varying variables when transform
    /// > feedback is active. `bufferMode` must be [`GL_INTERLEAVED_ATTRIBS`](crate::enums::GL_INTERLEAVED_ATTRIBS)
    /// > or [`GL_SEPARATE_ATTRIBS`](crate::enums::GL_SEPARATE_ATTRIBS).
    ///
    /// ### Description
    /// The names of the vertex or geometry shader outputs to be recorded in transform
    /// feedback mode are specified using [**glTransformFeedbackVaryings**](crate::context::Context::oxidegl_transform_feedback_varyings).
    /// When a geometry shader is active, transform feedback records the values
    /// of selected geometry shader output variables from the emitted vertices.
    /// Otherwise, the values of the selected vertex shader outputs are recorded.
    ///
    /// The state set by [**glTranformFeedbackVaryings**](crate::context::Context::oxidegl_tranform_feedback_varyings)
    /// is stored and takes effect next time [**glLinkProgram**](crate::context::Context::oxidegl_link_program)
    /// is called on `program`. When [**glLinkProgram**](crate::context::Context::oxidegl_link_program)
    /// is called, `program` is linked so that the values of the specified varying
    /// variables for the vertices of each primitive generated by the GL are written
    /// to a single buffer object if `bufferMode` is [`GL_INTERLEAVED_ATTRIBS`](crate::enums::GL_INTERLEAVED_ATTRIBS)
    /// or multiple buffer objects if `bufferMode` is [`GL_SEPARATE_ATTRIBS`](crate::enums::GL_SEPARATE_ATTRIBS).
    ///
    /// [**glTransformFeedbackVaryings**](crate::context::Context::oxidegl_transform_feedback_varyings)
    /// can also special identifiers if `bufferMode` is [`GL_INTERLEAVED_ATTRIBS`](crate::enums::GL_INTERLEAVED_ATTRIBS):
    ///
    /// Subsequent variables in `varyings` will be assigned to the next buffer
    /// binding point.
    ///
    /// Where# may be 1, 2, 3, or 4. The variable is treated as having this number
    /// of components, but the contents of the memory are preserved under feedback
    /// operations.
    ///
    /// In addition to the errors generated by [**glTransformFeedbackVaryings**](crate::context::Context::oxidegl_transform_feedback_varyings),
    /// the program `program` will fail to link if: The count specified by [**glTransformFeedbackVaryings**](crate::context::Context::oxidegl_transform_feedback_varyings)
    /// > is non-zero, but the program object has no vertex or geometry shader.
    ///
    /// > Any variable name specified in the `varyings` array is not declared as
    /// > an output in the vertex shader (or the geometry shader, if active), or
    /// > is not one of the special identifiers listed above.
    ///
    /// > Special identifiers appear in a `varyings` array where `bufferMode` is
    /// > not [`GL_INTERLEAVED_ATTRIBS`](crate::enums::GL_INTERLEAVED_ATTRIBS).
    ///
    /// > Any two entries in the `varyings` array, which are not one of the special
    /// > varyings above, specify the same varying variable.
    ///
    /// > Discounting any special identifiers, the total number of components to
    /// > capture in any varying variable in `varyings` is greater than the constant
    /// > [`GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS`](crate::enums::GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS)
    /// > and the buffer mode is [`GL_SEPARATE_ATTRIBS`](crate::enums::GL_SEPARATE_ATTRIBS).
    ///
    /// > The total number of components to capture is greater than the constant
    /// > [`GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS`](crate::enums::GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS)
    /// > and the buffer mode is [`GL_INTERLEAVED_ATTRIBS`](crate::enums::GL_INTERLEAVED_ATTRIBS).
    ///
    ///
    /// ### Notes
    /// [**glGetTransformFeedbackVarying**](crate::context::Context::oxidegl_get_transform_feedback_varying)
    /// is available only if the GL version is 3.0 or greater.
    ///
    /// ### Associated Gets
    /// [**glGetTransformFeedbackVarying**](crate::context::Context::oxidegl_get_transform_feedback_varying)

    pub fn oxidegl_transform_feedback_varyings(
        &mut self,
        program: GLuint,
        count: GLsizei,
        varyings: GLchar,
        buffer_mode: TransformFeedbackBufferMode,
    ) {
        panic!("command oxidegl_transform_feedback_varyings not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > The name of a program object containing the active uniform block whose
    /// > binding to assign.
    ///
    /// `uniformBlockIndex`
    ///
    /// > The index of the active uniform block within `program` whose binding to
    /// > assign.
    ///
    /// `uniformBlockBinding`
    ///
    /// > Specifies the binding point to which to bind the uniform block with index
    /// > `uniformBlockIndex` within `program`.
    ///
    /// ### Description
    /// Binding points for active uniform blocks are assigned using [**glUniformBlockBinding**](crate::context::Context::oxidegl_uniform_block_binding).
    /// Each of a program's active uniform blocks has a corresponding uniform
    /// buffer binding point. `program` is the name of a program object for which
    /// the command [**glLinkProgram**](crate::context::Context::oxidegl_link_program)
    /// has been issued in the past.
    ///
    /// If successful, [**glUniformBlockBinding**](crate::context::Context::oxidegl_uniform_block_binding)
    /// specifies that `program` will use the data store of the buffer object bound
    /// to the binding point `uniformBlockBinding` to extract the values of the
    /// uniforms in the uniform block identified by `uniformBlockIndex`.
    ///
    /// When a program object is linked or re-linked, the uniform buffer object
    /// binding point assigned to each of its active uniform blocks is reset to
    /// zero.
    ///
    /// ### Notes
    /// [**glUniformBlockBinding**](crate::context::Context::oxidegl_uniform_block_binding)
    /// is available only if the GL version is 3.1 or greater.
    ///
    /// ### Associated Gets
    /// [**glGetActiveUniformBlock**](crate::context::Context::oxidegl_get_active_uniform_block)
    /// with argument [`GL_UNIFORM_BLOCK_BINDING`](crate::enums::GL_UNIFORM_BLOCK_BINDING)

    pub fn oxidegl_uniform_block_binding(
        &mut self,
        program: GLuint,
        uniform_block_index: GLuint,
        uniform_block_binding: GLuint,
    ) {
        panic!("command oxidegl_uniform_block_binding not yet implemented");
    }
    /// ### Parameters
    /// `shadertype`
    ///
    /// > Specifies the shader stage from which to query for subroutine uniform index.
    /// > `shadertype` must be one of [`GL_VERTEX_SHADER`](crate::enums::GL_VERTEX_SHADER),
    /// > [`GL_TESS_CONTROL_SHADER`](crate::enums::GL_TESS_CONTROL_SHADER), [`GL_TESS_EVALUATION_SHADER`](crate::enums::GL_TESS_EVALUATION_SHADER),
    /// > [`GL_GEOMETRY_SHADER`](crate::enums::GL_GEOMETRY_SHADER) or [`GL_FRAGMENT_SHADER`](crate::enums::GL_FRAGMENT_SHADER).
    ///
    /// `count`
    ///
    /// > Specifies the number of uniform indices stored in `indices`.
    ///
    /// `indices`
    ///
    /// > Specifies the address of an array holding the indices to load into the
    /// > shader subroutine variables.
    ///
    /// ### Description
    /// [**glUniformSubroutines**](crate::context::Context::oxidegl_uniform_subroutines)
    /// loads all active subroutine uniforms for shader stage `shadertype` of the
    /// current program with subroutine indices from `indices`, storing `indices[i]`
    /// into the uniform at location `i`. `count` must be equal to the value of
    /// [`GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS`](crate::enums::GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS)
    /// for the program currently in use at shader stage `shadertype`. Furthermore,
    /// all values in `indices` must be less than the value of [`GL_ACTIVE_SUBROUTINES`](crate::enums::GL_ACTIVE_SUBROUTINES)
    /// for the shader stage.
    ///
    /// ### Associated Gets
    /// [**glGetProgramStage**](crate::context::Context::oxidegl_get_program_stage)
    /// with argument [`GL_ACTIVE_SUBROUTINES`](crate::enums::GL_ACTIVE_SUBROUTINES)
    ///
    /// [**glGetProgramStage**](crate::context::Context::oxidegl_get_program_stage)
    /// with argument [`GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS`](crate::enums::GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS)

    pub unsafe fn oxidegl_uniform_subroutinesuiv(
        &mut self,
        shadertype: ShaderType,
        count: GLsizei,
        indices: *const GLuint,
    ) {
        panic!("command oxidegl_uniform_subroutinesuiv not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the handle of the program object whose executables are to be
    /// > used as part of current rendering state.
    ///
    /// ### Description
    /// [**glUseProgram**](crate::context::Context::oxidegl_use_program) installs
    /// the program object specified by `program` as part of current rendering
    /// state. One or more executables are created in a program object by successfully
    /// attaching shader objects to it with [**glAttachShader**](crate::context::Context::oxidegl_attach_shader),
    /// successfully compiling the shader objects with [**glCompileShader**](crate::context::Context::oxidegl_compile_shader),
    /// and successfully linking the program object with [**glLinkProgram**](crate::context::Context::oxidegl_link_program).
    ///
    /// A program object will contain an executable that will run on the vertex
    /// processor if it contains one or more shader objects of type [`GL_VERTEX_SHADER`](crate::enums::GL_VERTEX_SHADER)
    /// that have been successfully compiled and linked. A program object will
    /// contain an executable that will run on the geometry processor if it contains
    /// one or more shader objects of type [`GL_GEOMETRY_SHADER`](crate::enums::GL_GEOMETRY_SHADER)
    /// that have been successfully compiled and linked. Similarly, a program object
    /// will contain an executable that will run on the fragment processor if it
    /// contains one or more shader objects of type [`GL_FRAGMENT_SHADER`](crate::enums::GL_FRAGMENT_SHADER)
    /// that have been successfully compiled and linked.
    ///
    /// While a program object is in use, applications are free to modify attached
    /// shader objects, compile attached shader objects, attach additional shader
    /// objects, and detach or delete shader objects. None of these operations
    /// will affect the executables that are part of the current state. However,
    /// relinking the program object that is currently in use will install the
    /// program object as part of the current rendering state if the link operation
    /// was successful (see [**glLinkProgram**](crate::context::Context::oxidegl_link_program)
    /// ). If the program object currently in use is relinked unsuccessfully, its
    /// link status will be set to [`GL_FALSE`](crate::enums::GL_FALSE), but the
    /// executables and associated state will remain part of the current state
    /// until a subsequent call to [**glUseProgram**](crate::context::Context::oxidegl_use_program)
    /// removes it from use. After it is removed from use, it cannot be made part
    /// of current state until it has been successfully relinked.
    ///
    /// If `program` is zero, then the current rendering state refers to an *invalid*
    /// program object and the results of shader execution are undefined. However,
    /// this is not an error.
    ///
    /// If `program` does not contain shader objects of type [`GL_FRAGMENT_SHADER`](crate::enums::GL_FRAGMENT_SHADER),
    /// an executable will be installed on the vertex, and possibly geometry processors,
    /// but the results of fragment shader execution will be undefined.
    ///
    /// ### Notes
    /// Like buffer and texture objects, the name space for program objects may
    /// be shared across a set of contexts, as long as the server sides of the
    /// contexts share the same address space. If the name space is shared across
    /// contexts, any attached objects and the data associated with those attached
    /// objects are shared as well.
    ///
    /// Applications are responsible for providing the synchronization across API
    /// calls when objects are accessed from different execution threads.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with the argument [`GL_CURRENT_PROGRAM`](crate::enums::GL_CURRENT_PROGRAM)
    ///
    /// [**glGetActiveAttrib**](crate::context::Context::oxidegl_get_active_attrib)
    /// with a valid program object and the index of an active attribute variable
    ///
    /// [**glGetActiveUniform**](crate::context::Context::oxidegl_get_active_uniform)
    /// with a valid program object and the index of an active uniform variable
    ///
    /// [**glGetAttachedShaders**](crate::context::Context::oxidegl_get_attached_shaders)
    /// with a valid program object
    ///
    /// [**glGetAttribLocation**](crate::context::Context::oxidegl_get_attrib_location)
    /// with a valid program object and the name of an attribute variable
    ///
    /// [**glGetProgram**](crate::context::Context::oxidegl_get_program) with a
    /// valid program object and the parameter to be queried
    ///
    /// [**glGetProgramInfoLog**](crate::context::Context::oxidegl_get_program_info_log)
    /// with a valid program object
    ///
    /// [**glGetUniform**](crate::context::Context::oxidegl_get_uniform) with a
    /// valid program object and the location of a uniform variable
    ///
    /// [**glGetUniformLocation**](crate::context::Context::oxidegl_get_uniform_location)
    /// with a valid program object and the name of a uniform variable
    ///
    /// [**glIsProgram**](crate::context::Context::oxidegl_is_program)

    pub fn oxidegl_use_program(&mut self, program: GLuint) {
        panic!("command oxidegl_use_program not yet implemented");
    }
    /// ### Parameters
    /// `pipeline`
    ///
    /// > Specifies the program pipeline object to which to bind stages from `program`.
    ///
    /// `stages`
    ///
    /// > Specifies a set of program stages to bind to the program pipeline object.
    ///
    /// `program`
    ///
    /// > Specifies the program object containing the shader executables to use in
    /// > `pipeline`.
    ///
    /// ### Description
    /// [**glUseProgramStages**](crate::context::Context::oxidegl_use_program_stages)
    /// binds executables from a program object associated with a specified set
    /// of shader stages to the program pipeline object given by `pipeline`. `pipeline`
    /// specifies the program pipeline object to which to bind the executables.
    /// `stages` contains a logical combination of bits indicating the shader stages
    /// to use within `program` with the program pipeline object `pipeline`. `stages`
    /// must be a logical combination of [`GL_VERTEX_SHADER_BIT`](crate::enums::GL_VERTEX_SHADER_BIT),
    /// [`GL_TESS_CONTROL_SHADER_BIT`](crate::enums::GL_TESS_CONTROL_SHADER_BIT),
    /// [`GL_TESS_EVALUATION_SHADER_BIT`](crate::enums::GL_TESS_EVALUATION_SHADER_BIT),
    /// [`GL_GEOMETRY_SHADER_BIT`](crate::enums::GL_GEOMETRY_SHADER_BIT), [`GL_FRAGMENT_SHADER_BIT`](crate::enums::GL_FRAGMENT_SHADER_BIT)
    /// and [`GL_COMPUTE_SHADER_BIT`](crate::enums::GL_COMPUTE_SHADER_BIT). Additionally,
    /// the special value [`GL_ALL_SHADER_BITS`](crate::enums::GL_ALL_SHADER_BITS)
    /// may be specified to indicate that all executables contained in `program`
    /// should be installed in `pipeline`.
    ///
    /// If `program` refers to a program object with a valid shader attached for
    /// an indicated shader stage, [**glUseProgramStages**](crate::context::Context::oxidegl_use_program_stages)
    /// installs the executable code for that stage in the indicated program pipeline
    /// object `pipeline`. If `program` is zero, or refers to a program object
    /// with no valid shader executable for a given stage, it is as if the pipeline
    /// object has no programmable stage configured for the indicated shader stages.
    /// If `stages` contains bits other than those listed above, and is not equal
    /// to [`GL_ALL_SHADER_BITS`](crate::enums::GL_ALL_SHADER_BITS), an error is
    /// generated.
    ///
    /// ### Notes
    /// The [`GL_COMPUTE_SHADER_BIT`](crate::enums::GL_COMPUTE_SHADER_BIT) bit
    /// is available only if the GL version is 4.3 or greater.

    pub fn oxidegl_use_program_stages(
        &mut self,
        pipeline: GLuint,
        stages: UseProgramStageMask,
        program: GLuint,
    ) {
        panic!("command oxidegl_use_program_stages not yet implemented");
    }
    /// ### Parameters
    /// `program`
    ///
    /// > Specifies the handle of the program object to be validated.
    ///
    /// ### Description
    /// [**glValidateProgram**](crate::context::Context::oxidegl_validate_program)
    /// checks to see whether the executables contained in `program` can execute
    /// given the current OpenGL state. The information generated by the validation
    /// process will be stored in `program` 's information log. The validation
    /// information may consist of an empty string, or it may be a string containing
    /// information about how the current program object interacts with the rest
    /// of current OpenGL state. This provides a way for OpenGL implementers to
    /// convey more information about why the current program is inefficient, suboptimal,
    /// failing to execute, and so on.
    ///
    /// The status of the validation operation will be stored as part of the program
    /// object's state. This value will be set to [`GL_TRUE`](crate::enums::GL_TRUE)
    /// if the validation succeeded, and [`GL_FALSE`](crate::enums::GL_FALSE) otherwise.
    /// It can be queried by calling [**glGetProgram**](crate::context::Context::oxidegl_get_program)
    /// with arguments `program` and [`GL_VALIDATE_STATUS`](crate::enums::GL_VALIDATE_STATUS).
    /// If validation is successful, `program` is guaranteed to execute given
    /// the current state. Otherwise, `program` is guaranteed to not execute.
    ///
    /// This function is typically useful only during application development.
    /// The informational string stored in the information log is completely implementation
    /// dependent; therefore, an application should not expect different OpenGL
    /// implementations to produce identical information strings.
    ///
    /// ### Notes
    /// This function mimics the validation operation that OpenGL implementations
    /// must perform when rendering commands are issued while programmable shaders
    /// are part of current state. The error [`GL_INVALID_OPERATION`](crate::enums::GL_INVALID_OPERATION)
    /// will be generated by any command that triggers the rendering of geometry
    /// if:
    ///
    /// > any two active samplers in the current program object are of different
    /// > types, but refer to the same texture image unit,
    ///
    /// > the number of active samplers in the program exceeds the maximum number
    /// > of texture image units allowed.
    ///
    /// It may be difficult or cause a performance degradation for applications
    /// to catch these errors when rendering commands are issued. Therefore, applications
    /// are advised to make calls to [**glValidateProgram**](crate::context::Context::oxidegl_validate_program)
    /// to detect these issues during application development.
    ///
    /// ### Associated Gets
    /// [**glGetProgram**](crate::context::Context::oxidegl_get_program) with arguments
    /// `program` and [`GL_VALIDATE_STATUS`](crate::enums::GL_VALIDATE_STATUS)
    ///
    /// [**glGetProgramInfoLog**](crate::context::Context::oxidegl_get_program_info_log)
    /// with argument `program`
    ///
    /// [**glIsProgram**](crate::context::Context::oxidegl_is_program)

    pub fn oxidegl_validate_program(&mut self, program: GLuint) {
        panic!("command oxidegl_validate_program not yet implemented");
    }
    /// ### Parameters
    /// `pipeline`
    ///
    /// > Specifies the name of a program pipeline object to validate.
    ///
    /// ### Description
    /// [**glValidateProgramPipeline**](crate::context::Context::oxidegl_validate_program_pipeline)
    /// instructs the implementation to validate the shader executables contained
    /// in `pipeline` against the current GL state. The implementation may use
    /// this as an opportunity to perform any internal shader modifications that
    /// may be required to ensure correct operation of the installed shaders given
    /// the current GL state.
    ///
    /// After a program pipeline has been validated, its validation status is set
    /// to [`GL_TRUE`](crate::enums::GL_TRUE). The validation status of a program
    /// pipeline object may be queried by calling [**glGetProgramPipeline**](crate::context::Context::oxidegl_get_program_pipeline)
    /// with parameter [`GL_VALIDATE_STATUS`](crate::enums::GL_VALIDATE_STATUS).
    ///
    /// If `pipeline` is a name previously returned from a call to [**glGenProgramPipelines**](crate::context::Context::oxidegl_gen_program_pipelines)
    /// but that has not yet been bound by a call to [**glBindProgramPipeline**](crate::context::Context::oxidegl_bind_program_pipeline),
    /// a new program pipeline object is created with name `pipeline` and the
    /// default state vector.
    ///
    /// ### Associated Gets
    /// [**glGetProgramPipeline**](crate::context::Context::oxidegl_get_program_pipeline)
    /// with parameter [`GL_VALIDATE_STATUS`](crate::enums::GL_VALIDATE_STATUS).

    pub fn oxidegl_validate_program_pipeline(&mut self, pipeline: GLuint) {
        panic!("command oxidegl_validate_program_pipeline not yet implemented");
    }
    /// ### Parameters
    /// `vaobj`
    ///
    /// > Specifies the name of the vertex array object.
    ///
    /// `buffer`
    ///
    /// > Specifies the name of the buffer object to use for the element array buffer
    /// > binding.
    ///
    /// ### Description
    /// [**glVertexArrayElementBuffer**](crate::context::Context::oxidegl_vertex_array_element_buffer)
    /// binds a buffer object with id `buffer` to the element array buffer bind
    /// point of a vertex array object with id `vaobj`. If `buffer` is zero, any
    /// existing element array buffer binding to `vaobj` is removed.
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_ELEMENT_ARRAY_BUFFER_BINDING`](crate::enums::GL_ELEMENT_ARRAY_BUFFER_BINDING).
    ///
    /// [**glGetVertexArrayiv**](crate::context::Context::oxidegl_get_vertex_arrayiv)
    /// with argument [`GL_ELEMENT_ARRAY_BUFFER_BINDING`](crate::enums::GL_ELEMENT_ARRAY_BUFFER_BINDING).

    pub fn oxidegl_vertex_array_element_buffer(&mut self, vaobj: GLuint, buffer: GLuint) {
        panic!("command oxidegl_vertex_array_element_buffer not yet implemented");
    }
    /// ### Parameters
    /// `index`
    ///
    /// > Specify the index of the generic vertex attribute.
    ///
    /// `divisor`
    ///
    /// > Specify the number of instances that will pass between updates of the generic
    /// > attribute at slot `index`.
    ///
    /// ### Description
    /// [**glVertexAttribDivisor**](crate::context::Context::oxidegl_vertex_attrib_divisor)
    /// modifies the rate at which generic vertex attributes advance when rendering
    /// multiple instances of primitives in a single draw call. If `divisor` is
    /// zero, the attribute at slot `index` advances once per vertex. If `divisor`
    /// is non-zero, the attribute advances once per `divisor` instances of the
    /// set(s) of vertices being rendered. An attribute is referred to as instanced
    /// if its [`GL_VERTEX_ATTRIB_ARRAY_DIVISOR`](crate::enums::GL_VERTEX_ATTRIB_ARRAY_DIVISOR)
    /// value is non-zero.
    ///
    /// `index` must be less than the value of [`GL_MAX_VERTEX_ATTRIBS`](crate::enums::GL_MAX_VERTEX_ATTRIBS).
    ///
    /// ### Notes
    /// [**glVertexAttribDivisor**](crate::context::Context::oxidegl_vertex_attrib_divisor)
    /// is available only if the GL version is 3.3 or higher.

    pub fn oxidegl_vertex_attrib_divisor(&mut self, index: GLuint, divisor: GLuint) {
        panic!("command oxidegl_vertex_attrib_divisor not yet implemented");
    }
    /// ### Parameters
    /// `x`
    ///
    /// `y`
    ///
    /// > Specify the lower left corner of the viewport rectangle, in pixels. The
    /// > initial value is (0,0).
    ///
    /// `width`
    ///
    /// `height`
    ///
    /// > Specify the width and height of the viewport. When a GL context is first
    /// > attached to a window, `width` and `height` are set to the dimensions of
    /// > that window.
    ///
    /// ### Description
    /// [**glViewport**](crate::context::Context::oxidegl_viewport) specifies the
    /// affine transformation of `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]`
    ///
    ///
    ///
    /// Viewport width and height are silently clamped to a range that depends
    /// on the implementation. To query this range, call [**glGet**](crate::context::Context::oxidegl_get)
    /// with argument [`GL_MAX_VIEWPORT_DIMS`](crate::enums::GL_MAX_VIEWPORT_DIMS).
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_VIEWPORT`](crate::enums::GL_VIEWPORT)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_VIEWPORT_DIMS`](crate::enums::GL_MAX_VIEWPORT_DIMS)

    pub fn oxidegl_viewport(&mut self, x: GLint, y: GLint, width: GLsizei, height: GLsizei) {
        panic!("command oxidegl_viewport not yet implemented");
    }
    /// ### Parameters
    /// `first`
    ///
    /// > Specify the first viewport to set.
    ///
    /// `count`
    ///
    /// > Specify the number of viewports to set.
    ///
    /// `v`
    ///
    /// > Specify the address of an array containing the viewport parameters.
    ///
    /// ### Description
    /// [**glViewportArrayv**](crate::context::Context::oxidegl_viewport_arrayv)
    /// specifies the parameters for multiple viewports simulataneously. `first`
    /// specifies the index of the first viewport to modify and `count` specifies
    /// the number of viewports to modify. `first` must be less than the value
    /// of [`GL_MAX_VIEWPORTS`](crate::enums::GL_MAX_VIEWPORTS), and `first`+ `count`
    /// must be less than or equal to the value of [`GL_MAX_VIEWPORTS`](crate::enums::GL_MAX_VIEWPORTS).
    /// Viewports whose indices lie outside the range \[ `first`, `first`+ `count`)
    /// are not modified. `v` contains the address of an array of floating point
    /// values specifying the left( `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]`
    /// `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]` `[inlineq]`
    /// `[inlineq]` `[inlineq]`
    ///
    ///
    ///
    /// The location of the viewport's bottom left corner, given by( `[inlineq]`
    /// `[inlineq]` `[inlineq]` `[inlineq]` [**glGet**](crate::context::Context::oxidegl_get)
    /// with argument [`GL_VIEWPORT_BOUNDS_RANGE`](crate::enums::GL_VIEWPORT_BOUNDS_RANGE).
    /// Viewport width and height are silently clamped to a range that depends
    /// on the implementation. To query this range, call [**glGet**](crate::context::Context::oxidegl_get)
    /// with argument [`GL_MAX_VIEWPORT_DIMS`](crate::enums::GL_MAX_VIEWPORT_DIMS).
    ///
    /// The precision with which the GL interprets the floating point viewport
    /// bounds is implementation-dependent and may be determined by querying the
    /// impementation-defined constant [`GL_VIEWPORT_SUBPIXEL_BITS`](crate::enums::GL_VIEWPORT_SUBPIXEL_BITS).
    ///
    /// ### Associated Gets
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_VIEWPORT`](crate::enums::GL_VIEWPORT)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_MAX_VIEWPORT_DIMS`](crate::enums::GL_MAX_VIEWPORT_DIMS)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_VIEWPORT_BOUNDS_RANGE`](crate::enums::GL_VIEWPORT_BOUNDS_RANGE)
    ///
    /// [**glGet**](crate::context::Context::oxidegl_get) with argument [`GL_VIEWPORT_SUBPIXEL_BITS`](crate::enums::GL_VIEWPORT_SUBPIXEL_BITS)

    pub unsafe fn oxidegl_viewport_arrayv(
        &mut self,
        first: GLuint,
        count: GLsizei,
        v: *const GLfloat,
    ) {
        panic!("command oxidegl_viewport_arrayv not yet implemented");
    }
    /// ### Parameters
    /// `sync`
    ///
    /// > Specifies the sync object whose status to wait on.
    ///
    /// `flags`
    ///
    /// > A bitfield controlling the command flushing behavior. `flags` may be zero.
    ///
    /// `timeout`
    ///
    /// > Specifies the timeout that the server should wait before continuing. `timeout`
    /// > must be [`GL_TIMEOUT_IGNORED`](crate::enums::GL_TIMEOUT_IGNORED).
    ///
    /// ### Description
    /// [**glWaitSync**](crate::context::Context::oxidegl_wait_sync) causes the
    /// GL server to block and wait until `sync` becomes signaled. `sync` is the
    /// name of an existing sync object upon which to wait. `flags` and `timeout`
    /// are currently not used and must be set to zero and the special value [`GL_TIMEOUT_IGNORED`](crate::enums::GL_TIMEOUT_IGNORED),
    /// respectively `flags` and `timeout` are placeholders for anticipated future
    /// extensions of sync object capabilities. They must have these reserved values
    /// in order that existing code calling [**glWaitSync**](crate::context::Context::oxidegl_wait_sync)
    /// operate properly in the presence of such extensions.
    ///
    /// [**glWaitSync**](crate::context::Context::oxidegl_wait_sync) will always
    /// wait no longer than an implementation-dependent timeout. The duration of
    /// this timeout in nanoseconds may be queried by calling [**glGet**](crate::context::Context::oxidegl_get)
    /// with the parameter [`GL_MAX_SERVER_WAIT_TIMEOUT`](crate::enums::GL_MAX_SERVER_WAIT_TIMEOUT).
    /// There is currently no way to determine whether [**glWaitSync**](crate::context::Context::oxidegl_wait_sync)
    /// unblocked because the timeout expired or because the sync object being
    /// waited on was signaled.
    ///
    /// If an error occurs, [**glWaitSync**](crate::context::Context::oxidegl_wait_sync)
    /// does not cause the GL server to block.
    ///
    /// ### Notes
    /// [**glWaitSync**](crate::context::Context::oxidegl_wait_sync) is available
    /// only if the GL version is 3.2 or higher.

    pub fn oxidegl_wait_sync(&mut self, sync: GLsync, flags: GLbitfield, timeout: GLuint64) {
        panic!("command oxidegl_wait_sync not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib_p1uiv(
        &mut self,
        index: GLuint,
        r#type: VertexAttribPointerType,
        normalized: GLboolean,
        value: *const GLuint,
    ) {
        panic!("command oxidegl_vertex_attrib_p1uiv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib_p2uiv(
        &mut self,
        index: GLuint,
        r#type: VertexAttribPointerType,
        normalized: GLboolean,
        value: *const GLuint,
    ) {
        panic!("command oxidegl_vertex_attrib_p2uiv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib_p3uiv(
        &mut self,
        index: GLuint,
        r#type: VertexAttribPointerType,
        normalized: GLboolean,
        value: *const GLuint,
    ) {
        panic!("command oxidegl_vertex_attrib_p3uiv not yet implemented");
    }
    pub unsafe fn oxidegl_vertex_attrib_p4uiv(
        &mut self,
        index: GLuint,
        r#type: VertexAttribPointerType,
        normalized: GLboolean,
        value: *const GLuint,
    ) {
        panic!("command oxidegl_vertex_attrib_p4uiv not yet implemented");
    }
    pub fn oxidegl_uniform1d(&mut self, location: GLint, x: GLdouble) {
        panic!("command oxidegl_uniform1d not yet implemented");
    }
    pub fn oxidegl_uniform2d(&mut self, location: GLint, x: GLdouble, y: GLdouble) {
        panic!("command oxidegl_uniform2d not yet implemented");
    }
    pub fn oxidegl_uniform3d(&mut self, location: GLint, x: GLdouble, y: GLdouble, z: GLdouble) {
        panic!("command oxidegl_uniform3d not yet implemented");
    }
    pub fn oxidegl_uniform4d(
        &mut self,
        location: GLint,
        x: GLdouble,
        y: GLdouble,
        z: GLdouble,
        w: GLdouble,
    ) {
        panic!("command oxidegl_uniform4d not yet implemented");
    }
    pub unsafe fn oxidegl_uniform1dv(
        &mut self,
        location: GLint,
        count: GLsizei,
        value: *const GLdouble,
    ) {
        panic!("command oxidegl_uniform1dv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform2dv(
        &mut self,
        location: GLint,
        count: GLsizei,
        value: *const GLdouble,
    ) {
        panic!("command oxidegl_uniform2dv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform3dv(
        &mut self,
        location: GLint,
        count: GLsizei,
        value: *const GLdouble,
    ) {
        panic!("command oxidegl_uniform3dv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform4dv(
        &mut self,
        location: GLint,
        count: GLsizei,
        value: *const GLdouble,
    ) {
        panic!("command oxidegl_uniform4dv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform_matrix2dv(
        &mut self,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLdouble,
    ) {
        panic!("command oxidegl_uniform_matrix2dv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform_matrix3dv(
        &mut self,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLdouble,
    ) {
        panic!("command oxidegl_uniform_matrix3dv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform_matrix4dv(
        &mut self,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLdouble,
    ) {
        panic!("command oxidegl_uniform_matrix4dv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform_matrix2x3dv(
        &mut self,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLdouble,
    ) {
        panic!("command oxidegl_uniform_matrix2x3dv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform_matrix2x4dv(
        &mut self,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLdouble,
    ) {
        panic!("command oxidegl_uniform_matrix2x4dv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform_matrix3x2dv(
        &mut self,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLdouble,
    ) {
        panic!("command oxidegl_uniform_matrix3x2dv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform_matrix3x4dv(
        &mut self,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLdouble,
    ) {
        panic!("command oxidegl_uniform_matrix3x4dv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform_matrix4x2dv(
        &mut self,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLdouble,
    ) {
        panic!("command oxidegl_uniform_matrix4x2dv not yet implemented");
    }
    pub unsafe fn oxidegl_uniform_matrix4x3dv(
        &mut self,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLdouble,
    ) {
        panic!("command oxidegl_uniform_matrix4x3dv not yet implemented");
    }
    pub fn oxidegl_program_uniform1d(&mut self, program: GLuint, location: GLint, v0: GLdouble) {
        panic!("command oxidegl_program_uniform1d not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform1dv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLdouble,
    ) {
        panic!("command oxidegl_program_uniform1dv not yet implemented");
    }
    pub fn oxidegl_program_uniform2d(
        &mut self,
        program: GLuint,
        location: GLint,
        v0: GLdouble,
        v1: GLdouble,
    ) {
        panic!("command oxidegl_program_uniform2d not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform2dv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLdouble,
    ) {
        panic!("command oxidegl_program_uniform2dv not yet implemented");
    }
    pub fn oxidegl_program_uniform3d(
        &mut self,
        program: GLuint,
        location: GLint,
        v0: GLdouble,
        v1: GLdouble,
        v2: GLdouble,
    ) {
        panic!("command oxidegl_program_uniform3d not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform3dv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLdouble,
    ) {
        panic!("command oxidegl_program_uniform3dv not yet implemented");
    }
    pub fn oxidegl_program_uniform4d(
        &mut self,
        program: GLuint,
        location: GLint,
        v0: GLdouble,
        v1: GLdouble,
        v2: GLdouble,
        v3: GLdouble,
    ) {
        panic!("command oxidegl_program_uniform4d not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform4dv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLdouble,
    ) {
        panic!("command oxidegl_program_uniform4dv not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform_matrix2dv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLdouble,
    ) {
        panic!("command oxidegl_program_uniform_matrix2dv not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform_matrix3dv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLdouble,
    ) {
        panic!("command oxidegl_program_uniform_matrix3dv not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform_matrix4dv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLdouble,
    ) {
        panic!("command oxidegl_program_uniform_matrix4dv not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform_matrix2x3dv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLdouble,
    ) {
        panic!("command oxidegl_program_uniform_matrix2x3dv not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform_matrix3x2dv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLdouble,
    ) {
        panic!("command oxidegl_program_uniform_matrix3x2dv not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform_matrix2x4dv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLdouble,
    ) {
        panic!("command oxidegl_program_uniform_matrix2x4dv not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform_matrix4x2dv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLdouble,
    ) {
        panic!("command oxidegl_program_uniform_matrix4x2dv not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform_matrix3x4dv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLdouble,
    ) {
        panic!("command oxidegl_program_uniform_matrix3x4dv not yet implemented");
    }
    pub unsafe fn oxidegl_program_uniform_matrix4x3dv(
        &mut self,
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLdouble,
    ) {
        panic!("command oxidegl_program_uniform_matrix4x3dv not yet implemented");
    }
    pub unsafe fn oxidegl_specialize_shader(
        &mut self,
        shader: GLuint,
        p_entry_point: *const GLchar,
        num_specialization_constants: GLuint,
        p_constant_index: *const GLuint,
        p_constant_value: *const GLuint,
    ) {
        panic!("command oxidegl_specialize_shader not yet implemented");
    }
    pub unsafe fn oxidegl_multi_draw_arrays_indirect_count(
        &mut self,
        mode: PrimitiveType,
        indirect: *const GLvoid,
        drawcount: GLintptr,
        maxdrawcount: GLsizei,
        stride: GLsizei,
    ) {
        panic!("command oxidegl_multi_draw_arrays_indirect_count not yet implemented");
    }
    pub unsafe fn oxidegl_multi_draw_elements_indirect_count(
        &mut self,
        mode: PrimitiveType,
        r#type: DrawElementsType,
        indirect: *const GLvoid,
        drawcount: GLintptr,
        maxdrawcount: GLsizei,
        stride: GLsizei,
    ) {
        panic!("command oxidegl_multi_draw_elements_indirect_count not yet implemented");
    }
    pub fn oxidegl_polygon_offset_clamp(
        &mut self,
        factor: GLfloat,
        units: GLfloat,
        clamp: GLfloat,
    ) {
        panic!("command oxidegl_polygon_offset_clamp not yet implemented");
    }
}
